"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// esbuild-shims.js
var init_esbuild_shims = __esm({
  "esbuild-shims.js"() {
    "use strict";
    globalThis.require = (name) => {
      if (name === "ethers") {
        return ethers;
      }
      throw new Error("unknown module " + name);
    };
  }
});

// buffer-shims.js
var import_buffer;
var init_buffer_shims = __esm({
  "buffer-shims.js"() {
    "use strict";
    import_buffer = require("buffer");
    globalThis.Buffer = import_buffer.Buffer;
  }
});

// node_modules/bitcoinjs-lib/src/networks.js
var require_networks = __commonJS({
  "node_modules/bitcoinjs-lib/src/networks.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testnet = exports2.regtest = exports2.bitcoin = void 0;
    exports2.bitcoin = {
      /**
       * The message prefix used for signing Bitcoin messages.
       */
      messagePrefix: "Bitcoin Signed Message:\n",
      /**
       * The Bech32 prefix used for Bitcoin addresses.
       */
      bech32: "bc",
      /**
       * The BIP32 key prefixes for Bitcoin.
       */
      bip32: {
        /**
         * The public key prefix for BIP32 extended public keys.
         */
        public: 76067358,
        /**
         * The private key prefix for BIP32 extended private keys.
         */
        private: 76066276
      },
      /**
       * The prefix for Bitcoin public key hashes.
       */
      pubKeyHash: 0,
      /**
       * The prefix for Bitcoin script hashes.
       */
      scriptHash: 5,
      /**
       * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
       */
      wif: 128
    };
    exports2.regtest = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bcrt",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
    exports2.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/bitcoinjs-lib/src/bip66.js
var require_bip66 = __commonJS({
  "node_modules/bitcoinjs-lib/src/bip66.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = exports2.check = void 0;
    function check(buffer) {
      if (buffer.length < 8) return false;
      if (buffer.length > 72) return false;
      if (buffer[0] !== 48) return false;
      if (buffer[1] !== buffer.length - 2) return false;
      if (buffer[2] !== 2) return false;
      const lenR = buffer[3];
      if (lenR === 0) return false;
      if (5 + lenR >= buffer.length) return false;
      if (buffer[4 + lenR] !== 2) return false;
      const lenS = buffer[5 + lenR];
      if (lenS === 0) return false;
      if (6 + lenR + lenS !== buffer.length) return false;
      if (buffer[4] & 128) return false;
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
      if (buffer[lenR + 6] & 128) return false;
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
        return false;
      return true;
    }
    exports2.check = check;
    function decode(buffer) {
      if (buffer.length < 8) throw new Error("DER sequence length is too short");
      if (buffer.length > 72) throw new Error("DER sequence length is too long");
      if (buffer[0] !== 48) throw new Error("Expected DER sequence");
      if (buffer[1] !== buffer.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer[2] !== 2) throw new Error("Expected DER integer");
      const lenR = buffer[3];
      if (lenR === 0) throw new Error("R length is zero");
      if (5 + lenR >= buffer.length) throw new Error("R length is too long");
      if (buffer[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
      const lenS = buffer[5 + lenR];
      if (lenS === 0) throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
      if (buffer[4] & 128) throw new Error("R value is negative");
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer[lenR + 6] & 128) throw new Error("S value is negative");
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer.slice(4, 4 + lenR),
        s: buffer.slice(6 + lenR)
      };
    }
    exports2.decode = decode;
    function encode(r, s) {
      const lenR = r.length;
      const lenS = s.length;
      if (lenR === 0) throw new Error("R length is zero");
      if (lenS === 0) throw new Error("S length is zero");
      if (lenR > 33) throw new Error("R length is too long");
      if (lenS > 33) throw new Error("S length is too long");
      if (r[0] & 128) throw new Error("R value is negative");
      if (s[0] & 128) throw new Error("S value is negative");
      if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
        throw new Error("S value excessively padded");
      const signature = Buffer.allocUnsafe(6 + lenR + lenS);
      signature[0] = 48;
      signature[1] = signature.length - 2;
      signature[2] = 2;
      signature[3] = r.length;
      r.copy(signature, 4);
      signature[4 + lenR] = 2;
      signature[5 + lenR] = s.length;
      s.copy(signature, 6 + lenR);
      return signature;
    }
    exports2.encode = encode;
  }
});

// node_modules/bitcoinjs-lib/src/ops.js
var require_ops = __commonJS({
  "node_modules/bitcoinjs-lib/src/ops.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.REVERSE_OPS = exports2.OPS = void 0;
    var OPS = {
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      OP_CHECKSIGADD: 186,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
    exports2.OPS = OPS;
    var REVERSE_OPS = {};
    exports2.REVERSE_OPS = REVERSE_OPS;
    for (const op of Object.keys(OPS)) {
      const code = OPS[op];
      REVERSE_OPS[code] = op;
    }
  }
});

// node_modules/bitcoinjs-lib/src/push_data.js
var require_push_data = __commonJS({
  "node_modules/bitcoinjs-lib/src/push_data.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.encodingLength = void 0;
    var ops_1 = require_ops();
    function encodingLength(i) {
      return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
    }
    exports2.encodingLength = encodingLength;
    function encode(buffer, num, offset) {
      const size = encodingLength(num);
      if (size === 1) {
        buffer.writeUInt8(num, offset);
      } else if (size === 2) {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
        buffer.writeUInt8(num, offset + 1);
      } else if (size === 3) {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
        buffer.writeUInt16LE(num, offset + 1);
      } else {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
        buffer.writeUInt32LE(num, offset + 1);
      }
      return size;
    }
    exports2.encode = encode;
    function decode(buffer, offset) {
      const opcode = buffer.readUInt8(offset);
      let num;
      let size;
      if (opcode < ops_1.OPS.OP_PUSHDATA1) {
        num = opcode;
        size = 1;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length) return null;
        num = buffer.readUInt8(offset + 1);
        size = 2;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length) return null;
        num = buffer.readUInt16LE(offset + 1);
        size = 3;
      } else {
        if (offset + 5 > buffer.length) return null;
        if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        num = buffer.readUInt32LE(offset + 1);
        size = 5;
      }
      return {
        opcode,
        number: num,
        size
      };
    }
    exports2.decode = decode;
  }
});

// node_modules/bitcoinjs-lib/src/script_number.js
var require_script_number = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_number.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    function decode(buffer, maxLength, minimal) {
      maxLength = maxLength || 4;
      minimal = minimal === void 0 ? true : minimal;
      const length = buffer.length;
      if (length === 0) return 0;
      if (length > maxLength) throw new TypeError("Script number overflow");
      if (minimal) {
        if ((buffer[length - 1] & 127) === 0) {
          if (length <= 1 || (buffer[length - 2] & 128) === 0)
            throw new Error("Non-minimally encoded script number");
        }
      }
      if (length === 5) {
        const a = buffer.readUInt32LE(0);
        const b = buffer.readUInt8(4);
        if (b & 128) return -((b & ~128) * 4294967296 + a);
        return b * 4294967296 + a;
      }
      let result = 0;
      for (let i = 0; i < length; ++i) {
        result |= buffer[i] << 8 * i;
      }
      if (buffer[length - 1] & 128)
        return -(result & ~(128 << 8 * (length - 1)));
      return result;
    }
    exports2.decode = decode;
    function scriptNumSize(i) {
      return i > 2147483647 ? 5 : i > 8388607 ? 4 : i > 32767 ? 3 : i > 127 ? 2 : i > 0 ? 1 : 0;
    }
    function encode(_number) {
      let value = Math.abs(_number);
      const size = scriptNumSize(value);
      const buffer = Buffer.allocUnsafe(size);
      const negative = _number < 0;
      for (let i = 0; i < size; ++i) {
        buffer.writeUInt8(value & 255, i);
        value >>= 8;
      }
      if (buffer[size - 1] & 128) {
        buffer.writeUInt8(negative ? 128 : 0, size - 1);
      } else if (negative) {
        buffer[size - 1] |= 128;
      }
      return buffer;
    }
    exports2.encode = encode;
  }
});

// node_modules/typeforce/native.js
var require_native = __commonJS({
  "node_modules/typeforce/native.js"(exports2, module2) {
    init_esbuild_shims();
    init_buffer_shims();
    var types = {
      Array: function(value) {
        return value !== null && value !== void 0 && value.constructor === Array;
      },
      Boolean: function(value) {
        return typeof value === "boolean";
      },
      Function: function(value) {
        return typeof value === "function";
      },
      Nil: function(value) {
        return value === void 0 || value === null;
      },
      Number: function(value) {
        return typeof value === "number";
      },
      Object: function(value) {
        return typeof value === "object";
      },
      String: function(value) {
        return typeof value === "string";
      },
      "": function() {
        return true;
      }
    };
    types.Null = types.Nil;
    for (typeName in types) {
      types[typeName].toJSON = function(t) {
        return t;
      }.bind(null, typeName);
    }
    var typeName;
    module2.exports = types;
  }
});

// node_modules/typeforce/errors.js
var require_errors = __commonJS({
  "node_modules/typeforce/errors.js"(exports2, module2) {
    init_esbuild_shims();
    init_buffer_shims();
    var native = require_native();
    function getTypeName(fn) {
      return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value) {
      return native.Nil(value) ? "" : getTypeName(value.constructor);
    }
    function getValue(value) {
      if (native.Function(value)) return "";
      if (native.String(value)) return JSON.stringify(value);
      if (value && native.Object(value)) return "";
      return value;
    }
    function captureStackTrace(e, t) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e, t);
      }
    }
    function tfJSON(type) {
      if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type)) return "Array";
      if (type && native.Object(type)) return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value, valueTypeName) {
      var valueJson = getValue(value);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value);
      this.message = tfErrorString(type, value, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name, value, valueTypeName) {
      var description = '" of type ';
      if (label === "key") description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected, actual) {
      return new TfTypeError(expected, {}, actual);
    }
    function tfSubError(e, property, label) {
      if (e instanceof TfPropertyTypeError) {
        property = property + "." + e.__property;
        e = new TfPropertyTypeError(
          e.__type,
          property,
          e.__label,
          e.__value,
          e.__valueTypeName
        );
      } else if (e instanceof TfTypeError) {
        e = new TfPropertyTypeError(
          e.__type,
          property,
          label,
          e.__value,
          e.__valueTypeName
        );
      }
      captureStackTrace(e);
      return e;
    }
    module2.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "node_modules/typeforce/extra.js"(exports2, module2) {
    init_esbuild_shims();
    init_buffer_shims();
    var NATIVE = require_native();
    var ERRORS = require_errors();
    function _Buffer(value) {
      return Buffer.isBuffer(value);
    }
    function Hex(value) {
      return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
    }
    function _LengthN(type, length) {
      var name = type.toJSON();
      function Length(value) {
        if (!type(value)) return false;
        if (value.length === length) return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
      }
      Length.toJSON = function() {
        return name;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a, b, f) {
      f = f || NATIVE.Number;
      function _range(value, strict) {
        return f(value, strict) && value > a && value < b;
      }
      _range.toJSON = function() {
        return `${f.toJSON()} between [${a}, ${b}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value) {
      return typeof value === "number" && isFinite(value);
    }
    function Int8(value) {
      return value << 24 >> 24 === value;
    }
    function Int16(value) {
      return value << 16 >> 16 === value;
    }
    function Int32(value) {
      return (value | 0) === value;
    }
    function Int53(value) {
      return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
    }
    function UInt8(value) {
      return (value & 255) === value;
    }
    function UInt16(value) {
      return (value & 65535) === value;
    }
    function UInt32(value) {
      return value >>> 0 === value;
    }
    function UInt53(value) {
      return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
    }
    var types = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types) {
      types[typeName].toJSON = function(t) {
        return t;
      }.bind(null, typeName);
    }
    var typeName;
    module2.exports = types;
  }
});

// node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "node_modules/typeforce/index.js"(exports2, module2) {
    init_esbuild_shims();
    init_buffer_shims();
    var ERRORS = require_errors();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array, strict) {
          if (!NATIVE.Array(array)) return false;
          if (NATIVE.Nil(array)) return false;
          if (options.minLength !== void 0 && array.length < options.minLength) return false;
          if (options.maxLength !== void 0 && array.length > options.maxLength) return false;
          if (options.length !== void 0 && array.length !== options.length) return false;
          return array.every(function(value, i) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe(type) {
        type = compile(type);
        function _maybe(value, strict) {
          return NATIVE.Nil(value) || type(value, strict, maybe);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          for (var propertyName in value) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e) {
              throw tfSubError(e, propertyName, "key");
            }
            try {
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e) {
              throw tfSubError(e, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile(uncompiled[typePropertyName]);
        }
        function _object(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e) {
            throw tfSubError(e, propertyName);
          }
          if (strict) {
            for (propertyName in value) {
              if (type[propertyName]) continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
          return types.some(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
          return types.every(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
          return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple() {
        var types = [].slice.call(arguments).map(compile);
        function _tuple(values, strict) {
          if (NATIVE.Nil(values)) return false;
          if (NATIVE.Nil(values.length)) return false;
          if (strict && values.length !== types.length) return false;
          return types.every(function(type, i) {
            try {
              return typeforce(type, values[i], strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value(expected) {
        function _value(actual) {
          return actual === expected;
        }
        _value.toJSON = function() {
          return expected;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value, strict)) return true;
        throw new TfTypeError(surrogate || type, value);
      }
      return typeforce(compile(type), value, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module2.exports = typeforce;
  }
});

// node_modules/bitcoinjs-lib/src/types.js
var require_types = __commonJS({
  "node_modules/bitcoinjs-lib/src/types.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.oneOf = exports2.Null = exports2.BufferN = exports2.Function = exports2.UInt32 = exports2.UInt8 = exports2.tuple = exports2.maybe = exports2.Hex = exports2.Buffer = exports2.String = exports2.Boolean = exports2.Array = exports2.Number = exports2.Hash256bit = exports2.Hash160bit = exports2.Buffer256bit = exports2.isTaptree = exports2.isTapleaf = exports2.TAPLEAF_VERSION_MASK = exports2.Satoshi = exports2.isPoint = exports2.stacksEqual = exports2.typeforce = void 0;
    var buffer_1 = require("buffer");
    exports2.typeforce = require_typeforce();
    var ZERO32 = buffer_1.Buffer.alloc(32, 0);
    var EC_P = buffer_1.Buffer.from(
      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
      "hex"
    );
    function stacksEqual(a, b) {
      if (a.length !== b.length) return false;
      return a.every((x, i) => {
        return x.equals(b[i]);
      });
    }
    exports2.stacksEqual = stacksEqual;
    function isPoint4(p) {
      if (!buffer_1.Buffer.isBuffer(p)) return false;
      if (p.length < 33) return false;
      const t = p[0];
      const x = p.slice(1, 33);
      if (x.compare(ZERO32) === 0) return false;
      if (x.compare(EC_P) >= 0) return false;
      if ((t === 2 || t === 3) && p.length === 33) {
        return true;
      }
      const y = p.slice(33);
      if (y.compare(ZERO32) === 0) return false;
      if (y.compare(EC_P) >= 0) return false;
      if (t === 4 && p.length === 65) return true;
      return false;
    }
    exports2.isPoint = isPoint4;
    var SATOSHI_MAX = 21 * 1e14;
    function Satoshi(value) {
      return exports2.typeforce.UInt53(value) && value <= SATOSHI_MAX;
    }
    exports2.Satoshi = Satoshi;
    exports2.TAPLEAF_VERSION_MASK = 254;
    function isTapleaf(o) {
      if (!o || !("output" in o)) return false;
      if (!buffer_1.Buffer.isBuffer(o.output)) return false;
      if (o.version !== void 0)
        return (o.version & exports2.TAPLEAF_VERSION_MASK) === o.version;
      return true;
    }
    exports2.isTapleaf = isTapleaf;
    function isTaptree(scriptTree) {
      if (!(0, exports2.Array)(scriptTree)) return isTapleaf(scriptTree);
      if (scriptTree.length !== 2) return false;
      return scriptTree.every((t) => isTaptree(t));
    }
    exports2.isTaptree = isTaptree;
    exports2.Buffer256bit = exports2.typeforce.BufferN(32);
    exports2.Hash160bit = exports2.typeforce.BufferN(20);
    exports2.Hash256bit = exports2.typeforce.BufferN(32);
    exports2.Number = exports2.typeforce.Number;
    exports2.Array = exports2.typeforce.Array;
    exports2.Boolean = exports2.typeforce.Boolean;
    exports2.String = exports2.typeforce.String;
    exports2.Buffer = exports2.typeforce.Buffer;
    exports2.Hex = exports2.typeforce.Hex;
    exports2.maybe = exports2.typeforce.maybe;
    exports2.tuple = exports2.typeforce.tuple;
    exports2.UInt8 = exports2.typeforce.UInt8;
    exports2.UInt32 = exports2.typeforce.UInt32;
    exports2.Function = exports2.typeforce.Function;
    exports2.BufferN = exports2.typeforce.BufferN;
    exports2.Null = exports2.typeforce.Null;
    exports2.oneOf = exports2.typeforce.oneOf;
  }
});

// node_modules/bitcoinjs-lib/src/script_signature.js
var require_script_signature = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_signature.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    var bip66 = require_bip66();
    var script_1 = require_script();
    var types = require_types();
    var { typeforce } = types;
    var ZERO = Buffer.alloc(1, 0);
    function toDER(x) {
      let i = 0;
      while (x[i] === 0) ++i;
      if (i === x.length) return ZERO;
      x = x.slice(i);
      if (x[0] & 128) return Buffer.concat([ZERO, x], 1 + x.length);
      return x;
    }
    function fromDER(x) {
      if (x[0] === 0) x = x.slice(1);
      const buffer = Buffer.alloc(32, 0);
      const bstart = Math.max(0, 32 - x.length);
      x.copy(buffer, bstart);
      return buffer;
    }
    function decode(buffer) {
      const hashType = buffer.readUInt8(buffer.length - 1);
      if (!(0, script_1.isDefinedHashType)(hashType)) {
        throw new Error("Invalid hashType " + hashType);
      }
      const decoded = bip66.decode(buffer.slice(0, -1));
      const r = fromDER(decoded.r);
      const s = fromDER(decoded.s);
      const signature = Buffer.concat([r, s], 64);
      return { signature, hashType };
    }
    exports2.decode = decode;
    function encode(signature, hashType) {
      typeforce(
        {
          signature: types.BufferN(64),
          hashType: types.UInt8
        },
        { signature, hashType }
      );
      if (!(0, script_1.isDefinedHashType)(hashType)) {
        throw new Error("Invalid hashType " + hashType);
      }
      const hashTypeBuffer = Buffer.allocUnsafe(1);
      hashTypeBuffer.writeUInt8(hashType, 0);
      const r = toDER(signature.slice(0, 32));
      const s = toDER(signature.slice(32, 64));
      return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
    }
    exports2.encode = encode;
  }
});

// node_modules/bitcoinjs-lib/src/script.js
var require_script = __commonJS({
  "node_modules/bitcoinjs-lib/src/script.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signature = exports2.number = exports2.isCanonicalScriptSignature = exports2.isDefinedHashType = exports2.isCanonicalPubKey = exports2.toStack = exports2.fromASM = exports2.toASM = exports2.decompile = exports2.compile = exports2.countNonPushOnlyOPs = exports2.isPushOnly = exports2.OPS = void 0;
    var bip66 = require_bip66();
    var ops_1 = require_ops();
    Object.defineProperty(exports2, "OPS", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var pushdata = require_push_data();
    var scriptNumber = require_script_number();
    var scriptSignature = require_script_signature();
    var types = require_types();
    var { typeforce } = types;
    var OP_INT_BASE = ops_1.OPS.OP_RESERVED;
    function isOPInt(value) {
      return types.Number(value) && (value === ops_1.OPS.OP_0 || value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16 || value === ops_1.OPS.OP_1NEGATE);
    }
    function isPushOnlyChunk(value) {
      return types.Buffer(value) || isOPInt(value);
    }
    function isPushOnly(value) {
      return types.Array(value) && value.every(isPushOnlyChunk);
    }
    exports2.isPushOnly = isPushOnly;
    function countNonPushOnlyOPs(value) {
      return value.length - value.filter(isPushOnlyChunk).length;
    }
    exports2.countNonPushOnlyOPs = countNonPushOnlyOPs;
    function asMinimalOP(buffer) {
      if (buffer.length === 0) return ops_1.OPS.OP_0;
      if (buffer.length !== 1) return;
      if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
      if (buffer[0] === 129) return ops_1.OPS.OP_1NEGATE;
    }
    function chunksIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function chunksIsArray(buf) {
      return types.Array(buf);
    }
    function singleChunkIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function compile(chunks) {
      if (chunksIsBuffer(chunks)) return chunks;
      typeforce(types.Array, chunks);
      const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
            return accum + 1;
          }
          return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        return accum + 1;
      }, 0);
      const buffer = Buffer.allocUnsafe(bufferSize);
      let offset = 0;
      chunks.forEach((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const opcode = asMinimalOP(chunk);
          if (opcode !== void 0) {
            buffer.writeUInt8(opcode, offset);
            offset += 1;
            return;
          }
          offset += pushdata.encode(buffer, chunk.length, offset);
          chunk.copy(buffer, offset);
          offset += chunk.length;
        } else {
          buffer.writeUInt8(chunk, offset);
          offset += 1;
        }
      });
      if (offset !== buffer.length) throw new Error("Could not decode chunks");
      return buffer;
    }
    exports2.compile = compile;
    function decompile(buffer) {
      if (chunksIsArray(buffer)) return buffer;
      typeforce(types.Buffer, buffer);
      const chunks = [];
      let i = 0;
      while (i < buffer.length) {
        const opcode = buffer[i];
        if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
          const d = pushdata.decode(buffer, i);
          if (d === null) return null;
          i += d.size;
          if (i + d.number > buffer.length) return null;
          const data = buffer.slice(i, i + d.number);
          i += d.number;
          const op = asMinimalOP(data);
          if (op !== void 0) {
            chunks.push(op);
          } else {
            chunks.push(data);
          }
        } else {
          chunks.push(opcode);
          i += 1;
        }
      }
      return chunks;
    }
    exports2.decompile = decompile;
    function toASM(chunks) {
      if (chunksIsBuffer(chunks)) {
        chunks = decompile(chunks);
      }
      if (!chunks) {
        throw new Error("Could not convert invalid chunks to ASM");
      }
      return chunks.map((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const op = asMinimalOP(chunk);
          if (op === void 0) return chunk.toString("hex");
          chunk = op;
        }
        return ops_1.REVERSE_OPS[chunk];
      }).join(" ");
    }
    exports2.toASM = toASM;
    function fromASM(asm) {
      typeforce(types.String, asm);
      return compile(
        asm.split(" ").map((chunkStr) => {
          if (ops_1.OPS[chunkStr] !== void 0) return ops_1.OPS[chunkStr];
          typeforce(types.Hex, chunkStr);
          return Buffer.from(chunkStr, "hex");
        })
      );
    }
    exports2.fromASM = fromASM;
    function toStack(chunks) {
      chunks = decompile(chunks);
      typeforce(isPushOnly, chunks);
      return chunks.map((op) => {
        if (singleChunkIsBuffer(op)) return op;
        if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE);
      });
    }
    exports2.toStack = toStack;
    function isCanonicalPubKey(buffer) {
      return types.isPoint(buffer);
    }
    exports2.isCanonicalPubKey = isCanonicalPubKey;
    function isDefinedHashType(hashType) {
      const hashTypeMod = hashType & ~128;
      return hashTypeMod > 0 && hashTypeMod < 4;
    }
    exports2.isDefinedHashType = isDefinedHashType;
    function isCanonicalScriptSignature(buffer) {
      if (!Buffer.isBuffer(buffer)) return false;
      if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
      return bip66.check(buffer.slice(0, -1));
    }
    exports2.isCanonicalScriptSignature = isCanonicalScriptSignature;
    exports2.number = scriptNumber;
    exports2.signature = scriptSignature;
  }
});

// node_modules/bitcoinjs-lib/src/payments/lazy.js
var require_lazy = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/lazy.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.value = exports2.prop = void 0;
    function prop(object, name, f) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        get() {
          const _value = f.call(this);
          this[name] = _value;
          return _value;
        },
        set(_value) {
          Object.defineProperty(this, name, {
            configurable: true,
            enumerable: true,
            value: _value,
            writable: true
          });
        }
      });
    }
    exports2.prop = prop;
    function value(f) {
      let _value;
      return () => {
        if (_value !== void 0) return _value;
        _value = f();
        return _value;
      };
    }
    exports2.value = value;
  }
});

// node_modules/bitcoinjs-lib/src/payments/embed.js
var require_embed = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/embed.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2data = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    function p2data(a, opts) {
      if (!a.data && !a.output) throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          data: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const network = a.network || networks_1.bitcoin;
      const o = { name: "embed", network };
      lazy.prop(o, "output", () => {
        if (!a.data) return;
        return bscript.compile([OPS.OP_RETURN].concat(a.data));
      });
      lazy.prop(o, "data", () => {
        if (!a.output) return;
        return bscript.decompile(a.output).slice(1);
      });
      if (opts.validate) {
        if (a.output) {
          const chunks = bscript.decompile(a.output);
          if (chunks[0] !== OPS.OP_RETURN) throw new TypeError("Output is invalid");
          if (!chunks.slice(1).every(types_1.typeforce.Buffer))
            throw new TypeError("Output is invalid");
          if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))
            throw new TypeError("Data mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2data = p2data;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2ms.js
var require_p2ms = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2ms.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2ms = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    var OP_INT_BASE = OPS.OP_RESERVED;
    function p2ms(a, opts) {
      if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      function isAcceptableSignature(x) {
        return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS.OP_0) !== void 0;
      }
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          m: types_1.typeforce.maybe(types_1.typeforce.Number),
          n: types_1.typeforce.maybe(types_1.typeforce.Number),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkeys: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.isPoint)
          ),
          signatures: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(isAcceptableSignature)
          ),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const network = a.network || networks_1.bitcoin;
      const o = { network };
      let chunks = [];
      let decoded = false;
      function decode(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o.m = chunks[0] - OP_INT_BASE;
        o.n = chunks[chunks.length - 2] - OP_INT_BASE;
        o.pubkeys = chunks.slice(1, -2);
      }
      lazy.prop(o, "output", () => {
        if (!a.m) return;
        if (!o.n) return;
        if (!a.pubkeys) return;
        return bscript.compile(
          [].concat(
            OP_INT_BASE + a.m,
            a.pubkeys,
            OP_INT_BASE + o.n,
            OPS.OP_CHECKMULTISIG
          )
        );
      });
      lazy.prop(o, "m", () => {
        if (!o.output) return;
        decode(o.output);
        return o.m;
      });
      lazy.prop(o, "n", () => {
        if (!o.pubkeys) return;
        return o.pubkeys.length;
      });
      lazy.prop(o, "pubkeys", () => {
        if (!a.output) return;
        decode(a.output);
        return o.pubkeys;
      });
      lazy.prop(o, "signatures", () => {
        if (!a.input) return;
        return bscript.decompile(a.input).slice(1);
      });
      lazy.prop(o, "input", () => {
        if (!a.signatures) return;
        return bscript.compile([OPS.OP_0].concat(a.signatures));
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      lazy.prop(o, "name", () => {
        if (!o.m || !o.n) return;
        return `p2ms(${o.m} of ${o.n})`;
      });
      if (opts.validate) {
        if (a.output) {
          decode(a.output);
          if (!types_1.typeforce.Number(chunks[0]))
            throw new TypeError("Output is invalid");
          if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
            throw new TypeError("Output is invalid");
          if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
            throw new TypeError("Output is invalid");
          if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
            throw new TypeError("Output is invalid");
          if (!o.pubkeys.every((x) => (0, types_1.isPoint)(x)))
            throw new TypeError("Output is invalid");
          if (a.m !== void 0 && a.m !== o.m) throw new TypeError("m mismatch");
          if (a.n !== void 0 && a.n !== o.n) throw new TypeError("n mismatch");
          if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))
            throw new TypeError("Pubkeys mismatch");
        }
        if (a.pubkeys) {
          if (a.n !== void 0 && a.n !== a.pubkeys.length)
            throw new TypeError("Pubkey count mismatch");
          o.n = a.pubkeys.length;
          if (o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a.signatures) {
          if (a.signatures.length < o.m)
            throw new TypeError("Not enough signatures provided");
          if (a.signatures.length > o.m)
            throw new TypeError("Too many signatures provided");
        }
        if (a.input) {
          if (a.input[0] !== OPS.OP_0) throw new TypeError("Input is invalid");
          if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
            throw new TypeError("Input has invalid signature(s)");
          if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))
            throw new TypeError("Signature mismatch");
          if (a.m !== void 0 && a.m !== a.signatures.length)
            throw new TypeError("Signature count mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2ms = p2ms;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pk.js
var require_p2pk = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pk.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2pk = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    function p2pk(a, opts) {
      if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2pk", network };
      lazy.prop(o, "output", () => {
        if (!a.pubkey) return;
        return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.output) return;
        return a.output.slice(1, -1);
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.signature) return;
        return bscript.compile([a.signature]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        if (a.output) {
          if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          if (!(0, types_1.isPoint)(o.pubkey))
            throw new TypeError("Output pubkey is invalid");
          if (a.pubkey && !a.pubkey.equals(o.pubkey))
            throw new TypeError("Pubkey mismatch");
        }
        if (a.signature) {
          if (a.input && !a.input.equals(o.input))
            throw new TypeError("Signature mismatch");
        }
        if (a.input) {
          if (_chunks().length !== 1) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(o.signature))
            throw new TypeError("Input has invalid signature");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pk = p2pk;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anumber = anumber;
    exports2.number = anumber;
    exports2.abytes = abytes;
    exports2.bytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    var assert = {
      number: anumber,
      bytes: abytes,
      hash: ahash,
      exists: aexists,
      output: aoutput
    };
    exports2.default = assert;
  }
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("node:crypto");
    exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = exports2.nextTick = exports2.byteSwapIfBE = exports2.byteSwap = exports2.isLE = exports2.rotl = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    exports2.isBytes = isBytes;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.toBytes = toBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.wrapConstructor = wrapConstructor;
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports2.randomBytes = randomBytes2;
    var crypto_1 = require_cryptoNode();
    var _assert_js_1 = require_assert();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports2.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports2.rotl = rotl;
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports2.byteSwap = byteSwap;
    exports2.byteSwapIfBE = exports2.isLE ? (n) => n : (n) => (0, exports2.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports2.byteSwap)(arr[i]);
      }
    }
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.abytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("utf8ToBytes expected string, got " + typeof str);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.abytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.abytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashMD = exports2.Maj = exports2.Chi = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports2.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports2.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.HashMD = HashMD;
  }
});

// node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/@noble/hashes/ripemd160.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.RIPEMD160 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
    var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    var shifts = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    var Kl = /* @__PURE__ */ new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr = /* @__PURE__ */ new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      else if (group === 1)
        return x & y | ~x & z;
      else if (group === 2)
        return (x | ~y) ^ z;
      else if (group === 3)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    var R_BUF = /* @__PURE__ */ new Uint32Array(16);
    var RIPEMD160 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          R_BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_js_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_js_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        R_BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports2.RIPEMD160 = RIPEMD160;
    exports2.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/@noble/hashes/sha1.js
var require_sha1 = __commonJS({
  "node_modules/@noble/hashes/sha1.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha1 = exports2.SHA1 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var SHA1_IV = /* @__PURE__ */ new Uint32Array([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
    var SHA1 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_js_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K;
          if (i < 20) {
            F = (0, _md_js_1.Chi)(B, C, D);
            K = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K = 1859775393;
          } else if (i < 60) {
            F = (0, _md_js_1.Maj)(B, C, D);
            K = 2400959708;
          } else {
            F = B ^ C ^ D;
            K = 3395469782;
          }
          const T = (0, utils_js_1.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;
          E = D;
          D = C;
          C = (0, utils_js_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        SHA1_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports2.SHA1 = SHA1;
    exports2.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = exports2.SHA256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports2.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/bitcoinjs-lib/src/crypto.js
var require_crypto = __commonJS({
  "node_modules/bitcoinjs-lib/src/crypto.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.taggedHash = exports2.TAGGED_HASH_PREFIXES = exports2.TAGS = exports2.hash256 = exports2.hash160 = exports2.sha256 = exports2.sha1 = exports2.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha1_1 = require_sha1();
    var sha256_1 = require_sha256();
    function ripemd160(buffer) {
      return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
    }
    exports2.ripemd160 = ripemd160;
    function sha1(buffer) {
      return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
    }
    exports2.sha1 = sha1;
    function sha256(buffer) {
      return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
    }
    exports2.sha256 = sha256;
    function hash160(buffer) {
      return Buffer.from(
        (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
      );
    }
    exports2.hash160 = hash160;
    function hash256(buffer) {
      return Buffer.from(
        (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
      );
    }
    exports2.hash256 = hash256;
    exports2.TAGS = [
      "BIP0340/challenge",
      "BIP0340/aux",
      "BIP0340/nonce",
      "TapLeaf",
      "TapBranch",
      "TapSighash",
      "TapTweak",
      "KeyAgg list",
      "KeyAgg coefficient"
    ];
    exports2.TAGGED_HASH_PREFIXES = {
      "BIP0340/challenge": Buffer.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
      ]),
      "BIP0340/aux": Buffer.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
      ]),
      "BIP0340/nonce": Buffer.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
      ]),
      TapLeaf: Buffer.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
      ]),
      TapBranch: Buffer.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
      ]),
      TapSighash: Buffer.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
      ]),
      TapTweak: Buffer.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
      ]),
      "KeyAgg list": Buffer.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
      ]),
      "KeyAgg coefficient": Buffer.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
      ])
    };
    function taggedHash(prefix, data) {
      return sha256(Buffer.concat([exports2.TAGGED_HASH_PREFIXES[prefix], data]));
    }
    exports2.taggedHash = taggedHash;
  }
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    init_esbuild_shims();
    init_buffer_shims();
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// node_modules/bs58check/base.js
var require_base = __commonJS({
  "node_modules/bs58check/base.js"(exports2, module2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    var base58 = require_bs58();
    module2.exports = function(checksumFn) {
      function encode(payload) {
        var payloadU8 = Uint8Array.from(payload);
        var checksum = checksumFn(payloadU8);
        var length = payloadU8.length + 4;
        var both = new Uint8Array(length);
        both.set(payloadU8, 0);
        both.set(checksum.subarray(0, 4), payloadU8.length);
        return base58.encode(both, length);
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string) {
        var buffer = base58.decodeUnsafe(string);
        if (!buffer) return;
        return decodeRaw(buffer);
      }
      function decode(string) {
        var buffer = base58.decode(string);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode,
        decode,
        decodeUnsafe
      };
    };
  }
});

// node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "node_modules/bs58check/index.js"(exports2, module2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    var { sha256 } = require_sha256();
    var bs58checkBase = require_base();
    function sha256x2(buffer) {
      return sha256(sha256(buffer));
    }
    module2.exports = bs58checkBase(sha256x2);
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pkh.js
var require_p2pkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pkh.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2pkh = void 0;
    var bcrypto = require_crypto();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bs58check = require_bs58check();
    var OPS = bscript.OPS;
    function p2pkh(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a
      );
      const _address = lazy.value(() => {
        const payload = Buffer.from(bs58check.decode(a.address));
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2pkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o.hash.copy(payload, 1);
        return bs58check.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(3, 23);
        if (a.address) return _address().hash;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([
          OPS.OP_DUP,
          OPS.OP_HASH160,
          o.hash,
          OPS.OP_EQUALVERIFY,
          OPS.OP_CHECKSIG
        ]);
      });
      lazy.prop(o, "pubkey", () => {
        if (!a.input) return;
        return _chunks()[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.input) return;
        return _chunks()[0];
      });
      lazy.prop(o, "input", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return bscript.compile([a.signature, a.pubkey]);
      });
      lazy.prop(o, "witness", () => {
        if (!o.input) return;
        return [];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.pubKeyHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 25 || a.output[0] !== OPS.OP_DUP || a.output[1] !== OPS.OP_HASH160 || a.output[2] !== 20 || a.output[23] !== OPS.OP_EQUALVERIFY || a.output[24] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(3, 23);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
        }
        if (a.input) {
          const chunks = _chunks();
          if (chunks.length !== 2) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(chunks[0]))
            throw new TypeError("Input has invalid signature");
          if (!(0, types_1.isPoint)(chunks[1]))
            throw new TypeError("Input has invalid pubkey");
          if (a.signature && !a.signature.equals(chunks[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(chunks[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(chunks[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2pkh = p2pkh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2sh.js
var require_p2sh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2sh.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2sh = void 0;
    var bcrypto = require_crypto();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bs58check = require_bs58check();
    var OPS = bscript.OPS;
    function p2sh(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
          redeem: types_1.typeforce.maybe({
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.bitcoin;
      }
      const o = { network };
      const _address = lazy.value(() => {
        const payload = Buffer.from(bs58check.decode(a.address));
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a.input);
      });
      const _redeem = lazy.value(() => {
        const chunks = _chunks();
        const lastChunk = chunks[chunks.length - 1];
        return {
          network,
          output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
          input: bscript.compile(chunks.slice(0, -1)),
          witness: a.witness || []
        };
      });
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(o.network.scriptHash, 0);
        o.hash.copy(payload, 1);
        return bs58check.encode(payload);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().hash;
        if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.input) return;
        return _redeem();
      });
      lazy.prop(o, "input", () => {
        if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
        return bscript.compile(
          [].concat(bscript.decompile(a.redeem.input), a.redeem.output)
        );
      });
      lazy.prop(o, "witness", () => {
        if (o.redeem && o.redeem.witness) return o.redeem.witness;
        if (o.input) return [];
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2sh"];
        if (o.redeem !== void 0 && o.redeem.name !== void 0)
          nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (_address().version !== network.scriptHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 20 || a.output[22] !== OPS.OP_EQUAL)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2, 22);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        const checkRedeem = (redeem) => {
          if (redeem.output) {
            const decompile = bscript.decompile(redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output too short");
            if (redeem.output.byteLength > 520)
              throw new TypeError(
                "Redeem.output unspendable if larger than 520 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.hash160(redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) throw new TypeError("Empty input");
            if (hasInput && hasWitness)
              throw new TypeError("Input and witness provided");
            if (hasInput) {
              const richunks = bscript.decompile(redeem.input);
              if (!bscript.isPushOnly(richunks))
                throw new TypeError("Non push-only scriptSig");
            }
          }
        };
        if (a.input) {
          const chunks = _chunks();
          if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
          if (!Buffer.isBuffer(_redeem().output))
            throw new TypeError("Input is invalid");
          checkRedeem(_redeem());
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.input) {
            const redeem = _redeem();
            if (a.redeem.output && !a.redeem.output.equals(redeem.output))
              throw new TypeError("Redeem.output mismatch");
            if (a.redeem.input && !a.redeem.input.equals(redeem.input))
              throw new TypeError("Redeem.input mismatch");
          }
          checkRedeem(a.redeem);
        }
        if (a.witness) {
          if (a.redeem && a.redeem.witness && !(0, types_1.stacksEqual)(a.redeem.witness, a.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2sh = p2sh;
  }
});

// node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/bech32/dist/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bech32m = exports2.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z = 0; z < ALPHABET.length; z++) {
      const x = ALPHABET.charAt(z);
      ALPHABET_MAP[x] = z;
    }
    function polymodStep(pre) {
      const b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i = 0; i < words.length; ++i) {
          const x = words[i];
          if (x >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x;
          result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
          const v = chk >> (5 - i) * 5 & 31;
          result += ALPHABET.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split = str.lastIndexOf("1");
        if (split === -1)
          return "No separator character for " + str;
        if (split === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
          const c = wordChars.charAt(i);
          const v = ALPHABET_MAP[c];
          if (v === void 0)
            return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i + 6 >= wordChars.length)
            continue;
          words.push(v);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports2.bech32 = getLibraryFromEncoding("bech32");
    exports2.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wpkh.js
var require_p2wpkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wpkh = void 0;
    var bcrypto = require_crypto();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bech32_1 = require_dist();
    var OPS = bscript.OPS;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function p2wpkh(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2wpkh", network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32_1.bech32.toWords(o.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2, 22);
        if (a.address) return _address().data;
        if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS.OP_0, o.hash]);
      });
      lazy.prop(o, "pubkey", () => {
        if (a.pubkey) return a.pubkey;
        if (!a.witness) return;
        return a.witness[1];
      });
      lazy.prop(o, "signature", () => {
        if (!a.witness) return;
        return a.witness[0];
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o, "witness", () => {
        if (!a.pubkey) return;
        if (!a.signature) return;
        return [a.signature, a.pubkey];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 20)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 20)
            throw new TypeError("Output is invalid");
          if (hash.length > 0 && !hash.equals(a.output.slice(2)))
            throw new TypeError("Hash mismatch");
          else hash = a.output.slice(2);
        }
        if (a.pubkey) {
          const pkh = bcrypto.hash160(a.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
          if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
            throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a.witness) {
          if (a.witness.length !== 2) throw new TypeError("Witness is invalid");
          if (!bscript.isCanonicalScriptSignature(a.witness[0]))
            throw new TypeError("Witness has invalid signature");
          if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
            throw new TypeError("Witness has invalid pubkey");
          if (a.signature && !a.signature.equals(a.witness[0]))
            throw new TypeError("Signature mismatch");
          if (a.pubkey && !a.pubkey.equals(a.witness[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(a.witness[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wpkh = p2wpkh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wsh.js
var require_p2wsh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wsh.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2wsh = void 0;
    var bcrypto = require_crypto();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bech32_1 = require_dist();
    var OPS = bscript.OPS;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function chunkHasUncompressedPubkey(chunk) {
      if (Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && (0, types_1.isPoint)(chunk)) {
        return true;
      } else {
        return false;
      }
    }
    function p2wsh(a, opts) {
      if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          redeem: types_1.typeforce.maybe({
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const _rchunks = lazy.value(() => {
        return bscript.decompile(a.redeem.input);
      });
      let network = a.network;
      if (!network) {
        network = a.redeem && a.redeem.network || networks_1.bitcoin;
      }
      const o = { network };
      lazy.prop(o, "address", () => {
        if (!o.hash) return;
        const words = bech32_1.bech32.toWords(o.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
      });
      lazy.prop(o, "output", () => {
        if (!o.hash) return;
        return bscript.compile([OPS.OP_0, o.hash]);
      });
      lazy.prop(o, "redeem", () => {
        if (!a.witness) return;
        return {
          output: a.witness[a.witness.length - 1],
          input: EMPTY_BUFFER,
          witness: a.witness.slice(0, -1)
        };
      });
      lazy.prop(o, "input", () => {
        if (!o.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o, "witness", () => {
        if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
          const stack = bscript.toStack(_rchunks());
          o.redeem = Object.assign({ witness: stack }, a.redeem);
          o.redeem.input = EMPTY_BUFFER;
          return [].concat(stack, a.redeem.output);
        }
        if (!a.redeem) return;
        if (!a.redeem.output) return;
        if (!a.redeem.witness) return;
        return [].concat(a.redeem.witness, a.redeem.output);
      });
      lazy.prop(o, "name", () => {
        const nameParts = ["p2wsh"];
        if (o.redeem !== void 0 && o.redeem.name !== void 0)
          nameParts.push(o.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a.address) {
          if (_address().prefix !== network.bech32)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a.hash) {
          if (hash.length > 0 && !hash.equals(a.hash))
            throw new TypeError("Hash mismatch");
          else hash = a.hash;
        }
        if (a.output) {
          if (a.output.length !== 34 || a.output[0] !== OPS.OP_0 || a.output[1] !== 32)
            throw new TypeError("Output is invalid");
          const hash2 = a.output.slice(2);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a.redeem) {
          if (a.redeem.network && a.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0)
            throw new TypeError("Ambiguous witness source");
          if (a.redeem.output) {
            const decompile = bscript.decompile(a.redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output is invalid");
            if (a.redeem.output.byteLength > 3600)
              throw new TypeError(
                "Redeem.output unspendable if larger than 3600 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.sha256(a.redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
            throw new TypeError("Non push-only scriptSig");
          if (a.witness && a.redeem.witness && !(0, types_1.stacksEqual)(a.witness, a.redeem.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
          if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey
          )) {
            throw new TypeError(
              "redeem.input or redeem.output contains uncompressed pubkey"
            );
          }
        }
        if (a.witness && a.witness.length > 0) {
          const wScript = a.witness[a.witness.length - 1];
          if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
            throw new TypeError("Witness and redeem.output mismatch");
          if (a.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey))
            throw new TypeError("Witness contains uncompressed pubkey");
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2wsh = p2wsh;
  }
});

// node_modules/bitcoinjs-lib/src/ecc_lib.js
var require_ecc_lib = __commonJS({
  "node_modules/bitcoinjs-lib/src/ecc_lib.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEccLib = exports2.initEccLib = void 0;
    var _ECCLIB_CACHE = {};
    function initEccLib2(eccLib, opts) {
      if (!eccLib) {
        _ECCLIB_CACHE.eccLib = eccLib;
      } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
        if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)
          verifyEcc(eccLib);
        _ECCLIB_CACHE.eccLib = eccLib;
      }
    }
    exports2.initEccLib = initEccLib2;
    function getEccLib() {
      if (!_ECCLIB_CACHE.eccLib)
        throw new Error(
          "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
        );
      return _ECCLIB_CACHE.eccLib;
    }
    exports2.getEccLib = getEccLib;
    var h = (hex) => Buffer.from(hex, "hex");
    function verifyEcc(ecc) {
      assert(typeof ecc.isXOnlyPoint === "function");
      assert(
        ecc.isXOnlyPoint(
          h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h("0000000000000000000000000000000000000000000000000000000000000001")
        )
      );
      assert(
        !ecc.isXOnlyPoint(
          h("0000000000000000000000000000000000000000000000000000000000000000")
        )
      );
      assert(
        !ecc.isXOnlyPoint(
          h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
        )
      );
      assert(typeof ecc.xOnlyPointAddTweak === "function");
      tweakAddVectors.forEach((t) => {
        const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
        if (t.result === null) {
          assert(r === null);
        } else {
          assert(r !== null);
          assert(r.parity === t.parity);
          assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));
        }
      });
    }
    function assert(bool) {
      if (!bool) throw new Error("ecc library invalid");
    }
    var tweakAddVectors = [
      {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
      },
      {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
      },
      {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
      }
    ];
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_esbuild_shims();
    init_buffer_shims();
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/varuint-bitcoin/index.js
var require_varuint_bitcoin = __commonJS({
  "node_modules/varuint-bitcoin/index.js"(exports2, module2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    var Buffer3 = require_safe_buffer().Buffer;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n) {
      if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError("value out of range");
    }
    function encode(number, buffer, offset) {
      checkUInt53(number);
      if (!buffer) buffer = Buffer3.allocUnsafe(encodingLength(number));
      if (!Buffer3.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (number < 253) {
        buffer.writeUInt8(number, offset);
        encode.bytes = 1;
      } else if (number <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(number, offset + 1);
        encode.bytes = 3;
      } else if (number <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(number, offset + 1);
        encode.bytes = 5;
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(number >>> 0, offset + 1);
        buffer.writeUInt32LE(number / 4294967296 | 0, offset + 5);
        encode.bytes = 9;
      }
      return buffer;
    }
    function decode(buffer, offset) {
      if (!Buffer3.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      var first = buffer.readUInt8(offset);
      if (first < 253) {
        decode.bytes = 1;
        return first;
      } else if (first === 253) {
        decode.bytes = 3;
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        decode.bytes = 5;
        return buffer.readUInt32LE(offset + 1);
      } else {
        decode.bytes = 9;
        var lo = buffer.readUInt32LE(offset + 1);
        var hi = buffer.readUInt32LE(offset + 5);
        var number = hi * 4294967296 + lo;
        checkUInt53(number);
        return number;
      }
    }
    function encodingLength(number) {
      checkUInt53(number);
      return number < 253 ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
    }
    module2.exports = { encode, decode, encodingLength };
  }
});

// node_modules/bitcoinjs-lib/src/bufferutils.js
var require_bufferutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/bufferutils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferReader = exports2.BufferWriter = exports2.cloneBuffer = exports2.reverseBuffer = exports2.writeUInt64LE = exports2.readUInt64LE = exports2.varuint = void 0;
    var types = require_types();
    var { typeforce } = types;
    var varuint = require_varuint_bitcoin();
    exports2.varuint = varuint;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a = buffer.readUInt32LE(offset);
      let b = buffer.readUInt32LE(offset + 4);
      b *= 4294967296;
      verifuint(b + a, 9007199254740991);
      return b + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j = buffer.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer.length / 2; i++) {
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
      }
      return buffer;
    }
    exports2.reverseBuffer = reverseBuffer;
    function cloneBuffer(buffer) {
      const clone = Buffer.allocUnsafe(buffer.length);
      buffer.copy(clone);
      return clone;
    }
    exports2.cloneBuffer = cloneBuffer;
    var BufferWriter = class _BufferWriter {
      static withCapacity(size) {
        return new _BufferWriter(Buffer.alloc(size));
      }
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      writeUInt8(i) {
        this.offset = this.buffer.writeUInt8(i, this.offset);
      }
      writeInt32(i) {
        this.offset = this.buffer.writeInt32LE(i, this.offset);
      }
      writeUInt32(i) {
        this.offset = this.buffer.writeUInt32LE(i, this.offset);
      }
      writeUInt64(i) {
        this.offset = writeUInt64LE(this.buffer, i, this.offset);
      }
      writeVarInt(i) {
        varuint.encode(i, this.buffer, this.offset);
        this.offset += varuint.encode.bytes;
      }
      writeSlice(slice) {
        if (this.buffer.length < this.offset + slice.length) {
          throw new Error("Cannot write slice out of bounds");
        }
        this.offset += slice.copy(this.buffer, this.offset);
      }
      writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
      }
      writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf) => this.writeVarSlice(buf));
      }
      end() {
        if (this.buffer.length === this.offset) {
          return this.buffer;
        }
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
      }
    };
    exports2.BufferWriter = BufferWriter;
    var BufferReader = class {
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
      }
      readVarInt() {
        const vi = varuint.decode(this.buffer, this.offset);
        this.offset += varuint.decode.bytes;
        return vi;
      }
      readSlice(n) {
        if (this.buffer.length < this.offset + n) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n);
        this.offset += n;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
        return vector;
      }
    };
    exports2.BufferReader = BufferReader;
  }
});

// node_modules/bitcoinjs-lib/src/payments/bip341.js
var require_bip341 = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/bip341.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tweakKey = exports2.tapTweakHash = exports2.tapleafHash = exports2.findScriptPath = exports2.toHashTree = exports2.rootHashFromPath = exports2.MAX_TAPTREE_DEPTH = exports2.LEAF_VERSION_TAPSCRIPT = void 0;
    var buffer_1 = require("buffer");
    var ecc_lib_1 = require_ecc_lib();
    var bcrypto = require_crypto();
    var bufferutils_1 = require_bufferutils();
    var types_1 = require_types();
    exports2.LEAF_VERSION_TAPSCRIPT = 192;
    exports2.MAX_TAPTREE_DEPTH = 128;
    var isHashBranch = (ht) => "left" in ht && "right" in ht;
    function rootHashFromPath(controlBlock, leafHash) {
      if (controlBlock.length < 33)
        throw new TypeError(
          `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
        );
      const m = (controlBlock.length - 33) / 32;
      let kj = leafHash;
      for (let j = 0; j < m; j++) {
        const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
        if (kj.compare(ej) < 0) {
          kj = tapBranchHash(kj, ej);
        } else {
          kj = tapBranchHash(ej, kj);
        }
      }
      return kj;
    }
    exports2.rootHashFromPath = rootHashFromPath;
    function toHashTree(scriptTree) {
      if ((0, types_1.isTapleaf)(scriptTree))
        return { hash: tapleafHash(scriptTree) };
      const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
      hashes.sort((a, b) => a.hash.compare(b.hash));
      const [left, right] = hashes;
      return {
        hash: tapBranchHash(left.hash, right.hash),
        left,
        right
      };
    }
    exports2.toHashTree = toHashTree;
    function findScriptPath(node, hash) {
      if (isHashBranch(node)) {
        const leftPath = findScriptPath(node.left, hash);
        if (leftPath !== void 0) return [...leftPath, node.right.hash];
        const rightPath = findScriptPath(node.right, hash);
        if (rightPath !== void 0) return [...rightPath, node.left.hash];
      } else if (node.hash.equals(hash)) {
        return [];
      }
      return void 0;
    }
    exports2.findScriptPath = findScriptPath;
    function tapleafHash(leaf) {
      const version = leaf.version || exports2.LEAF_VERSION_TAPSCRIPT;
      return bcrypto.taggedHash(
        "TapLeaf",
        buffer_1.Buffer.concat([
          buffer_1.Buffer.from([version]),
          serializeScript(leaf.output)
        ])
      );
    }
    exports2.tapleafHash = tapleafHash;
    function tapTweakHash(pubKey, h) {
      return bcrypto.taggedHash(
        "TapTweak",
        buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey])
      );
    }
    exports2.tapTweakHash = tapTweakHash;
    function tweakKey(pubKey, h) {
      if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
      if (pubKey.length !== 32) return null;
      if (h && h.length !== 32) return null;
      const tweakHash = tapTweakHash(pubKey, h);
      const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
      if (!res || res.xOnlyPubkey === null) return null;
      return {
        parity: res.parity,
        x: buffer_1.Buffer.from(res.xOnlyPubkey)
      };
    }
    exports2.tweakKey = tweakKey;
    function tapBranchHash(a, b) {
      return bcrypto.taggedHash("TapBranch", buffer_1.Buffer.concat([a, b]));
    }
    function serializeScript(s) {
      const varintLen = bufferutils_1.varuint.encodingLength(s.length);
      const buffer = buffer_1.Buffer.allocUnsafe(varintLen);
      bufferutils_1.varuint.encode(s.length, buffer);
      return buffer_1.Buffer.concat([buffer, s]);
    }
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2tr.js
var require_p2tr = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2tr.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2tr = void 0;
    var buffer_1 = require("buffer");
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var ecc_lib_1 = require_ecc_lib();
    var bip341_1 = require_bip341();
    var lazy = require_lazy();
    var bech32_1 = require_dist();
    var address_1 = require_address();
    var OPS = bscript.OPS;
    var TAPROOT_WITNESS_VERSION = 1;
    var ANNEX_PREFIX = 80;
    function p2tr(a, opts) {
      if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1))
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          signature: types_1.typeforce.maybe(
            types_1.typeforce.anyOf(
              types_1.typeforce.BufferN(64),
              types_1.typeforce.BufferN(65)
            )
          ),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          ),
          scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
          redeem: types_1.typeforce.maybe({
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number)
        },
        a
      );
      const _address = lazy.value(() => {
        return (0, address_1.fromBech32)(a.address);
      });
      const _witness = lazy.value(() => {
        if (!a.witness || !a.witness.length) return;
        if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {
          return a.witness.slice(0, -1);
        }
        return a.witness.slice();
      });
      const _hashTree = lazy.value(() => {
        if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);
        if (a.hash) return { hash: a.hash };
        return;
      });
      const network = a.network || networks_1.bitcoin;
      const o = { name: "p2tr", network };
      lazy.prop(o, "address", () => {
        if (!o.pubkey) return;
        const words = bech32_1.bech32m.toWords(o.pubkey);
        words.unshift(TAPROOT_WITNESS_VERSION);
        return bech32_1.bech32m.encode(network.bech32, words);
      });
      lazy.prop(o, "hash", () => {
        const hashTree = _hashTree();
        if (hashTree) return hashTree.hash;
        const w = _witness();
        if (w && w.length > 1) {
          const controlBlock = w[w.length - 1];
          const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
          const script = w[w.length - 2];
          const leafHash = (0, bip341_1.tapleafHash)({
            output: script,
            version: leafVersion
          });
          return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        }
        return null;
      });
      lazy.prop(o, "output", () => {
        if (!o.pubkey) return;
        return bscript.compile([OPS.OP_1, o.pubkey]);
      });
      lazy.prop(o, "redeemVersion", () => {
        if (a.redeemVersion) return a.redeemVersion;
        if (a.redeem && a.redeem.redeemVersion !== void 0 && a.redeem.redeemVersion !== null) {
          return a.redeem.redeemVersion;
        }
        return bip341_1.LEAF_VERSION_TAPSCRIPT;
      });
      lazy.prop(o, "redeem", () => {
        const witness = _witness();
        if (!witness || witness.length < 2) return;
        return {
          output: witness[witness.length - 2],
          witness: witness.slice(0, -2),
          redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK
        };
      });
      lazy.prop(o, "pubkey", () => {
        if (a.pubkey) return a.pubkey;
        if (a.output) return a.output.slice(2);
        if (a.address) return _address().data;
        if (o.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);
          if (tweakedKey) return tweakedKey.x;
        }
      });
      lazy.prop(o, "internalPubkey", () => {
        if (a.internalPubkey) return a.internalPubkey;
        const witness = _witness();
        if (witness && witness.length > 1)
          return witness[witness.length - 1].slice(1, 33);
      });
      lazy.prop(o, "signature", () => {
        if (a.signature) return a.signature;
        const witness = _witness();
        if (!witness || witness.length !== 1) return;
        return witness[0];
      });
      lazy.prop(o, "witness", () => {
        if (a.witness) return a.witness;
        const hashTree = _hashTree();
        if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a.redeem.output,
            version: o.redeemVersion
          });
          const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
          if (!path) return;
          const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);
          if (!outputKey) return;
          const controlBock = buffer_1.Buffer.concat(
            [
              buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),
              a.internalPubkey
            ].concat(path)
          );
          return [a.redeem.output, controlBock];
        }
        if (a.signature) return [a.signature];
      });
      if (opts.validate) {
        let pubkey = buffer_1.Buffer.from([]);
        if (a.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== TAPROOT_WITNESS_VERSION)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          pubkey = _address().data;
        }
        if (a.pubkey) {
          if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a.pubkey;
        }
        if (a.output) {
          if (a.output.length !== 34 || a.output[0] !== OPS.OP_1 || a.output[1] !== 32)
            throw new TypeError("Output is invalid");
          if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a.output.slice(2);
        }
        if (a.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);
          if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
            throw new TypeError("Pubkey mismatch");
          else pubkey = tweakedKey.x;
        }
        if (pubkey && pubkey.length) {
          if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
            throw new TypeError("Invalid pubkey for p2tr");
        }
        const hashTree = _hashTree();
        if (a.hash && hashTree) {
          if (!a.hash.equals(hashTree.hash)) throw new TypeError("Hash mismatch");
        }
        if (a.redeem && a.redeem.output && hashTree) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a.redeem.output,
            version: o.redeemVersion
          });
          if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
            throw new TypeError("Redeem script not in tree");
        }
        const witness = _witness();
        if (a.redeem && o.redeem) {
          if (a.redeem.redeemVersion) {
            if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
              throw new TypeError("Redeem.redeemVersion and witness mismatch");
          }
          if (a.redeem.output) {
            if (bscript.decompile(a.redeem.output).length === 0)
              throw new TypeError("Redeem.output is invalid");
            if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
              throw new TypeError("Redeem.output and witness mismatch");
          }
          if (a.redeem.witness) {
            if (o.redeem.witness && !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness))
              throw new TypeError("Redeem.witness and witness mismatch");
          }
        }
        if (witness && witness.length) {
          if (witness.length === 1) {
            if (a.signature && !a.signature.equals(witness[0]))
              throw new TypeError("Signature mismatch");
          } else {
            const controlBlock = witness[witness.length - 1];
            if (controlBlock.length < 33)
              throw new TypeError(
                `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
              );
            if ((controlBlock.length - 33) % 32 !== 0)
              throw new TypeError(
                `The control-block length of ${controlBlock.length} is incorrect!`
              );
            const m = (controlBlock.length - 33) / 32;
            if (m > 128)
              throw new TypeError(
                `The script path is too long. Got ${m}, expected max 128.`
              );
            const internalPubkey = controlBlock.slice(1, 33);
            if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
              throw new TypeError("Internal pubkey mismatch");
            if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
              throw new TypeError("Invalid internalPubkey for p2tr witness");
            const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
            const script = witness[witness.length - 2];
            const leafHash = (0, bip341_1.tapleafHash)({
              output: script,
              version: leafVersion
            });
            const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
            const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
            if (!outputKey)
              throw new TypeError("Invalid outputKey for p2tr witness");
            if (pubkey.length && !pubkey.equals(outputKey.x))
              throw new TypeError("Pubkey mismatch for p2tr witness");
            if (outputKey.parity !== (controlBlock[0] & 1))
              throw new Error("Incorrect parity");
          }
        }
      }
      return Object.assign(o, a);
    }
    exports2.p2tr = p2tr;
  }
});

// node_modules/bitcoinjs-lib/src/payments/index.js
var require_payments = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.p2tr = exports2.p2wsh = exports2.p2wpkh = exports2.p2sh = exports2.p2pkh = exports2.p2pk = exports2.p2ms = exports2.embed = void 0;
    var embed_1 = require_embed();
    Object.defineProperty(exports2, "embed", {
      enumerable: true,
      get: function() {
        return embed_1.p2data;
      }
    });
    var p2ms_1 = require_p2ms();
    Object.defineProperty(exports2, "p2ms", {
      enumerable: true,
      get: function() {
        return p2ms_1.p2ms;
      }
    });
    var p2pk_1 = require_p2pk();
    Object.defineProperty(exports2, "p2pk", {
      enumerable: true,
      get: function() {
        return p2pk_1.p2pk;
      }
    });
    var p2pkh_1 = require_p2pkh();
    Object.defineProperty(exports2, "p2pkh", {
      enumerable: true,
      get: function() {
        return p2pkh_1.p2pkh;
      }
    });
    var p2sh_1 = require_p2sh();
    Object.defineProperty(exports2, "p2sh", {
      enumerable: true,
      get: function() {
        return p2sh_1.p2sh;
      }
    });
    var p2wpkh_1 = require_p2wpkh();
    Object.defineProperty(exports2, "p2wpkh", {
      enumerable: true,
      get: function() {
        return p2wpkh_1.p2wpkh;
      }
    });
    var p2wsh_1 = require_p2wsh();
    Object.defineProperty(exports2, "p2wsh", {
      enumerable: true,
      get: function() {
        return p2wsh_1.p2wsh;
      }
    });
    var p2tr_1 = require_p2tr();
    Object.defineProperty(exports2, "p2tr", {
      enumerable: true,
      get: function() {
        return p2tr_1.p2tr;
      }
    });
  }
});

// node_modules/bitcoinjs-lib/src/address.js
var require_address = __commonJS({
  "node_modules/bitcoinjs-lib/src/address.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toOutputScript = exports2.fromOutputScript = exports2.toBech32 = exports2.toBase58Check = exports2.fromBech32 = exports2.fromBase58Check = void 0;
    var networks = require_networks();
    var payments = require_payments();
    var bscript = require_script();
    var types_1 = require_types();
    var bech32_1 = require_dist();
    var bs58check = require_bs58check();
    var FUTURE_SEGWIT_MAX_SIZE = 40;
    var FUTURE_SEGWIT_MIN_SIZE = 2;
    var FUTURE_SEGWIT_MAX_VERSION = 16;
    var FUTURE_SEGWIT_MIN_VERSION = 2;
    var FUTURE_SEGWIT_VERSION_DIFF = 80;
    var FUTURE_SEGWIT_VERSION_WARNING = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
    function _toFutureSegwitAddress(output, network) {
      const data = output.slice(2);
      if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError("Invalid program length for segwit address");
      const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
      if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION)
        throw new TypeError("Invalid version for segwit address");
      if (output[1] !== data.length)
        throw new TypeError("Invalid script for segwit address");
      console.warn(FUTURE_SEGWIT_VERSION_WARNING);
      return toBech32(data, version, network.bech32);
    }
    function fromBase58Check(address) {
      const payload = Buffer.from(bs58check.decode(address));
      if (payload.length < 21) throw new TypeError(address + " is too short");
      if (payload.length > 21) throw new TypeError(address + " is too long");
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    }
    exports2.fromBase58Check = fromBase58Check;
    function fromBech32(address) {
      let result;
      let version;
      try {
        result = bech32_1.bech32.decode(address);
      } catch (e) {
      }
      if (result) {
        version = result.words[0];
        if (version !== 0) throw new TypeError(address + " uses wrong encoding");
      } else {
        result = bech32_1.bech32m.decode(address);
        version = result.words[0];
        if (version === 0) throw new TypeError(address + " uses wrong encoding");
      }
      const data = bech32_1.bech32.fromWords(result.words.slice(1));
      return {
        version,
        prefix: result.prefix,
        data: Buffer.from(data)
      };
    }
    exports2.fromBech32 = fromBech32;
    function toBase58Check(hash, version) {
      (0, types_1.typeforce)(
        (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
        arguments
      );
      const payload = Buffer.allocUnsafe(21);
      payload.writeUInt8(version, 0);
      hash.copy(payload, 1);
      return bs58check.encode(payload);
    }
    exports2.toBase58Check = toBase58Check;
    function toBech32(data, version, prefix) {
      const words = bech32_1.bech32.toWords(data);
      words.unshift(version);
      return version === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
    }
    exports2.toBech32 = toBech32;
    function fromOutputScript(output, network) {
      network = network || networks.bitcoin;
      try {
        return payments.p2pkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2sh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wpkh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2wsh({ output, network }).address;
      } catch (e) {
      }
      try {
        return payments.p2tr({ output, network }).address;
      } catch (e) {
      }
      try {
        return _toFutureSegwitAddress(output, network);
      } catch (e) {
      }
      throw new Error(bscript.toASM(output) + " has no matching Address");
    }
    exports2.fromOutputScript = fromOutputScript;
    function toOutputScript(address, network) {
      network = network || networks.bitcoin;
      let decodeBase58;
      let decodeBech32;
      try {
        decodeBase58 = fromBase58Check(address);
      } catch (e) {
      }
      if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
          return payments.p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
          return payments.p2sh({ hash: decodeBase58.hash }).output;
      } else {
        try {
          decodeBech32 = fromBech32(address);
        } catch (e) {
        }
        if (decodeBech32) {
          if (decodeBech32.prefix !== network.bech32)
            throw new Error(address + " has an invalid prefix");
          if (decodeBech32.version === 0) {
            if (decodeBech32.data.length === 20)
              return payments.p2wpkh({ hash: decodeBech32.data }).output;
            if (decodeBech32.data.length === 32)
              return payments.p2wsh({ hash: decodeBech32.data }).output;
          } else if (decodeBech32.version === 1) {
            if (decodeBech32.data.length === 32)
              return payments.p2tr({ pubkey: decodeBech32.data }).output;
          } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
            console.warn(FUTURE_SEGWIT_VERSION_WARNING);
            return bscript.compile([
              decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
              decodeBech32.data
            ]);
          }
        }
      }
      throw new Error(address + " has no matching Script");
    }
    exports2.toOutputScript = toOutputScript;
  }
});

// node_modules/bitcoinjs-lib/src/merkle.js
var require_merkle = __commonJS({
  "node_modules/bitcoinjs-lib/src/merkle.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fastMerkleRoot = void 0;
    function fastMerkleRoot(values, digestFn) {
      if (!Array.isArray(values)) throw TypeError("Expected values Array");
      if (typeof digestFn !== "function")
        throw TypeError("Expected digest Function");
      let length = values.length;
      const results = values.concat();
      while (length > 1) {
        let j = 0;
        for (let i = 0; i < length; i += 2, ++j) {
          const left = results[i];
          const right = i + 1 === length ? left : results[i + 1];
          const data = Buffer.concat([left, right]);
          results[j] = digestFn(data);
        }
        length = j;
      }
      return results[0];
    }
    exports2.fastMerkleRoot = fastMerkleRoot;
  }
});

// node_modules/bitcoinjs-lib/src/transaction.js
var require_transaction = __commonJS({
  "node_modules/bitcoinjs-lib/src/transaction.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transaction = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto();
    var bscript = require_script();
    var script_1 = require_script();
    var types = require_types();
    var { typeforce } = types;
    function varSliceSize(someScript) {
      const length = someScript.length;
      return bufferutils_1.varuint.encodingLength(length) + length;
    }
    function vectorSize(someVector) {
      const length = someVector.length;
      return bufferutils_1.varuint.encodingLength(length) + someVector.reduce((sum, witness) => {
        return sum + varSliceSize(witness);
      }, 0);
    }
    var EMPTY_BUFFER = Buffer.allocUnsafe(0);
    var EMPTY_WITNESS = [];
    var ZERO = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000000",
      "hex"
    );
    var ONE = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    var VALUE_UINT64_MAX = Buffer.from("ffffffffffffffff", "hex");
    var BLANK_OUTPUT = {
      script: EMPTY_BUFFER,
      valueBuffer: VALUE_UINT64_MAX
    };
    function isOutput(out) {
      return out.value !== void 0;
    }
    var Transaction2 = class _Transaction {
      constructor() {
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
      }
      static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const tx = new _Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
          hasWitnesses = true;
        } else {
          bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i = 0; i < vinLen; ++i) {
          tx.ins.push({
            hash: bufferReader.readSlice(32),
            index: bufferReader.readUInt32(),
            script: bufferReader.readVarSlice(),
            sequence: bufferReader.readUInt32(),
            witness: EMPTY_WITNESS
          });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i = 0; i < voutLen; ++i) {
          tx.outs.push({
            value: bufferReader.readUInt64(),
            script: bufferReader.readVarSlice()
          });
        }
        if (hasWitnesses) {
          for (let i = 0; i < vinLen; ++i) {
            tx.ins[i].witness = bufferReader.readVector();
          }
          if (!tx.hasWitnesses())
            throw new Error("Transaction has superfluous witness data");
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer.length)
          throw new Error("Transaction has unexpected data");
        return tx;
      }
      static fromHex(hex) {
        return _Transaction.fromBuffer(Buffer.from(hex, "hex"), false);
      }
      static isCoinbaseHash(buffer) {
        typeforce(types.Hash256bit, buffer);
        for (let i = 0; i < 32; ++i) {
          if (buffer[i] !== 0) return false;
        }
        return true;
      }
      isCoinbase() {
        return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
      }
      addInput(hash, index, sequence, scriptSig) {
        typeforce(
          types.tuple(
            types.Hash256bit,
            types.UInt32,
            types.maybe(types.UInt32),
            types.maybe(types.Buffer)
          ),
          arguments
        );
        if (types.Null(sequence)) {
          sequence = _Transaction.DEFAULT_SEQUENCE;
        }
        return this.ins.push({
          hash,
          index,
          script: scriptSig || EMPTY_BUFFER,
          sequence,
          witness: EMPTY_WITNESS
        }) - 1;
      }
      addOutput(scriptPubKey, value) {
        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
        return this.outs.push({
          script: scriptPubKey,
          value
        }) - 1;
      }
      hasWitnesses() {
        return this.ins.some((x) => {
          return x.witness.length !== 0;
        });
      }
      stripWitnesses() {
        this.ins.forEach((input) => {
          input.witness = EMPTY_WITNESS;
        });
      }
      weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
      }
      virtualSize() {
        return Math.ceil(this.weight() / 4);
      }
      byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return (hasWitnesses ? 10 : 8) + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {
          return sum + 40 + varSliceSize(input.script);
        }, 0) + this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
          return sum + vectorSize(input.witness);
        }, 0) : 0);
      }
      clone() {
        const newTx = new _Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
          return {
            hash: txIn.hash,
            index: txIn.index,
            script: txIn.script,
            sequence: txIn.sequence,
            witness: txIn.witness
          };
        });
        newTx.outs = this.outs.map((txOut) => {
          return {
            script: txOut.script,
            value: txOut.value
          };
        });
        return newTx;
      }
      /**
       * Hash transaction for signing a specific input.
       *
       * Bitcoin uses a different hash for each signed transaction input.
       * This method copies the transaction, makes the necessary changes based on the
       * hashType, and then hashes the result.
       * This hash can then be used to sign the provided transaction input.
       */
      hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(
          types.tuple(
            types.UInt32,
            types.Buffer,
            /* types.UInt8 */
            types.Number
          ),
          arguments
        );
        if (inIndex >= this.ins.length) return ONE;
        const ourScript = bscript.compile(
          bscript.decompile(prevOutScript).filter((x) => {
            return x !== script_1.OPS.OP_CODESEPARATOR;
          })
        );
        const txTmp = this.clone();
        if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
          txTmp.outs = [];
          txTmp.ins.forEach((input, i) => {
            if (i === inIndex) return;
            input.sequence = 0;
          });
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
          if (inIndex >= this.outs.length) return ONE;
          txTmp.outs.length = inIndex + 1;
          for (let i = 0; i < inIndex; i++) {
            txTmp.outs[i] = BLANK_OUTPUT;
          }
          txTmp.ins.forEach((input, y) => {
            if (y === inIndex) return;
            input.sequence = 0;
          });
        }
        if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
          txTmp.ins = [txTmp.ins[inIndex]];
          txTmp.ins[0].script = ourScript;
        } else {
          txTmp.ins.forEach((input) => {
            input.script = EMPTY_BUFFER;
          });
          txTmp.ins[inIndex].script = ourScript;
        }
        const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer.writeInt32LE(hashType, buffer.length - 4);
        txTmp.__toBuffer(buffer, 0, false);
        return bcrypto.hash256(buffer);
      }
      hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
        typeforce(
          types.tuple(
            types.UInt32,
            typeforce.arrayOf(types.Buffer),
            typeforce.arrayOf(types.Satoshi),
            types.UInt32
          ),
          arguments
        );
        if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
          throw new Error("Must supply prevout script and value for all inputs");
        }
        const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === _Transaction.SIGHASH_NONE;
        const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BUFFER;
        let hashAmounts = EMPTY_BUFFER;
        let hashScriptPubKeys = EMPTY_BUFFER;
        let hashSequences = EMPTY_BUFFER;
        let hashOutputs = EMPTY_BUFFER;
        if (!isAnyoneCanPay) {
          let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            36 * this.ins.length
          );
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 * this.ins.length
          );
          values.forEach((value) => bufferWriter.writeUInt64(value));
          hashAmounts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            prevOutScripts.map(varSliceSize).reduce((a, b) => a + b)
          );
          prevOutScripts.forEach(
            (prevOutScript) => bufferWriter.writeVarSlice(prevOutScript)
          );
          hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            4 * this.ins.length
          );
          this.ins.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
          hashSequences = bcrypto.sha256(bufferWriter.end());
        }
        if (!(isNone || isSingle)) {
          const txOutsSize = this.outs.map((output) => 8 + varSliceSize(output.script)).reduce((a, b) => a + b);
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        } else if (isSingle && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 + varSliceSize(output.script)
          );
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
        const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
        sigMsgWriter.writeUInt8(hashType);
        sigMsgWriter.writeInt32(this.version);
        sigMsgWriter.writeUInt32(this.locktime);
        sigMsgWriter.writeSlice(hashPrevouts);
        sigMsgWriter.writeSlice(hashAmounts);
        sigMsgWriter.writeSlice(hashScriptPubKeys);
        sigMsgWriter.writeSlice(hashSequences);
        if (!(isNone || isSingle)) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
          const input = this.ins[inIndex];
          sigMsgWriter.writeSlice(input.hash);
          sigMsgWriter.writeUInt32(input.index);
          sigMsgWriter.writeUInt64(values[inIndex]);
          sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
          sigMsgWriter.writeUInt32(input.sequence);
        } else {
          sigMsgWriter.writeUInt32(inIndex);
        }
        if (annex) {
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            varSliceSize(annex)
          );
          bufferWriter.writeVarSlice(annex);
          sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
        }
        if (isSingle) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        if (leafHash) {
          sigMsgWriter.writeSlice(leafHash);
          sigMsgWriter.writeUInt8(0);
          sigMsgWriter.writeUInt32(4294967295);
        }
        return bcrypto.taggedHash(
          "TapSighash",
          Buffer.concat([Buffer.from([0]), sigMsgWriter.end()])
        );
      }
      hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        typeforce(
          types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
          arguments
        );
        let tbuffer = Buffer.from([]);
        let bufferWriter;
        let hashOutputs = ZERO;
        let hashPrevouts = ZERO;
        let hashSequence = ZERO;
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.hash256(tbuffer);
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeUInt32(txIn.sequence);
          });
          hashSequence = bcrypto.hash256(tbuffer);
        }
        if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const txOutsSize = this.outs.reduce((sum, output) => {
            return sum + 8 + varSliceSize(output.script);
          }, 0);
          tbuffer = Buffer.allocUnsafe(txOutsSize);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.hash256(tbuffer);
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.hash256(tbuffer);
        }
        tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return bcrypto.hash256(tbuffer);
      }
      getHash(forWitness) {
        if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
        return bcrypto.hash256(this.__toBuffer(void 0, void 0, forWitness));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
          "hex"
        );
      }
      toBuffer(buffer, initialOffset) {
        return this.__toBuffer(buffer, initialOffset, true);
      }
      toHex() {
        return this.toBuffer(void 0, void 0).toString("hex");
      }
      setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
      }
      setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].witness = witness;
      }
      __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new bufferutils_1.BufferWriter(
          buffer,
          initialOffset || 0
        );
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
          bufferWriter.writeVarSlice(txIn.script);
          bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
          if (isOutput(txOut)) {
            bufferWriter.writeUInt64(txOut.value);
          } else {
            bufferWriter.writeSlice(txOut.valueBuffer);
          }
          bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) {
          this.ins.forEach((input) => {
            bufferWriter.writeVector(input.witness);
          });
        }
        bufferWriter.writeUInt32(this.locktime);
        if (initialOffset !== void 0)
          return buffer.slice(initialOffset, bufferWriter.offset);
        return buffer;
      }
    };
    exports2.Transaction = Transaction2;
    Transaction2.DEFAULT_SEQUENCE = 4294967295;
    Transaction2.SIGHASH_DEFAULT = 0;
    Transaction2.SIGHASH_ALL = 1;
    Transaction2.SIGHASH_NONE = 2;
    Transaction2.SIGHASH_SINGLE = 3;
    Transaction2.SIGHASH_ANYONECANPAY = 128;
    Transaction2.SIGHASH_OUTPUT_MASK = 3;
    Transaction2.SIGHASH_INPUT_MASK = 128;
    Transaction2.ADVANCED_TRANSACTION_MARKER = 0;
    Transaction2.ADVANCED_TRANSACTION_FLAG = 1;
  }
});

// node_modules/bitcoinjs-lib/src/block.js
var require_block = __commonJS({
  "node_modules/bitcoinjs-lib/src/block.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Block = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto();
    var merkle_1 = require_merkle();
    var transaction_1 = require_transaction();
    var types = require_types();
    var { typeforce } = types;
    var errorMerkleNoTxes = new TypeError(
      "Cannot compute merkle root for zero transactions"
    );
    var errorWitnessNotSegwit = new TypeError(
      "Cannot compute witness commit for non-segwit block"
    );
    var Block = class _Block {
      constructor() {
        this.version = 1;
        this.prevHash = void 0;
        this.merkleRoot = void 0;
        this.timestamp = 0;
        this.witnessCommit = void 0;
        this.bits = 0;
        this.nonce = 0;
        this.transactions = void 0;
      }
      static fromBuffer(buffer) {
        if (buffer.length < 80) throw new Error("Buffer too small (< 80 bytes)");
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const block = new _Block();
        block.version = bufferReader.readInt32();
        block.prevHash = bufferReader.readSlice(32);
        block.merkleRoot = bufferReader.readSlice(32);
        block.timestamp = bufferReader.readUInt32();
        block.bits = bufferReader.readUInt32();
        block.nonce = bufferReader.readUInt32();
        if (buffer.length === 80) return block;
        const readTransaction = () => {
          const tx = transaction_1.Transaction.fromBuffer(
            bufferReader.buffer.slice(bufferReader.offset),
            true
          );
          bufferReader.offset += tx.byteLength();
          return tx;
        };
        const nTransactions = bufferReader.readVarInt();
        block.transactions = [];
        for (let i = 0; i < nTransactions; ++i) {
          const tx = readTransaction();
          block.transactions.push(tx);
        }
        const witnessCommit = block.getWitnessCommit();
        if (witnessCommit) block.witnessCommit = witnessCommit;
        return block;
      }
      static fromHex(hex) {
        return _Block.fromBuffer(Buffer.from(hex, "hex"));
      }
      static calculateTarget(bits) {
        const exponent = ((bits & 4278190080) >> 24) - 3;
        const mantissa = bits & 8388607;
        const target = Buffer.alloc(32, 0);
        target.writeUIntBE(mantissa, 29 - exponent, 3);
        return target;
      }
      static calculateMerkleRoot(transactions, forWitness) {
        typeforce([{ getHash: types.Function }], transactions);
        if (transactions.length === 0) throw errorMerkleNoTxes;
        if (forWitness && !txesHaveWitnessCommit(transactions))
          throw errorWitnessNotSegwit;
        const hashes = transactions.map(
          (transaction) => transaction.getHash(forWitness)
        );
        const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
        return forWitness ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])
        ) : rootHash;
      }
      getWitnessCommit() {
        if (!txesHaveWitnessCommit(this.transactions)) return null;
        const witnessCommits = this.transactions[0].outs.filter(
          (out) => out.script.slice(0, 6).equals(Buffer.from("6a24aa21a9ed", "hex"))
        ).map((out) => out.script.slice(6, 38));
        if (witnessCommits.length === 0) return null;
        const result = witnessCommits[witnessCommits.length - 1];
        if (!(result instanceof Buffer && result.length === 32)) return null;
        return result;
      }
      hasWitnessCommit() {
        if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32)
          return true;
        if (this.getWitnessCommit() !== null) return true;
        return false;
      }
      hasWitness() {
        return anyTxHasWitness(this.transactions);
      }
      weight() {
        const base = this.byteLength(false, false);
        const total = this.byteLength(false, true);
        return base * 3 + total;
      }
      byteLength(headersOnly, allowWitness = true) {
        if (headersOnly || !this.transactions) return 80;
        return 80 + bufferutils_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0);
      }
      getHash() {
        return bcrypto.hash256(this.toBuffer(true));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString("hex");
      }
      getUTCDate() {
        const date = /* @__PURE__ */ new Date(0);
        date.setUTCSeconds(this.timestamp);
        return date;
      }
      // TODO: buffer, offset compatibility
      toBuffer(headersOnly) {
        const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer);
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(this.prevHash);
        bufferWriter.writeSlice(this.merkleRoot);
        bufferWriter.writeUInt32(this.timestamp);
        bufferWriter.writeUInt32(this.bits);
        bufferWriter.writeUInt32(this.nonce);
        if (headersOnly || !this.transactions) return buffer;
        bufferutils_1.varuint.encode(
          this.transactions.length,
          buffer,
          bufferWriter.offset
        );
        bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
        this.transactions.forEach((tx) => {
          const txSize = tx.byteLength();
          tx.toBuffer(buffer, bufferWriter.offset);
          bufferWriter.offset += txSize;
        });
        return buffer;
      }
      toHex(headersOnly) {
        return this.toBuffer(headersOnly).toString("hex");
      }
      checkTxRoots() {
        const hasWitnessCommit = this.hasWitnessCommit();
        if (!hasWitnessCommit && this.hasWitness()) return false;
        return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
      }
      checkProofOfWork() {
        const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
        const target = _Block.calculateTarget(this.bits);
        return hash.compare(target) <= 0;
      }
      __checkMerkleRoot() {
        if (!this.transactions) throw errorMerkleNoTxes;
        const actualMerkleRoot = _Block.calculateMerkleRoot(this.transactions);
        return this.merkleRoot.compare(actualMerkleRoot) === 0;
      }
      __checkWitnessCommit() {
        if (!this.transactions) throw errorMerkleNoTxes;
        if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
        const actualWitnessCommit = _Block.calculateMerkleRoot(
          this.transactions,
          true
        );
        return this.witnessCommit.compare(actualWitnessCommit) === 0;
      }
    };
    exports2.Block = Block;
    function txesHaveWitnessCommit(transactions) {
      return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
    }
    function anyTxHasWitness(transactions) {
      return transactions instanceof Array && transactions.some(
        (tx) => typeof tx === "object" && tx.ins instanceof Array && tx.ins.some(
          (input) => typeof input === "object" && input.witness instanceof Array && input.witness.length > 0
        )
      );
    }
  }
});

// node_modules/bip174/src/lib/typeFields.js
var require_typeFields = __commonJS({
  "node_modules/bip174/src/lib/typeFields.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GlobalTypes;
    (function(GlobalTypes2) {
      GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
      GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
    })(GlobalTypes = exports2.GlobalTypes || (exports2.GlobalTypes = {}));
    exports2.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
    var InputTypes;
    (function(InputTypes2) {
      InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
      InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
      InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
      InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
      InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
      InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
      InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
    })(InputTypes = exports2.InputTypes || (exports2.InputTypes = {}));
    exports2.INPUT_TYPE_NAMES = [
      "nonWitnessUtxo",
      "witnessUtxo",
      "partialSig",
      "sighashType",
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "finalScriptSig",
      "finalScriptWitness",
      "porCommitment",
      "tapKeySig",
      "tapScriptSig",
      "tapLeafScript",
      "tapBip32Derivation",
      "tapInternalKey",
      "tapMerkleRoot"
    ];
    var OutputTypes;
    (function(OutputTypes2) {
      OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
      OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
      OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
      OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
      OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
    })(OutputTypes = exports2.OutputTypes || (exports2.OutputTypes = {}));
    exports2.OUTPUT_TYPE_NAMES = [
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "tapInternalKey",
      "tapTree",
      "tapBip32Derivation"
    ];
  }
});

// node_modules/bip174/src/lib/converter/global/globalXpub.js
var require_globalXpub = __commonJS({
  "node_modules/bip174/src/lib/converter/global/globalXpub.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var range = (n) => [...Array(n).keys()];
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
        throw new Error(
          "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
        throw new Error(
          "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length / 4 % 1 !== 0) {
        throw new Error(
          "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
        );
      }
      const extendedPubkey = keyVal.key.slice(1);
      const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        extendedPubkey,
        path: "m"
      };
      for (const i of range(keyVal.value.length / 4 - 1)) {
        const val = keyVal.value.readUInt32LE(i * 4 + 4);
        const isHard = !!(val & 2147483648);
        const idx = val & 2147483647;
        data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
      }
      return data;
    }
    exports2.decode = decode;
    function encode(data) {
      const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
      const key = Buffer.concat([head, data.extendedPubkey]);
      const splitPath = data.path.split("/");
      const value = Buffer.allocUnsafe(splitPath.length * 4);
      data.masterFingerprint.copy(value, 0);
      let offset = 4;
      splitPath.slice(1).forEach((level) => {
        const isHard = level.slice(-1) === "'";
        let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num += 2147483648;
        value.writeUInt32LE(num, offset);
        offset += 4;
      });
      return {
        key,
        value
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
    function check(data) {
      const epk = data.extendedPubkey;
      const mfp = data.masterFingerprint;
      const p = data.path;
      return Buffer.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
    }
    exports2.check = check;
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.extendedPubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter((v) => v.extendedPubkey.equals(item.extendedPubkey)).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/global/unsignedTx.js
var require_unsignedTx = __commonJS({
  "node_modules/bip174/src/lib/converter/global/unsignedTx.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function encode(data) {
      return {
        key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
        value: data.toBuffer()
      };
    }
    exports2.encode = encode;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptSig.js
var require_finalScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptSig.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
        throw new Error(
          "Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
      return {
        key,
        value: data
      };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptSig === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptWitness.js
var require_finalScriptWitness = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptWitness.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
        throw new Error(
          "Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
      return {
        key,
        value: data
      };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js
var require_nonWitnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(data) {
      return {
        key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
        value: data
      };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/partialSig.js
var require_partialSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/partialSig.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
        throw new Error(
          "Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
        throw new Error(
          "Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1);
      return {
        pubkey,
        signature: keyVal.value
      };
    }
    exports2.decode = decode;
    function encode(pSig) {
      const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
      return {
        key: Buffer.concat([head, pSig.pubkey]),
        value: pSig.signature
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ pubkey: Buffer; signature: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
    }
    exports2.check = check;
    function isDerSigWithSighash(buf) {
      if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
      if (buf[0] !== 48) return false;
      if (buf.length !== buf[1] + 3) return false;
      if (buf[2] !== 2) return false;
      const rLen = buf[3];
      if (rLen > 33 || rLen < 1) return false;
      if (buf[3 + rLen + 1] !== 2) return false;
      const sLen = buf[3 + rLen + 2];
      if (sLen > 33 || sLen < 1) return false;
      if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
      return true;
    }
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/porCommitment.js
var require_porCommitment = __commonJS({
  "node_modules/bip174/src/lib/converter/input/porCommitment.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
        throw new Error(
          "Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.toString("utf8");
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
      return {
        key,
        value: Buffer.from(data, "utf8")
      };
    }
    exports2.encode = encode;
    exports2.expected = "string";
    function check(data) {
      return typeof data === "string";
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.porCommitment === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/sighashType.js
var require_sighashType = __commonJS({
  "node_modules/bip174/src/lib/converter/input/sighashType.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
        throw new Error(
          "Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.readUInt32LE(0);
    }
    exports2.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
      const value = Buffer.allocUnsafe(4);
      value.writeUInt32LE(data, 0);
      return {
        key,
        value
      };
    }
    exports2.encode = encode;
    exports2.expected = "number";
    function check(data) {
      return typeof data === "number";
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.sighashType === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapKeySig.js
var require_tapKeySig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapKeySig.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check(keyVal.value)) {
        throw new Error(
          "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
        );
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
      return { key, value };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapKeySig === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapLeafScript.js
var require_tapLeafScript = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapLeafScript.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
        throw new Error(
          "Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex")
        );
      }
      if ((keyVal.key.length - 2) % 32 !== 0) {
        throw new Error(
          "Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex")
        );
      }
      const leafVersion = keyVal.value[keyVal.value.length - 1];
      if ((keyVal.key[1] & 254) !== leafVersion) {
        throw new Error(
          "Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex")
        );
      }
      const script = keyVal.value.slice(0, -1);
      const controlBlock = keyVal.key.slice(1);
      return { controlBlock, script, leafVersion };
    }
    exports2.decode = decode;
    function encode(tScript) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
      const verBuf = Buffer.from([tScript.leafVersion]);
      return {
        key: Buffer.concat([head, tScript.controlBlock]),
        value: Buffer.concat([tScript.script, verBuf])
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && Buffer.isBuffer(data.script);
    }
    exports2.check = check;
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.controlBlock.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter((v) => v.controlBlock.equals(item.controlBlock)).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js
var require_tapMerkleRoot = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check(keyVal.value)) {
        throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
      }
      return keyVal.value;
    }
    exports2.decode = decode;
    function encode(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
      return { key, value };
    }
    exports2.encode = encode;
    exports2.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data) && data.length === 32;
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapScriptSig.js
var require_tapScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapScriptSig.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
        throw new Error(
          "Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1, 33);
      const leafHash = keyVal.key.slice(33);
      return {
        pubkey,
        leafHash,
        signature: keyVal.value
      };
    }
    exports2.decode = decode;
    function encode(tSig) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
      return {
        key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
        value: tSig.signature
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.leafHash) && Buffer.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
    }
    exports2.check = check;
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter(
        (v) => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash)
      ).length === 0;
    }
    exports2.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/varint.js
var require_varint = __commonJS({
  "node_modules/bip174/src/lib/converter/varint.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n) {
      if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError("value out of range");
    }
    function encode(_number, buffer, offset) {
      checkUInt53(_number);
      if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (_number < 253) {
        buffer.writeUInt8(_number, offset);
        Object.assign(encode, { bytes: 1 });
      } else if (_number <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(_number, offset + 1);
        Object.assign(encode, { bytes: 3 });
      } else if (_number <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(_number, offset + 1);
        Object.assign(encode, { bytes: 5 });
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(_number >>> 0, offset + 1);
        buffer.writeUInt32LE(_number / 4294967296 | 0, offset + 5);
        Object.assign(encode, { bytes: 9 });
      }
      return buffer;
    }
    exports2.encode = encode;
    function decode(buffer, offset) {
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      const first = buffer.readUInt8(offset);
      if (first < 253) {
        Object.assign(decode, { bytes: 1 });
        return first;
      } else if (first === 253) {
        Object.assign(decode, { bytes: 3 });
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        Object.assign(decode, { bytes: 5 });
        return buffer.readUInt32LE(offset + 1);
      } else {
        Object.assign(decode, { bytes: 9 });
        const lo = buffer.readUInt32LE(offset + 1);
        const hi = buffer.readUInt32LE(offset + 5);
        const _number = hi * 4294967296 + lo;
        checkUInt53(_number);
        return _number;
      }
    }
    exports2.decode = decode;
    function encodingLength(_number) {
      checkUInt53(_number);
      return _number < 253 ? 1 : _number <= 65535 ? 3 : _number <= 4294967295 ? 5 : 9;
    }
    exports2.encodingLength = encodingLength;
  }
});

// node_modules/bip174/src/lib/converter/tools.js
var require_tools = __commonJS({
  "node_modules/bip174/src/lib/converter/tools.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varuint = require_varint();
    exports2.range = (n) => [...Array(n).keys()];
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j = buffer.length - 1;
      let tmp = 0;
      for (let i = 0; i < buffer.length / 2; i++) {
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
      }
      return buffer;
    }
    exports2.reverseBuffer = reverseBuffer;
    function keyValsToBuffer(keyVals) {
      const buffers = keyVals.map(keyValToBuffer);
      buffers.push(Buffer.from([0]));
      return Buffer.concat(buffers);
    }
    exports2.keyValsToBuffer = keyValsToBuffer;
    function keyValToBuffer(keyVal) {
      const keyLen = keyVal.key.length;
      const valLen = keyVal.value.length;
      const keyVarIntLen = varuint.encodingLength(keyLen);
      const valVarIntLen = varuint.encodingLength(valLen);
      const buffer = Buffer.allocUnsafe(
        keyVarIntLen + keyLen + valVarIntLen + valLen
      );
      varuint.encode(keyLen, buffer, 0);
      keyVal.key.copy(buffer, keyVarIntLen);
      varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
      keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
      return buffer;
    }
    exports2.keyValToBuffer = keyValToBuffer;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a = buffer.readUInt32LE(offset);
      let b = buffer.readUInt32LE(offset + 4);
      b *= 4294967296;
      verifuint(b + a, 9007199254740991);
      return b + a;
    }
    exports2.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports2.writeUInt64LE = writeUInt64LE;
  }
});

// node_modules/bip174/src/lib/converter/input/witnessUtxo.js
var require_witnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/witnessUtxo.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var tools_1 = require_tools();
    var varuint = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      const value = tools_1.readUInt64LE(keyVal.value, 0);
      let _offset = 8;
      const scriptLen = varuint.decode(keyVal.value, _offset);
      _offset += varuint.encodingLength(scriptLen);
      const script = keyVal.value.slice(_offset);
      if (script.length !== scriptLen) {
        throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
      }
      return {
        script,
        value
      };
    }
    exports2.decode = decode;
    function encode(data) {
      const { script, value } = data;
      const varintLen = varuint.encodingLength(script.length);
      const result = Buffer.allocUnsafe(8 + varintLen + script.length);
      tools_1.writeUInt64LE(result, value, 0);
      varuint.encode(script.length, result, 8);
      script.copy(result, 8 + varintLen);
      return {
        key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
        value: result
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ script: Buffer; value: number; }";
    function check(data) {
      return Buffer.isBuffer(data.script) && typeof data.value === "number";
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.witnessUtxo === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/output/tapTree.js
var require_tapTree = __commonJS({
  "node_modules/bip174/src/lib/converter/output/tapTree.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var varuint = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex")
        );
      }
      let _offset = 0;
      const data = [];
      while (_offset < keyVal.value.length) {
        const depth = keyVal.value[_offset++];
        const leafVersion = keyVal.value[_offset++];
        const scriptLen = varuint.decode(keyVal.value, _offset);
        _offset += varuint.encodingLength(scriptLen);
        data.push({
          depth,
          leafVersion,
          script: keyVal.value.slice(_offset, _offset + scriptLen)
        });
        _offset += scriptLen;
      }
      return { leaves: data };
    }
    exports2.decode = decode;
    function encode(tree) {
      const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
      const bufs = [].concat(
        ...tree.leaves.map((tapLeaf) => [
          Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
          varuint.encode(tapLeaf.script.length),
          tapLeaf.script
        ])
      );
      return {
        key,
        value: Buffer.concat(bufs)
      };
    }
    exports2.encode = encode;
    exports2.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
    function check(data) {
      return Array.isArray(data.leaves) && data.leaves.every(
        (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && Buffer.isBuffer(tapLeaf.script)
      );
    }
    exports2.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapTree === void 0;
    }
    exports2.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/shared/bip32Derivation.js
var require_bip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var range = (n) => [...Array(n).keys()];
    var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
    function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1);
        if (!isValidPubkey(pubkey)) {
          throw new Error(
            "Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length / 4 % 1 !== 0) {
          throw new Error(
            "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
          );
        }
        const data = {
          masterFingerprint: keyVal.value.slice(0, 4),
          pubkey,
          path: "m"
        };
        for (const i of range(keyVal.value.length / 4 - 1)) {
          const val = keyVal.value.readUInt32LE(i * 4 + 4);
          const isHard = !!(val & 2147483648);
          const idx = val & 2147483647;
          data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
      }
      function encode(data) {
        const head = Buffer.from([TYPE_BYTE]);
        const key = Buffer.concat([head, data.pubkey]);
        const splitPath = data.path.split("/");
        const value = Buffer.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level) => {
          const isHard = level.slice(-1) === "'";
          let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
          if (isHard) num += 2147483648;
          value.writeUInt32LE(num, offset);
          offset += 4;
        });
        return {
          key,
          value
        };
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
      function check(data) {
        return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
      }
      function canAddToArray(array, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array.filter((v) => v.pubkey.equals(item.pubkey)).length === 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAddToArray
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/checkPubkey.js
var require_checkPubkey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/checkPubkey.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeChecker(pubkeyTypes) {
      return checkPubkey;
      function checkPubkey(keyVal) {
        let pubkey;
        if (pubkeyTypes.includes(keyVal.key[0])) {
          pubkey = keyVal.key.slice(1);
          if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
            throw new Error(
              "Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex")
            );
          }
        }
        return pubkey;
      }
    }
    exports2.makeChecker = makeChecker;
  }
});

// node_modules/bip174/src/lib/converter/shared/redeemScript.js
var require_redeemScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/redeemScript.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.redeemScript === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js
var require_tapBip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varuint = require_varint();
    var bip32Derivation = require_bip32Derivation();
    var isValidBIP340Key = (pubkey) => pubkey.length === 32;
    function makeConverter(TYPE_BYTE) {
      const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
      function decode(keyVal) {
        const nHashes = varuint.decode(keyVal.value);
        const nHashesLen = varuint.encodingLength(nHashes);
        const base = parent.decode({
          key: keyVal.key,
          value: keyVal.value.slice(nHashesLen + nHashes * 32)
        });
        const leafHashes = new Array(nHashes);
        for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
          leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
        }
        return Object.assign({}, base, { leafHashes });
      }
      function encode(data) {
        const base = parent.encode(data);
        const nHashesLen = varuint.encodingLength(data.leafHashes.length);
        const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
        varuint.encode(data.leafHashes.length, nHashesBuf);
        const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
        return Object.assign({}, base, { value });
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
      function check(data) {
        return Array.isArray(data.leafHashes) && data.leafHashes.every(
          (leafHash) => Buffer.isBuffer(leafHash) && leafHash.length === 32
        ) && parent.check(data);
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAddToArray: parent.canAddToArray
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapInternalKey.js
var require_tapInternalKey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapInternalKey.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length !== 32) {
          throw new Error(
            "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
          );
        }
        return keyVal.value;
      }
      function encode(value) {
        const key = Buffer.from([TYPE_BYTE]);
        return { key, value };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data) && data.length === 32;
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapInternalKey === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/witnessScript.js
var require_witnessScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/witnessScript.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessScript === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports2.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/index.js
var require_converter = __commonJS({
  "node_modules/bip174/src/lib/converter/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var globalXpub = require_globalXpub();
    var unsignedTx = require_unsignedTx();
    var finalScriptSig = require_finalScriptSig();
    var finalScriptWitness = require_finalScriptWitness();
    var nonWitnessUtxo = require_nonWitnessUtxo();
    var partialSig = require_partialSig();
    var porCommitment = require_porCommitment();
    var sighashType = require_sighashType();
    var tapKeySig = require_tapKeySig();
    var tapLeafScript = require_tapLeafScript();
    var tapMerkleRoot = require_tapMerkleRoot();
    var tapScriptSig = require_tapScriptSig();
    var witnessUtxo = require_witnessUtxo();
    var tapTree = require_tapTree();
    var bip32Derivation = require_bip32Derivation();
    var checkPubkey = require_checkPubkey();
    var redeemScript = require_redeemScript();
    var tapBip32Derivation = require_tapBip32Derivation();
    var tapInternalKey = require_tapInternalKey();
    var witnessScript = require_witnessScript();
    var globals = {
      unsignedTx,
      globalXpub,
      // pass an Array of key bytes that require pubkey beside the key
      checkPubkey: checkPubkey.makeChecker([])
    };
    exports2.globals = globals;
    var inputs = {
      nonWitnessUtxo,
      partialSig,
      sighashType,
      finalScriptSig,
      finalScriptWitness,
      porCommitment,
      witnessUtxo,
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.InputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.InputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.InputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.InputTypes.PARTIAL_SIG,
        typeFields_1.InputTypes.BIP32_DERIVATION
      ]),
      tapKeySig,
      tapScriptSig,
      tapLeafScript,
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.InputTypes.TAP_BIP32_DERIVATION
      ),
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.InputTypes.TAP_INTERNAL_KEY
      ),
      tapMerkleRoot
    };
    exports2.inputs = inputs;
    var outputs = {
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.OutputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.OutputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ]),
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
      ),
      tapTree,
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.OutputTypes.TAP_INTERNAL_KEY
      )
    };
    exports2.outputs = outputs;
  }
});

// node_modules/bip174/src/lib/parser/fromBuffer.js
var require_fromBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/fromBuffer.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    var varuint = require_varint();
    var typeFields_1 = require_typeFields();
    function psbtFromBuffer(buffer, txGetter) {
      let offset = 0;
      function varSlice() {
        const keyLen = varuint.decode(buffer, offset);
        offset += varuint.encodingLength(keyLen);
        const key = buffer.slice(offset, offset + keyLen);
        offset += keyLen;
        return key;
      }
      function readUInt32BE() {
        const num = buffer.readUInt32BE(offset);
        offset += 4;
        return num;
      }
      function readUInt8() {
        const num = buffer.readUInt8(offset);
        offset += 1;
        return num;
      }
      function getKeyValue() {
        const key = varSlice();
        const value = varSlice();
        return {
          key,
          value
        };
      }
      function checkEndOfKeyValPairs() {
        if (offset >= buffer.length) {
          throw new Error("Format Error: Unexpected End of PSBT");
        }
        const isEnd = buffer.readUInt8(offset) === 0;
        if (isEnd) {
          offset++;
        }
        return isEnd;
      }
      if (readUInt32BE() !== 1886610036) {
        throw new Error("Format Error: Invalid Magic Number");
      }
      if (readUInt8() !== 255) {
        throw new Error(
          "Format Error: Magic Number must be followed by 0xff separator"
        );
      }
      const globalMapKeyVals = [];
      const globalKeyIndex = {};
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString("hex");
        if (globalKeyIndex[hexKey]) {
          throw new Error(
            "Format Error: Keys must be unique for global keymap: key " + hexKey
          );
        }
        globalKeyIndex[hexKey] = 1;
        globalMapKeyVals.push(keyVal);
      }
      const unsignedTxMaps = globalMapKeyVals.filter(
        (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
      );
      if (unsignedTxMaps.length !== 1) {
        throw new Error("Format Error: Only one UNSIGNED_TX allowed");
      }
      const unsignedTx = txGetter(unsignedTxMaps[0].value);
      const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
      const inputKeyVals = [];
      const outputKeyVals = [];
      for (const index of tools_1.range(inputCount)) {
        const inputKeyIndex = {};
        const input = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (inputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
            );
          }
          inputKeyIndex[hexKey] = 1;
          input.push(keyVal);
        }
        inputKeyVals.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const outputKeyIndex = {};
        const output = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (outputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
            );
          }
          outputKeyIndex[hexKey] = 1;
          output.push(keyVal);
        }
        outputKeyVals.push(output);
      }
      return psbtFromKeyVals(unsignedTx, {
        globalMapKeyVals,
        inputKeyVals,
        outputKeyVals
      });
    }
    exports2.psbtFromBuffer = psbtFromBuffer;
    function checkKeyBuffer(type, keyBuf, keyNum) {
      if (!keyBuf.equals(Buffer.from([keyNum]))) {
        throw new Error(
          `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
        );
      }
    }
    exports2.checkKeyBuffer = checkKeyBuffer;
    function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
      const globalMap = {
        unsignedTx
      };
      let txCount = 0;
      for (const keyVal of globalMapKeyVals) {
        switch (keyVal.key[0]) {
          case typeFields_1.GlobalTypes.UNSIGNED_TX:
            checkKeyBuffer(
              "global",
              keyVal.key,
              typeFields_1.GlobalTypes.UNSIGNED_TX
            );
            if (txCount > 0) {
              throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            }
            txCount++;
            break;
          case typeFields_1.GlobalTypes.GLOBAL_XPUB:
            if (globalMap.globalXpub === void 0) {
              globalMap.globalXpub = [];
            }
            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
            break;
          default:
            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
            globalMap.unknownKeyVals.push(keyVal);
        }
      }
      const inputCount = inputKeyVals.length;
      const outputCount = outputKeyVals.length;
      const inputs = [];
      const outputs = [];
      for (const index of tools_1.range(inputCount)) {
        const input = {};
        for (const keyVal of inputKeyVals[index]) {
          convert.inputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.InputTypes.NON_WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.NON_WITNESS_UTXO
              );
              if (input.nonWitnessUtxo !== void 0) {
                throw new Error(
                  "Format Error: Input has multiple NON_WITNESS_UTXO"
                );
              }
              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_UTXO
              );
              if (input.witnessUtxo !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_UTXO");
              }
              input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.PARTIAL_SIG:
              if (input.partialSig === void 0) {
                input.partialSig = [];
              }
              input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.SIGHASH_TYPE:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.SIGHASH_TYPE
              );
              if (input.sighashType !== void 0) {
                throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
              }
              input.sighashType = convert.inputs.sighashType.decode(keyVal);
              break;
            case typeFields_1.InputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.REDEEM_SCRIPT
              );
              if (input.redeemScript !== void 0) {
                throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
              }
              input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_SCRIPT
              );
              if (input.witnessScript !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
              }
              input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.BIP32_DERIVATION:
              if (input.bip32Derivation === void 0) {
                input.bip32Derivation = [];
              }
              input.bip32Derivation.push(
                convert.inputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTSIG
              );
              input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
              );
              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                keyVal
              );
              break;
            case typeFields_1.InputTypes.POR_COMMITMENT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.POR_COMMITMENT
              );
              input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_KEY_SIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_KEY_SIG
              );
              input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
              if (input.tapScriptSig === void 0) {
                input.tapScriptSig = [];
              }
              input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
              if (input.tapLeafScript === void 0) {
                input.tapLeafScript = [];
              }
              input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
              if (input.tapBip32Derivation === void 0) {
                input.tapBip32Derivation = [];
              }
              input.tapBip32Derivation.push(
                convert.inputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_INTERNAL_KEY
              );
              input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_MERKLE_ROOT
              );
              input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
              break;
            default:
              if (!input.unknownKeyVals) input.unknownKeyVals = [];
              input.unknownKeyVals.push(keyVal);
          }
        }
        inputs.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const output = {};
        for (const keyVal of outputKeyVals[index]) {
          convert.outputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.OutputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.REDEEM_SCRIPT
              );
              if (output.redeemScript !== void 0) {
                throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
              }
              output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.WITNESS_SCRIPT
              );
              if (output.witnessScript !== void 0) {
                throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
              }
              output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.BIP32_DERIVATION:
              if (output.bip32Derivation === void 0) {
                output.bip32Derivation = [];
              }
              output.bip32Derivation.push(
                convert.outputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_INTERNAL_KEY
              );
              output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_TREE:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_TREE
              );
              output.tapTree = convert.outputs.tapTree.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
              if (output.tapBip32Derivation === void 0) {
                output.tapBip32Derivation = [];
              }
              output.tapBip32Derivation.push(
                convert.outputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            default:
              if (!output.unknownKeyVals) output.unknownKeyVals = [];
              output.unknownKeyVals.push(keyVal);
          }
        }
        outputs.push(output);
      }
      return { globalMap, inputs, outputs };
    }
    exports2.psbtFromKeyVals = psbtFromKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/toBuffer.js
var require_toBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/toBuffer.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    function psbtToBuffer({ globalMap, inputs, outputs }) {
      const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
        globalMap,
        inputs,
        outputs
      });
      const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
      const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
      const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
      const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
      const header = Buffer.allocUnsafe(5);
      header.writeUIntBE(482972169471, 0, 5);
      return Buffer.concat(
        [header, globalBuffer].concat(inputBuffers, outputBuffers)
      );
    }
    exports2.psbtToBuffer = psbtToBuffer;
    var sortKeyVals = (a, b) => {
      return a.key.compare(b.key);
    };
    function keyValsFromMap(keyValMap, converterFactory) {
      const keyHexSet = /* @__PURE__ */ new Set();
      const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
        if (key === "unknownKeyVals") return result;
        const converter = converterFactory[key];
        if (converter === void 0) return result;
        const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
          converter.encode
        );
        const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
        keyHexes.forEach((hex) => {
          if (keyHexSet.has(hex))
            throw new Error("Serialize Error: Duplicate key: " + hex);
          keyHexSet.add(hex);
        });
        return result.concat(encodedKeyVals);
      }, []);
      const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
        return !keyHexSet.has(keyVal.key.toString("hex"));
      }) : [];
      return keyVals.concat(otherKeyVals).sort(sortKeyVals);
    }
    function psbtToKeyVals({ globalMap, inputs, outputs }) {
      return {
        globalKeyVals: keyValsFromMap(globalMap, convert.globals),
        inputKeyVals: inputs.map((i) => keyValsFromMap(i, convert.inputs)),
        outputKeyVals: outputs.map((o) => keyValsFromMap(o, convert.outputs))
      };
    }
    exports2.psbtToKeyVals = psbtToKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/index.js
var require_parser = __commonJS({
  "node_modules/bip174/src/lib/parser/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    function __export2(m) {
      for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_fromBuffer());
    __export2(require_toBuffer());
  }
});

// node_modules/bip174/src/lib/combiner/index.js
var require_combiner = __commonJS({
  "node_modules/bip174/src/lib/combiner/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parser_1 = require_parser();
    function combine(psbts) {
      const self = psbts[0];
      const selfKeyVals = parser_1.psbtToKeyVals(self);
      const others = psbts.slice(1);
      if (others.length === 0) throw new Error("Combine: Nothing to combine");
      const selfTx = getTx(self);
      if (selfTx === void 0) {
        throw new Error("Combine: Self missing transaction");
      }
      const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
      const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
      const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
      for (const other of others) {
        const otherTx = getTx(other);
        if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
          throw new Error(
            "Combine: One of the Psbts does not have the same transaction."
          );
        }
        const otherKeyVals = parser_1.psbtToKeyVals(other);
        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
        otherGlobalSet.forEach(
          keyPusher(
            selfGlobalSet,
            selfKeyVals.globalKeyVals,
            otherKeyVals.globalKeyVals
          )
        );
        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
        otherInputSets.forEach(
          (inputSet, idx) => inputSet.forEach(
            keyPusher(
              selfInputSets[idx],
              selfKeyVals.inputKeyVals[idx],
              otherKeyVals.inputKeyVals[idx]
            )
          )
        );
        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
        otherOutputSets.forEach(
          (outputSet, idx) => outputSet.forEach(
            keyPusher(
              selfOutputSets[idx],
              selfKeyVals.outputKeyVals[idx],
              otherKeyVals.outputKeyVals[idx]
            )
          )
        );
      }
      return parser_1.psbtFromKeyVals(selfTx, {
        globalMapKeyVals: selfKeyVals.globalKeyVals,
        inputKeyVals: selfKeyVals.inputKeyVals,
        outputKeyVals: selfKeyVals.outputKeyVals
      });
    }
    exports2.combine = combine;
    function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
      return (key) => {
        if (selfSet.has(key)) return;
        const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
        selfKeyVals.push(newKv);
        selfSet.add(key);
      };
    }
    function getTx(psbt) {
      return psbt.globalMap.unsignedTx;
    }
    function getKeySet(keyVals) {
      const set = /* @__PURE__ */ new Set();
      keyVals.forEach((keyVal) => {
        const hex = keyVal.key.toString("hex");
        if (set.has(hex))
          throw new Error("Combine: KeyValue Map keys should be unique");
        set.add(hex);
      });
      return set;
    }
  }
});

// node_modules/bip174/src/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/bip174/src/lib/utils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter = require_converter();
    function checkForInput(inputs, inputIndex) {
      const input = inputs[inputIndex];
      if (input === void 0) throw new Error(`No input #${inputIndex}`);
      return input;
    }
    exports2.checkForInput = checkForInput;
    function checkForOutput(outputs, outputIndex) {
      const output = outputs[outputIndex];
      if (output === void 0) throw new Error(`No output #${outputIndex}`);
      return output;
    }
    exports2.checkForOutput = checkForOutput;
    function checkHasKey(checkKeyVal, keyVals, enumLength) {
      if (checkKeyVal.key[0] < enumLength) {
        throw new Error(
          `Use the method for your specific key instead of addUnknownKeyVal*`
        );
      }
      if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
        throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
      }
    }
    exports2.checkHasKey = checkHasKey;
    function getEnumLength(myenum) {
      let count = 0;
      Object.keys(myenum).forEach((val) => {
        if (Number(isNaN(Number(val)))) {
          count++;
        }
      });
      return count;
    }
    exports2.getEnumLength = getEnumLength;
    function inputCheckUncleanFinalized(inputIndex, input) {
      let result = false;
      if (input.nonWitnessUtxo || input.witnessUtxo) {
        const needScriptSig = !!input.redeemScript;
        const needWitnessScript = !!input.witnessScript;
        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
        result = scriptSigOK && witnessScriptOK && hasOneFinal;
      }
      if (result === false) {
        throw new Error(
          `Input #${inputIndex} has too much or too little data to clean`
        );
      }
    }
    exports2.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
    function throwForUpdateMaker(typeName, name, expected, data) {
      throw new Error(
        `Data for ${typeName} key ${name} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
      );
    }
    function updateMaker(typeName) {
      return (updateData, mainData) => {
        for (const name of Object.keys(updateData)) {
          const data = updateData[name];
          const { canAdd, canAddToArray, check, expected } = (
            // @ts-ignore
            converter[typeName + "s"][name] || {}
          );
          const isArray = !!canAddToArray;
          if (check) {
            if (isArray) {
              if (!Array.isArray(data) || // @ts-ignore
              mainData[name] && !Array.isArray(mainData[name])) {
                throw new Error(`Key type ${name} must be an array`);
              }
              if (!data.every(check)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              const arr = mainData[name] || [];
              const dupeCheckSet = /* @__PURE__ */ new Set();
              if (!data.every((v) => canAddToArray(arr, v, dupeCheckSet))) {
                throw new Error("Can not add duplicate data to array");
              }
              mainData[name] = arr.concat(data);
            } else {
              if (!check(data)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              if (!canAdd(mainData, data)) {
                throw new Error(`Can not add duplicate data to ${typeName}`);
              }
              mainData[name] = data;
            }
          }
        }
      };
    }
    exports2.updateGlobal = updateMaker("global");
    exports2.updateInput = updateMaker("input");
    exports2.updateOutput = updateMaker("output");
    function addInputAttributes(inputs, data) {
      const index = inputs.length - 1;
      const input = checkForInput(inputs, index);
      exports2.updateInput(data, input);
    }
    exports2.addInputAttributes = addInputAttributes;
    function addOutputAttributes(outputs, data) {
      const index = outputs.length - 1;
      const output = checkForOutput(outputs, index);
      exports2.updateOutput(data, output);
    }
    exports2.addOutputAttributes = addOutputAttributes;
    function defaultVersionSetter(version, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Version: Invalid Transaction");
      }
      txBuf.writeUInt32LE(version, 0);
      return txBuf;
    }
    exports2.defaultVersionSetter = defaultVersionSetter;
    function defaultLocktimeSetter(locktime, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Locktime: Invalid Transaction");
      }
      txBuf.writeUInt32LE(locktime, txBuf.length - 4);
      return txBuf;
    }
    exports2.defaultLocktimeSetter = defaultLocktimeSetter;
  }
});

// node_modules/bip174/src/lib/psbt.js
var require_psbt = __commonJS({
  "node_modules/bip174/src/lib/psbt.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var combiner_1 = require_combiner();
    var parser_1 = require_parser();
    var typeFields_1 = require_typeFields();
    var utils_1 = require_utils2();
    var Psbt = class {
      constructor(tx) {
        this.inputs = [];
        this.outputs = [];
        this.globalMap = {
          unsignedTx: tx
        };
      }
      static fromBase64(data, txFromBuffer) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromHex(data, txFromBuffer) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromBuffer(buffer, txFromBuffer) {
        const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
        const psbt = new this(results.globalMap.unsignedTx);
        Object.assign(psbt, results);
        return psbt;
      }
      toBase64() {
        const buffer = this.toBuffer();
        return buffer.toString("base64");
      }
      toHex() {
        const buffer = this.toBuffer();
        return buffer.toString("hex");
      }
      toBuffer() {
        return parser_1.psbtToBuffer(this);
      }
      updateGlobal(updateData) {
        utils_1.updateGlobal(updateData, this.globalMap);
        return this;
      }
      updateInput(inputIndex, updateData) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.updateInput(updateData, input);
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.updateOutput(updateData, output);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        utils_1.checkHasKey(
          keyVal,
          this.globalMap.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.GlobalTypes)
        );
        if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
        this.globalMap.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.checkHasKey(
          keyVal,
          input.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.InputTypes)
        );
        if (!input.unknownKeyVals) input.unknownKeyVals = [];
        input.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.checkHasKey(
          keyVal,
          output.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.OutputTypes)
        );
        if (!output.unknownKeyVals) output.unknownKeyVals = [];
        output.unknownKeyVals.push(keyVal);
        return this;
      }
      addInput(inputData) {
        this.globalMap.unsignedTx.addInput(inputData);
        this.inputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = inputData.unknownKeyVals || [];
        const inputIndex = this.inputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
        );
        utils_1.addInputAttributes(this.inputs, inputData);
        return this;
      }
      addOutput(outputData) {
        this.globalMap.unsignedTx.addOutput(outputData);
        this.outputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = outputData.unknownKeyVals || [];
        const outputIndex = this.outputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
        );
        utils_1.addOutputAttributes(this.outputs, outputData);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.inputCheckUncleanFinalized(inputIndex, input);
        for (const key of Object.keys(input)) {
          if (![
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
          ].includes(key)) {
            delete input[key];
          }
        }
        return this;
      }
      combine(...those) {
        const result = combiner_1.combine([this].concat(those));
        Object.assign(this, result);
        return this;
      }
      getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
      }
    };
    exports2.Psbt = Psbt;
  }
});

// node_modules/bitcoinjs-lib/src/psbt/psbtutils.js
var require_psbtutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt/psbtutils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signatureBlocksAction = exports2.checkInputForSig = exports2.pubkeyInScript = exports2.pubkeyPositionInScript = exports2.witnessStackToScriptWitness = exports2.isP2TR = exports2.isP2SHScript = exports2.isP2WSHScript = exports2.isP2WPKH = exports2.isP2PKH = exports2.isP2PK = exports2.isP2MS = void 0;
    var varuint = require_varint();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var crypto_1 = require_crypto();
    var payments = require_payments();
    function isPaymentFactory(payment) {
      return (script) => {
        try {
          payment({ output: script });
          return true;
        } catch (err) {
          return false;
        }
      };
    }
    exports2.isP2MS = isPaymentFactory(payments.p2ms);
    exports2.isP2PK = isPaymentFactory(payments.p2pk);
    exports2.isP2PKH = isPaymentFactory(payments.p2pkh);
    exports2.isP2WPKH = isPaymentFactory(payments.p2wpkh);
    exports2.isP2WSHScript = isPaymentFactory(payments.p2wsh);
    exports2.isP2SHScript = isPaymentFactory(payments.p2sh);
    exports2.isP2TR = isPaymentFactory(payments.p2tr);
    function witnessStackToScriptWitness(witness) {
      let buffer = Buffer.allocUnsafe(0);
      function writeSlice(slice) {
        buffer = Buffer.concat([buffer, Buffer.from(slice)]);
      }
      function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = varuint.encodingLength(i);
        buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
        varuint.encode(i, buffer, currentLen);
      }
      function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeVector(witness);
      return buffer;
    }
    exports2.witnessStackToScriptWitness = witnessStackToScriptWitness;
    function pubkeyPositionInScript(pubkey, script) {
      const pubkeyHash = (0, crypto_1.hash160)(pubkey);
      const pubkeyXOnly = pubkey.slice(1, 33);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.findIndex((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
      });
    }
    exports2.pubkeyPositionInScript = pubkeyPositionInScript;
    function pubkeyInScript(pubkey, script) {
      return pubkeyPositionInScript(pubkey, script) !== -1;
    }
    exports2.pubkeyInScript = pubkeyInScript;
    function checkInputForSig(input, action) {
      const pSigs = extractPartialSigs(input);
      return pSigs.some(
        (pSig) => signatureBlocksAction(pSig, bscript.signature.decode, action)
      );
    }
    exports2.checkInputForSig = checkInputForSig;
    function signatureBlocksAction(signature, signatureDecodeFn, action) {
      const { hashType } = signatureDecodeFn(signature);
      const whitelist = [];
      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
      if (isAnyoneCanPay) whitelist.push("addInput");
      const hashMod = hashType & 31;
      switch (hashMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
        case transaction_1.Transaction.SIGHASH_NONE:
          whitelist.push("addOutput");
          whitelist.push("setInputSequence");
          break;
      }
      if (whitelist.indexOf(action) === -1) {
        return true;
      }
      return false;
    }
    exports2.signatureBlocksAction = signatureBlocksAction;
    function extractPartialSigs(input) {
      let pSigs = [];
      if ((input.partialSig || []).length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness) return [];
        pSigs = getPsigsFromInputFinalScripts(input);
      } else {
        pSigs = input.partialSig;
      }
      return pSigs.map((p) => p.signature);
    }
    function getPsigsFromInputFinalScripts(input) {
      const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
      const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
      return scriptItems.concat(witnessItems).filter((item) => {
        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
      }).map((sig) => ({ signature: sig }));
    }
  }
});

// node_modules/bitcoinjs-lib/src/psbt/bip371.js
var require_bip371 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt/bip371.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkTaprootInputForSigs = exports2.tapTreeFromList = exports2.tapTreeToList = exports2.tweakInternalPubKey = exports2.checkTaprootOutputFields = exports2.checkTaprootInputFields = exports2.isTaprootOutput = exports2.isTaprootInput = exports2.serializeTaprootSignature = exports2.tapScriptFinalizer = exports2.toXOnly = void 0;
    var types_1 = require_types();
    var transaction_1 = require_transaction();
    var psbtutils_1 = require_psbtutils();
    var bip341_1 = require_bip341();
    var payments_1 = require_payments();
    var psbtutils_2 = require_psbtutils();
    var toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    exports2.toXOnly = toXOnly;
    function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
      const tapLeaf = findTapLeafToFinalize(
        input,
        inputIndex,
        tapLeafHashToFinalize
      );
      try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return {
          finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness)
        };
      } catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
      }
    }
    exports2.tapScriptFinalizer = tapScriptFinalizer;
    function serializeTaprootSignature(sig, sighashType) {
      const sighashTypeByte = sighashType ? Buffer.from([sighashType]) : Buffer.from([]);
      return Buffer.concat([sig, sighashTypeByte]);
    }
    exports2.serializeTaprootSignature = serializeTaprootSignature;
    function isTaprootInput(input) {
      return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script));
    }
    exports2.isTaprootInput = isTaprootInput;
    function isTaprootOutput(output, script) {
      return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_1.isP2TR)(script));
    }
    exports2.isTaprootOutput = isTaprootOutput;
    function checkTaprootInputFields(inputData, newInputData, action) {
      checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
      checkIfTapLeafInTree(inputData, newInputData, action);
    }
    exports2.checkTaprootInputFields = checkTaprootInputFields;
    function checkTaprootOutputFields(outputData, newOutputData, action) {
      checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
      checkTaprootScriptPubkey(outputData, newOutputData);
    }
    exports2.checkTaprootOutputFields = checkTaprootOutputFields;
    function checkTaprootScriptPubkey(outputData, newOutputData) {
      if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
      const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
      const tapTree = newOutputData.tapTree || outputData.tapTree;
      if (tapInternalKey) {
        const { script: scriptPubkey } = outputData;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !scriptPubkey.equals(script))
          throw new Error("Error adding output. Script or address missmatch.");
      }
    }
    function getTaprootScripPubkey(tapInternalKey, tapTree) {
      const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
      const { output } = (0, payments_1.p2tr)({
        internalPubkey: tapInternalKey,
        scriptTree
      });
      return output;
    }
    function tweakInternalPubKey(inputIndex, input) {
      const tapInternalKey = input.tapInternalKey;
      const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
      if (!outputKey)
        throw new Error(
          `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString("hex")}`
        );
      return outputKey.x;
    }
    exports2.tweakInternalPubKey = tweakInternalPubKey;
    function tapTreeToList(tree) {
      if (!(0, types_1.isTaptree)(tree))
        throw new Error(
          "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
        );
      return _tapTreeToList(tree);
    }
    exports2.tapTreeToList = tapTreeToList;
    function tapTreeFromList(leaves = []) {
      if (leaves.length === 1 && leaves[0].depth === 0)
        return {
          output: leaves[0].script,
          version: leaves[0].leafVersion
        };
      return instertLeavesInTree(leaves);
    }
    exports2.tapTreeFromList = tapTreeFromList;
    function checkTaprootInputForSigs(input, action) {
      const sigs = extractTaprootSigs(input);
      return sigs.some(
        (sig) => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action)
      );
    }
    exports2.checkTaprootInputForSigs = checkTaprootInputForSigs;
    function decodeSchnorrSignature(signature) {
      return {
        signature: signature.slice(0, 64),
        hashType: signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT
      };
    }
    function extractTaprootSigs(input) {
      const sigs = [];
      if (input.tapKeySig) sigs.push(input.tapKeySig);
      if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s) => s.signature));
      if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
        if (finalTapKeySig) sigs.push(finalTapKeySig);
      }
      return sigs;
    }
    function getTapKeySigFromWithness(finalScriptWitness) {
      if (!finalScriptWitness) return;
      const witness = finalScriptWitness.slice(2);
      if (witness.length === 64 || witness.length === 65) return witness;
    }
    function _tapTreeToList(tree, leaves = [], depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (!tree) return [];
      if ((0, types_1.isTapleaf)(tree)) {
        leaves.push({
          depth,
          leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
          script: tree.output
        });
        return leaves;
      }
      if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
      if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
      return leaves;
    }
    function instertLeavesInTree(leaves) {
      let tree;
      for (const leaf of leaves) {
        tree = instertLeafInTree(leaf, tree);
        if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
      }
      return tree;
    }
    function instertLeafInTree(leaf, tree, depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (leaf.depth === depth) {
        if (!tree)
          return {
            output: leaf.script,
            version: leaf.leafVersion
          };
        return;
      }
      if ((0, types_1.isTapleaf)(tree)) return;
      const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
      if (leftSide) return [leftSide, tree && tree[1]];
      const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
      if (rightSide) return [tree && tree[0], rightSide];
    }
    function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkIfTapLeafInTree(inputData, newInputData, action) {
      if (newInputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l) => isTapLeafInTree(l, newInputData.tapMerkleRoot)
        );
        const oldLeafsInTree = (inputData.tapLeafScript || []).every(
          (l) => isTapLeafInTree(l, newInputData.tapMerkleRoot)
        );
        if (!newLeafsInTree || !oldLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      } else if (inputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l) => isTapLeafInTree(l, inputData.tapMerkleRoot)
        );
        if (!newLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      }
    }
    function isTapLeafInTree(tapLeaf, merkleRoot) {
      if (!merkleRoot) return true;
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      const rootHash = (0, bip341_1.rootHashFromPath)(
        tapLeaf.controlBlock,
        leafHash
      );
      return rootHash.equals(merkleRoot);
    }
    function sortSignatures(input, tapLeaf) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      return (input.tapScriptSig || []).filter((tss) => tss.leafHash.equals(leafHash)).map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map((t) => t.signature);
    }
    function addPubkeyPositionInScript(script, tss) {
      return Object.assign(
        {
          positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
            tss.pubkey,
            script
          )
        },
        tss
      );
    }
    function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
      if (!input.tapScriptSig || !input.tapScriptSig.length)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`
        );
      const tapLeaf = (input.tapLeafScript || []).sort((a, b) => a.controlBlock.length - b.controlBlock.length).find(
        (leaf) => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize)
      );
      if (!tapLeaf)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`
        );
      return tapLeaf;
    }
    function canFinalizeLeaf(leaf, tapScriptSig, hash) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: leaf.script,
        version: leaf.leafVersion
      });
      const whiteListedHash = !hash || hash.equals(leafHash);
      return whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== void 0;
    }
    function hasNonTaprootFields(io) {
      return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
    }
  }
});

// node_modules/bitcoinjs-lib/src/psbt.js
var require_psbt2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Psbt = void 0;
    var bip174_1 = require_psbt();
    var varuint = require_varint();
    var utils_1 = require_utils2();
    var address_1 = require_address();
    var bufferutils_1 = require_bufferutils();
    var networks_1 = require_networks();
    var payments = require_payments();
    var bip341_1 = require_bip341();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var bip371_1 = require_bip371();
    var psbtutils_1 = require_psbtutils();
    var DEFAULT_OPTS = {
      /**
       * A bitcoinjs Network object. This is only used if you pass an `address`
       * parameter to addOutput. Otherwise it is not needed and can be left default.
       */
      network: networks_1.bitcoin,
      /**
       * When extractTransaction is called, the fee rate is checked.
       * THIS IS NOT TO BE RELIED ON.
       * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
       */
      maximumFeeRate: 5e3
      // satoshi per byte
    };
    var Psbt = class _Psbt {
      static fromBase64(data, opts = {}) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, opts);
      }
      static fromHex(data, opts = {}) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, opts);
      }
      static fromBuffer(buffer, opts = {}) {
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
        const psbt = new _Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
        return psbt;
      }
      constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
        this.data = data;
        this.opts = Object.assign({}, DEFAULT_OPTS, opts);
        this.__CACHE = {
          __NON_WITNESS_UTXO_TX_CACHE: [],
          __NON_WITNESS_UTXO_BUF_CACHE: [],
          __TX_IN_CACHE: {},
          __TX: this.data.globalMap.unsignedTx.tx,
          // Psbt's predecessor (TransactionBuilder - now removed) behavior
          // was to not confirm input values  before signing.
          // Even though we highly encourage people to get
          // the full parent transaction to verify values, the ability to
          // sign non-segwit inputs without the full transaction was often
          // requested. So the only way to activate is to use @ts-ignore.
          // We will disable exporting the Psbt when unsafe sign is active.
          // because it is not BIP174 compliant.
          __UNSAFE_SIGN_NONSEGWIT: false
        };
        if (this.data.inputs.length === 0) this.setVersion(2);
        const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {
          enumerable,
          writable
        });
        dpew(this, "__CACHE", false, true);
        dpew(this, "opts", false, true);
      }
      get inputCount() {
        return this.data.inputs.length;
      }
      get version() {
        return this.__CACHE.__TX.version;
      }
      set version(version) {
        this.setVersion(version);
      }
      get locktime() {
        return this.__CACHE.__TX.locktime;
      }
      set locktime(locktime) {
        this.setLocktime(locktime);
      }
      get txInputs() {
        return this.__CACHE.__TX.ins.map((input) => ({
          hash: (0, bufferutils_1.cloneBuffer)(input.hash),
          index: input.index,
          sequence: input.sequence
        }));
      }
      get txOutputs() {
        return this.__CACHE.__TX.outs.map((output) => {
          let address;
          try {
            address = (0, address_1.fromOutputScript)(
              output.script,
              this.opts.network
            );
          } catch (_) {
          }
          return {
            script: (0, bufferutils_1.cloneBuffer)(output.script),
            value: output.value,
            address
          };
        });
      }
      combine(...those) {
        this.data.combine(...those.map((o) => o.data));
        return this;
      }
      clone() {
        const res = _Psbt.fromBuffer(this.data.toBuffer());
        res.opts = JSON.parse(JSON.stringify(this.opts));
        return res;
      }
      setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte);
        this.opts.maximumFeeRate = satoshiPerByte;
      }
      setVersion(version) {
        check32Bit(version);
        checkInputsForPartialSig(this.data.inputs, "setVersion");
        const c = this.__CACHE;
        c.__TX.version = version;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, "setLocktime");
        const c = this.__CACHE;
        c.__TX.locktime = locktime;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, "setInputSequence");
        const c = this.__CACHE;
        if (c.__TX.ins.length <= inputIndex) {
          throw new Error("Input index too high");
        }
        c.__TX.ins[inputIndex].sequence = sequence;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      addInputs(inputDatas) {
        inputDatas.forEach((inputData) => this.addInput(inputData));
        return this;
      }
      addInput(inputData) {
        if (arguments.length > 1 || !inputData || inputData.hash === void 0 || inputData.index === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`
          );
        }
        (0, bip371_1.checkTaprootInputFields)(inputData, inputData, "addInput");
        checkInputsForPartialSig(this.data.inputs, "addInput");
        if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
        const c = this.__CACHE;
        this.data.addInput(inputData);
        const txIn = c.__TX.ins[c.__TX.ins.length - 1];
        checkTxInputCache(c, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) {
          addNonWitnessTxCache(this.__CACHE, input, inputIndex);
        }
        c.__FEE = void 0;
        c.__FEE_RATE = void 0;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      addOutputs(outputDatas) {
        outputDatas.forEach((outputData) => this.addOutput(outputData));
        return this;
      }
      addOutput(outputData) {
        if (arguments.length > 1 || !outputData || outputData.value === void 0 || outputData.address === void 0 && outputData.script === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`
          );
        }
        checkInputsForPartialSig(this.data.inputs, "addOutput");
        const { address } = outputData;
        if (typeof address === "string") {
          const { network } = this.opts;
          const script = (0, address_1.toOutputScript)(address, network);
          outputData = Object.assign({}, outputData, { script });
        }
        (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, "addOutput");
        const c = this.__CACHE;
        this.data.addOutput(outputData);
        c.__FEE = void 0;
        c.__FEE_RATE = void 0;
        c.__EXTRACTED_TX = void 0;
        return this;
      }
      extractTransaction(disableFeeCheck) {
        if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
        const c = this.__CACHE;
        if (!disableFeeCheck) {
          checkFees(this, c, this.opts);
        }
        if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
        const tx = c.__TX.clone();
        inputFinalizeGetAmts(this.data.inputs, tx, c, true);
        return tx;
      }
      getFeeRate() {
        return getTxCacheValue(
          "__FEE_RATE",
          "fee rate",
          this.data.inputs,
          this.__CACHE
        );
      }
      getFee() {
        return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
      }
      finalizeAllInputs() {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        range(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
        return this;
      }
      finalizeInput(inputIndex, finalScriptsFunc) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            void 0,
            finalScriptsFunc
          );
        return this._finalizeInput(inputIndex, input, finalScriptsFunc);
      }
      finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            tapLeafHashToFinalize,
            finalScriptsFunc
          );
        throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
      }
      _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
          inputIndex,
          input,
          this.__CACHE
        );
        if (!script) throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
          inputIndex,
          input,
          script,
          isSegwit,
          isP2SH,
          isP2WSH
        );
        if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
        if (finalScriptWitness)
          this.data.updateInput(inputIndex, { finalScriptWitness });
        if (!finalScriptSig && !finalScriptWitness)
          throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        if (!input.witnessUtxo)
          throw new Error(
            `Cannot finalize input #${inputIndex}. Missing withness utxo.`
          );
        if (input.tapKeySig) {
          const payment = payments.p2tr({
            output: input.witnessUtxo.script,
            signature: input.tapKeySig
          });
          const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        } else {
          const { finalScriptWitness } = finalScriptsFunc(
            inputIndex,
            input,
            tapLeafHashToFinalize
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        }
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      getInputType(inputIndex) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
        const result = getMeaningfulScript(
          script,
          inputIndex,
          "input",
          input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
          input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness)
        );
        const type = result.type === "raw" ? "" : result.type + "-";
        const mainType = classifyScript(result.meaningfulScript);
        return type + mainType;
      }
      inputHasPubkey(inputIndex, pubkey) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
      }
      inputHasHDKey(inputIndex, root) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
      }
      outputHasPubkey(outputIndex, pubkey) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
      }
      outputHasHDKey(outputIndex, root) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
      }
      validateSignaturesOfAllInputs(validator) {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        const results = range(this.data.inputs.length).map(
          (idx) => this.validateSignaturesOfInput(idx, validator)
        );
        return results.reduce((final, res) => res === true && final, true);
      }
      validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        if ((0, bip371_1.isTaprootInput)(input))
          return this.validateSignaturesOfTaprootInput(
            inputIndex,
            validator,
            pubkey
          );
        return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
      }
      _validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = (input || {}).partialSig;
        if (!input || !partialSig || partialSig.length < 1)
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
        if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs) {
          const sig = bscript.signature.decode(pSig.signature);
          const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(
            inputIndex,
            Object.assign({}, input, { sighashType: sig.hashType }),
            this.__CACHE,
            true
          ) : { hash: hashCache, script: scriptCache };
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, "verify");
          results.push(validator(pSig.pubkey, hash, sig.signature));
        }
        return results.every((res) => res === true);
      }
      validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const tapKeySig = (input || {}).tapKeySig;
        const tapScriptSig = (input || {}).tapScriptSig;
        if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
        const allHashses = pubkey ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE
        ) : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE
        );
        if (!allHashses.length) throw new Error("No signatures for this pubkey");
        const tapKeyHash = allHashses.find((h) => !h.leafHash);
        let validationResultCount = 0;
        if (tapKeySig && tapKeyHash) {
          const isValidTapkeySig = validator(
            tapKeyHash.pubkey,
            tapKeyHash.hash,
            trimTaprootSig(tapKeySig)
          );
          if (!isValidTapkeySig) return false;
          validationResultCount++;
        }
        if (tapScriptSig) {
          for (const tapSig of tapScriptSig) {
            const tapSigHash = allHashses.find((h) => tapSig.pubkey.equals(h.pubkey));
            if (tapSigHash) {
              const isValidTapScriptSig = validator(
                tapSig.pubkey,
                tapSigHash.hash,
                trimTaprootSig(tapSig.signature)
              );
              if (!isValidTapScriptSig) return false;
              validationResultCount++;
            }
          }
        }
        return validationResultCount > 0;
      }
      signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const results = [];
        for (const i of range(this.data.inputs.length)) {
          try {
            this.signInputHD(i, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v) => v === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const results = [];
          const promises = [];
          for (const i of range(this.data.inputs.length)) {
            promises.push(
              this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v) => v === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
        return this;
      }
      signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
          const promises = signers.map(
            (signer) => this.signInputAsync(inputIndex, signer, sighashTypes)
          );
          return Promise.all(promises).then(() => {
            resolve();
          }).catch(reject);
        });
      }
      signAllInputs(keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const results = [];
        for (const i of range(this.data.inputs.length)) {
          try {
            this.signInput(i, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v) => v === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsAsync(keyPair, sighashTypes) {
        return new Promise((resolve, reject) => {
          if (!keyPair || !keyPair.publicKey)
            return reject(new Error("Need Signer to sign input"));
          const results = [];
          const promises = [];
          for (const [i] of this.data.inputs.entries()) {
            promises.push(
              this.signInputAsync(i, keyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v) => v === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInput(inputIndex, keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input)) {
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            void 0,
            sighashTypes
          );
        }
        return this._signInput(inputIndex, keyPair, sighashTypes);
      }
      signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            tapLeafHashToSign,
            sighashTypes
          );
        throw new Error(`Input #${inputIndex} is not of type Taproot.`);
      }
      _signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        const partialSig = [
          {
            pubkey: keyPair.publicKey,
            signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
          }
        ];
        this.data.updateInput(inputIndex, { partialSig });
        return this;
      }
      _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        const tapKeySig = hashesForSig.filter((h) => !h.leafHash).map(
          (h) => (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h.hash),
            input.sighashType
          )
        )[0];
        const tapScriptSig = hashesForSig.filter((h) => !!h.leafHash).map((h) => ({
          pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
          signature: (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h.hash),
            input.sighashType
          ),
          leafHash: h.leafHash
        }));
        if (tapKeySig) {
          this.data.updateInput(inputIndex, { tapKeySig });
        }
        if (tapScriptSig.length) {
          this.data.updateInput(inputIndex, { tapScriptSig });
        }
        return this;
      }
      signInputAsync(inputIndex, keyPair, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              void 0,
              sighashTypes
            );
          return this._signInputAsync(inputIndex, keyPair, sighashTypes);
        });
      }
      signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              tapLeafHash,
              sighashTypes
            );
          throw new Error(`Input #${inputIndex} is not of type Taproot.`);
        });
      }
      _signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        return Promise.resolve(keyPair.sign(hash)).then((signature) => {
          const partialSig = [
            {
              pubkey: keyPair.publicKey,
              signature: bscript.signature.encode(signature, sighashType)
            }
          ];
          this.data.updateInput(inputIndex, { partialSig });
        });
      }
      async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes
        );
        const signaturePromises = [];
        const tapKeyHash = hashesForSig.filter((h) => !h.leafHash)[0];
        if (tapKeyHash) {
          const tapKeySigPromise = Promise.resolve(
            keyPair.signSchnorr(tapKeyHash.hash)
          ).then((sig) => {
            return {
              tapKeySig: (0, bip371_1.serializeTaprootSignature)(
                sig,
                input.sighashType
              )
            };
          });
          signaturePromises.push(tapKeySigPromise);
        }
        const tapScriptHashes = hashesForSig.filter((h) => !!h.leafHash);
        if (tapScriptHashes.length) {
          const tapScriptSigPromises = tapScriptHashes.map((tsh) => {
            return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
              (signature) => {
                const tapScriptSig = [
                  {
                    pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                    signature: (0, bip371_1.serializeTaprootSignature)(
                      signature,
                      input.sighashType
                    ),
                    leafHash: tsh.leafHash
                  }
                ];
                return { tapScriptSig };
              }
            );
          });
          signaturePromises.push(...tapScriptSigPromises);
        }
        return Promise.all(signaturePromises).then((results) => {
          results.forEach((v) => this.data.updateInput(inputIndex, v));
        });
      }
      checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
        if (typeof keyPair.signSchnorr !== "function")
          throw new Error(
            `Need Schnorr Signer to sign taproot input #${inputIndex}.`
          );
        const hashesForSig = getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          keyPair.publicKey,
          this.__CACHE,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        if (!hashesForSig || !hashesForSig.length)
          throw new Error(
            `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
              "hex"
            )}`
          );
        return hashesForSig;
      }
      toBuffer() {
        checkCache(this.__CACHE);
        return this.data.toBuffer();
      }
      toHex() {
        checkCache(this.__CACHE);
        return this.data.toHex();
      }
      toBase64() {
        checkCache(this.__CACHE);
        return this.data.toBase64();
      }
      updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
      }
      updateInput(inputIndex, updateData) {
        if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
        (0, bip371_1.checkTaprootInputFields)(
          this.data.inputs[inputIndex],
          updateData,
          "updateInput"
        );
        this.data.updateInput(inputIndex, updateData);
        if (updateData.nonWitnessUtxo) {
          addNonWitnessTxCache(
            this.__CACHE,
            this.data.inputs[inputIndex],
            inputIndex
          );
        }
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const outputData = this.data.outputs[outputIndex];
        (0, bip371_1.checkTaprootOutputFields)(
          outputData,
          updateData,
          "updateOutput"
        );
        this.data.updateOutput(outputIndex, updateData);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
    };
    exports2.Psbt = Psbt;
    var transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);
    var PsbtTransaction = class {
      constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
        this.tx = transaction_1.Transaction.fromBuffer(buffer);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, "tx", {
          enumerable: false,
          writable: true
        });
      }
      getInputOutputCounts() {
        return {
          inputCount: this.tx.ins.length,
          outputCount: this.tx.outs.length
        };
      }
      addInput(input) {
        if (input.hash === void 0 || input.index === void 0 || !Buffer.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
          throw new Error("Error adding input.");
        }
        const hash = typeof input.hash === "string" ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, "hex")) : input.hash;
        this.tx.addInput(hash, input.index, input.sequence);
      }
      addOutput(output) {
        if (output.script === void 0 || output.value === void 0 || !Buffer.isBuffer(output.script) || typeof output.value !== "number") {
          throw new Error("Error adding output.");
        }
        this.tx.addOutput(output.script, output.value);
      }
      toBuffer() {
        return this.tx.toBuffer();
      }
    };
    function canFinalize(input, script, scriptType) {
      switch (scriptType) {
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
          return hasSigs(1, input.partialSig);
        case "multisig":
          const p2ms = payments.p2ms({ output: script });
          return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
        default:
          return false;
      }
    }
    function checkCache(cache) {
      if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
        throw new Error("Not BIP174 compliant, can not export");
      }
    }
    function hasSigs(neededSigs, partialSig, pubkeys) {
      if (!partialSig) return false;
      let sigs;
      if (pubkeys) {
        sigs = pubkeys.map((pkey) => {
          const pubkey = compressPubkey(pkey);
          return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
        }).filter((v) => !!v);
      } else {
        sigs = partialSig;
      }
      if (sigs.length > neededSigs) throw new Error("Too many signatures");
      return sigs.length === neededSigs;
    }
    function isFinalized(input) {
      return !!input.finalScriptSig || !!input.finalScriptWitness;
    }
    function bip32DerivationIsMine(root) {
      return (d) => {
        if (!d.masterFingerprint.equals(root.fingerprint)) return false;
        if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
        return true;
      };
    }
    function check32Bit(num) {
      if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
        throw new Error("Invalid 32 bit integer");
      }
    }
    function checkFees(psbt, cache, opts) {
      const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
      const vsize = cache.__EXTRACTED_TX.virtualSize();
      const satoshis = feeRate * vsize;
      if (feeRate >= opts.maximumFeeRate) {
        throw new Error(
          `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
        );
      }
    }
    function checkInputsForPartialSig(inputs, action) {
      inputs.forEach((input) => {
        const throws = (0, bip371_1.isTaprootInput)(input) ? (0, bip371_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_1.checkInputForSig)(input, action);
        if (throws)
          throw new Error("Can not modify transaction, signatures exist.");
      });
    }
    function checkPartialSigSighashes(input) {
      if (!input.sighashType || !input.partialSig) return;
      const { partialSig, sighashType } = input;
      partialSig.forEach((pSig) => {
        const { hashType } = bscript.signature.decode(pSig.signature);
        if (sighashType !== hashType) {
          throw new Error("Signature sighash does not match input sighash type");
        }
      });
    }
    function checkScriptForPubkey(pubkey, script, action) {
      if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
        throw new Error(
          `Can not ${action} for this input with the key ${pubkey.toString("hex")}`
        );
      }
    }
    function checkTxEmpty(tx) {
      const isEmpty = tx.ins.every(
        (input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0
      );
      if (!isEmpty) {
        throw new Error("Format Error: Transaction ScriptSigs are not empty");
      }
    }
    function checkTxForDupeIns(tx, cache) {
      tx.ins.forEach((input) => {
        checkTxInputCache(cache, input);
      });
    }
    function checkTxInputCache(cache, input) {
      const key = (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString("hex") + ":" + input.index;
      if (cache.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
      cache.__TX_IN_CACHE[key] = 1;
    }
    function scriptCheckerFactory(payment, paymentScriptName) {
      return (inputIndex, scriptPubKey, redeemScript, ioType) => {
        const redeemScriptOutput = payment({
          redeem: { output: redeemScript }
        }).output;
        if (!scriptPubKey.equals(redeemScriptOutput)) {
          throw new Error(
            `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
          );
        }
      };
    }
    var checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script");
    var checkWitnessScript = scriptCheckerFactory(
      payments.p2wsh,
      "Witness script"
    );
    function getTxCacheValue(key, name, inputs, c) {
      if (!inputs.every(isFinalized))
        throw new Error(`PSBT must be finalized to calculate ${name}`);
      if (key === "__FEE_RATE" && c.__FEE_RATE) return c.__FEE_RATE;
      if (key === "__FEE" && c.__FEE) return c.__FEE;
      let tx;
      let mustFinalize = true;
      if (c.__EXTRACTED_TX) {
        tx = c.__EXTRACTED_TX;
        mustFinalize = false;
      } else {
        tx = c.__TX.clone();
      }
      inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
      if (key === "__FEE_RATE") return c.__FEE_RATE;
      else if (key === "__FEE") return c.__FEE;
    }
    function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
      const scriptType = classifyScript(script);
      if (!canFinalize(input, script, scriptType))
        throw new Error(`Can not finalize input #${inputIndex}`);
      return prepareFinalScripts(
        script,
        scriptType,
        input.partialSig,
        isSegwit,
        isP2SH,
        isP2WSH
      );
    }
    function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
      let finalScriptSig;
      let finalScriptWitness;
      const payment = getPayment(script, scriptType, partialSig);
      const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
      const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
      if (isSegwit) {
        if (p2wsh) {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            p2wsh.witness
          );
        } else {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
        }
        if (p2sh) {
          finalScriptSig = p2sh.input;
        }
      } else {
        if (p2sh) {
          finalScriptSig = p2sh.input;
        } else {
          finalScriptSig = payment.input;
        }
      }
      return {
        finalScriptSig,
        finalScriptWitness
      };
    }
    function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
      const input = (0, utils_1.checkForInput)(inputs, inputIndex);
      const { hash, sighashType, script } = getHashForSig(
        inputIndex,
        input,
        cache,
        false,
        sighashTypes
      );
      checkScriptForPubkey(pubkey, script, "sign");
      return {
        hash,
        sighashType
      };
    }
    function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
      checkSighashTypeAllowed(sighashType, sighashTypes);
      let hash;
      let prevout;
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const prevoutHash = unsignedTx.ins[inputIndex].hash;
        const utxoHash = nonWitnessUtxoTx.getHash();
        if (!prevoutHash.equals(utxoHash)) {
          throw new Error(
            `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`
          );
        }
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        prevout = nonWitnessUtxoTx.outs[prevoutIndex];
      } else if (input.witnessUtxo) {
        prevout = input.witnessUtxo;
      } else {
        throw new Error("Need a Utxo input item for signing");
      }
      const { meaningfulScript, type } = getMeaningfulScript(
        prevout.script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          meaningfulScript,
          prevout.value,
          sighashType
        );
      } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
        const signingScript = payments.p2pkh({
          hash: meaningfulScript.slice(2)
        }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          prevout.value,
          sighashType
        );
      } else {
        if (input.nonWitnessUtxo === void 0 && cache.__UNSAFE_SIGN_NONSEGWIT === false)
          throw new Error(
            `Input #${inputIndex} has witnessUtxo but non-segwit script: ${meaningfulScript.toString("hex")}`
          );
        if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
          console.warn(
            "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"
          );
        hash = unsignedTx.hashForSignature(
          inputIndex,
          meaningfulScript,
          sighashType
        );
      }
      return {
        script: meaningfulScript,
        sighashType,
        hash
      };
    }
    function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
      const allPublicKeys = [];
      if (input.tapInternalKey) {
        const key = getPrevoutTaprootKey(inputIndex, input, cache);
        if (key) {
          allPublicKeys.push(key);
        }
      }
      if (input.tapScriptSig) {
        const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
        allPublicKeys.push(...tapScriptPubkeys);
      }
      const allHashes = allPublicKeys.map(
        (pubicKey) => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache)
      );
      return allHashes.flat();
    }
    function getPrevoutTaprootKey(inputIndex, input, cache) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
      return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
    }
    function trimTaprootSig(signature) {
      return signature.length === 64 ? signature : signature.subarray(0, 64);
    }
    function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
      checkSighashTypeAllowed(sighashType, allowedSighashTypes);
      const prevOuts = inputs.map(
        (i, index) => getScriptAndAmountFromUtxo(index, i, cache)
      );
      const signingScripts = prevOuts.map((o) => o.script);
      const values = prevOuts.map((o) => o.value);
      const hashes = [];
      if (input.tapInternalKey && !tapLeafHashToSign) {
        const outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
        if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
          const tapKeyHash = unsignedTx.hashForWitnessV1(
            inputIndex,
            signingScripts,
            values,
            sighashType
          );
          hashes.push({ pubkey, hash: tapKeyHash });
        }
      }
      const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script)).map((tapLeaf) => {
        const hash = (0, bip341_1.tapleafHash)({
          output: tapLeaf.script,
          version: tapLeaf.leafVersion
        });
        return Object.assign({ hash }, tapLeaf);
      }).filter(
        (tapLeaf) => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)
      ).map((tapLeaf) => {
        const tapScriptHash = unsignedTx.hashForWitnessV1(
          inputIndex,
          signingScripts,
          values,
          sighashType,
          tapLeaf.hash
        );
        return {
          pubkey,
          hash: tapScriptHash,
          leafHash: tapLeaf.hash
        };
      });
      return hashes.concat(tapLeafHashes);
    }
    function checkSighashTypeAllowed(sighashType, sighashTypes) {
      if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
        const str = sighashTypeToString(sighashType);
        throw new Error(
          `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`
        );
      }
    }
    function getPayment(script, scriptType, partialSig) {
      let payment;
      switch (scriptType) {
        case "multisig":
          const sigs = getSortedSigs(script, partialSig);
          payment = payments.p2ms({
            output: script,
            signatures: sigs
          });
          break;
        case "pubkey":
          payment = payments.p2pk({
            output: script,
            signature: partialSig[0].signature
          });
          break;
        case "pubkeyhash":
          payment = payments.p2pkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
        case "witnesspubkeyhash":
          payment = payments.p2wpkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
      }
      return payment;
    }
    function getScriptFromInput(inputIndex, input, cache) {
      const unsignedTx = cache.__TX;
      const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
      };
      res.isP2SH = !!input.redeemScript;
      res.isP2WSH = !!input.witnessScript;
      if (input.witnessScript) {
        res.script = input.witnessScript;
      } else if (input.redeemScript) {
        res.script = input.redeemScript;
      } else {
        if (input.nonWitnessUtxo) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache,
            input,
            inputIndex
          );
          const prevoutIndex = unsignedTx.ins[inputIndex].index;
          res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
        } else if (input.witnessUtxo) {
          res.script = input.witnessUtxo.script;
        }
      }
      if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
        res.isSegwit = true;
      }
      return res;
    }
    function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
      const input = (0, utils_1.checkForInput)(inputs, inputIndex);
      if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
        throw new Error("Need bip32Derivation to sign with HD");
      }
      const myDerivations = input.bip32Derivation.map((bipDv) => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
          return bipDv;
        } else {
          return;
        }
      }).filter((v) => !!v);
      if (myDerivations.length === 0) {
        throw new Error(
          "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
        );
      }
      const signers = myDerivations.map((bipDv) => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) {
          throw new Error("pubkey did not match bip32Derivation");
        }
        return node;
      });
      return signers;
    }
    function getSortedSigs(script, partialSig) {
      const p2ms = payments.p2ms({ output: script });
      return p2ms.pubkeys.map((pk) => {
        return (partialSig.filter((ps) => {
          return ps.pubkey.equals(pk);
        })[0] || {}).signature;
      }).filter((v) => !!v);
    }
    function scriptWitnessToWitnessStack(buffer) {
      let offset = 0;
      function readSlice(n) {
        offset += n;
        return buffer.slice(offset - n, offset);
      }
      function readVarInt() {
        const vi = varuint.decode(buffer, offset);
        offset += varuint.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(readVarSlice());
        return vector;
      }
      return readVector();
    }
    function sighashTypeToString(sighashType) {
      let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
      const sigMod = sighashType & 31;
      switch (sigMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          text += "SIGHASH_ALL";
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
          text += "SIGHASH_SINGLE";
          break;
        case transaction_1.Transaction.SIGHASH_NONE:
          text += "SIGHASH_NONE";
          break;
      }
      return text;
    }
    function addNonWitnessTxCache(cache, input, inputIndex) {
      cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
      const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
      cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
      const self = cache;
      const selfIndex = inputIndex;
      delete input.nonWitnessUtxo;
      Object.defineProperty(input, "nonWitnessUtxo", {
        enumerable: true,
        get() {
          const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
          const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
          if (buf !== void 0) {
            return buf;
          } else {
            const newBuf = txCache.toBuffer();
            self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
            return newBuf;
          }
        },
        set(data) {
          self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
        }
      });
    }
    function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
      let inputAmount = 0;
      inputs.forEach((input, idx) => {
        if (mustFinalize && input.finalScriptSig)
          tx.ins[idx].script = input.finalScriptSig;
        if (mustFinalize && input.finalScriptWitness) {
          tx.ins[idx].witness = scriptWitnessToWitnessStack(
            input.finalScriptWitness
          );
        }
        if (input.witnessUtxo) {
          inputAmount += input.witnessUtxo.value;
        } else if (input.nonWitnessUtxo) {
          const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
          const vout = tx.ins[idx].index;
          const out = nwTx.outs[vout];
          inputAmount += out.value;
        }
      });
      const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
      const fee = inputAmount - outputAmount;
      if (fee < 0) {
        throw new Error("Outputs are spending more than Inputs");
      }
      const bytes = tx.virtualSize();
      cache.__FEE = fee;
      cache.__EXTRACTED_TX = tx;
      cache.__FEE_RATE = Math.floor(fee / bytes);
    }
    function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
      const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
      if (!c[inputIndex]) {
        addNonWitnessTxCache(cache, input, inputIndex);
      }
      return c[inputIndex];
    }
    function getScriptFromUtxo(inputIndex, input, cache) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
      return script;
    }
    function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
      if (input.witnessUtxo !== void 0) {
        return {
          script: input.witnessUtxo.script,
          value: input.witnessUtxo.value
        };
      } else if (input.nonWitnessUtxo !== void 0) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
        return { script: o.script, value: o.value };
      } else {
        throw new Error("Can't find pubkey in input without Utxo data");
      }
    }
    function pubkeyInInput(pubkey, input, inputIndex, cache) {
      const script = getScriptFromUtxo(inputIndex, input, cache);
      const { meaningfulScript } = getMeaningfulScript(
        script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function pubkeyInOutput(pubkey, output, outputIndex, cache) {
      const script = cache.__TX.outs[outputIndex].script;
      const { meaningfulScript } = getMeaningfulScript(
        script,
        outputIndex,
        "output",
        output.redeemScript,
        output.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function redeemFromFinalScriptSig(finalScript) {
      if (!finalScript) return;
      const decomp = bscript.decompile(finalScript);
      if (!decomp) return;
      const lastItem = decomp[decomp.length - 1];
      if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
        return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function redeemFromFinalWitnessScript(finalScript) {
      if (!finalScript) return;
      const decomp = scriptWitnessToWitnessStack(finalScript);
      const lastItem = decomp[decomp.length - 1];
      if (isPubkeyLike(lastItem)) return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function compressPubkey(pubkey) {
      if (pubkey.length === 65) {
        const parity = pubkey[64] & 1;
        const newKey = pubkey.slice(0, 33);
        newKey[0] = 2 | parity;
        return newKey;
      }
      return pubkey.slice();
    }
    function isPubkeyLike(buf) {
      return buf.length === 33 && bscript.isCanonicalPubKey(buf);
    }
    function isSigLike(buf) {
      return bscript.isCanonicalScriptSignature(buf);
    }
    function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
      const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
      const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
      const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
      if (isP2SH && redeemScript === void 0)
        throw new Error("scriptPubkey is P2SH but redeemScript missing");
      if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
        throw new Error(
          "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
        );
      let meaningfulScript;
      if (isP2SHP2WSH) {
        meaningfulScript = witnessScript;
        checkRedeemScript(index, script, redeemScript, ioType);
        checkWitnessScript(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2WSH) {
        meaningfulScript = witnessScript;
        checkWitnessScript(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2SH) {
        meaningfulScript = redeemScript;
        checkRedeemScript(index, script, redeemScript, ioType);
      } else {
        meaningfulScript = script;
      }
      return {
        meaningfulScript,
        type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
      };
    }
    function checkInvalidP2WSH(script) {
      if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {
        throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
      }
    }
    function classifyScript(script) {
      if ((0, psbtutils_1.isP2WPKH)(script)) return "witnesspubkeyhash";
      if ((0, psbtutils_1.isP2PKH)(script)) return "pubkeyhash";
      if ((0, psbtutils_1.isP2MS)(script)) return "multisig";
      if ((0, psbtutils_1.isP2PK)(script)) return "pubkey";
      return "nonstandard";
    }
    function range(n) {
      return [...Array(n).keys()];
    }
  }
});

// node_modules/bitcoinjs-lib/src/index.js
var require_src2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initEccLib = exports2.Transaction = exports2.opcodes = exports2.Psbt = exports2.Block = exports2.script = exports2.payments = exports2.networks = exports2.crypto = exports2.address = void 0;
    var address = require_address();
    exports2.address = address;
    var crypto = require_crypto();
    exports2.crypto = crypto;
    var networks = require_networks();
    exports2.networks = networks;
    var payments = require_payments();
    exports2.payments = payments;
    var script = require_script();
    exports2.script = script;
    var block_1 = require_block();
    Object.defineProperty(exports2, "Block", {
      enumerable: true,
      get: function() {
        return block_1.Block;
      }
    });
    var psbt_1 = require_psbt2();
    Object.defineProperty(exports2, "Psbt", {
      enumerable: true,
      get: function() {
        return psbt_1.Psbt;
      }
    });
    var ops_1 = require_ops();
    Object.defineProperty(exports2, "opcodes", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var transaction_1 = require_transaction();
    Object.defineProperty(exports2, "Transaction", {
      enumerable: true,
      get: function() {
        return transaction_1.Transaction;
      }
    });
    var ecc_lib_1 = require_ecc_lib();
    Object.defineProperty(exports2, "initEccLib", {
      enumerable: true,
      get: function() {
        return ecc_lib_1.initEccLib;
      }
    });
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anumber = anumber;
    exports2.number = anumber;
    exports2.abytes = abytes;
    exports2.bytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    var assert = {
      number: anumber,
      bytes: abytes,
      hash: ahash,
      exists: aexists,
      output: aoutput
    };
    exports2.default = assert;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("node:crypto");
    exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
var require_utils3 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = exports2.nextTick = exports2.byteSwapIfBE = exports2.byteSwap = exports2.isLE = exports2.rotl = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    exports2.isBytes = isBytes;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.toBytes = toBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.wrapConstructor = wrapConstructor;
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports2.randomBytes = randomBytes2;
    var crypto_1 = require_cryptoNode2();
    var _assert_js_1 = require_assert2();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports2.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports2.rotl = rotl;
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports2.byteSwap = byteSwap;
    exports2.byteSwapIfBE = exports2.isLE ? (n) => n : (n) => (0, exports2.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports2.byteSwap)(arr[i]);
      }
    }
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.abytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("utf8ToBytes expected string, got " + typeof str);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.abytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.abytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_md.js
var require_md2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashMD = exports2.Maj = exports2.Chi = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils3();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports2.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports2.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.HashMD = HashMD;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = exports2.SHA256 = void 0;
    var _md_js_1 = require_md2();
    var utils_js_1 = require_utils3();
    var SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports2.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils3();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.ahash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils4 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.notImplemented = exports2.bitMask = void 0;
    exports2.isBytes = isBytes;
    exports2.abytes = abytes;
    exports2.abool = abool;
    exports2.bytesToHex = bytesToHex;
    exports2.numberToHexUnpadded = numberToHexUnpadded;
    exports2.hexToNumber = hexToNumber;
    exports2.hexToBytes = hexToBytes;
    exports2.bytesToNumberBE = bytesToNumberBE;
    exports2.bytesToNumberLE = bytesToNumberLE;
    exports2.numberToBytesBE = numberToBytesBE;
    exports2.numberToBytesLE = numberToBytesLE;
    exports2.numberToVarBytesBE = numberToVarBytesBE;
    exports2.ensureBytes = ensureBytes;
    exports2.concatBytes = concatBytes;
    exports2.equalBytes = equalBytes;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.inRange = inRange;
    exports2.aInRange = aInRange;
    exports2.bitLen = bitLen;
    exports2.bitGet = bitGet;
    exports2.bitSet = bitSet;
    exports2.createHmacDrbg = createHmacDrbg;
    exports2.validateObject = validateObject;
    exports2.memoized = memoized;
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports2.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports2.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNegativeLE = void 0;
    exports2.mod = mod;
    exports2.pow = pow;
    exports2.pow2 = pow2;
    exports2.invert = invert;
    exports2.tonelliShanks = tonelliShanks;
    exports2.FpSqrt = FpSqrt;
    exports2.validateField = validateField;
    exports2.FpPow = FpPow;
    exports2.FpInvertBatch = FpInvertBatch;
    exports2.FpDiv = FpDiv;
    exports2.FpLegendre = FpLegendre;
    exports2.FpIsSquare = FpIsSquare;
    exports2.nLength = nLength;
    exports2.Field = Field;
    exports2.FpSqrtOdd = FpSqrtOdd;
    exports2.FpSqrtEven = FpSqrtEven;
    exports2.hashToPrivateScalar = hashToPrivateScalar;
    exports2.getFieldBytesLength = getFieldBytesLength;
    exports2.getMinHashLength = getMinHashLength;
    exports2.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _3n = /* @__PURE__ */ BigInt(3);
    var _4n = /* @__PURE__ */ BigInt(4);
    var _5n = /* @__PURE__ */ BigInt(5);
    var _8n = /* @__PURE__ */ BigInt(8);
    var _9n = /* @__PURE__ */ BigInt(9);
    var _16n = /* @__PURE__ */ BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (modulo <= _0n)
        throw new Error("invalid modulus");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {
        if (Z > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      }
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports2.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpLegendre(order) {
      const legendreConst = (order - _1n) / _2n;
      return (f, x) => f.pow(x, legendreConst);
    }
    function FpIsSquare(f) {
      const legendre = FpLegendre(f.ORDER);
      return (x) => {
        const p = legendre(f, x);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wNAF = wNAF;
    exports2.pippenger = pippenger;
    exports2.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports2.validateBasic = validateBasic;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function constTimeNegate(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, bits) {
      validateW(W, bits);
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function wNAF(c, bits) {
      return {
        constTimeNegate,
        hasPrecomputes(elm) {
          return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder(elm, n, p = c.ZERO) {
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = calcWOpts(W, bits);
          const points = [];
          let p = elm;
          let base = p;
          for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = calcWOpts(W, bits);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
          const { windows, windowSize } = calcWOpts(W, bits);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            if (n === _0n)
              break;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            if (wbits === 0)
              continue;
            let curr = precomputes[offset + Math.abs(wbits) - 1];
            if (wbits < 0)
              curr = curr.negate();
            acc = acc.add(curr);
          }
          return acc;
        },
        getPrecomputes(W, P, transform) {
          let comp = pointPrecomputes.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1)
              pointPrecomputes.set(P, transform(comp));
          }
          return comp;
        },
        wNAFCached(P, n, transform) {
          const W = getW(P);
          return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe(P, n, transform, prev) {
          const W = getW(P);
          if (W === 1)
            return this.unsafeLadder(P, n, prev);
          return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
          validateW(W, bits);
          pointWindowSizes.set(P, W);
          pointPrecomputes.delete(P);
        }
      };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      if (points.length !== scalars.length)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));
      const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
      const MASK = (1 << windowSize) - 1;
      const buckets = new Array(MASK + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < scalars.length; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = BigInt((1 << windowSize) - 1);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DER = void 0;
    exports2.weierstrassPoints = weierstrassPoints;
    exports2.weierstrass = weierstrass;
    exports2.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports2.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve();
    var mod = require_modular();
    var ut = require_utils4();
    var utils_js_1 = require_utils4();
    function validateSigVerOpts(opts) {
      if (opts.lowS !== void 0)
        (0, utils_js_1.abool)("lowS", opts.lowS);
      if (opts.prehash !== void 0)
        (0, utils_js_1.abool)("prehash", opts.prehash);
    }
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports2.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = exports2.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = ut.numberToHexUnpadded(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? ut.numberToHexUnpadded(len.length / 2 | 128) : "";
          const t = ut.numberToHexUnpadded(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = exports2.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports2.DER;
          if (num < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = ut.numberToHexUnpadded(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = exports2.DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return b2n(data);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = exports2.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports2.DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const Fn = mod.Field(CURVE.n, CURVE.nBitLength);
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return ut.inRange(num, _1n, CURVE.n);
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("invalid private key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, N);
        ut.aInRange("private key", num, _1n, N);
        return num;
      }
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        if (Fp.eql(z, Fp.ONE))
          return { x, y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      });
      const assertValidMemo = (0, utils_js_1.memoized)((p) => {
        if (p.is0()) {
          if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
          Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
          return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          wnaf.setWindowSize(this, windowSize);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo, n: N } = CURVE;
          ut.aInRange("scalar", sc, _0n, N);
          const I = Point.ZERO;
          if (sc === _0n)
            return I;
          if (this.is0() || sc === _1n)
            return this;
          if (!endo || wnaf.hasPrecomputes(this))
            return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo, n: N } = CURVE;
          ut.aInRange("scalar", scalar, _1n, N);
          let point, fake;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(scalar);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          return toAffineMemo(this, iz);
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!ut.inRange(x, _1n, Fp.ORDER))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            const cl = compressedLen;
            const ul = uncompressedLen;
            throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports2.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          ut.aInRange("r", this.r, _1n, CURVE_ORDER);
          ut.aInRange("s", this.s, _1n, CURVE_ORDER);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports2.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        ut.aInRange("num < 2^" + CURVE.nBitLength, num, _0n, ORDER_MASK);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes: randomBytes2 } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        validateSigVerOpts(opts);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes2(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign3(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify3(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        const { lowS, prehash, format } = opts;
        validateSigVerOpts(opts);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        if (format !== void 0 && format !== "compact" && format !== "der")
          throw new Error("format must be compact or der");
        const isHex = typeof sg === "string" || ut.isBytes(sg);
        const isObj = !isHex && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let _sig = void 0;
        let P;
        try {
          if (isObj)
            _sig = new Signature(sg.r, sg.s);
          if (isHex) {
            try {
              if (format !== "compact")
                _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports2.DER.Err))
                throw derError;
            }
            if (!_sig && format !== "der")
              _sig = Signature.fromCompact(sg);
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          return false;
        }
        if (!_sig)
          return false;
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign: sign3,
        verify: verify3,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHash = getHash;
    exports2.createCurve = createCurve;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils3();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand_message_xmd = expand_message_xmd;
    exports2.expand_message_xof = expand_message_xof;
    exports2.hash_to_field = hash_to_field;
    exports2.isogenyMap = isogenyMap;
    exports2.createHasher = createHasher;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils4();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("mapToCurve: expected array of bigints");
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeToCurve = exports2.hashToCurve = exports2.schnorr = exports2.secp256k1 = void 0;
    var sha256_1 = require_sha2562();
    var utils_1 = require_utils3();
    var _shortw_utils_js_1 = require_shortw_utils();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils4();
    var weierstrass_js_1 = require_weierstrass();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports2.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp: Fpk1,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports2.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports2.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      (0, utils_js_1.aInRange)("x", x, _1n, secp256k1P);
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    var num = utils_js_1.bytesToNumberBE;
    function challenge(...args) {
      return modN(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN(num(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_js_1.inRange)(r, _1n, secp256k1P))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports2.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports2.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports2.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports2.hashToCurve = (() => htf.hashToCurve)();
    exports2.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@bitcoinerlab/secp256k1/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@bitcoinerlab/secp256k1/dist/index.js"(exports2) {
    "use strict";
    init_esbuild_shims();
    init_buffer_shims();
    var secp256k1 = require_secp256k1();
    var mod = require_modular();
    var utils = require_utils4();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var mod__namespace = /* @__PURE__ */ _interopNamespaceDefault(mod);
    var utils__namespace = /* @__PURE__ */ _interopNamespaceDefault(utils);
    var Point = secp256k1.secp256k1.ProjectivePoint;
    var THROW_BAD_PRIVATE = "Expected Private";
    var THROW_BAD_POINT = "Expected Point";
    var THROW_BAD_TWEAK = "Expected Tweak";
    var THROW_BAD_HASH = "Expected Hash";
    var THROW_BAD_SIGNATURE = "Expected Signature";
    var THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
    var THROW_BAD_SCALAR = "Expected Scalar";
    var THROW_BAD_RECOVERY_ID = "Bad Recovery Id";
    var HASH_SIZE2 = 32;
    var TWEAK_SIZE2 = 32;
    var BN32_N2 = new Uint8Array([
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65
    ]);
    var EXTRA_DATA_SIZE2 = 32;
    var BN32_ZERO2 = new Uint8Array(32);
    var BN32_P_MINUS_N2 = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      69,
      81,
      35,
      25,
      80,
      183,
      95,
      196,
      64,
      45,
      161,
      114,
      47,
      201,
      186,
      238
    ]);
    var _1n = BigInt(1);
    function isUint8Array2(value) {
      return value instanceof Uint8Array;
    }
    function cmpBN322(data1, data2) {
      for (let i = 0; i < 32; ++i) {
        if (data1[i] !== data2[i]) {
          return data1[i] < data2[i] ? -1 : 1;
        }
      }
      return 0;
    }
    function isZero2(x) {
      return cmpBN322(x, BN32_ZERO2) === 0;
    }
    function isTweak2(tweak) {
      if (!(tweak instanceof Uint8Array) || tweak.length !== TWEAK_SIZE2 || cmpBN322(tweak, BN32_N2) >= 0) {
        return false;
      }
      return true;
    }
    function isSignature2(signature) {
      return signature instanceof Uint8Array && signature.length === 64 && cmpBN322(signature.subarray(0, 32), BN32_N2) < 0 && cmpBN322(signature.subarray(32, 64), BN32_N2) < 0;
    }
    function isSigrLessThanPMinusN2(signature) {
      return isUint8Array2(signature) && signature.length === 64 && cmpBN322(signature.subarray(0, 32), BN32_P_MINUS_N2) < 0;
    }
    function isSignatureNonzeroRS(signature) {
      return !(isZero2(signature.subarray(0, 32)) || isZero2(signature.subarray(32, 64)));
    }
    function isHash2(h) {
      return h instanceof Uint8Array && h.length === HASH_SIZE2;
    }
    function isExtraData2(e) {
      return e === void 0 || e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE2;
    }
    function normalizeScalar(scalar) {
      let num;
      if (typeof scalar === "bigint") {
        num = scalar;
      } else if (typeof scalar === "number" && Number.isSafeInteger(scalar) && scalar >= 0) {
        num = BigInt(scalar);
      } else if (typeof scalar === "string") {
        if (scalar.length !== 64)
          throw new Error("Expected 32 bytes of private scalar");
        num = utils__namespace.hexToNumber(scalar);
      } else if (scalar instanceof Uint8Array) {
        if (scalar.length !== 32)
          throw new Error("Expected 32 bytes of private scalar");
        num = utils__namespace.bytesToNumberBE(scalar);
      } else {
        throw new TypeError("Expected valid private scalar");
      }
      if (num < 0) throw new Error("Expected private scalar >= 0");
      return num;
    }
    function normalizePrivateKey(privateKey) {
      return secp256k1.secp256k1.utils.normPrivateKeyToScalar(privateKey);
    }
    function _privateAdd(privateKey, tweak) {
      const p = normalizePrivateKey(privateKey);
      const t = normalizeScalar(tweak);
      const add = utils__namespace.numberToBytesBE(mod__namespace.mod(p + t, secp256k1.secp256k1.CURVE.n), 32);
      return secp256k1.secp256k1.utils.isValidPrivateKey(add) ? add : null;
    }
    function _privateSub(privateKey, tweak) {
      const p = normalizePrivateKey(privateKey);
      const t = normalizeScalar(tweak);
      const sub = utils__namespace.numberToBytesBE(mod__namespace.mod(p - t, secp256k1.secp256k1.CURVE.n), 32);
      return secp256k1.secp256k1.utils.isValidPrivateKey(sub) ? sub : null;
    }
    function _privateNegate(privateKey) {
      const p = normalizePrivateKey(privateKey);
      const not = utils__namespace.numberToBytesBE(secp256k1.secp256k1.CURVE.n - p, 32);
      return secp256k1.secp256k1.utils.isValidPrivateKey(not) ? not : null;
    }
    function _pointAddScalar(p, tweak, isCompressed) {
      const P = fromHex(p);
      const t = normalizeScalar(tweak);
      const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
      if (!Q) throw new Error("Tweaked point at infinity");
      return Q.toRawBytes(isCompressed);
    }
    function _pointMultiply(p, tweak, isCompressed) {
      const P = fromHex(p);
      const h = typeof tweak === "string" ? tweak : utils__namespace.bytesToHex(tweak);
      const t = utils__namespace.hexToNumber(h);
      return P.multiply(t).toRawBytes(isCompressed);
    }
    function assumeCompression2(compressed, p) {
      if (compressed === void 0) {
        return p !== void 0 ? isPointCompressed3(p) : true;
      }
      return !!compressed;
    }
    function throwToNull(fn) {
      try {
        return fn();
      } catch (e) {
        return null;
      }
    }
    function fromXOnly(bytes) {
      return secp256k1.schnorr.utils.lift_x(utils__namespace.bytesToNumberBE(bytes));
    }
    function fromHex(bytes) {
      return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);
    }
    function _isPoint2(p, xOnly) {
      if (p.length === 32 !== xOnly) return false;
      try {
        if (xOnly) return !!fromXOnly(p);
        else return !!Point.fromHex(p);
      } catch (e) {
        return false;
      }
    }
    function isPoint4(p) {
      return _isPoint2(p, false);
    }
    function isPointCompressed3(p) {
      const PUBLIC_KEY_COMPRESSED_SIZE2 = 33;
      return _isPoint2(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE2;
    }
    function isPrivate3(d) {
      return secp256k1.secp256k1.utils.isValidPrivateKey(d);
    }
    function isXOnlyPoint3(p) {
      return _isPoint2(p, true);
    }
    function xOnlyPointAddTweak3(p, tweak) {
      if (!isXOnlyPoint3(p)) {
        throw new Error(THROW_BAD_POINT);
      }
      if (!isTweak2(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
      }
      return throwToNull(() => {
        const P = _pointAddScalar(p, tweak, true);
        const parity = P[0] % 2 === 1 ? 1 : 0;
        return { parity, xOnlyPubkey: P.slice(1) };
      });
    }
    function xOnlyPointFromPoint3(p) {
      if (!isPoint4(p)) {
        throw new Error(THROW_BAD_POINT);
      }
      return p.slice(1, 33);
    }
    function pointFromScalar3(sk, compressed) {
      if (!isPrivate3(sk)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      return throwToNull(
        () => secp256k1.secp256k1.getPublicKey(sk, assumeCompression2(compressed))
      );
    }
    function xOnlyPointFromScalar3(d) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      return xOnlyPointFromPoint3(pointFromScalar3(d));
    }
    function pointCompress3(p, compressed) {
      if (!isPoint4(p)) {
        throw new Error(THROW_BAD_POINT);
      }
      return fromHex(p).toRawBytes(assumeCompression2(compressed, p));
    }
    function pointMultiply3(a, tweak, compressed) {
      if (!isPoint4(a)) {
        throw new Error(THROW_BAD_POINT);
      }
      if (!isTweak2(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
      }
      return throwToNull(
        () => _pointMultiply(a, tweak, assumeCompression2(compressed, a))
      );
    }
    function pointAdd3(a, b, compressed) {
      if (!isPoint4(a) || !isPoint4(b)) {
        throw new Error(THROW_BAD_POINT);
      }
      return throwToNull(() => {
        const A = fromHex(a);
        const B = fromHex(b);
        if (A.equals(B.negate())) {
          return null;
        } else {
          return A.add(B).toRawBytes(assumeCompression2(compressed, a));
        }
      });
    }
    function pointAddScalar3(p, tweak, compressed) {
      if (!isPoint4(p)) {
        throw new Error(THROW_BAD_POINT);
      }
      if (!isTweak2(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
      }
      return throwToNull(
        () => _pointAddScalar(p, tweak, assumeCompression2(compressed, p))
      );
    }
    function privateAdd3(d, tweak) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      if (!isTweak2(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
      }
      return throwToNull(() => _privateAdd(d, tweak));
    }
    function privateSub3(d, tweak) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      if (!isTweak2(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
      }
      return throwToNull(() => _privateSub(d, tweak));
    }
    function privateNegate3(d) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      return _privateNegate(d);
    }
    function sign3(h, d, e) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      if (!isHash2(h)) {
        throw new Error(THROW_BAD_SCALAR);
      }
      if (!isExtraData2(e)) {
        throw new Error(THROW_BAD_EXTRA_DATA);
      }
      return secp256k1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();
    }
    function signRecoverable3(h, d, e) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      if (!isHash2(h)) {
        throw new Error(THROW_BAD_SCALAR);
      }
      if (!isExtraData2(e)) {
        throw new Error(THROW_BAD_EXTRA_DATA);
      }
      const sig = secp256k1.secp256k1.sign(h, d, { extraEntropy: e });
      return {
        signature: sig.toCompactRawBytes(),
        recoveryId: sig.recovery
      };
    }
    function signSchnorr4(h, d, e) {
      if (!isPrivate3(d)) {
        throw new Error(THROW_BAD_PRIVATE);
      }
      if (!isHash2(h)) {
        throw new Error(THROW_BAD_SCALAR);
      }
      if (!isExtraData2(e)) {
        throw new Error(THROW_BAD_EXTRA_DATA);
      }
      return secp256k1.schnorr.sign(h, d, e);
    }
    function recover3(h, signature, recoveryId, compressed) {
      if (!isHash2(h)) {
        throw new Error(THROW_BAD_HASH);
      }
      if (!isSignature2(signature) || !isSignatureNonzeroRS(signature)) {
        throw new Error(THROW_BAD_SIGNATURE);
      }
      if (recoveryId & 2) {
        if (!isSigrLessThanPMinusN2(signature))
          throw new Error(THROW_BAD_RECOVERY_ID);
      }
      if (!isXOnlyPoint3(signature.subarray(0, 32))) {
        throw new Error(THROW_BAD_SIGNATURE);
      }
      const s = secp256k1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(recoveryId);
      const Q = s.recoverPublicKey(h);
      if (!Q) throw new Error(THROW_BAD_SIGNATURE);
      return Q.toRawBytes(assumeCompression2(compressed));
    }
    function verify3(h, Q, signature, strict) {
      if (!isPoint4(Q)) {
        throw new Error(THROW_BAD_POINT);
      }
      if (!isSignature2(signature)) {
        throw new Error(THROW_BAD_SIGNATURE);
      }
      if (!isHash2(h)) {
        throw new Error(THROW_BAD_SCALAR);
      }
      return secp256k1.secp256k1.verify(signature, h, Q, { lowS: strict });
    }
    function verifySchnorr3(h, Q, signature) {
      if (!isXOnlyPoint3(Q)) {
        throw new Error(THROW_BAD_POINT);
      }
      if (!isSignature2(signature)) {
        throw new Error(THROW_BAD_SIGNATURE);
      }
      if (!isHash2(h)) {
        throw new Error(THROW_BAD_SCALAR);
      }
      return secp256k1.schnorr.verify(signature, h, Q);
    }
    exports2.isPoint = isPoint4;
    exports2.isPointCompressed = isPointCompressed3;
    exports2.isPrivate = isPrivate3;
    exports2.isXOnlyPoint = isXOnlyPoint3;
    exports2.pointAdd = pointAdd3;
    exports2.pointAddScalar = pointAddScalar3;
    exports2.pointCompress = pointCompress3;
    exports2.pointFromScalar = pointFromScalar3;
    exports2.pointMultiply = pointMultiply3;
    exports2.privateAdd = privateAdd3;
    exports2.privateNegate = privateNegate3;
    exports2.privateSub = privateSub3;
    exports2.recover = recover3;
    exports2.sign = sign3;
    exports2.signRecoverable = signRecoverable3;
    exports2.signSchnorr = signSchnorr4;
    exports2.verify = verify3;
    exports2.verifySchnorr = verifySchnorr3;
    exports2.xOnlyPointAddTweak = xOnlyPointAddTweak3;
    exports2.xOnlyPointFromPoint = xOnlyPointFromPoint3;
    exports2.xOnlyPointFromScalar = xOnlyPointFromScalar3;
  }
});

// src/actions/taproot-action.js
init_esbuild_shims();
init_buffer_shims();
var bitcoin = __toESM(require_src2(), 1);

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  __initializeContext: () => __initializeContext,
  isPoint: () => isPoint3,
  isPointCompressed: () => isPointCompressed2,
  isPrivate: () => isPrivate2,
  isXOnlyPoint: () => isXOnlyPoint2,
  pointAdd: () => pointAdd2,
  pointAddScalar: () => pointAddScalar2,
  pointCompress: () => pointCompress2,
  pointFromScalar: () => pointFromScalar2,
  pointMultiply: () => pointMultiply2,
  privateAdd: () => privateAdd2,
  privateNegate: () => privateNegate2,
  privateSub: () => privateSub2,
  recover: () => recover2,
  sign: () => sign2,
  signRecoverable: () => signRecoverable2,
  signSchnorr: () => signSchnorr2,
  verify: () => verify2,
  verifySchnorr: () => verifySchnorr2,
  xOnlyPointAddTweak: () => xOnlyPointAddTweak2,
  xOnlyPointAddTweakCheck: () => xOnlyPointAddTweakCheck2,
  xOnlyPointFromPoint: () => xOnlyPointFromPoint2,
  xOnlyPointFromScalar: () => xOnlyPointFromScalar2
});
init_esbuild_shims();
init_buffer_shims();

// node_modules/uint8array-tools/src/mjs/index.js
init_esbuild_shims();
init_buffer_shims();
function compare(v1, v2) {
  return Buffer.from(v1).compare(Buffer.from(v2));
}

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate.js
init_esbuild_shims();
init_buffer_shims();

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate_error.js
var validate_error_exports = {};
__export(validate_error_exports, {
  ERROR_BAD_EXTRA_DATA: () => ERROR_BAD_EXTRA_DATA,
  ERROR_BAD_HASH: () => ERROR_BAD_HASH,
  ERROR_BAD_PARITY: () => ERROR_BAD_PARITY,
  ERROR_BAD_POINT: () => ERROR_BAD_POINT,
  ERROR_BAD_PRIVATE: () => ERROR_BAD_PRIVATE,
  ERROR_BAD_RECOVERY_ID: () => ERROR_BAD_RECOVERY_ID,
  ERROR_BAD_SIGNATURE: () => ERROR_BAD_SIGNATURE,
  ERROR_BAD_TWEAK: () => ERROR_BAD_TWEAK,
  throwError: () => throwError
});
init_esbuild_shims();
init_buffer_shims();
var ERROR_BAD_PRIVATE = 0;
var ERROR_BAD_POINT = 1;
var ERROR_BAD_TWEAK = 2;
var ERROR_BAD_HASH = 3;
var ERROR_BAD_SIGNATURE = 4;
var ERROR_BAD_EXTRA_DATA = 5;
var ERROR_BAD_PARITY = 6;
var ERROR_BAD_RECOVERY_ID = 7;
var ERRORS_MESSAGES = {
  [ERROR_BAD_PRIVATE.toString()]: "Expected Private",
  [ERROR_BAD_POINT.toString()]: "Expected Point",
  [ERROR_BAD_TWEAK.toString()]: "Expected Tweak",
  [ERROR_BAD_HASH.toString()]: "Expected Hash",
  [ERROR_BAD_SIGNATURE.toString()]: "Expected Signature",
  [ERROR_BAD_EXTRA_DATA.toString()]: "Expected Extra Data (32 bytes)",
  [ERROR_BAD_PARITY.toString()]: "Expected Parity (1 | 0)",
  [ERROR_BAD_RECOVERY_ID.toString()]: "Bad Recovery Id"
};
function throwError(errcode) {
  const message = ERRORS_MESSAGES[errcode.toString()] || `Unknow error code: ${errcode}`;
  throw new TypeError(message);
}

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate.js
var PRIVATE_KEY_SIZE = 32;
var PUBLIC_KEY_COMPRESSED_SIZE = 33;
var PUBLIC_KEY_UNCOMPRESSED_SIZE = 65;
var X_ONLY_PUBLIC_KEY_SIZE = 32;
var TWEAK_SIZE = 32;
var HASH_SIZE = 32;
var EXTRA_DATA_SIZE = 32;
var SIGNATURE_SIZE = 64;
var BN32_ZERO = new Uint8Array(32);
var BN32_N = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]);
var BN32_P_MINUS_N = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function isUint8Array(value) {
  return value instanceof Uint8Array;
}
function cmpBN32(data1, data2) {
  for (let i = 0; i < 32; ++i) {
    if (data1[i] !== data2[i]) {
      return data1[i] < data2[i] ? -1 : 1;
    }
  }
  return 0;
}
function isZero(x) {
  return cmpBN32(x, BN32_ZERO) === 0;
}
function isPrivate(x) {
  return isUint8Array(x) && x.length === PRIVATE_KEY_SIZE && cmpBN32(x, BN32_ZERO) > 0 && cmpBN32(x, BN32_N) < 0;
}
function isPoint(p) {
  return isUint8Array(p) && (p.length === PUBLIC_KEY_COMPRESSED_SIZE || p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE || p.length === X_ONLY_PUBLIC_KEY_SIZE);
}
function isXOnlyPoint(p) {
  return isUint8Array(p) && p.length === X_ONLY_PUBLIC_KEY_SIZE;
}
function isDERPoint(p) {
  return isUint8Array(p) && (p.length === PUBLIC_KEY_COMPRESSED_SIZE || p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE);
}
function isPointCompressed(p) {
  return isUint8Array(p) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
}
function isTweak(tweak) {
  return isUint8Array(tweak) && tweak.length === TWEAK_SIZE && cmpBN32(tweak, BN32_N) < 0;
}
function isHash(h) {
  return isUint8Array(h) && h.length === HASH_SIZE;
}
function isExtraData(e) {
  return e === void 0 || isUint8Array(e) && e.length === EXTRA_DATA_SIZE;
}
function isSignature(signature) {
  return isUint8Array(signature) && signature.length === 64 && cmpBN32(signature.subarray(0, 32), BN32_N) < 0 && cmpBN32(signature.subarray(32, 64), BN32_N) < 0;
}
function isSigrLessThanPMinusN(signature) {
  return isUint8Array(signature) && signature.length === 64 && cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0;
}
function validateParity(p) {
  if (p !== 0 && p !== 1)
    throwError(ERROR_BAD_PARITY);
}
function validatePrivate(d) {
  if (!isPrivate(d))
    throwError(ERROR_BAD_PRIVATE);
}
function validatePoint(p) {
  if (!isPoint(p))
    throwError(ERROR_BAD_POINT);
}
function validateXOnlyPoint(p) {
  if (!isXOnlyPoint(p))
    throwError(ERROR_BAD_POINT);
}
function validateTweak(tweak) {
  if (!isTweak(tweak))
    throwError(ERROR_BAD_TWEAK);
}
function validateHash(h) {
  if (!isHash(h))
    throwError(ERROR_BAD_HASH);
}
function validateExtraData(e) {
  if (!isExtraData(e))
    throwError(ERROR_BAD_EXTRA_DATA);
}
function validateSignature(signature) {
  if (!isSignature(signature))
    throwError(ERROR_BAD_SIGNATURE);
}
function validateSignatureCustom(validatorFn) {
  if (!validatorFn())
    throwError(ERROR_BAD_SIGNATURE);
}
function validateSignatureNonzeroRS(signature) {
  if (isZero(signature.subarray(0, 32)))
    throwError(ERROR_BAD_SIGNATURE);
  if (isZero(signature.subarray(32, 64)))
    throwError(ERROR_BAD_SIGNATURE);
}
function validateSigrPMinusN(signature) {
  if (!isSigrLessThanPMinusN(signature))
    throwError(ERROR_BAD_RECOVERY_ID);
}

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/wasm_loader.js
init_esbuild_shims();
init_buffer_shims();

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/secp256k1.asm.js
var secp256k1_asm_exports = {};
__export(secp256k1_asm_exports, {
  EXTRA_DATA_INPUT: () => EXTRA_DATA_INPUT,
  HASH_INPUT: () => HASH_INPUT,
  PRIVATE_INPUT: () => PRIVATE_INPUT,
  PUBLIC_KEY_INPUT: () => PUBLIC_KEY_INPUT,
  PUBLIC_KEY_INPUT2: () => PUBLIC_KEY_INPUT2,
  SIGNATURE_INPUT: () => SIGNATURE_INPUT,
  TWEAK_INPUT: () => TWEAK_INPUT,
  X_ONLY_PUBLIC_KEY_INPUT: () => X_ONLY_PUBLIC_KEY_INPUT,
  X_ONLY_PUBLIC_KEY_INPUT2: () => X_ONLY_PUBLIC_KEY_INPUT2,
  __data_end: () => __data_end,
  __heap_base: () => __heap_base,
  initializeContext: () => initializeContext,
  isPoint: () => isPoint2,
  memory: () => memory,
  pointAdd: () => pointAdd,
  pointAddScalar: () => pointAddScalar,
  pointCompress: () => pointCompress,
  pointFromScalar: () => pointFromScalar,
  pointMultiply: () => pointMultiply,
  privateAdd: () => privateAdd,
  privateNegate: () => privateNegate,
  privateSub: () => privateSub,
  recover: () => recover,
  rustsecp256k1_v0_8_1_default_error_callback_fn: () => rustsecp256k1_v0_8_1_default_error_callback_fn,
  rustsecp256k1_v0_8_1_default_illegal_callback_fn: () => rustsecp256k1_v0_8_1_default_illegal_callback_fn,
  sign: () => sign,
  signRecoverable: () => signRecoverable,
  signSchnorr: () => signSchnorr,
  verify: () => verify,
  verifySchnorr: () => verifySchnorr,
  xOnlyPointAddTweak: () => xOnlyPointAddTweak,
  xOnlyPointAddTweakCheck: () => xOnlyPointAddTweakCheck,
  xOnlyPointFromPoint: () => xOnlyPointFromPoint,
  xOnlyPointFromScalar: () => xOnlyPointFromScalar
});
init_esbuild_shims();
init_buffer_shims();

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/rand.js
var rand_exports = {};
__export(rand_exports, {
  generateInt32: () => generateInt32
});
init_esbuild_shims();
init_buffer_shims();
var import_crypto = require("crypto");
function generateInt32() {
  return (0, import_crypto.randomBytes)(4).readInt32BE(0);
}

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/secp256k1.asm.js
var bufferView;
var base64ReverseLookup = new Uint8Array(
  123
  /*'z'+1*/
);
for (i = 25; i >= 0; --i) {
  base64ReverseLookup[48 + i] = 52 + i;
  base64ReverseLookup[65 + i] = i;
  base64ReverseLookup[97 + i] = 26 + i;
}
var i;
base64ReverseLookup[43] = 62;
base64ReverseLookup[47] = 63;
function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
  var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength * 3 >> 2) - (b64[bLength - 2] == "=") - (b64[bLength - 1] == "=");
  for (; i < bLength; i += 4) {
    b1 = base64ReverseLookup[b64.charCodeAt(i + 1)];
    b2 = base64ReverseLookup[b64.charCodeAt(i + 2)];
    uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
    if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
    if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i + 3)];
  }
}
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 655360, "AQAAAAQAAAAEAAAAAgAAAAEAAAAEAAAABAAAAAM=");
  base64DecodeToExistingUint8Array(bufferView, 655716, "MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAAmBf4FluB8lnZKM4t2/ybAgcLh86VYqBVrLvc+X5mvnm41BD7j9BHnBlUhaZItBf9qAgRDvz7pF1lxKMmd9o6SPk24LwT8QGGsJlvg0XIMbUpUp34hU80SRDDWJIBijD5cua4hHX9uWwbI8I0makAZVbzNyrmN+MPFOgtYw97jzjk70CyadWoy7eaYdy9hIvoKFFcCiWntFWTIAcaTd6LL9ZirKY6fajcQGgNqxsniPcmxMmm3anb1Nbj5TYmIqzYvPnEyu3dK+mc4zADfptBPQ566vJl85ij6rRdbmTwvVzaZHIIKCYIpbXn/RO40BOo21Qahm2NF6NgWSW6QMrratrAxJ5MRHsbNaM+cnhWjOguFh+YrcE5kjNfO/bSuWiPgv8fUHm/PPL9C1GV/izqu10hvrbCkB3ehjkGui2fKmb6CTjS7bjiGL5U2VGzXIT9CB9F8mMzqYsin1Auvh04OFLtHzMYdXC9TfLYMsv8gTbMsQ5SpQWUsNwXuQ8KLaPkEKPCl0gmpD4wJhJApa6G8aGZRqqCG5L25io35CQnJknQ3idegbZBDM74X6cSNhZtOzAUl1b6LFr5q6e8c+c3EzEtvc55sIQTjdsG/1YazE344nfks1Pi1ZAMJBqMVgbjRG5UkoNAK2kmODe+QoC8/7YNfX8QK4+IYEKTeONvrA61SwS6SOXO+9Bs3ggfe4FWUka1IcBa65rsPu1uc9OeOkqXx0UMAULSwQ5gjpgXdatpaU+euGPG3yPAyb0oWcx7WO+rUE98P2ARl3hK+ITmXPxKT6cBPBNOVyjLw3V2TeRL+xsenEtXtaMgU7Ib0mSMIG4ACmzYahniLC7+L7a8JXBHje6bJFAzcGJpSbFgS5Eepc3WkSUI528WGIGkmNpq6zrsoxod3wAHDE0IAN/dHIW6LRHavKegd3iE863fNMJDVz96KlVh7dGVOp8t+YZPfsrpTJXqELn7TSZj6EqpACMIBDfOF3HtD2xVGc96VUFnBNgGFDPnFY/Q0mrx91N/gU9lTXPsZQnD1ibLn8AHq3n0wc4vLze4svfNHOtihBslkMwMBxjRo5JDwKIYpO7kM33D+ydk3lUdiae0VWcvBrvSCyaNvjpZ7dDP8cHRcMyFxwC+KU/LDzwR2ZyZX7XDqhUQbXeYJ/ZxggbfMvPizV4Iax1FH2ocWiKWVgt5RYm5sKrWa9LD0di9Mq+m9c2j3M9sCU0UYu5CUSUaQRu0pMM07gCUAuDWVaOhLs0d22LSRqFyrcqfKWzlnilqf9466L+atwke32JNjXVD8dky5Fv6PTTlH2JKMH/5dcZnr9QhGbYSpZbONbDzGWwg5bloqdRBH1+ekjOFGoUqAKf+0BPPzQvSenGq+aSBGYe5mcJy6zWnTxlgAUmLQRjekelqP5FLAk3JGzBm+9qJfMyHJ3NRAJct3Qrl8oTzQBoB6H5LeVK056gw2AEAnRCjyM5nvpT5EMrdi3dZMvngpgOCwhTL+7vZCOi9nlXXQXqgmhbkBXbd7LbEKhO3JOxCOt8YN6o1VlcBmEsciALMGQXhi+ud9s8DtkW31ww1sLatSEhcyibWNhGwvoNRMlTPQVQykDv4smW+0IS5134YdkCBeq7lPNdnchkPk358vlKdha+Kfrfh9+S5mz3adPJ/SV1R8HhGtIXIQiy/uUi0YekfLYeWP+nhVa0/dtReClSHZNqGVn9xF3NFOwfL2xKZXszs9wdHTuBX+ixECod2BAqFZMxvZUZVoWLAoLLMaC5XN7z10Ms7uXyDofveppHSrF98dUQGPp+JN2rZRFgNwIoHmRlH5rWxOoZEK/LloyxBrsNUCp4jLDMqWiUtmIxH4qAPNeusewFu2VBDBIuzntiR5JXj2NdBHuUBDcY7fnA53ck1UHspg4g0QtvzdKcEOCznV7T7YX4RuWEp2plPO2Nv/hCcBfrlyQIAq1nCw7tay+N0fyI2Ca2UjC1etOIYBrZ4xuuGNWHLMBvioBaN4Z17ao+RpHUIeWDX8IlMvea2Yw85w8uRj1+Z6zRtJgA1tx+sjR7lKuE54zGqIxVEqPcz4znZ4Yxe9gx+WQz9pJUxE5LPvPq4VUXsziGelYuiuKQsJL9UjEl/3oeeV316iKNWBZTpmimwjrDbM6W+5Fi1K2BRI4VAJZFkp6vL9Q2L5z4bqsekA5Y6F9A9jD9kfbGm18605bhU7cX6f3cSVWUhDJo5Kks8gwBvHSpS1aj0SK/NiRokPzU0zR6sZuscLd7ja39y7p+gO8x6f3duFV6NiQjCdc7hftugrVqPO+WgDeGIDez5WjaYI21g4Iwl8vZkYebmsXx66DJn21kFPuSCjLNTduQvBFZ2rbl68lfoZHprxfrpSdBbMtwzCySd9IcPnoNWTGsZ8JxI/m+R0oNGSjDfm2u3Z9Y2YsBsJekhsF+uljZg03RLm7I3fmISfdH+QeKTdNVQVeQYtjaNXGs2aOc584S12vu1FCu61xJCJuwUZ8/2/hmmZ4jdxm2p8Rb55P0xHHnLnpfJ6nh7wdiaCjQcoe7asQnxMbQZ3z3jVUi0ap74LpsjW97UZlf1c5dEMh2yMtfMbRTzxndzZDegrEsoIqc0oPw8nfvZmwDrLdt7UVAw+vre/w21yuO5RrC0UGPz050BwpMcHfClRFduxr87LE+dIjU2cemJQ3NEfX2GENK02C7IqSQfjeuQtU9lN1jIyP8GIj9lZeucswdDuem7usEm+KnBhvP8QsDapInFhEGEV3su/94uMnDZmlwteAbrAPLTQmVVE+OvViCLwxtS9a/Lly12ZJKzXEBlpbsnQAmDAAZc8+m50HQPMqE+ln05Sk3nYGFN3ZRmu3brBw0X8Eer7m3f36Uyp8L6gI5/CVNDLYz889YDcsZiAvm3AkjvXznAIh58Ro57zjwUjrzhHesLgcRfKIhzULfU7q82l2qBVPXCh2T9gOiiidfg2UGOyT9V/+/OqHFhaMnnGFNgQXmrq2Hu0jRJhKI7aVaGTRTtenQ7SwIR2Zb8FFbCzxTA9lyGBN2f0E5S393vehgn/zCxl8Neg+I/E76bUp76S1vGh+rxZWMP3g5ZKHQ89zWs/1q9/IUA+k55jtMZwesGim6vHbns0rO+Mo2ZdK9S4bZnNuoPm82xsRE5kpk6GGdRDt1X6kwQHQFt97yEJFnSi2PpRhttMwwpOcLD+m1FSQBQleYZFCT8r7h2oYSJNwejGhKkigoXSY/mjVVFJmJW9/CTsktG43IWWIrwL0w4upSZCw9C8Sn4MAulBIoQcfS/fPLa/jOwsUyi3At7Yg3+U49FgHbhek+7UOssQGr/OZ8hC/mP5hPsY0fBPrB0o7BTxc4B7RP7JguX6o4dJvgHJOovyNbaNXi/ppYdsjrkYf0z/UCeSWiYR2hu+3fuPN518iF78fMAXg+oqR8hCGtCRnxmm9xmXJ+gKimmuUu8B2u32U0FAxazekDZKZ+9zgm8EW9ylWS57GKoOZIEDl1zXGM/oRI6p+cdb4kAsGBQWDjqRe4Snv25lk1Dr9nzzCFeT9E1klpdnGp99/AS9M/Zktn8DItADa+TOIoVdP5+q9HK+R3f3f6uBMr9OKtpuu7WwM/wIVatnwHjHnPkrRjwzL3DyVRkRPSttiQPYelJpEOrwlQc0en7y/Fj0+SmHhTCHBOOrEAxDoTuWNO4CujpZ36Dve6ZWlG0ExtjVcCLmnl7CkGG5qk4rdO0yY6BuychwTA27/FOkWobsbo63s7wiHQwi4JjiBfKd5TlYAcNOhG5gWdbNx8TSW9m0pXlyJZlMZydnQiOMJDhJ0gqNSyB3RK8S6AjXBOvI9ip8iyo7jCJNC2UARX5n2Awsck3dlUSPvw5orsGFJpx/zvAlNHBwdEoaHtxcmExtEeCDlMAJtXGxkGByjnecrxL1oeTXjG2OHUljC64ntPxHks8y1H0VboovAwi4StduFRgh+XP6kv/lCadETFXWKGnM90bq7sKJbC9xs21SEBW80prYadCrCTkwIYxjD49h+T5KoBaDmH0UzfvjVc5VjFYPnYKGe1AiItn9F8YktAYW8JZoTTXjnFfflz4g6YvRriF2laxeLHTsmkUL51L9IWO3W68qWrb/lOo6Rc/+XvZ4JtC50n/j1Z0D8VzAEwhdaCsuo/AMayLV50DJpieZ0Yn/F2e/wdieTacC6dhUg59I8ZHa8Ip48p4ar8RAOZ2JmiUqO0rFr4W3fTJqJZTwNHtnNSF8Z9Ng5Ybyikh0Fp4ptkYOhDrnER7A8O5+9vCW+Couv/lG+vTbDIqvXAKFuD8igUClluUU8wUTzLer2XNuEMF+n6oXLoCEHkjK8iTI2gcF/oBMavnu7cuj8ZHbLuLaCSfgIidn6RnSYa20twY9FILjRF4Fl4A/bZmSUCgqjP5EhUr7XubR41Wv1cCrAu6MPvrMApAZzAKS3AJKmK0vLw+tHYmCwz3oD6N39EeJFO/tx2aUu9ccdB9m8a5pkfGj47tVHrFldQeLltFBQV0ldKKY+Oa40soXs1npawr3ZHeC10zWZJD8E6AAJtKLWvIpVPDteFiBUrJhNkt0RchE6XK75rrc95STTgeAg1efYcen7pb7V92ShxbwtWKJfuY1hBQOENVMMLb/PUoYP25YkICejMTsNyEmIvtFn++43nmyqtXfMn6SIkNBTZY4XHW+8F54RgPaz7ochb20GWYV+0oZWhmdBRYCzLi9zbJDmTKJMDs6yRw7gyBLY1cdIoV5IcPJ3kGJ4FMDtQkWRmx3XdbM6EAeGxyrVWA0OGghoKM89Va/+qsYZstu5hFfX2ZFi7NUDtzI+tEiMDPi3DcX7u7AmT69UFZ4Z2PCJeNi8A7nNENgiP7gVfKcYf5md6XqRteTzt54F4GrWqu6fU7c7an1jTZy1Usj9tZpwiV3b2/8FXibW3y2/FM5lOoA3Lc9sb4IuMu0oVb2fS5goXzVbfWWDmAiPPiScExh4XLLJhstViEBcsAP0S/pNmyJnstsc8Em0lz0LWFa7CleWelLV38uLVKqHNvTaxsNwj8PhckebxROx5FjTbOY8FJ3YgzJxO/zSodlqYP9JGtbroz5UU9QvFcCYFeBLt4GaeV+hhXR4XSZ8pMpqmy/DoQCj7YIWILxVRYjr3c2AbLeQhzSr1m0ktjCGWTWVmT39Gx43jlEpKQScVoFwByh1rwUVqDHUplpCxyhiwevPVZUc1YFHVRcxZoxm1Ztp6cYKJRTcCY8GZme+SpYtfJDyZh+9jYGSeylWm+June16qFtnwCRcr65UyreYxImuN5rUeB0lkDByD8GDjleUV/CDFQJz5usFm0h4gkTYIzkZd27qJcHMA5aBZg2n20HJgOuSEHPNNNuVYmPPh2f7XOXwWka64HeiaN7/pmMMoJNB0PzZ+pwCjPCoOnWDoZ87R0rlrqzibcZPSpF+KNohj0OaNDHTZRmMBOqv+qG6pLWAP7XrvXuUtRPCDYz4/cw42dy97oRwpb3hcC7WQo8ZsovBG4Adib7Zn5Z4aBvRnHUS6RY17xOsDde8ekpyVkjob/7jrXpPCeE6vvAc6NsWcgd7b+cEecRPGr5YgBM9XXBr2UtSlqeZBp6oEUA3N3CBrNS43qfVlH/GK6Vg9ti+EYC+Jj86qn4Tr5Rdc4M0yYaouHJAsyO80gnmnSNk8JwrXtz8OwrAD4m87vZUquukUc7oMzwe9lDTcCZtxJNLikEOTfAwIx7Siu9ge9zSafBkUYMuyL9dZ4bvVsyCGgbZw3tzqbIn7BCZr4NDFlpYl24gppFFyN95HMJEzGu+mw+ostPws574eJ95lhGTUC6TfzMeH1oRY5QascdpG9bfKOsg/ww9MmBZe3570RMP0XhdplNUAc6fffcgLxrsKdrl3Xn2d9PefZkQELj76ISy7F0w0if1IRMvLOReyeMHY/zy9rZLIYHEQK4Ul3BuO1QpbjAI+EiM/HL0AHrJteYYXsnDZVYjXtAAUoZ70mybeagVpSoZng8mEyTiNwYGOwyQ4L5Lh8wjJp7sqNIPkiWQMys/PMjzpn8pNsWnhrtCsMO2nJSfJrI57vPlmA2bWA3geDukiaL2nDzaDJpzw9oGLXkrynkjAlqfGsPj5FyJ5ulGZjCaKcC3mzWELUetrdH4ST4QYVFVEB7PYvP5eGUEAlp4vnHXjPJWcQsGDrlowJtwtmRvxj5t+O+yBdeLhNbcT7Lgi5Iezwh89MYjiJt2yE9HIHPGpVRA4twEKRImvwOdUZlGwyv16dWCRdoKVZ1GnZJ6omtJlMQq/uviVCBkMhfSVXt7+ddbvmti8BN7GboKQ4ujqrmKYPQJA8tAuYOGODJJMVZH95edvUQ/1fxjj4Rt9+jWJWcmT97ru34I5nN+Gw79oXRbi/z7risj3F+BPU+8/zJwZNJFw7RUh+Aoo8b1l4JTNf2TFcDusLSk1jEgmjXyzHWFPhvx2KbHx8GjBaC8zalzx8AGA4KVAGigzfUk9wmurGP0JB8JFEm3LOPOrcfnVcFonE7wenkiz6dG8Hpd0J+Lj3Y21ByVtia9CQWhzAlIRhbHxl5/LG1HpFWyPDlempmMvizitQK6jdcrqJtYBt842mjAuTC/aLHjpAm1VGQqRuvQMQP/1oiGL3rroSGrTxcJk3/497UrXWwKZCpVmCS7Sit4gIqkRHSNS8N6LuHADh9zMybQoMpwaSs++mMeRRu69CGFWU5tDAPFLSeXHAy8IBclcvDarLAzN7PmX05cfeG1Ii0K/6HLuYd6EIK1A/3OW1fd3BvNMZVlvzfhUH6LnLUPyBqSLRnS4D2WvEuF3iAMN2hlV4UvM/UYt/TGJIufXJrBTvxJQ3BgB62Qs58tSuYIf9bpf51xfB6sior1rYxtP8aaKKBuryNxsiqgdTTGkprKx0Veld0B6hMMp5ojcyUreimkjotB+xA/eIghH9yTV01s3zdpTzPV1X4BiXBdolaIel8dxTvf3fUL0tTttJPBGeFA0oEIRS1KQLPTdQ41bnvDZH0LrbuG2zi/mfUJx4z/2wnnx0IQVGsNwSficq584wtuk1s4Qg2HGrxcqykVB1inzyYaGqNMey8+ZFFeL+BeOYcY6rhL8mHK6dVvF3rVPKtTTbrCXhT7WgqTBXrozeWUZQbboL0yOEzEEd7YLdbskOqPA5AW7BpRinXiYjm71fmPiosAG253c2P88GeWd+7y1Mx1l8MlaSxvH4e5sMeCmlJ+iNVef6ZNMmg4zfu4kKZYug9bOh5A9k/uweggNxsJfb4meRdgL/QNMwD/PC7HyEQD00u4GHRw1mPHdZEtGvffYSueXGAEsM2/ShPlDEWQ6lnq+pr3pHtgSnC6LIvzVWARWqltZZuZw7BKpLS2ZXQeppL9TWvOUV8bLqKP4vUgCBdnhKBodCl1tOK0MRTeQDShKxQYOcf6oLFakOCYRBMapW8yDr1cC7gRNDMraJU2edBbiFxQTNjn1Wk6OcfLO5cDBxrktvht4cmhZ60kWWmfpJLWW5QY9SsdHbD4xoDDAQi8+mpEfMuix9XPdv1QWXmBsghEMoGHCJJORDhp3fxVYIySzXfZX82y5viRF/P8WZYYt6OaZEdpGHisADkkDSeXCb6YhQb054GxVVkCc27aHKRjrR+nMewhDNwQQZPl2NbSklbBkDsJwQoGKM+q+E49A7e3xIYZZIqqoJ+MM8ApnvB3bhUQPDb8reuClyIiEhf0OnBbT7iLTVOqrhlh2x7PvXpTRCvfiLVqv8R0oFCn3wkDBRdlHw7Qk+dzFDTNZ95JODU9aamSShrzJ8IvJZcgQ74Ga/YXBnCaAOb34pqN5/tM+I8XBDEq2t2N//SBOiZkh13WotSrLqP9qrQ4MCpg6WmoZkf7qp8ETGwa4nW0MLKMr8S5GKJe+YKYWsG111YptCeRgvqx5s7ipcNh89/FOS8ZIzSWwjvtfNz+9hk3lnnnuARLTiOnZwo6898Cf/tUSMLwUYwR8P68yAaJUxVjxyYsVIF53wPY/Nh/jt7kvgVUhYUw7o1fvjxe6GjS46bH0flc+YMs8TdI3C2AHTpSJL2bUqqWPXecH9UI+YomGJf4uctlxGOneUXvHXVmgHhM6bx4AtEnNsKchnE0xIGa2ZUgM0l1/IAv1yC2eIi9TFBXquZI5OREzNkv7krWOUB8kyDVyXMkRcDTssWovJLxPnnCVX5cE2MalH5vlPfA+IAtp/FcyCFJllSiEqUVPTmTwLFoOiE7HmsiLnp+a4Ll/1gBfgslr6QMwTW8fKPEe+cWczNn+NIhetTtp9oMRcyMHfZlYf7Hq3+4zmIB4qiqAysy/qlI5PL56jT/XoSHEfxqinmBgm/1BmPyt19bEtZnR5X1Ap/Kkb8Suo/CljXw+dqlYgUuiOX04124YNVng4sVNWeOG1lbxvAufuQ5F5qngL2i+JhI2dL/RgKNW/fSADR4bxzT5mm4ZoeTduJ5VhTeY5Y0HQlHkE3wvEwySc8s02UtKP73fLxwKiZKz4z/lo27s6qlCC5tzIGAk7ZNj5aOwN9mHi3lZ8m0I/Qdx3Ji/EFrVwSbtAob7Y6TQFuhw7B5+Oxih6EFQmFJUQ2nnELbbNejfqqbCYEJD/WuWzDQPdJ+lh8OuqstiGddoTnuIoYHWtAYNQJRIK/ffsKGIZZjdunDf5hgqtdXtWn0qn3HXPPZ8niIsh9A3TCD68IQ9ey/soRC7WVCLeKY3piu5mQ196UhiD0IPuN7+jGoVUB4IHgIpmljWaBSO0ShFeh6jd6xzfoa3nFniT45MzQhfIrrEyd/teA2ZdSuVQn/YO8M5p+j8mpm9NZ51V9Gx+os5w98gk086p4dx8MBdaEC+6i+JEwEccIwasx9sMbTwxJ5QLbFHfG6j+DPSykEi+M25thR+b6znnFT4KogN13XdMpYM7LRpmyPe2sovbigugCD6VGbiIULSaeMNO0JzKU14qd+JsOZ0GpmsOmWBcR0wflPdK1vAJwlHSMzHAUJjbGhwuf+VPuGQwCBXpnZyJoOXWNM7fmyD5r7WyIDGtrJfXeB2Oaj4/I3CMtv883b5gNrgMIUdXBISCY1N4RRkUViXvKFc5/2eIZG7bmxcesYZzl3zA+1XIyi/l9BB6TQkDxoWa3rJ+KT0PqCeVp+11XwJH7Hl/Wybw5fbRyZBawzj4Yz+SuKq0lJ7dxLEu4LchJF6HkwmqX+SHUQ3tazOUK/okVcLG9vF3WlcHC65rv/ZEuEYVcpUkxnKNH2BrEci91tHd2QvCQL8sgu0TLzdTG4JGOmUsiDTfBCDepnxHt9wDGRt0PVgr2XtzEE4NEAbzNoLAbGmREjFpATvXgQ8QdgnJtqVzI13+Y4Ex1wp4fmhpvjhM1vq8IvZ6pjcMdIBSMf3mdSmBH+VdymwZPB1JdAVdDCsMYIrFnnyKyOXTF5oLvDY5jyMDIZYyLTUz30NJecUim+br+LWC8J6wu3ZmdVQKWQi/c8wR5fAsd/IoZKlEBH4h15Sm6QPVba+2zPf4bKwoPWXk/bX5TB3OSS0JpDUqdwOjOvIGcToAT699gWbAaXOxPBjvHlPHD9Lp/7k2D6w3tWfJBUZYvYNcjf/nqDDM2wqwBV8bILomeVQW3g6pPoT6adz2GwOC5Es8nJraX4trAoqX3lVK8UUv3/AOOhO+1nopVG73lR/dxRY72jJhHKpur2F6+he1/asyvu0QKy70Ez9XcAp0B81qwhJnFf8CTob2ldI6vZohO+Lc8MhFw21byKzic3Js/q8V5RgV1fxjCUll/6985PPyv85oHjhe8pCCdPodvLHwjoSfM4vfLowIcxBmDpG+jANAwbvfynfAJlVzMu81CYzu671mUHoMUzvG5H+sjFsng5jUXpSa3S/lb2wNnrUROb9bypEO8OdpeE+SrdvIx8tGVDemz+fICrWjBltVGObsGI3w2G5gRgYXktHXnaBnL3AF6ixUmYNzJAaD2+tXCZEjHalGVJukx4/V+imXqO2iTzFOU7VvPpHHUM/tc+gAtyte9joojruUheAZdyDs/WjzuNbP1uWmku+dFfu253B96OD+2spB8aZ/VdJRNBy3Z7omOQG6j6TRxH0PZgCQAIvxF9sQTKy9mshLm6Mcv4Tsq4JfgNRFiCfgdPXVQVpEUTTMWy+Z8Nif371Cci9xHBh5M9+GOnqHNhrBUpEtl8tVwbYYqyni4Lrly44qXPnaHdVqkHLP5GMAuy0R/MCa/Nwb9Li4r9rp7m47UrPjsJWYJX2xRnyq7fk1EMx1X/2ez44APMrS9HI1XIsMbQRtQHconRdyD2u53jT8jxK76TwAqa52pqrwcIQQSEZxAP9vbFVtESU6WMPsBPCrRuF/vxHE8wPPv+c5SynxmQzwqROBjytHxy70J1WzajO/13J91ZcBDKomi56D0MANyHNNiG+XOB7FtkBS01ZT5smHWYfLHjd4XXO/oLKl5roxZQeAoZ3Vzyy2Bi5B130Bd2h0nVxIG0V2zLqiwdHP3Y8jhmhD4DJ08ya1bkapw0oqL7oBYOYL38FgkGJczwlVdVooWQ0o/74zp0Z8fEyfhOVGzz4r1Xa2qCQApOY6VO32PBEk76wzgqeFB8llAJVVuF2HMzWRlk6K9LwlaaYVTE1LV9oYdnxa1DSJ+MN/bC5g+R0JjUSUfQXHDH0ETJBswPf/ZHrb204lTY9lQYVPGu0JB5S7kNavAi88I/ZKwHqD7/lX0FC1l1iz+qZixJohvAzFzTtwcBfS+py7R4Jf4ZPXbUjf15snwv3dm2ZaLng4TbgGhEZmrQrlr6G11/s5rYKqy06ofP0r/kR6X+mVhfOt62UgtmgKXLtMHAZNtB/lK3MhyxwNQFrfnOloBmSbqDWNUBsgJ31KvQ8rI5e7wcdGcwD0pJvQ1FLNUuhotoJNbANZnclMcQ1X2HMhjppPr9Mv0gpqx48Ol2LKQsdGIF28jO+cv42PRSCY8lahDA7nZQXQCI2gEk22xz1uF0WSBl9roxSPTAdXpMnyVzPW6FMx+yWi2RI0LSvt1h0jDMELRHubt/QiApdXk0/kf4ugzpoz6eXtvPBQcCIf3SqkU2YZS4zySglRUaDPMt9HF3kfZyIEyNWRWjzg+aFyYD9N3QOpRQZ/Ef1e84OE+0djZPzDAgyviu4rEcP/ATjTX3prxuxEm2zdCndlUxzFU4MjMFWcF1eH22T1X1DQ0kOeWy2AUrsq2qjm/3HLA7PdmKqaIwHEUBjwhPrlO5GLGQfUZeFxQQD1ABpPd9PfP2im6QlskheXTMS2GVtBONCu65nd0tvPnt70/9KL+masZwWItiMWHRKrfBUNN9V9e8xmpcw8foeJi+/op3RFSp4coQ0LMonrGSjiTMnRKKXGoSjZdSLXw05BMa9aa6eNkUlLhC4yEsEZngg4pRvkMed81X9b7VSww99uSV1YgrYxm4ikQmvxWhTU4X77YM7ZgX4IXtYu7qMNcIl5BR2EZzCT38VAV5Wb3LCJ8JoUOzsUW/UkYxbXsrBHuo+KRQ1CTxELr/qdl48mnq/fKOowHcByQH1tJunP+SjggrRx/0pFfU5NYkANphlDFHKCukf8UQgiok9zIrp8C6Hf7eAyFinLFlUP86reze6DJqCIqng8YcB8v1zOYRMvQrWzVnE0lHpuA42AgahZ5TvHhin/SsR86cLHCnYszFDLkBcLXitIvUhXRNKYoFDx7PzSsMd0VVtErOo/sztfR5Y1NKXPWDrIzD28BBA6biKbvvd/T3AGx6s2apWUo0ry+K58+jjWS8zrP1cgs669gSVcXqJcPKB7Z5FPTDmBbgsxAFAytVaA4rvmu2CR/Z+De1rEBuGAHF1tUiX2LnUGdIYjHAKc6ltaM/YgrbEzj9qvQXSQWZwER8C1raz6nhvAOoS+sAh4MvXHcx3KJYaDdmVvxDLEmvojWhZseQqvC3TQFB2+/XtENGpDomR7AVYBj6BpZ28iRnVPUasDqgzBOtMBLjZ4IAmOSerxY3d6PsASK4jm4SnPN8moYO/yYSyhd7317AyiqiYcHisReqteSSs2LbRvnu0vbeP0W0xZcAJEEMg0XMaztpgr5oOSJHeVilOYj1FiY3Kfh1OjvFXbtEGXk8A+Tu2QE2/XNeRr7XE8/SiEx93X95j+8czIm6eiOIBAuidA58gwPVin2Ed+Af2xLboYBB8TAmn5xlij9EVzvC2DdoWMlvxFajNyeS3Hc3ofFBvCqK3t8IakUtdQUWsOj83DtUdKnZXxcOWLOYw8JEbqolqtKbaGfZESHwIY/tE8hpJpwHtBpO0h9GZjccExA1nbeCQkieLRCJ63YOMHSJPvAj/iJEOoM50ZXBlw18KyWFhHf2gOdi9+p+dQJjz4953yjyDRk9nfTokUdKR22ObBdMioDwP8HPp64HqSNcJz9bGL+cLdRFKJAiaRRglibryA19WHKGA6eLDc5oaAFcKELmET1e1efrMSvUP2XEFBasP0Fw84AEc8P7BuOteI5VMXzwv+/r3pe8IG/fSmhNA1UK8/46nflpJM3yLtwxw6PT1qzw03IPEKZkN/Qr+EGaO4kN57R65COFZaSAZJ4n/VfgrzCd1Sl5rlPlgC+PumdpMDJpgSBaZSjANF2ie/Fmtm/rl+OKjtsB6arOeD2qCF1PG+5IvY778JZ6pwoM6s44BgGYET9QfuPtqOPYygX0Ij3ZQOde9g+f/Y/p0c/JOYBk0fo/yAnCBvwi6qGTWyFhVYw2+/BPQtMAr56YIsQStXLqQu9xKGaUmns7RlnH/ScM9Zu5NteRUMPkm4u7Ix/9a9vPn97/kMKg4ZbE1Ro1NRL17YNVZ5uRmxUhMDzsCyzu6RsIvbZfMQ3m9/WkhxYESrAb6k5iv1GmfUvWnvtJqqZxbBhyPqA6GeiKpADhhsnOIJagAgN3vH46sQNaK3seiMGH8BAQX/fTTHMycBsqTXXaGVZePXZ3Lv+jeIP4bybjPuHD0sEq6YURfHV5bNtaJLdUj3JVJ75fMrg49ICiGQfoLckxK9n+OpRNdIK1zKHzlVMiW0LWnyjGRAbTJOUp4bUjILBBHtVJWxTvZbBBKSGzZijT37f3Fcp+InYr+jWVR/y3G8IwLFfGiqkbqcoKsM+UtMC/mFjPhB/SaYIHBfueJ50CQYXbgJpkGLaxCOTIBaqum5VJuX1pCOyuzA/8SMuDk0JaYJeNkV71gRsSly144AzGCWR/9uKzhR6Rw6yw0jA7ouEJyyN0J2c6BU31leWRfbrN0PnwYG4WFIPVHrPSbo2Tg9b0fiqFTJ1m///BbT10ZwE8tZ5JAho19DMcHmcWOI2pAmW7PhPRWBPyPqjRZz1Y82emZUpUbec6TsvNsTT560WBVq+K6B1k+HiqBI3un5K3o22a6SYrSgS0jRwsVhXA6+ceFup4lYnHFaXc23LRLscq4vBk9O5FpDgPNEILSV+Ti2mcy42Q4UhbulhLMpkrU5g9WvH5TEptQx7rRWzElgiaKKZQGRzudJk5C2CtqPmxUM9L+PS+lwwZLpiV2mwVZU4aNYpUWz7CZ/MdhpeuKFcKq6AuYEVrQZlfMal8lEQcmtWRFkbhW+iYwvv7Nni6MZQyni9WE7BCqc647EW6pZPzdOUckaasqL182j2RH7DL5Wcgls4cfXF+Ar4PgGRqyf/RoMOOE0tEhdJ+8U9GeSKXF6FzWke21Hwu1W9/N3PNMtkUYbJW1eabl0dx10ZU3BRwSmV/pVEn+KgKJ9ojxRMLzTXbFzH/c8fy/MhKNGrKR8+uOqVclLrAmYlfzXql6FlUcdtanMFS7lWpYZOv1fSsRF+W/o5E5pLeL+aUG6+oMVO8ufajxF38LGM87V1sUC1l/OJeT2tENMLkOjwO1+Z3q81HBDYomzvPt5eAbEvB9P5y5XZA7a393KqXV+2mZ5GCAR0BxzfOMeKKnOg81pJe5w2pYl3cDiB2WLgzOZjC+dK7/7WThUYC/1ryvsOb74BqYg7fjse/ihs9+B6ZRVMQLQTGctMd6wMulBmCEBYhITDfu3TKtiT0+D4jVHmOiRvych/yzSaFnZu/w5DJsSqVNm0cXY/UUR6RtfhlY50f74gWo88CSo66iQYIOKZYjkaAAUrZ6lLMqzcA2dXF8JhKH9xowg43XU4Ju3g/4dcOQDkJyO+Ybi+EvF03XSfnuOm/QgWkXvByqR3aYzdbr8X5k0AY3QdefqVfjR2H/N8j2eBSIIL00ivBrOIKV+bOgya9EL3VanS6p4iWT0mV4eya16zSlcSx0QclqWeirYCw5xEK68FGxW2+Gwuvw1/rDRRYz8JY8xIPkDtV6uO2r9OjIEullQkVZ4Y/I2oh9EMznD9HwGYW69aM7HBdVxh+RRxjiRSKcFDxEWOwrp9t+TT3lNiSc1+BAveHAt0AGVGPZcDY0XLWVhB2+L9DOBvugNZIq6GPYKj36WmfqApiasc/RTGcOqGQR+j2M4XBaoWa/MKaLYPvwl8ERxrWOG63TnTamCW9ZL77bIzqzHBX5JEAROrDfbYU+Eodl0yBzznGB9VkRgbMIM7I66usgZJpSy7A6Rdcfa7NHBnYPsSE0UgQ4nfT94SAAgzCZWVUzLPss8qOH8vt1m4yub+nYBF0sECvlsbWWyK5SnQFyq6ZDf8QuIlmiYRaoUBloY+xcUYDGOXYMqNi5+4FsOtk9XLD40Z+1xxbJy+/IZt+0iZUZ20k6hOWojQh8IS3402HqWd3NJRbsuAQYfUpGTEp+MuuhRAl4dbOUO8TSwL0I7NJSQ9kBHPXKo+5x+Sj8IUEOc8WuGmsS1VsKD+dXYu/UbiSm8FsAbH7k/9lCF54C+0t111seIxRZ/LN0R7TbJKIPnzQBtnEUslfwouZJA2I6NwnGoaAaplZkU/DffFhOkJjdnF95GEC/vYGfDfxHQvG0DWUQuRMJv+3yw4HWhlFA+t8M61ira26w1uJFdDC9o0nwA+vOUZZEugvxPQ3iS3PxbyRGLAM3WdwpayRgu+lrk7YatDemuV/sy9z9jIi+aLjeX9Mt0HlN+RwmCLyH28oDO6i+pyr2ze/LILZAHNRCzurRkl83NLNSrT/x2d/T+uoCh/+5btZanY+t/94yT01fn1oKfyI3GEpWDvzpPv1/ZIYYmyMJ32MTUlcN6mnc3xuoznQlNhHNari6JWZiF38OZRyAjMuekRKQ3C3600sgdvpzF2fzwaLFCwmq0T9yr+HRWOTAqTrS4VBTTgk0a41ckkcdfSvB0UlvnFHpEz0sS3oKUzXWHb+TLpMVyIkWfohLhsoLZi60Eg56CtVp93WSkebKEQOegbLczwYBLQ7bGAG+Ts/9QYcmleqVpJRtkUe+7kwG2sGURRMQ75NdK+C8RWVJ/mjtRv+apOFMPQToG+QyBXPA++lNQjRGSnjAG0TlgqC2g8YT66jKdSuTkMkLI1icoJRjJm/xxo1JBWhgwbIUzgu7zHRzTivV5LsTv96Zgdu/JVxQNH/Ep8JvZahAMQV869wUeWw8pDcj8i1r7GXJlJmNQWusszGDVgjDfoKZ8coEjOJLqNddnr7h4OS88SSOeBvR6Onp1q0H94NsOE64InX+qg0LjxvhfxRV9e2qpgXGswhqNQV4z92ByR6S72op2hM1e8owNoCQ88x516tAUUHUZC7YP6TeuuypylFYyAUoLyJSKpYgLBPFxUDZAiD6vvhN2c03OkJuZTx50bbCtOwC7OMr9R6j4AeIUZu70Ti55tC0qPotWfOr/4aXl2W7Qp4uTUScd2UBMWiDtPthJ5MzLYZWzNHP/QHq4rAJvuol0Anq05fXIBAKU9pzGJj9n+pLoHRg3jslRen1eifAO45HplPb3p9+2alzUr4hjh9ONQb/QOhqcc5ahVQHUMj2qCpCEO3o9CK7kZZ52crLP8BNHEzBjLs9T5Hfss4mwBfJxRHJrBbtD7wR4dopEIwnDF7vryqWguLmwCnTtuOI/6Yj5gY3zsbx4G1V2rCi95rJa1tI3+Q2sJexAKyK9Or9UTau1BhROg+sBzEkYD09ski4LEvL6RvW73E79+ctu22QatDHA983ULV4xLfVP/ETHXDAT1/wyfPRryHsb2TGKNOnLWRMekPs+mCIZK09KCvS44bj3KwB/+53zyXMYNlOyKIVTe0dGjd4wRyJkV9iT3hxA8EDmcgy+jztYSegxnn8TfQo5PoLcvJCooTkYVGNEgna1sgAXV3BUAEmp0evIOioFH+P8mp1tUnFiuOodHJ4cCYPsz/Y73kULuHDwfGbKv1bpa6B5ABdmWVB9bX4ZuxN9vEf/+zUY+CunEMQdEIN+6xrns2ySXBQLUEfWpXdrLCxs09kWNMx1oYyBt7EiINxt9lhDvHvv8Tmez4azMLC4CHTEoIXHbkTKs1u3sGVrQZis2/gNs6vbuUIVwZPilkwJkqUN1ymZB8cxYsaA/3+Uij9oxqHvcrejh5idit2WlSbDPKqlqCfYM52msM4AwtiEenqqcSpRKNh52OnwXelrQB4iA6+8OUJPqRI2nW71mzm+Db79sTclbNxbr6LA8K2w71zPnnqyOaNFGPzTTf7J0/8owMm55SC+cNFcrs14wqjWffMkehvutci6im5TUTVjg77MEnDBm7qrYMA4eBR63NA6k19wlz3IoxfSgeE0z+befpldeCsXcqmRqtyTnT5KqvP+X8NxlXeWvfkdVpKKD900FCgGZ2epvdnQWhypBb235TgmEnomUiXCNctF8upgHbZst6P1BDwPWGZb9OZqGSV5u4V4p1WFLiLM86IQGQMvh9KI3SGoadI6nREaAd7ZtOKqOZinHketRPK+IFCcDoj7n4bhc8KYNE6JRktetVkmBfgltH5agpMYKhQ0e7Vunb0XWltzjG8KB/34qLYiZA9H5r2w3yNAqI6ARCrfWzze+Zyw9YnbWMOXLwyngrGTdUxe3MxUKKeK/GqlQ/HNqMdPm7kaARESwv2t6/puUXrfQ7UEgG1XbyQP1qWr0a6cF4SfXK5ozqKueCQ525itHjOpQV/Vo8arrQ0pvpiR8kTWwn2+aRhv9pIAcqmNObzIYSnV7kNA2UJykeKpYC9rq6ixdYHsweQVcCIzI6/fxFEfKfAiBC5CH5ygLROdxSsFTrZoGhhZPTYNNxTW4Z3T1Q6wMq5RxFjMgCk9/ph59Tl1Uj99KSJElNYA/wqbQ5b88A+ShzKahrdfDXZizoelNGne/k7zaY8iUlNkuGzhL1YNczSr6kHGu4SssFwC2G+/WZ7Qiyi5BCt6bD9t4986cCx2N86pidr5AndjqPadEtxPu6E4I2gEmpqAD2jQhaHprQOOnh4ETgzyVxnf/C3KVT1fPzmOkUeTUCMrZBHUAbe6YgJIp9RgdFZsvPWkTtfkptNbupxYC+jR35GE7mu9r6fgdQhGk4oCFLv+fl7SjPJ1oU/2k0wUTFlABhgCfBVy43Miz0NOnQWUbd74BjJJBgZvQ9Y3BP3qEHQjeDMAxqtMLQmLH59ZOYMl01uyVfbPZV6ONTYKDOnqcyxTif3vID3+5SfjlgkF77uLOmuFEQpGdtMUAIUlh9lyqWvPOD9MjqoyGTG6ReXGYClzR9g8n++qa+ZWjh+e0ucWBOqUmelic4zgX4Ct1y9Cfw0oLqfeTccOHFNTZG1Ij9vgzRYINFp2Pzf5CYZIMqweU70AXDv5GtwXQHdc36LQ9xnA8Pa3dKT1MlyTMY0Yx4ayT5i2iLPPoCUVxqZVlE0b87hd64Y96wjKlL1AelSdIpMsF2dems+Kn5EtuhnYPPU7I6Cfe1qnqxCfYSO/0AB6ERG4PzOW4TUXszIf0tqqZbCHVkRKJZVSSIVIPjr7rejizsZj4lukeNXocaJ755kBVCF25E4RAKdttf02dcHLELwqr94jZiwEmbDwisy4P426lpkSbCPEh+wjCWvpk5jOxDk+/nBIkCbhB6CoYbDWY4Vatwq+pfdP2am+5otw7PEbnjzkXP9ePvtylAHBn31hG6YlbTagKBsbjezo7xAUOPrPsLPSTWWi16YH+pGZsgf0uPjSHjj1o5/79Nk+gHB5frG6NsXaoMG6vwEOtD+yK7Jr8LdCv2eRm45ECilc9mQWzsZXnqgY0oDwa8U4Ite2c8FBoxzSSc5lswTPBMMCQKzSiYn1YIuPYAbEXUs7cl8E1DFl0nXdNXnnVegX6g428fbSFDWMxBu4qiArK/f+3ywrEXHA3hPaEvW+im3YuEM+Cn66vRNqH0skYPIr+hsXu3dykCaHW7M0OaY1Q+Xr+fpNu7Br108W0ICEV72Sygj31/3l37oIBwA+gJ27WtjpNs+ERWweK9N+UoUrI2xH6hFxOh0bfMkVOXE0mbQOK37HTQ/xPyDOoOTvQAJ6j5fqiEnvCvAXCHLpxtQDrufLkwk0/8KroQ350YMUX/0A/UhQmLSZ5PDXwnzUKr+dsTDePxY526gte1c3IJoE3sZtP09VWLGSYB1qGDjIQ2zL7zIvRCYjJ+u1yob5VG1WR/QBXUGKon6cRfCMCq1Xyu0uNa+7IdAtPhctuxvOyC575xp/UYOiWB9XGpGsOktzKakO8b9hBsR6sTuaKZIhKg1wHIVmO0Z48vOF6ckWRS3jU4DQdHvcp9qO9g24xRVN8GfeiXHyjG4vBBJpmssaYvSTn/vdWXCCdMaoeBUFH7Uy/OlJPSb8SGS9egqm2tG4VSQEh4vhXKnehlWOYbQ4B1s3/Hu+/Bm15eTPbo74HjRqqVzMBUfhwJ+7DyODJ7/Ww+2Ks0PDXs9TU5lFTXLiniImx8oNtLALFKAaAH1srapACMr4jFohUsG68+XYgbN0cY3LVVV8T1ed0C92yrbfJqRYsj/li2DoIaiQk+VX/W3zt7trQo/bY33Za5zy4cuDJSKaC11yuAb/8hUcKPF7yKjOeRStbn0p28xgvH6omTpbwJ429Yj9Sv0AKkXKXB5azLU/uJ3etFFeauz6PHJjuB9hewg2KhIauTMZxml4fUOXwQQeWP/lN/XxNPvdCnCmLhlplJDaMtZ0bX6xGLheqyqZhgYcTPk5tf2C/BYnsf6ep2saQrNcxpvQOHvpqOHJv12HuVBSLdhkDkuxt9OluEqr/eupcpmJLXFDJEOwVHe0G9gVEVPK1BxftdIiDHpMrxyDfnQzkfTgsNIb9KNPjLZqmXwpwRaNmSO147ynkw7ptp56xXto1CbXhZSG+XyXypKVREdMynM/7EVp3NThIBK1wPyu42JQuWUWFrae079EgRyBHRXeweFsVTur4os20LyPcX2+Sd3mI1/q7bFjeqE+C2cbZhqzS1gOuMeK2+nKRGE6hs3TQzfURaLva9lff1vpIr01D4scp0oXtiJNwn7994E34xdhgNILucwUGScMjH/qYecT+wl/0LkoXXIp2P2y4BXOwwD8imhZ/8YFqZVRHI18jFrAUmj+KcNIqHc4SLvEtC18SKof3XmXyTdTbXkRCGCPT3eGK0NGVo0g9rHMaK+KxWEc58tSxGcKjJOb34GhtmVPuX5nl0/vo08LtcvH3BHiriWh3ln41Y6xQTjqJQ5kMg+ohNmSqVkArZG35hQCWOjNP0oXHnwkxBX7QtMw8jDKmXFF5DyUBi8CM8I8OwgOSYoidIpjnxqMSQotx8QRaBqEgtb51krAmEhfFep2hq/WHRJmdzlu0/HrN6nORPHVx1As1IhazLV4eKXgy81t3Zid2yQtccBhI94zCx26Dc+9KSOjP6on4t/HZN2gB4pltlStLB8vpbAxrb9xk1Wu1j3QaBT9iu0lOFMlRiF60cedL+KbL4Ngx5uO5BneF/3A+JkDvMgHNbeqsGulz1YZDwyP3gwUl9BWD7kK74i2DfXrMwzfBwBfbBG5n4pZkN5xuqYMtDEfLtbQfZxzt/4wozhs1qXEWM1uq9cAaL/PUNQGKvvsUrNwoJ/opB/b8pY33le3ENLlV8n1QL9Lfw5g2zVLB4sUjW4iP33LXWUN2mW51fyJa+Ggd61+ihYGP9hp/EmNnNRu8qxtEhFUu5EqYYPXR2FeOHyY6Cwu3/KS/89PAv1bMUaJVMHg9dsu8EqIVOPLB1DriPvegIEWlSwKSrvGyvvpRLkzYnz4kGDXltAlsiYuVP2t9eaoAAFrEuvfskY2jD/nDQolYgJMImfz81WIoP8dGGDQkea8fNxNDOyFjItlRVAJMQwhfFRArZt5uFfUSwEbM0tvwcuaO+e2ruccIxwnxYyayZhJKE5FaP7KM5iE2gLrS7qVRiVITcqZs7D53cwvR0iZJIXDw/+2sXKB0LRxRoq1sX+2IGP+odLaT+WDRgOKoFRgGa8qzPxh1kLDFBIcC64bl2tLYhb/u+cy1uLoyMsiPe8RwcRHegYyb0AEN0bsAXpcHPFjocVuHMpDmMJhrh8yHMiNZ1rWIB3YLRj47HDS7yxvchcVTv6wnpwIj7YkUJwB2csLPSWnjaGxP8d73qDXsRb8FgWcrELJdkrUaSiV3ynl7RtiPnwWwrrZM9fVLadj11UjqIjM3CeB41w3NNryjOLS73oVQeQcYiwlpwRcTZAHoPLhlYDSUxPbeWVCE/V+WlGES0dePAAOXHQIRQ9W5dzhEc6fZYRdfZNpb6cMOUlGxfoA6b8VujMmilJWQeqJU3uNDSnRZT4ep0IA4dI7uanI/VYeixZNO86nZiDkLeJQlwzqzz0HgfmSeFN6jQNXBtaBGZoE+Tklka6waYEmtbeO4b3ujoMLXQvZqjLKx2lIYbkze/Y+33dgb7rRIm2kpROmBhw97l0IUQqnjNXb+4LuhKBm7iMowdcCx6J2sMNxk/6fq5MJFhxFVi0hvYmHntMnLBeK+xbklheufwJQCItuH7mRrw3Es5x00g2olnhCry+CXVZcq1mqlsZ9Hc3mHM1SNrDhxZpR6eFhYUZ9/GyQPCodon8kt0gy/5RKeQKh55WFEQdks1qGYTUx4so2G7scgRRv8jUf4AfZZTB9lHB9ebRI8UwlIg10qPaaMBsP5UpiByjv0LA322HrIZfvkp7ZbM22quUpSkd5VtvjPOduMMTzc1bTL+8YTy0M5o/wHrIPtzu080X5W6AyEVNOCcgZEAYf+T0PxTkNWT/Y9DlfJZbIAVhE65/qaUU7j9283Zcflbk4kRqbL/4qycHaDGmIFvDBtnI/zzq++pdlx5Ip6FdB+G6ADmOh3Pc0R5ZGULije1u6wAjM9uPes+jiutlu+d1Z4Z55Mc7Wh9RjXzlYsmLbWb1MAGs8vyPVMzcS43A5dbh8CUA5hor9Ea4RwcUL6suT9qKA750exJMK7n9JmXDtqr9ki9tX8eVV7RVSXLbkW+6zZJSEtRulgzTnjHGzTvd2gyLt518hFttH3Q+jUZyjcuEUU2yLC8Jq8yavieDfLemUGuRKs5MwuIqiTNfbDe8V+DY4yqfPsHN5ZCp9cVG5kz3p7Cjj+JiD3dYHgKAQOcR9nZTc+Mg2dRAKN9iEEGYvrjWooZCERFjQu9y80XN5GFsVNiytFOJDIVBwKXmA4dreoeonsNRh5+sombrDxqz2M+PhaCAunN8tAxvaWhRgwKSrkLr5Wt5gwbbFqGCQ/jWRf5NuW0UfSe5tNwkJCJTmOKm5KFnCXXQILqYCJELspcCvXMkzEj/bFtdOjkLeFlSbqgfvxHMGiGUdoQE/iPCVSc0IKUs7kJQa6UhNFGYfilaR2fpxyIZZDGkgLH4hS4yfcSPJTqXtpLmm07qhwi95jLhQUVnE4C6RkMibej5nOjm5HedfanOHAhKWMBWAGpWsI5HaG71oPNV1/6oWOyZg2LE9rFpHog4+Ayn/qxLy+3SvdsFVhaRFr3CQRddlh+VzNWxxEjJyLqhNAEthtVzCcAxsvRslxRFQhgT1Fz5H7HTMe280qd+vOUqamWo/k/2G8gwKRsSleN3dzASUD3K4xs511SbsbrHflG4/3k+CyGuNxRO9nmNl6Vk5I6er01y59e2EBvYp5RBGMKtdfH/24K+PVdemoKcqH4eKrJQKIY6aKeVlTzWTDz1FL/r9gNMkLIBJbKq25/SC6kC4rqu6eZvfRzuKQ4Nz6xfr16v/vlSMPGHOl1c5j9HRFrJdAkZ8A6ziKUP9JUj/fPZP3XCQdS8JETkvl903uQT58c/cncr353ZP0LMwT7+NWK/5DRLt6yBwGI/DA/CUkUsiIVxkfirnMKJ2Abce4FNqOcSW6mmBKFbbLVr6Bu2393FpoRbj19lVxunpyB+KC5+y+7UJKsXescvgauAXSj4bXRV6ii31soxubvM7lvFm0KQJzlIAspEnoO7cIufP8tqbB5rhs/HmA9hVt7YlxOIOzFnB7vlkPdqzoXh/dYMzHkgICdq20VJuXBAPNc00pK8LgM1HV+2sEdikL78etHRr+L+Ny9kp/vOoaDNxc5HH6SjwDPuWFLhCxNlTtz0yaAmt9G+MWAf6pPzkmSqzL18A5Yq/t9UDuBjMUtOqB0yAOeHnlY38ZbEj0J+Knh7ooXECmK0CUI1/OQEk6ZflmGc4pvThiQVh/GoorX7dWJ8AqByugRDcgC1kEqtZtLig1RrQb0Y+LsTCwRl2aJ2RQ0EjEqeDCSeVaawICVoU4/gdw0BXsR/1BH9ognP6NKpoVH7J7GlUYkuK8Qb4F/NDpSX73yi6hX3qp26mVvev2WMVnjZE86e+0qkogv3smXY9ij/mF1CAAfbLtS6tRLN/P/+imoOi+zdn/bwjBieG86kmq1nmw4AmfyDNknXz1z4Ne9hikOiY65WUS9Io2XoJnmU5MxOoea4Gyf4GKqVG7PUd63etwiEPgIYaAV/nOhqqhAVtFNuEGp+MCbsmpn/vyXtEwgMXWgmrED2jmZWSRe0azWeyVDnd3I7uEyepyIQdlqpB6W6orB4FNS0EAmIV3M5fUzp51oVsCAPJQt6+W+u9JHufe8uwHgdvv1LNHcqLtYLOMcYvDHNXpouu5+CwDbWsPUMUGwBG2o1OEouo9TF1NvqtluxCtTcBrgHA2/rXX9Foz8m7gVsa005ZT+UFd20E+Y36xcPl0auePJzkM5dzD5cl2j2HSz0ordL15222sna90US4cgUSpe/imeHC9fNIE0+OW5hHrcP/VeZLEDO/C8VL4e7tHa+I88Mmmdn5KBbxsMAGUZbRlaiow6IVelpBgzrv7eimvtivTt8ZaLmP1ruWn3vLzLa0VzxQ1iKyR6bEDKXfd80Bn26vNm7HjqE8M2mri7zAAUem2l8Ut4fXZk6ps4qKpyoFTxqMmTPonSgde+gpOnvYEquXuZV2txCygkYL9b51XjWNImmgLqgZnBrbFAbLxNeVf8lzw5fV6yv6An4tvlkVF/bbiGM1YD5x7IvoPm7PXlDaPJXimL6zJytY4aeAmN2DfG7QsYjR7S0tWuyohCzDxEsZr+vBysCjNG6PeSCIPFJJRvJmJQQ5EWco4IV6b4u7V/bpCjWT0AFGuEoGaQTldN5gbeyQhHzqGIL9YyFrn76NWarml9OY92tItNGH/GdWOUR4Q4kp6+ZWXQkXa3t6YWz8A+bxDzamuWdKak6QOFdMO/Pcmc9AZJFVnYzdiu5AXYyyUDE1zfuQM1EGSqIqTpwvQowkBfKNTpvf4+CdJF8ALYv96w2dkZd5Zw95GD8swAkYAnOL+osGZeKi4nKG27NT5s6ZgmXhzgLihNMGwG/mt/RGeg5n+Jx6k2x/XtBQOPMgTMJs0jzp9i4rgojI1lgqndBCHeKbZi6By0NmdYpa3qQmlKya+uf/HVQCL9RmwGCToVh5itS/uHhKooq32SIgYXw22B/1asqlXPyaho6UOdI9P7busc7JMJEfLeHYXCj7lVkSw+JBR4E6TAku9rbI8VO1aIW0PFBIDUpTYVr/8Zu61d3d/VxoJPFOxONCnRMpkRYSHSQubkjqpHgBnX11b96ak9eggsPpEPh76OwffNI8l5iR/A9n6QuLr/NQKKf4sC4VQgtSlEPSO8RSGMiSYYDAs/eZtQkl/Fyo7Uhq2b4wL3ELXdM6s57AE6WFySkA4MMFoqcwFOUomXWp47RsDngukSN89YkcmDn7u8Hr+IO8iskrfv0qW0umgnc6wpReVDHDSYnYafQaGEIA/l0sKIUcptb7PLikC6Ai7aGjgUFymt8vSN1AQYvSxjJAXbDwiOplT5zglqSToHh2bRcrHBLNr7OeJncu0SWHGCaDwSaOaONyhIMl1ZlihKuoUyEelwinRfEX5INfgLCefpVNVwrvpWcPcnfY3uBVVQevJyZyWcuLB2l0FMOQQLqHfyxWftQxH0yYrh4zBn82LtqBZvyxHZZY+5P3FLSkbRrF/z5DQxz/wAFBG0YF9ArR49rHeBWAudKuPLIM5SvFYonOc7IWn5ejzLpcbIpMQlnO0EXxJWl2VxkQ9PeWmLlyOdS6ThFMw581rxNcxuGfUKGJKmQHZRZ9lP6xOCYg6CbpHDDcU2vKUptx21NHuehAe1fSEk9Q+8RCv+WmUmnJUqEwcgqg/frL4/CpamnTbtlO6qk/9yp6WxLH5YN+1X6pLNOfSv1vRdqKzy4Twoi6+gnpXSJKwizrnqr8y2xcnQuoyFlG1Jo5cXH/blDDbrtlJmWJlT8byE+yeA5bGPJQplG6iZFnoElg+LtZDYRd2Vx4cO5XKUvNTbRVX/Ve/tm2cHccmI923wAlVaWfKWXkeDwtdPdbZpU+j0aFDKlamgcsCUOAVV99SuCH/9PQykS0qX1YH+gSVDZfdbNJ8hSp7XXzTV1Mpdw9ulJFhS2izW5Utu1h5oy8auEp/HBZ+TPHbLnOxEo7bpzUEn30ruEavw1aP6u1VhI0e87ksj5QXPEKcRpsT3hvpJgleXAFyGpTksod9zbyEgwyluRjAZ4kVNP9L+/Z46E/YfdkXQDjzlUTD/ZoPoBkmRLNoZe2kVR53P0hsXb1KptqhQSngZmwsYpU1UPtrtjeSUbOObq8gYMh94GzvQITZ7MwzL/cu7oI8Udv8rPUcIJZpJYTvJPpCQMYQP1EFwulK19Ens8EO8UcfpjToPC8ELjjsLTqtbqKbsaIm72FW8910RQ5JW8ohSRStSASGfszjnflq6i53G/zjS8PUk6aIELzwjw2fw+8S7fx9i7j3Du07XXrN0d0poC6qD1nFK2itIVRghXEUkorZQC9h34NBaTi4x6U0bi9GTod1gLs/ItmZtVJM294wkHQjtd+Z4E9tLvUgudrcbPxeTeiY3kh9H7C4Ny43GSXnQzeZggsyip7vG7ZU4vzwwF9tTPjHKTtvwNWQJm5pYsVyfbBU7iiFlY7obztHON9hXmT4sMO2dSCwrKTh+GhofzVrH72OAa3iGMaNoaEUIhwCP+/14dhhxxTDqHN1wrGXX3XLyN67EW2NarZRxgQ1lBg6EJjBez9GQURTtk93Ujbbxb/2vZnTtmhxHmBq+C1QBEKDvKhLLiRTtNnWxcCmLj27fPMSDmajvAZ7lKyP6E74mwjZyZk+ZNLCZYi5ceiWgj06Vsz13BlRRULZK6KXBucVjvlhJKdzRu4CKD7VhVhsFplk5vAomrMMVinViko1fTKrjrpId+E5iBps/q3El7o0ML+8sbYAf7RIfBXw/ZfHt3v2mdF2FoY4+Dg70zS1pBI6ScgENzYG3y97qtZDm/2sp4ZmwYV1b/D7qtkuMY8be+xKK1xTLqLXC8WlhCypoA0EhjtVnVlxa2DWlvykXiBUBsA6XqdRn6xXz5iAfUWpHjhabOji9VuHa1zwF6bpmJn3VkEnsFaw1IElxqN5+YrceCD6LUWg0Z+2stOoGXoGRBUieykxx72TPTMqDtsCDskmcLgLd+LfVUZItdVC8OhP0DKV6UQUHMk1RSSq0yfGrWfcrOPgI/oEuf1ms+3wjUyEsoWP6kifqQvH+vuXOJhPMN0gqjwEme3nFwdmLQNIG+ZUj+yauErmaD4LTY6f+0tp/Pz4PbWdSml3pFREjs5ROE4WQY/4Oxp6E/PCZwtGkhGEsU9uvJypnQZ/TzW0GFqpkkh7PDNLCpB8B/4UDVZJHRv2JhCOsQbA8t1j/6q9LxdRK2FwhqLShH7Uif/SvvVtRnlh40JTFeSBOQUAht4sB9SwMA6YQYoyiY/brPLEC5viZJFvGSpUHJ9kv0sFTJkGsXLmc8mrqaTv69bokKsizDEq8H3jtwfC8O2t8JE2DvhQkLNHWy9gz0JVnIFS8U4q6eRpLzWZfOtOXQEqcbphkh1AUoc9AALvyRNgGfhP8azLpv4XMXj6E9ApV9uNea1k45MgPm5VyZu46OV2nelodAxtV0DXkyzcI0ahdJIzBXnMdOqbwTW+wNHvl9SBv0RURUVDUTK+MRZ7Uy9+l7OZUBtRDyhH19Q2QE5Pf+Q5v+WSvtpR6yTPTGM4nuZDi9ZSorHvllG1MmS4ScPO77yEry3MZwfndvpO3rVHSczuePI9qExsUOV9Gaf1vYBaBo/FLNhqyPy7+i0CgB5gOTUVt798JuYKwWcaEC2MGf1nMDt6hvJRxit91/g1vJtHxyOw4sVv1M9BvaP8t7e6pga8lcPxzc1kO+vckojNkJKIkrZ1eoCQf2Aenvd5i6WM8mmSwuEspiwvpb2pj398Ox9HDv8/fQ3wM20d41MQsivZEL4gkGTwYUKK4TATH87AZ2Dcyjd72f36Q8vAGWYefkZO238XqAKs7rRIEFM/WxgtqEqTvSOcvN7xjoM8AvJnL1hsjGSgdzRTHkGrwSJWY8oor4G0FgE13qX0nymzLrW++a5Hk9mz35y3KtC9n3b+luxc3W5KkiNeZbVgaLsKs9b/QuQXzKFdw7uyda+VW1Tpn5I9T5l+iwnBTtaoh2OPMHj8lYilxB8vd93E8hYLQ1fDLejJMsAlIeKEMxg7Gds48p7N6PLaRyfSSm63UP4GqGy3xub1GMIKDTbgZTw9B6kFxPtXuoRnjT+k3QDN1cPbi47VBLGZfWQnsQfAqkLwI6qKMoQnyPA4CrXEwU8YJLamNijAgBoT3z0iOtKbFvO5ZxadHgN3bzF3+o5A3rQ588NGpggBtfFvYJ5ST9F73BT0sGD1zwsqXZnhSyRP6Fdosjoa7Bh+VAlqO694vXKA6peVxZGYlAD9b/6RgNw+TOS9/gfgzmb8771eXxNbNqCKipz/91OHCxtrdV5b430yjbiky8mUd78JWZ1G37HmcGRALc91Vxpvsp21q6M7bPWySP23kTLfgo7P1AoAWA9XzQB0/IDYRcbyd2/58QKcnPpysneVTVjELBduf2YXW3ToI4z+1e+Y0eI5x8HPAQ805pS0tU4v/8kHduNHlSO4VNOnr03OGnLkDjeIvF4ku2wu/1t/BpcD/wpoxZoCB2FFAaFzzM/ngZNF7MjH1vInXz6plvYqTMRQR3a/Bjo2/jP3Wi3ftzKZT02og2EFFr7sDOpHXgjMxTqJqZzVJXmXrxeGePWi5KRUKeWicq1JOBKZHP/Prvok7tGH935Tf/nQ9qs0IAVKC4UOvP+e+hYVu2Kahrb1A2bwYPDbV83xWDsy0FXW8vmG/VfEnQE23p81VKRoYxj196WBFAke/JtKnLp6WaYcuWtsbAFy55orhEW1gFW4vSklXHvsblgZEzqm7xkfmKKdUKbZivkD2M3Fe+WCF32sfwjs0JIMoZJCWWy2EO/krTpY1kxaAbOS1ACL+19u2ps4d0EckFRGE0+UoYeYxeXXIENrARxY7RmGEhOnK8EPxRxJM9Ok01ZLGLkPgg6zPtGXw5HhO0bqtGNzU1RbpikdS/YLe6eItRc3QKBjNlpBt7pQ7L0A4FDU7fq10bcnDiwPiQgyqNkvBvpQCf9cn0sPLLKc27mLTe3vOU9SM0JtN6MVutbD19EGWYM0cD3dnrvg4cfIi3uMvTjKNZfW/uTgcddaNDSbhFES5nNIgRUdHUp1HwnqI7WF1isQcPCT9/8Wbfb+4frtTlw9nTVOGlT3pnz65MAYlLVBkbJF+mKgaBeGlEdltOoXGiDvHkmWtudgq4saP2wQGNWI0I0TPQ6cEjLaCb3/PWjdaCy0QoGGCjKwPqSeVgsA7nnyIw7dGF/eIco5XQ1fUW9Rti5S1PWoumUQfg7g31X4HTPKVpyIKixHTWmUVZd59hCX4dmHb54CsIUUs0pzMPiqV7rLo0ZrorX5tTjwnqHiCE90z6AOepZeze2sYTNGC7qnwuAu/z3P+IgVDRwMBuBBEEBQM8nGQnd9A8r1CJTiOMxNVAW34wXk2VomSku7i1yvKmMK1xJSGUcArMoB6Vkj/VigEJw/zqydbl2zcslmS+sEib/s5RZU3idLs9vtete2ORh9urXWw/z0CyNL3hGYC1QvOOHMVNSoyq1iZHHhSHkGY9t7uDMuXOzakyCnF5Kne05SCNDMCCXjv4Hcf8WqBhrC2LzkLoz//png3J0AAfZPmahMUWar7SZk8iUPTA40jFi8IZb3Vtp6/hG4vbeXhdL6gDH59PD5mv/2QGn1Z73NIwuRKY/+6Idc9q0MlZV4iHwqjukS3d2InA+ZKvvnZd78e0i8WVdJiGMVAtQkDt98N5i0Jp/6QSpwi0heqoFu5pkSd6pV64/kD3IZM0+vSt3qhywTniymD2J3aA88yecIwD7tvzwix+qq/8/jYnnzLbKuLAdCkvzKgZ9NyR2cwDkMVjxL7k5f5wcXDtdzM0HEYSWqKX23iq8TLCn4EolmVI2FAnhgAT98rLZUNiN3a8xuWONKDAwC6EXsnUX2Z4Be7TmQX5YNCIRewKcEgCB/Rfb3WHd/+aPLRGFdNWCd90PQYnVqM4hIqDMoA1QxUD006Si13vNXvUUjthLjfL2vljxlpbz/L2K7B0DKQ+L20Z/vK3NBnGD1+GaT/5kEneVtIvXwivAH0L+qm16pzp922YnJKymPd5IZP9YApy7ZhEXH4JMpRqvQs3EbaD1g39jf50P2g2mjieQME4kpStvq42P5s/HAtixkLOfP+Vz+GS3icCq/54do/ivgDl9dpQMfbZ6sUSg7BOqucfRR/uyIOmDf998I58SjV7JIL/KOnLFxNjo5AcHMt/RRSze4M+lmmDulQaw8FV6a7gri3kO5cZoCY6Jt9hYGesJHL7s0k+AoSe3gYrI2QTAF3N3qHOKhZJX/dU+bMozEa8ThsKLqfzHFhuLXMWmaF5X7wLVVymnkrcBDtIyYKCWf4+D7QSMf2197HxR3vGHDvJXAJcqARQKIx9GNy4KwyGviM8WTsLPxcJ+w0WS1DXTdAhK4zh4xuo/t7EpFp93tLEvaG2/TINsakJG3Z64/Qo9YGbsdUhDyUmaJN6F0g/dI3Gic3ZAgJQctYfYPllLFEojjk7xemLjQ5MCwM28J4ti6L6BZ5ktEgKtzkXGMC3Ne99prBU8+I8f9TwIck9asJEb332dQ7o2o83K5AfU964HXsNQ6d0FkOLKbHpHFWMk5wJMhaX8GZmpJJ3wNWvYzyt8hRjoBMFcmiSEBCB2JdsJyRz2bFVwHiG79CQDo/CAF33cVPMma9KnmEn25GRTYItJzIDUx/Kd9p8IIERG65JO0cAsshV2gm6EWZPww7PBbUdpJ4ZEjxt4Cb6bEtkmVvUCmNub4cK4c0l0zXrDgWDMHuvMPu9QmsQrJg8+IaPY5RnR3eTC+TIeqx3ds3yKqgWm2hqSFh0WYostNeUowB9YbqB4N3i26fwoMxUyuJ5Hq4EX1UlgW67q0M9wi6mvS/ifb9qdFSOXivyT53QwbXp10/NlmvFg05usgVDv/mXOL3ZFf4XPISCGj4VvD+ewgmMdhTdZ0Y1r0epfponiI6Evh0+Mwu/RVESjovmxLEo/VlR6dPRtPw+CSxJRW+YFbfSakqPNx0cOxxtLXdQ+vu0sD3trISEkqCcwbcqvSTfGyGFmv95ps34Uj1RiZ0W6E8PBXJYzZo7oN1+IxPR89yfNUIkc9BeVsmdf3eHHLNhCy5S/l/eIOlfC9y16xqOvtN2vhgi1giqoW7w0MXXP4Lw+cBf6Ig7f0DkruxZR+D4N1qeOqXUijA76o5y6I36tAPmdJe8/17YFOm2gX2pDOpJ0fwhymN+yA5lCy6CKW0VVSUaEQe+0bWhHYOO+auNplTjJHu4Wb09NL6/uoVZs+gFov1gZulgifJmS9H9jw/rol+wj7c1axqBwyc0A55aTfmmMyN9+UOWF7+1788hhQ7Y1MqCJihdsGyMXV0twnEf8kPd/ncPr+99+23OWBOIm3LXqvZu4jQYaNLgH3tSTFgHMSMbPxF3zkEcootbAtFB5oOLVEc4zEBVYax4bOnx+QphUDIeXmcOyUmxEmPJiNNtBPpXpy4GMiZzDICkfUgMAts0d5y1Nl/60na6N65mBJpCtxX8wvyff5W8qRIHmoX0bQWjgKB6S9/LgPlbY8gXLVDgYWwBWhu6K4My8reImOWny4JLxWp7WFwcV4dLf5Iaa6yFL4ClUH2+XSwlo/EvR+Dlalb/hxPAP9De5/BO+uUT5wAu2pnH3Xmle0ms0O1J3GLJmooHYdeLZEBe5TQJuVAhF5Mocim/hoF1jMltOJZeSxLi/7H2RUAsBGD4zlbmw/gB3waY0n3ioiLqMy24gCe2PSQDcQ05Zxu4eguEozgEzsRUQGgh5jcU62niD85SgyrUDncpBBxCtWypNjm9jYxfz8iXxBulz0KYQgrzldD1lWIiYbUP3Fe9g6N9w65DZWnPwoKRjgq3HhROFerTJ7QSaN7npTX2bLUi6ClvywC+NEse9873qXhyZlSX/tHKdk9piYC+KctyLfOX1PCoGMAHECzfLsO0bsOsL5mg6bQEhL/YI16J/KeQuL0QvIXl5Tw3YgK4CT9xNl1V7a7R329VtE48jv0L445onWEfVpdl8YTgb2yGNX847r13BYfq3TumKHGAz5f6FnaOVvR3Bx2peEPtPE38Mg5nfz4585iEzEFvZV/s0UmbdH/KWXFjogDIP8QjFhSk2FawIGrZ+x0zfqKgZ6KuFuQRaFbKAyKenU93j9Mao65P0OvSaRNb4BoruDVwVzb0gr11QgTBCfV8M8UJMYNj1Ip/8maEBeUG3G7pBdAqCvnq3IAr1Sr/Yjy3AYFDjrK8FiUHeRpHuuRfRHtS0VQOgXDmFvdVTP2MJRM9w6//HrEdgS6FnCj2boVdYzTXd0L2cN87d6G8x/AIvJsn7Rk5IrsvIhkwInUCsph/re5IENlN9wV1FrOmDmjRXOWbkN0ba0g4BqWCwCdK5ZhubUpJcwpaoH2V4JpAZ8GNPRmZ2EuIlQzrvpaw1G5baaRn9gaYagXJMblHSginbt2dL5qraWK1beeQFIEZ4CH03oMq+81tje5CvHIAdxcALOm2avFq0vaDO90BRcMZwtwdRoocau2SirB1gxLJJCO8V85imk7EqlLg9ZyML9918DzRAi8EYXhf5eQTPJIMJGWW5GPm0jPRAHwD9urzMAjNSED2uaZuQBEdgH8ktL8mWqgaZI31S9JoBnPnH6+1u6JqINljpFR71e3thMRsiwn41/XfUhaLCEPhUAtvb6STCPjEVZBiqL5shQIJZWlkphlckfdwqr6V+fQ/IBLv1ZNx7GAaQ4lDPLxJDJ6+wsUWkNnYdLO3GsmyyMtMK69sGFY5E+OrDcpE7i5lN3Bw5TfAqHyQ3/N9+n9VFpCjYSNTViPwfF/Yn5WnfOUjonGZhIlb1Q/SrnQ2HrFJ52TcgVMz0joMZIElw+AemQNiNXVVMnDNjtlq8sauEw2VH/UNk9+jlyAqnt90GuFLJ0JrYe34FbXFFFFPgmIZU7NSqwGBj96BOAZDGH7VToMifVblfmdIEnSQm3xbClPwtgmi3oxcH06M50KQYvbhE/cpl2NYZe8hQSc+7PxCEsHo7EZGBJGePHZ52YCWVZm3bQ+ps57lnYR+Ti2A7iDXpbejU5Bv5qmktfYrTzkga3p8tCzp06Lnr33mxFKBI48E4xuzb/U/ABkCuqQh5kFI8du308VA16DlDDbey9dQRo66LcR6BKUrNSvcwEK8n6iNH7oB6vPpEVN+AA+bzx12hwqHGL94qkQ0APwH8INtT75Z4K2lGUgqCP1IwbP2T7IErIB4zXtMSjFfNbRmyCOuDkMKlRkLAFGPQa/nz8tK80u/Vo1nN8p1bsv+MFFcmj1+Py/xWcF4wETfEEwI/yYaRiVtL28o8dRQcPRGa1I9mkscwP4bkpWc5QpHfLRMYUQrYBFyogas/I2fPo8+SrDO8S0khoOoeqdg+knLRJhlj/HEZqYgBi5rHTieZknb4tckOcFnF9iUuu6ekkZU3Z5o9K3GANgExGMlIDkeOK1ZsdiS4SDFFZpZ74wkufJfB8Ko2E1G9yt3Z0KK5AwBpTaJefnTiLQwgwHbTExnqROOY1K4AsAWbYMu/Zd/qlntz/eWrCuqKObfIo6P/3xti2SqnQntons1tdRrYLMTxFaUlJ87N7/fU4oEuO9RhdBeaQC7rlYbv7qVYpT/YaPh28D3S0ZP+F3dZPc193u4H3sqvA9TGfK4w5CSU6ZpnRmW+qwz6b7aQopFBbGaKDljvPpEY8lHbSU6CXIG1VVqW97leOpaZBs2qrXiITk39QscY4boVOTodPKeefe90hp5ItWohciZmHBn8esN00ed8vQySThYr09m3bDddQtdITr4mzvoLvBaOSxrDQv3kpkm8UzPSf63faVzeKejE/9jOZWVAA0tZHvbDWoweSvs/CDP4jb8JjuVPqNUOmLLV/80P7tiWw3upPim20nBUPDUf9L3XVqW0ajBlzv6neGb12ZIKRP9xORKVBop0VeBwIHyhA5nOwN3aZeHynVw0MjRHXH5b5Mw5rGJjKN0Phq1V/QVMQ5vGd0RIPeffnRcFO4z/fHTtKf8liqRoqBWJSctLnN8HXVphZr0ZgGnnmumrcuoHaRtjJtshOKkD6riIOR01EqgkNzWzH3k8EXE/mw/Ihnt2VLSjvJTaNhVgMzV1VKABQzzH+hdtC0w9Uz9JTA5eyJQcfMl6XuOrDcdv++EORDEs1ZOkIFJaEovaQ5eMKy/bZVPXxfh1raTuP/eX+YKC1wnUAcb/0P39cG6pcytsq9QBo1/HNPa3UJMlsyEccF0uUvcB+qX+zY3F61FNmfdqBGDQc8vHekK/3SUSoE9HCPRneFf9O8LP2DD3HHK9GsHXkd3msXa1VU0uvjZ+kodsHD3AzeSJEWyDuKrJ/WJU+vRkYxMtlodkNkBcASyqXgAKtOhdg80xJS/Vrfo9PPmeLqKIXxIFxbYmxK6UlqZ9uZ4d1BgJFegwbqdmOhSi/TRlFvoO1/cGW8bn45CkdeiazLZpu8ZXJfoqRphTB7xYZ5MVDG400pTO133+lY9l0YlJsytTpcZoHAweiZ4wRxKVEQI+s7pvQSyh5UjGEARqeSB23ysOQHGEKqmk+X5A4Py+Sdo96UpdpYNc1NCIeAnPIAtQnXvWiH56qr3RoWCBeXtSb3YPczd2bqUu9kkrjCGeMsA7tR/JJZh0SaGO/UdRxQUMo3tMT+M8xoBXiA29AIOliEuGgqL0OBy6zcQDVPcXrgFmcLLJT58kbJspHt121strIjIeHuhEr049FuaEPUAibz60TmQXoVeumoBAjctJgXlLwbckytTPdkF1T8YXSkEDXHbEtAMJ7hlaO9k9o/8UxLEYTY0KJvhnzj7CJiWiHY9aIqyvEQUZl9+v6CuCIHKP92z+fe4gWyKHRIuiXZVfGZc42KWvsrkun8ZyamjUK39V633mXW90V6xzOs8SIYM4RtNqGBNipeNtMtss6eGFDgoxUZmJc8kUdLl/PnLQBfWIrfhNjLAo6ApYzDqOmSIGuBqn8UShTT6OGMbNlYge3mcCthDGOVDi+bC3dCULgaASm/g16Yuw+zdg0V3EgXdqnPyEcNRLAPGusyV0zbctPkQDQt67nLD2Cuv0tlthRSUeSh2ygdOw/jMofU0Sxe8G+Z7SVxcinQPd54QSn2W9PbKDsS0rWzqmtMfkLOaQ64c+YXmv9iORLWVXRPjDeZENjXndY2o0W0987UbA/EqHUhrL8PFJ8sS0eTgM9q1iQeW22zL50gKinkRqvVLFIaXIFeIziIVcukxEquVvwfVn7ccOHfId3jKQtSeHHNpxMXdZ5mlyPFHnlRYaEffF1Qvs8vMifKZXbilCPoLvAPDFWxZP8wXjEo/V1BKdJN0JFOiSn2AGlSZx9QrK8WCgAxwvtXvZHG0dE8RN6vjtyyw0xg/6Ex8Ad6Xb5E5Ky7dvqEKUdimX4er5xMhgGXS7b3e3K1+zryUMNtmgyNf1Wz8hpjovmRv3op/yw8XeFGFZWgAPTsAvf83/i1bLUQSwC5BhWym/rxWtXzJOydVRpQl0Os4kaAaHGE8wgUzAsCXhm+Ulv7rPp+yD2s9M5Iwen/4YI4GU3aXkGESu0dwbqatHgVxkxt2e2c1dsLENYjLuoZnX3Lg3RpJuZ9tK6ZUUnWgb+ogrGEcJi5qPgfl1m7dDEZbXN5GW9wbs4+WFqjkliXqgJsfnAiEMIagHf/Aeta7TdB5xOGS5aDtmNWCJhn0xinjS4YL35V7VG0FjwsCTuttl8yeX+mdkmDAhO55nZfKomugmOVRrxrf10jfMJNMMdF9TjoHAYTXuJsev9P3M9t5eRYSUP88QaFlnoWBKR1bAZRCkDCgfK8xioc27+bglQXf6Zckl9bW/z0HQUIXGHCNPxg8i33O5XNDB1B1JAQiTumL9Pf4ZuOFXxzSDq5JIBE27eId9NGHN2sG7unKIoWbK2KNzRgDzEcJAxrH/sVXxhyIWOqcZVkDHFcAqTdZHlU4haBl5Jor5BcMKKkiKFkxapIghZgetHhGqywKhOZBpx8WWinuuV4JmCnY2mui+sllcCz+dLxJFThUbmiwwN2y4LdKAXtrCdKOBrGMn/yea7s8/25iVfKSwW9ZVDVKnC/D/tGKCHIfBunBX25SuJFVZO6nKQXJt+LtwzuCNuafzo5AjRxBCRPN0UoLRZOhtjnEavaWM2j5ogmIOAyfqwfKOJxaA5WKKHc0ylFYQkCGKk3eiKrb8u74grO4VDJ1I4iWsHgz/O0RcaH5cJop7jUA/h+49RCVzO0ZgaIAV9br9/liaDDbxajGC+jKVQuDSUOmbmaHuBhAvRFpRmUZeU297ipQzt2Flk5KHuVOGCTroV5RLeVIffodGIo69i8lrw6MEbu22XhaWPyqPYBNW+QUz+gsCakdNTVgT5d3JmxtMoe6xJA28ylcDTs9C4fl8UHMpxhnQOPrhZklZGng4NOSVE+9Przxlj8iQtRGK0V0zuqmierKPJDJbDDUZerD397w9fEnQaMMwOvG11mgmvBNISuFR1xl00cYLSqLyhOpY+O0II7j2cs5rg3Fa/VfKA8TKSPCkzziPiWMshyq5lHjI5wE2n7jBTfBWMftWsgr3nZFiyg2jrTht9K0dpFjB9Xc7qd9kx2Zy/ZYZSP5v9pds3CiE9714kEktJFlw5qTnLYJIw/RPgaALmQPmXLVxuu/iYD3CS5foe1PV8z4eMOwuUdALU80GqFbE/nFzCJ1mOL6LqUEdewqd4dGsIuMucN1gZic0bkIbr3e87bAgG5tCzO1DI2CKvKlvmJp7luRS1TciW2BZB2HWt5z4yRgJ40uGaqMGGFhdR5NBTO720B+9HNOq6xMUw1JyIW3Y9ILLanxkPpdGyY2IpzsFg4Z/ZU1r/NIghJyIOlrZF7bLyLIEysXggVvtClNAgV1mjedLi+37wqM8vTyX9NciKJy8RWo1Q24SD5HcE6/Nz1whA9MelNY4d9d8r87zjM6mqam7UejTX+OlwXh27rU8t9baUrAG3Zq9kM8sgj6Dp6vabDphf1O9jIKHSyIhG0euyqlnVXxwPawaDublWKIHLCxSkRGlCtTuumKevu7izUdybHbAAhK5TPLoR5M0DX22C9opQmhChLUHNLvD85R74kKbxhnNLqTl6QZIwVT2CjTODfzwDrQUds5pnxm5mEt/ktH41O/XwV9m0Aa5xcqJ80MvYr6GA1IpyUwGnmoWuKKJUaHtQLA12zalo4kN87HeEcudf4FUKZrLQl8TFqm57uwLvgO5u35UU0EAzpoHH05eMCQiiDMa1h68V503l+pLu3QQcqnpC2IivHc1bj5iPUEdyq7saVrX28MT2XoR/ODbUN7kTDwiOEgueqk09jqDwNIYHJm99M+n5pTl99swdN8biPbZLFGWv2OjKGwxQXfxW8tXEUw3DcMvItu1Wg8cSUqjYiV8lp6yZXwIIkI2YkmtLp4lIiJfN7RPAGJgylliW5/rvwJwGWKfDKWEM7Njvg9ctRxM4my2dYbxV18gfvjlVssXOIXBpiO1o6837HlCmGs0FAouX3MseaYBX6YtNoz8Ds+QWr32RZoqCDKbm9cajKPtuJZ8g/5QuTZa1A6l9umdXKDwgKR+cZP6++TwoS15lJEP97K9j+soswIta7WUmDrGl0YZ8fzNRNDXwVMUJzVheE7bG2YVhRZQXyR2zRDI0znoe1tJSnhw2kZ/8hRTVn51f0aOfqE8vBQOi7HSPCrS/h6kughplQPOA0AEDV8tW4ihiaZLb/+crCKbATDXYIdVJRx9AH3Hf+H86MuFtRjeHloDmTGaKMbX6d/ryMI3YhLL0lCiEVJzWi9z2uX63Gy48d5wdp9xdEQP62noW50ey+zeLBo/IFMJ44qYgvjY1swRyFppVTlb8v9VnaTEpLrSKI2UgAniZmboh2kQpUBAbAE6nteQXV+huAfbMVY7xqhmSPjAID2nOoJCc34bxqMDnTbN0XAjt+PefDWKXhHB2iiMnF+VQ+gcG094nqMkN3eOF+H2cezXRTHY10XbF2mNzF1EZUngSIZf8tT8rnkFCpdM+OYyI+l+zOHBBbt0h0cRzIwgPyP16v6M5QuxmB3LwMWBxfHC+z+oc7oH5nb3Q1e+91s+yOb2R/pyPXf33v0arR3BdmR2QYBJ6biP8sictnJZaNKBbAhCOtH5wsLrgsvzwYqqnnM/WquzFBO0AiNReSgIefOx4bDWOwAAkmP8SM6u4or+Bb273aF6mCheYNH5qPhX69CNX4LUmt0BKbqwhsp181MNHNQIpTBLHzw6p5vOkAuQ99rH0zqdErsRADsX/u7jfec7oeWRMwY0yQZGwkZgbVStKslogQvKrSVgUOJKuiwwRWieHysmjwKbJMkhZbQt0J6MKKaAbPJ5VOGjDRUz5Wk5PM5aSBl5oIoc1UZ8NzMwg+7jj8qIk7J7SRiYrBB103UMUINHKVVxu2sdTYFplT6UV/cBrrgaWkjbp4M7h9M1FTnelyKKZOxGmwigBWVtdRiBlaTjVIG51T3dI+Js4iuW2uBPJr9p3XOswajYZ7+e/ae6yE8Gtqn+E6eXcoguefxjhGfcPRdBMasqIVWVoex26gGD4oZhN1tNLKWO6j7Xrnu6s8VHyU4DV9eOMXOMc0CzyF3u8KzRLMHik55OaKfffVrRsxyEx+nBvn80GzflGig4vFz9Z0khx2DF0S54yPuPRCXorSGQ5xTIq7z6ki359Is6zduhHNqti/SVE2W5z8iwaEbsm0vd+FECGXtlxAzQa+VhnHfHFBUkkU2yr3yExCdxSA4+7BcLgQF0euOSENeE6Y3BAFvcAsJrqbOw5zgkRn8ksQIQLqYXSHNsp1i5TICy/NKPtUGu5ol+nS7U9a7MkAbE+0dEjngP+zmeDvZ1x64WHGh0nES3+xVhM0hVEplInitfwvmdwit5RvuQAQXReNhmB/oaCdbVxKa3z4SrqTN0L68TTHN284pE6V+Sd9bRCPdOJsLH7ELaNr88YmGQHHd8e0NV1siHmbOtJ+MeuLpWIN8HUfyUoCMAYXA1eoVKDdluo/fzqa0rpaPLZsRuBL5eaPbDRIW6nhLhn6x1kP0En+v697QRjdcoQUzWJQe4XbZ/sq1eHjzuP8S3+2IYB3MqKfTFqTERdUsJA7rqNmFYaI1Ti2JgMD33/9c7b+PAIEBazlfXpBRT1OsEkgZAJ21GTeCqZteDVZ70xkirnNbDnjbNkAoBfz29Xrs0Edi/+bZjyLH6tvHqZpTOqLc+ZPqedSS3sxTFDOAZfRYakAWh/qljeknnLAUap1rJsXV2Iy0eYRdcKwkfReHR2QDhHZxzJjAQ/sheuvn/JjJVo9m1TDDlAB6AKT31OTe9+vB4Rho2xtqLmPfWDzonrKx4zB4xf4xsRPisntAOdaUjzZ18AiQP1jnSCS+89+yZj3WojgIZgbovzibg1yDYjU6PQ1cFYKEKsEkh3KVwVqanGYQeihoP6MwbXZd0c30ZuYF8AgWJess5PA/WrUfiMsGHOP+tm4rwxM7EaIUbJKzk6JE6RaylSlAz+ZhVd7DgXYakkyg7tqThbxl4c3QYTseJlA+dXrsN+vMg2AjlX/c9wCAyhMj46VBO8W4x9xClqOavQACiKmls3G0KT/eUv7yqEssMuPHysTJohvwUAKbNHk4pHeu8hYsqU45XpzxuldKR0WU/YfW7ruMKsb9kgix1PEnNEa+V2G8GApkMLmFX1cXUgPqrxxzac4BVBkDB9R8u0HhY8evYjhXoegvysSlzQgcwNBmawcJ5Hlxh+02amjH5ikZrxqqCvPIs2irqvFzqt0UK97v65kt1ufGle9o5VtZiYl/rrIw5A36nj8ZAdQoMtpomNyr/31jWkLqeFRTmCYENE2AslyFw+XnG4xhpdKxru2F/pzXhZbMnmaKXRGWnAhtCuAxsdPoU/LlDyAvZxL4Z6A0WRXT7pS58Pk0NhMZ6FKKRCu4IFwK/mFm8XpWKo/ZVktqQvN57Vc8GVrWW2D5dQrLyH70Qh4KTAQnYcBYQ81wBLhJ62g8Tcr3NGtdJ88VE+2WYH1QmCzNDD30lAahWvaaMhY3OejSGEMy4/zylTh9xkwvRf8VkKT/BJgi0vKokgjOCXuUfg0Ubh5NUClwB4lUAm4hD+vnK/bUXjs35jyRVbNb5VIAabTwweVHcIjHEhm/wk+j0K2KfTOMW27F9TjGNInV8y1mC0RmD3vaW7mPM+WAWQuu4EhQU2T0E9hCAaznu3sqV4k7LzAV9hfkUL6EP4u6PaNUoZxHVXd9mYLe+E3eLb3JkeJcTHRDp+8ZpRReVisrxX7e62upeNkfXY70IenxuutmUAv0DMbqffcvDLyF9SnnWb/tuJ6YRlInCEeF84dVqKXBywaKeYtjgxAJX5maDPxn6uzMF+wkJLMM2xqKjIiBYdumisGvX2oJ2Q4pY6neih9oxYyCMdRzT2qzOzBw1wTlAVLckEyITozElcmTXHfBKHDGKFt+lsNveoQDZMudRo0S7ToWHAI0wXMpcJHLN4EPJbAOKfsQe8Me94P9Q5LrAWt+cyMuaWZE1vOp/3Gr9ksrtwhbqFD3Wpl+4qCCG6m77NUnlJ+lIrW0vXr3kO6b3IbvTMCXCLrLst6Kr7TrDK0pfXiUIsmLEIV15vjgVoAhQycLu6+IVJ63Ev3R5jNoIQOTLeQB+5StZGY4tkFGrXRO0ubL71cO9Sl0H6gOPNKv7f0nhqm/uzLbbqGURJHiDvsv2dPs1tlvSOnF+8+HKUK1MGeOfP8QlvKby3q5jXlpqlGBYH7gye+qv2JnrQ6SqMVrtucaA8JXfUodwa+G4b6wvK6ib4DzgbUqhEtVfCj6vFb/l9LVRD4khZs3+awcql0RMGcye97mixwee9RZ6fAxysEWPvFXyojB0RFGiBhUrg2q4hlwd1RW1j5L2kI2mVNesuK3hywWJRtTURLnUBoiq0xmJdDJDVo+EfTPlJ82HJUyKOGiSlVMmsN6tKqFrVaFRJPQTIMSvTZCeyLpxdPPkHFiqWt7r3lSzpvczdjLhnd8ppL8deGcpQIftnpX10FjwTKiheOYuawYVm7OR3VmTTjwKoWQY4VlKaIygn3C1wFSSF988iwVqntP1XlYFyE2iupymxq/4XCTlJr9RM5eJIEm0yekCI8Ixldbndqg/hLeL19DO0U3RvRGIT3Uf0G8npPlIRnMneOnVy1hqsUe7BS7ZrJXenckyzXxjl/jwjAl7BQWrYZvD8e1nsEgZBrbQBooTVen2DjPd0bmZLDJ3Th098gpyXtarzut8WYs6np/h+zwfOqg9MwtMj8qChhYrIjWNDW3Vv1wm9ygUPEazt2ykPTJB32QB2TuhIscLN3hyMVwXol3XKoSwW4PtMcbVzyt2BbQLM18Lsgc1igmK2pdEEZHT1AycebGmpRQGY8Dw2ug/mesw4qLZ/Hii7xoFXNdxypKYoNpQoWg38XbT5z2SAQVKIUKl+pYDDZ/dR1cmqw8S8eK6GHeBPkGJCwr9LyfL3RkgPAg9AbJ82zleL0EyClwY39l2K0yRoPxHfOhQYh1XFUXbtYf9xDuGbi+KkfYvNj/I054XU6DxeFMFb3a2GOKMh1QKiAeUc1y9HVWljpkorpPim4sGkjITyT4VkJqUP8rEU6Me0Da57Bv/pm2m4FpV6ESQyAQW9uMTqIVBRSL2UcTG5j+yv2WCgKEugmnS4FUuJr7gz3pvRiHNNqy3L2EL7U02mWpIBpraMAe8oLjXZJI1SJWVIDdJIt1Ui93pqZZPkMp+z0PPE6bY/3yvXf4R+qhgJTrTBm0g3AE8xW631JE/WFAZGSiEn672liPCGw2KMdG9PpFLYNoYvSSM+0Kr3CPt73YSx6xVJMOqNGWAp0fMvegYH4Gno9EU/+E+3H/QltnxjIQpmhr8TPLfEh1sJ/sIcsACRwMv6nGm0xBkMbUE9y3IfyIqPTbk4Hk2edQrXHb++Jcl3FUZb5kMFquUkPRhBe8tb+iUryMRwbJir2UgdgkpJH6cJ9rUVYMxmm6HUOnkxLL0yqhg0TkwNJTwpn1XyW2nqLV9SX8/0toI06wt0UYKEUtt5Ke49S+SwYjGkKk3kAVFPkC2ippTmbDEXvCjbIatLrHDQVmDlZ5cIu1XABe2MJ5IL7NIx2RMCgaFXecfz3tqt0t/MA+1HxitQhBBUUFqz+uMD7COW9yfyIZPTaptvqM7wgog/GklNVXEzwF5wDOj5j05ugd9sprKDWD9hVToOuTyEM/buG9H3cwpJUynnYYp/6ia3pDD/RcJTyUN33TmjI1E1Eh4ADmgw3pxPiQQc1ceATEmqQKKjuGnP2b9Jj2iAnKgOO+dcO3TluJ99xXia6ez8OSxfyuryyLpxLerT6qsV2D74xdGnq2hHfu7X9KVx6WvtElhQfdpfrddn2H4Bazn01tWXXIkiyMgLutWqYwowmsEO9ZmxpuRZgtOiyfX8AnnmjulN9YFTDdfLbOJBsk/xOTi9njRktMujYoVdFByiOQ1eVZdu16OmGgtWa3Ce4uA/2TxX9nyYH9eWxCwe0I3FJV5NT+QrrPzdkBYtu1jestKp+FTRneemWy1ip3UOoYZhsVMJ7h1sj0d6jsWZwJQa4l0YdxkTv7nrKiHrD2hABVFWOhVGGmkMKNYT3W13zmQ9dIYCRBcR5Hcr1re3tz7768E2mNrT/ekDgIdkX2j0XR2xk1LPXMBvjWZcFP+raxe4HNC7B1Z8amPRv3p2Ncv8CHJRl6UImdTFgHnLS0afGkr74WHzly5OCXtk9V3qMUW7aFW3hA/g7SDVRNURFut1m3P4wI/Ajvb6/FAwySi7z9tJH0VJX9FQB/BvBz8s8zmzC+/krNgKDul6y6ajDYPHS3e521/hbGT62DG4KxeoZeXnZNQ0V0+jjearaemSQKrd8/FyKe3wW1VyRQiWdRc53HEC+n9ZS7PcG0LSTV6H4+z85t11OA4TyFuhrLBB5YMTjwk7SSxxMhSfdmpVleB39U0vqORvBJgxkYsIsCbTaneiDUzXjKh2xvyJSTSy9hHC2dQr2MiAXwuz6AVJn9m37MBbU4GZ9Ol4bTY05VrgLELnk4uvefU54d5wo7Ilke7Z5CSZ7UuD7fyBbLOhIpd35IdK75JRv3QOyKh1WJHS/AqlorLo3UQWLO741l7WIkG6t1cWMolOH4C/Rm2cUAsWYa/A3ev9LLzL/AnnaXEHUOiDM4iKXO5MrKFexkqv0Q4kr1PnzizV1zol2Z4bkObUNmWsP8mAJMQlmeU//txKCroBMgXF/QUdU+8FYHNjDyq/IUWpdSnR7Cap4LW8Bm0Mnc59cShhM6wx0TXdsZ+OTKAuy1IAaGfgqCOKNIyup8HnKY2WVeqBX8/yKRiQGNLiNTAhvCG0xRzujpk+oU5Fxcrc9cinB2niD6CjXYm6ZPu746uhageYDjkQxk8HTFf6ni8RLFcFBsVvT/quKJ+LHdNYcp8JzvmIZAz7TqJ3bA8lXm/jHlXrUhZq8thAp/d6Kh/vVzdbyP1cxcphPlooylJJnTTZjzThgWZGtDC6AgsVEiNShPYbzd7VQ5jMwukoiaI0v+01AxuViM8v67kiR1iT0mc8t6ycyi/It245JxLuy98t4tlq0qgObZza6f8NERUXKroyE8nAWaJd09CF/jU+iKww8befKCH2yQqRFcjiq2WyjiqfCbApMK9FxUH929ic+7T5TfNdVal4jgVwk1n9Pw9pcOAEjJtetuilbIWL1vEc9RXGGGM8rcbNoPWTXaLoFWZrZyKyPCSvO1enGG1PiGis3rG5RQryPBT4esgeISMc/5sP6/SgWERNkuG9hHV7COj8rA4lpsK6OKMzHCs+B3he0x1O65iFmnXlyZFx2g8tGjGb2q5s+FGyEChnqaT9s6QzMelY6zKMTJj6YT+BxT0ZAXa4DEN8dbbHqsxGsaDf0+8kzCjCqfNlVnKl8de+IEbEdP3CF6ZBpCOJkbH8aem9JStv3ob736u+WRKznq29MIhuaB5hGEM9HfVHvwLhsVOIZ29KSj7uI8mLoooUgv/2Q1xEu4DUsPzwiMnqsvL/vSYpWy25P5rVT3QQ4MyMPM357d4UaC4yDho0SXdQuF+aXdMmf151++tciqgeo7ZPl6mWuXnoJvoB8MIOTubEmgWpwhChikpDI7U92CgIVP1xNRRvJWzYjVCiuN09E457WBt1kXpgcDHsRpdkjRi5WSw+hK3YvjFYyIwai3Q5gVBrLonw6e1YRauWN34juhLZbXyqVQqNAae0IAS2ckYo4NU4MeBeBohpgnrGb8r0yLUOWK5/uyZlrf9Fh7aiL8KRTI0z4LhjSGrv0F7zwO4P2bxPE/Lt6TH7DQWmW2+/jK0RftYAx2O3eJsCrPxl9q32pcunBNgM5idfxxOtBsOg6bOIg+PScT1pYgrosvH72FdV1B0+Pg2RJTmmDWtu9ZkHj5K863CQAoaYhjn0LV3Wy0YPPqaZIGi42AdtXkNBwyJehIaSvKg4riPcOtDLhdbaiP0RlS+nSlvRC5Z2XTMYDEtCsI9WS/U7Bn5gDBGFkrBYJEzI0g5Yz00jXJFumbGpg/WdVyddWmx4Q0gZSpaS3cvlGxliVqrByZ90IAU8UkaeMAOFi+iUWhRI+9+VOTwxDnkEx9mMjY8hFxROuPMD9pjAp/Fy65MYu6dJG/rbzD5R0hkvdS+iPXtevFY9MzZn2cqLvliOYvUUaLJ8HcM25Y0UJONIKN/Gh3eGdTbU25U2iskkEVLYQ6xJ0hfNVxUxycLWCoXmnMfqP/x33rT+bp+CKCKQYDvthnBBuaBmiBlZVbSH84GVIZFCbWQZbLaKm2CA5KTxRNh5UxAsN2cql5kTXG47i4bEOY71cqX4wP38DF7nX7WnZbg7WnUktJdWTlghEjwI7hVAyHF7oCVPJoCwsdTavSXYpGGp6AkbwADVZeHuv94AcWvepj6VwjRsk5Op3L2TcJJXEFTA+XUlcsmgqhrLC9dm7frycA1e+S7nWHabXuEKWj+YSZSOLiwaPRPvLsYT4FOTxbxKx7kwkvm5QwCz2nEbc8gcHfQprAcYoXF2uy9wZDLsVxq5+TLFKlL2BooAQRnxGMhe5l6ME4VsvIR6NqFqYBinkW5VbapZg3lDTai8BcHnL0aiM3Kmg8j07n2jXNMHxaYtBx9N9i5XNpNNR8DdRNxxe4LEOCQ5kFs6QqIRSL/TSAunSpOhCUlu6CxqtpflboYfasEAtBCxCQHyHkxtndnJOyEEkZTnCdQ/xDDGdbcsZAATmZSh6n5UV+plno8rL7c8xpNO0fDTvJ55lDr4zfjglkanFyehpzzmaGbKXZiaUDH+s1Z7lYpwv0BhVnVhRTGptwvu1Sg2m1KgZblmLU5ybQFbewlCmxE8/G0lFOND4ffvHz7IVdttxgoxBaKVE7RxIFQ7C3q5IMviSJ3qtHd+xwHVywynA4nutvxko83HgcedPLdnJTaBbUNiFCKM9ruKMsDWVE/ObiqevstHYRW4SZvYrmS+B/XhH0/pezMYbqM2Q==");
  base64DecodeToExistingUint8Array(bufferView, 689368, "BgAAAAAAAAAG");
  base64DecodeToExistingUint8Array(bufferView, 689392, "BgAAAAAAAAByZXQASW52YWxpZCBmbGFncwBzZWxmIHRlc3QgZmFpbGVkAEZvciB0aGlzIHNhbXBsZSwgdGhpcyA2My1ieXRlIHN0cmluZyB3aWxsIGJlIHVzZWQgYXMgaW5wdXQgZGF0YQAoZmxhZ3MgJiBTRUNQMjU2SzFfRkxBR1NfVFlQRV9NQVNLKSA9PSBTRUNQMjU2SzFfRkxBR1NfVFlQRV9DT01QUkVTU0lPTgBzZWNrZXkgIT0gTlVMTAB4b25seV9wdWJrZXkgIT0gTlVMTABvdXRwdXRfcHVia2V5ICE9IE5VTEwAaW50ZXJuYWxfcHVia2V5ICE9IE5VTEwAb3V0cHV0ICE9IE5VTEwAaW5wdXQgIT0gTlVMTABwdWJub25jZXMgIT0gTlVMTABrZXlwYWlyICE9IE5VTEwAc2lnaW4gIT0gTlVMTABvdXRwdXRsZW4gIT0gTlVMTABzaWcgIT0gTlVMTABzaWduYXR1cmUgIT0gTlVMTABwdWJub25jZSAhPSBOVUxMAHJlY2lkICE9IE5VTEwAcHVibm9uY2VzW2ldICE9IE5VTEwAb3V0cHV0NjQgIT0gTlVMTABpbnB1dDY0ICE9IE5VTEwAc2lnNjQgIT0gTlVMTABzZWNrZXkzMiAhPSBOVUxMAHR3ZWFrZWRfcHVia2V5MzIgIT0gTlVMTABvdXRwdXQzMiAhPSBOVUxMAGlucHV0MzIgIT0gTlVMTAB0d2VhazMyICE9IE5VTEwAbXNnaGFzaDMyICE9IE5VTEwAcmVjaWQgPj0gMCAmJiByZWNpZCA8PSAzAG4gPj0gMQBtc2cgIT0gTlVMTCB8fCBtc2dsZW4gPT0gMABydXN0c2VjcDI1NmsxX3YwXzhfMV9lY211bHRfZ2VuX2NvbnRleHRfaXNfYnVpbHQoJmN0eC0+ZWNtdWx0X2dlbl9jdHgpACFydXN0c2VjcDI1NmsxX3YwXzhfMV9mZV9pc196ZXJvKCZnZS0+eCkAKm91dHB1dGxlbiA+PSAoKGZsYWdzICYgU0VDUDI1NksxX0ZMQUdTX0JJVF9DT01QUkVTU0lPTikgPyAzM3UgOiA2NXUpAAAAAAAABgAAAAAAAAAEAAAAAAAAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 690288, "8Ip4y7ruCCsFKuBwjzL6HlDFxCGqdyul27QGoupr40JBQTbQjF7SP+6AIr2ac7sq6/////////8=");
  base64DecodeToExistingUint8Array(bufferView, 690353, "AQAAAAAAAMFOd6qZAPI0AAEAAAAAAACYF/gWW4ECAJ+VjeLcsg0A/JsCBwuHDgBcKQZaxboLANz5fma+eQAAuNQQ+4/QBwDEmUFVaIoEALQX/agIEQ4AwL9P2lVGDACjJnfaOkg=");
  base64DecodeToExistingUint8Array(bufferView, 690464, "L/z///7///8=");
  base64DecodeToExistingUint8Array(bufferView, 690497, "AQAAAAAAAM/K2i3i9scngA==");
  base64DecodeToExistingUint8Array(bufferView, 690576, "w+S/Cql/VG8oiA4B1n5D5A==");
  base64DecodeToExistingUint8Array(bufferView, 690608, "LFaxPajNZddtNHQHxQooiv7///////////////////8xsNtFmiCT6H/K6HEUiqo9FeuEkuSQbOjNa9SnIdKGMHF/xIqutHEVxgb1nawIEiLE5L8KqX9UbyiIDgHWfkPkcr0jG3yWAt94ZoEg6iIuElpkEogCHCal4DBcwEytY1NCSVAwMzQwL25vbmNl");
  base64DecodeToExistingUint8Array(bufferView, 690752, "MIQK");
}
function wasm2js_trap() {
  throw new Error("abort");
}
function asmFunc(imports) {
  var buffer = new ArrayBuffer(720896);
  var HEAP8 = new Int8Array(buffer);
  var HEAP16 = new Int16Array(buffer);
  var HEAP32 = new Int32Array(buffer);
  var HEAPU8 = new Uint8Array(buffer);
  var HEAPU16 = new Uint16Array(buffer);
  var HEAPU32 = new Uint32Array(buffer);
  var HEAPF32 = new Float32Array(buffer);
  var HEAPF64 = new Float64Array(buffer);
  var Math_imul = Math.imul;
  var Math_fround = Math.fround;
  var Math_abs = Math.abs;
  var Math_clz32 = Math.clz32;
  var Math_min = Math.min;
  var Math_max = Math.max;
  var Math_floor = Math.floor;
  var Math_ceil = Math.ceil;
  var Math_trunc = Math.trunc;
  var Math_sqrt = Math.sqrt;
  var $_rand_js = imports["./rand.js"];
  var fimport$0 = $_rand_js.generateInt32;
  var $_validate_error_js = imports["./validate_error.js"];
  var fimport$1 = $_validate_error_js.throwError;
  var global$0 = 655360;
  var global$1 = 690820;
  var global$2 = 655584;
  var global$3 = 690949;
  var global$4 = 690885;
  var global$5 = 690917;
  var global$6 = 690788;
  var global$7 = 655649;
  var global$8 = 655681;
  var global$9 = 690981;
  var global$10 = 691052;
  var global$11 = 691056;
  var i64toi32_i32$HIGH_BITS = 0;
  function $0($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0;
    $4_1 = global$0 - 128 | 0;
    global$0 = $4_1;
    $0_1 = HEAP32[$0_1 >> 2];
    label$1: {
      label$2: {
        label$3: {
          label$4: {
            $2_1 = HEAP32[$1_1 + 24 >> 2];
            if (!($2_1 & 16)) {
              if ($2_1 & 32) {
                break label$4;
              }
              $0_1 = HEAP32[$0_1 >> 2];
              $2_1 = ($0_1 | 0) >= 0;
              $0_1 = $1($2_1 ? $0_1 : 0 - $0_1 | 0, $2_1 ? 0 : 0 - (($0_1 >> 31) + (($0_1 | 0) != 0) | 0) | 0, $2_1, $1_1);
              break label$3;
            }
            $0_1 = HEAP32[$0_1 >> 2];
            $2_1 = 0;
            while (1) {
              $3_1 = $0_1 & 15;
              HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 87);
              $2_1 = $2_1 - 1 | 0;
              $3_1 = $0_1 >>> 0 > 15;
              $0_1 = $0_1 >>> 4 | 0;
              if ($3_1) {
                continue;
              }
              break;
            }
            ;
            if ($2_1 + 128 >>> 0 >= 129) {
              break label$2;
            }
            $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
            break label$3;
          }
          $0_1 = HEAP32[$0_1 >> 2];
          $2_1 = 0;
          while (1) {
            $3_1 = $0_1 & 15;
            HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 55);
            $2_1 = $2_1 - 1 | 0;
            $3_1 = $0_1 >>> 0 > 15;
            $0_1 = $0_1 >>> 4 | 0;
            if ($3_1) {
              continue;
            }
            break;
          }
          ;
          if ($2_1 + 128 >>> 0 >= 129) {
            break label$1;
          }
          $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
        }
        global$0 = $4_1 + 128 | 0;
        return $0_1 | 0;
      }
      wasm2js_trap();
    }
    wasm2js_trap();
  }
  function $1($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
    $10_1 = global$0 - 48 | 0;
    global$0 = $10_1;
    $7_1 = 39;
    if (!(!$1_1 & $0_1 >>> 0 < 1e4)) {
      while (1) {
        $13_1 = ($10_1 + 9 | 0) + $7_1 | 0;
        $14_1 = $13_1 - 4 | 0;
        $5_1 = $0_1;
        $9_1 = 0;
        $11_1 = 0;
        __inlined_func$_ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E$2: {
          folding_inner0: {
            if (!$1_1) {
              $0_1 = ($5_1 >>> 0) / 1e4 | 0;
              break folding_inner0;
            }
            $6_1 = 51 - Math_clz32($1_1) | 0;
            $4_1 = 0 - $6_1 | 0;
            $8_1 = $6_1 & 63;
            $0_1 = $8_1 & 31;
            if ($8_1 >>> 0 >= 32) {
              $8_1 = $1_1 >>> $0_1 | 0;
            } else {
              $9_1 = $1_1 >>> $0_1 | 0;
              $8_1 = ((1 << $0_1) - 1 & $1_1) << 32 - $0_1 | $5_1 >>> $0_1;
            }
            $4_1 = $4_1 & 63;
            $0_1 = $4_1 & 31;
            if ($4_1 >>> 0 >= 32) {
              $4_1 = $5_1 << $0_1;
              $0_1 = 0;
            } else {
              $4_1 = (1 << $0_1) - 1 & $5_1 >>> 32 - $0_1 | $1_1 << $0_1;
              $0_1 = $5_1 << $0_1;
            }
            if ($6_1) {
              while (1) {
                $15_1 = $9_1 << 1 | $8_1 >>> 31;
                $12_1 = $8_1 << 1 | $4_1 >>> 31;
                $16_1 = 0 - ($15_1 + ($12_1 >>> 0 > 9999) | 0) >> 31;
                $9_1 = $16_1 & 1e4;
                $8_1 = $12_1 - $9_1 | 0;
                $9_1 = $15_1 - ($9_1 >>> 0 > $12_1 >>> 0) | 0;
                $4_1 = $4_1 << 1 | $0_1 >>> 31;
                $0_1 = $0_1 << 1 | $11_1;
                $11_1 = $16_1 & 1;
                $6_1 = $6_1 - 1 | 0;
                if ($6_1) {
                  continue;
                }
                break;
              }
            }
            i64toi32_i32$HIGH_BITS = $4_1 << 1 | $0_1 >>> 31;
            $0_1 = $0_1 << 1 | $11_1;
            break __inlined_func$_ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E$2;
          }
          i64toi32_i32$HIGH_BITS = 0;
        }
        $8_1 = i64toi32_i32$HIGH_BITS;
        $4_1 = __wasm_i64_mul($0_1, $8_1, 55536, 0) + $5_1 | 0;
        $9_1 = (($4_1 & 65535) >>> 0) / 100 | 0;
        $6_1 = ($9_1 << 1) + 655718 | 0;
        $6_1 = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8;
        HEAP8[$14_1 | 0] = $6_1;
        HEAP8[$14_1 + 1 | 0] = $6_1 >>> 8;
        $6_1 = $13_1 - 2 | 0;
        $4_1 = ((Math_imul($9_1, -100) + $4_1 & 65535) << 1) + 655718 | 0;
        $4_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8;
        HEAP8[$6_1 | 0] = $4_1;
        HEAP8[$6_1 + 1 | 0] = $4_1 >>> 8;
        $7_1 = $7_1 - 4 | 0;
        $5_1 = !$1_1 & $5_1 >>> 0 > 99999999 | ($1_1 | 0) != 0;
        $1_1 = $8_1;
        if ($5_1) {
          continue;
        }
        break;
      }
    }
    if ($0_1 >>> 0 > 99) {
      $7_1 = $7_1 - 2 | 0;
      $1_1 = $7_1 + ($10_1 + 9 | 0) | 0;
      $8_1 = $0_1;
      $0_1 = (($0_1 & 65535) >>> 0) / 100 | 0;
      $5_1 = (($8_1 + Math_imul($0_1, -100) & 65535) << 1) + 655718 | 0;
      $5_1 = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8;
      HEAP8[$1_1 | 0] = $5_1;
      HEAP8[$1_1 + 1 | 0] = $5_1 >>> 8;
    }
    label$5: {
      if ($0_1 >>> 0 >= 10) {
        $7_1 = $7_1 - 2 | 0;
        $1_1 = $7_1 + ($10_1 + 9 | 0) | 0;
        $0_1 = ($0_1 << 1) + 655718 | 0;
        $0_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8;
        HEAP8[$1_1 | 0] = $0_1;
        HEAP8[$1_1 + 1 | 0] = $0_1 >>> 8;
        break label$5;
      }
      $7_1 = $7_1 - 1 | 0;
      HEAP8[$7_1 + ($10_1 + 9 | 0) | 0] = $0_1 + 48;
    }
    $0_1 = $2($3_1, $2_1, 0, ($10_1 + 9 | 0) + $7_1 | 0, 39 - $7_1 | 0);
    global$0 = $10_1 + 48 | 0;
    return $0_1;
  }
  function $2($0_1, $1_1, $2_1, $3_1, $4_1) {
    var $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0;
    $9_1 = 655716;
    label$1: {
      if ($1_1) {
        $5_1 = HEAP32[$0_1 + 24 >> 2];
        $1_1 = $5_1 & 1;
        $10_1 = $1_1 ? 43 : 1114112;
        $6_1 = $1_1 + $4_1 | 0;
        break label$1;
      }
      $5_1 = HEAP32[$0_1 + 24 >> 2];
      $10_1 = 45;
      $6_1 = $4_1 + 1 | 0;
    }
    label$3: {
      if (!($5_1 & 4)) {
        $9_1 = 0;
        break label$3;
      }
      label$5: {
        if (!$2_1) {
          break label$5;
        }
        $7_1 = $2_1 & 3;
        if (!$7_1) {
          break label$5;
        }
        $1_1 = 655716;
        while (1) {
          $8_1 = $8_1 + (HEAP8[$1_1 | 0] > -65) | 0;
          $1_1 = $1_1 + 1 | 0;
          $7_1 = $7_1 - 1 | 0;
          if ($7_1) {
            continue;
          }
          break;
        }
        ;
      }
      $6_1 = $6_1 + $8_1 | 0;
    }
    label$7: {
      label$8: {
        if (!HEAP32[$0_1 + 8 >> 2]) {
          $1_1 = 1;
          $6_1 = HEAP32[$0_1 >> 2];
          $0_1 = HEAP32[$0_1 + 4 >> 2];
          if ($27($6_1, $0_1, $10_1, $9_1, $2_1)) {
            break label$8;
          }
          break label$7;
        }
        label$10: {
          label$11: {
            label$12: {
              label$13: {
                $7_1 = HEAP32[$0_1 + 12 >> 2];
                if ($7_1 >>> 0 > $6_1 >>> 0) {
                  if ($5_1 & 8) {
                    break label$10;
                  }
                  $5_1 = $7_1 - $6_1 | 0;
                  $6_1 = $5_1;
                  $1_1 = HEAPU8[$0_1 + 32 | 0];
                  $1_1 = ($1_1 | 0) == 3 ? 1 : $1_1;
                  switch ($1_1 - 1 | 0) {
                    case 1:
                      break label$12;
                    case 0:
                      break label$13;
                    default:
                      break label$11;
                  }
                  ;
                }
                $1_1 = 1;
                $6_1 = HEAP32[$0_1 >> 2];
                $0_1 = HEAP32[$0_1 + 4 >> 2];
                if ($27($6_1, $0_1, $10_1, $9_1, $2_1)) {
                  break label$8;
                }
                break label$7;
              }
              $6_1 = 0;
              $1_1 = $5_1;
              break label$11;
            }
            $1_1 = $5_1 >>> 1 | 0;
            $6_1 = $5_1 + 1 >>> 1 | 0;
          }
          $1_1 = $1_1 + 1 | 0;
          $5_1 = HEAP32[$0_1 + 4 >> 2];
          $8_1 = HEAP32[$0_1 + 28 >> 2];
          $7_1 = HEAP32[$0_1 >> 2];
          label$15: {
            while (1) {
              $1_1 = $1_1 - 1 | 0;
              if (!$1_1) {
                break label$15;
              }
              if (!(FUNCTION_TABLE[HEAP32[$5_1 + 16 >> 2]]($7_1, $8_1) | 0)) {
                continue;
              }
              break;
            }
            ;
            return 1;
          }
          $1_1 = 1;
          if (($8_1 | 0) == 1114112) {
            break label$8;
          }
          if ($27($7_1, $5_1, $10_1, $9_1, $2_1)) {
            break label$8;
          }
          if (FUNCTION_TABLE[HEAP32[$5_1 + 12 >> 2]]($7_1, $3_1, $4_1) | 0) {
            break label$8;
          }
          $1_1 = 0;
          label$17: {
            while (1) {
              $0_1 = $6_1;
              if (($0_1 | 0) == ($1_1 | 0)) {
                break label$17;
              }
              $1_1 = $1_1 + 1 | 0;
              if (!(FUNCTION_TABLE[HEAP32[$5_1 + 16 >> 2]]($7_1, $8_1) | 0)) {
                continue;
              }
              break;
            }
            ;
            $0_1 = $1_1 - 1 | 0;
          }
          $1_1 = $0_1 >>> 0 < $6_1 >>> 0;
          break label$8;
        }
        $11_1 = HEAP32[$0_1 + 28 >> 2];
        HEAP32[$0_1 + 28 >> 2] = 48;
        $12_1 = HEAPU8[$0_1 + 32 | 0];
        $1_1 = 1;
        HEAP8[$0_1 + 32 | 0] = 1;
        $5_1 = HEAP32[$0_1 >> 2];
        $8_1 = HEAP32[$0_1 + 4 >> 2];
        if ($27($5_1, $8_1, $10_1, $9_1, $2_1)) {
          break label$8;
        }
        $1_1 = ($7_1 - $6_1 | 0) + 1 | 0;
        label$19: {
          while (1) {
            $1_1 = $1_1 - 1 | 0;
            if (!$1_1) {
              break label$19;
            }
            if (!(FUNCTION_TABLE[HEAP32[$8_1 + 16 >> 2]]($5_1, 48) | 0)) {
              continue;
            }
            break;
          }
          ;
          return 1;
        }
        $1_1 = 1;
        if (FUNCTION_TABLE[HEAP32[$8_1 + 12 >> 2]]($5_1, $3_1, $4_1) | 0) {
          break label$8;
        }
        HEAP8[$0_1 + 32 | 0] = $12_1;
        HEAP32[$0_1 + 28 >> 2] = $11_1;
        return 0;
      }
      return $1_1;
    }
    return FUNCTION_TABLE[HEAP32[$0_1 + 12 >> 2]]($6_1, $3_1, $4_1) | 0;
  }
  function $3($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0;
    $4_1 = global$0 - 128 | 0;
    global$0 = $4_1;
    $0_1 = HEAP32[$0_1 >> 2];
    label$1: {
      label$2: {
        label$3: {
          label$4: {
            $2_1 = HEAP32[$1_1 + 24 >> 2];
            if (!($2_1 & 16)) {
              if ($2_1 & 32) {
                break label$4;
              }
              $0_1 = $1(HEAP32[$0_1 >> 2], 0, 1, $1_1);
              break label$3;
            }
            $0_1 = HEAP32[$0_1 >> 2];
            $2_1 = 0;
            while (1) {
              $3_1 = $0_1 & 15;
              HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 87);
              $2_1 = $2_1 - 1 | 0;
              $3_1 = $0_1 >>> 0 > 15;
              $0_1 = $0_1 >>> 4 | 0;
              if ($3_1) {
                continue;
              }
              break;
            }
            ;
            if ($2_1 + 128 >>> 0 >= 129) {
              break label$2;
            }
            $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
            break label$3;
          }
          $0_1 = HEAP32[$0_1 >> 2];
          $2_1 = 0;
          while (1) {
            $3_1 = $0_1 & 15;
            HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 55);
            $2_1 = $2_1 - 1 | 0;
            $3_1 = $0_1 >>> 0 > 15;
            $0_1 = $0_1 >>> 4 | 0;
            if ($3_1) {
              continue;
            }
            break;
          }
          ;
          if ($2_1 + 128 >>> 0 >= 129) {
            break label$1;
          }
          $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
        }
        global$0 = $4_1 + 128 | 0;
        return $0_1 | 0;
      }
      wasm2js_trap();
    }
    wasm2js_trap();
  }
  function $4($0_1) {
    $0_1 = $0_1 | 0;
  }
  function $5($0_1) {
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0;
    $3_1 = global$0 - 32 | 0;
    global$0 = $3_1;
    $1_1 = $0_1 + 16 | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $2_1 = $3_1 + 8 | 0;
    $5_1 = $2_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $4_1;
    $1_1 = $0_1 + 8 | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $2_1 = $2_1 + 8 | 0;
    HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$2_1 + 4 >> 2] = $4_1;
    $1_1 = HEAP32[$0_1 + 4 >> 2];
    HEAP32[$3_1 + 8 >> 2] = HEAP32[$0_1 >> 2];
    HEAP32[$3_1 + 12 >> 2] = $1_1;
    wasm2js_trap();
  }
  function $6() {
    var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
    $33_1 = global$0 - 32 | 0;
    global$0 = $33_1;
    label$1: {
      if (HEAPU8[690756]) {
        $47_1 = HEAP32[172762];
        break label$1;
      }
      HEAP32[$33_1 >> 2] = 192;
      HEAP32[$33_1 + 4 >> 2] = 192;
      $0_1 = global$0 - 144 | 0;
      global$0 = $0_1;
      HEAP32[$0_1 + 104 >> 2] = 0;
      HEAP32[$0_1 + 108 >> 2] = 0;
      HEAP32[$0_1 + 32 >> 2] = 528734635;
      HEAP32[$0_1 + 36 >> 2] = 1541459225;
      HEAP32[$0_1 + 24 >> 2] = 1359893119;
      HEAP32[$0_1 + 28 >> 2] = -1694144372;
      HEAP32[$0_1 + 16 >> 2] = 1013904242;
      HEAP32[$0_1 + 20 >> 2] = -1521486534;
      HEAP32[$0_1 + 8 >> 2] = 1779033703;
      HEAP32[$0_1 + 12 >> 2] = -1150833019;
      $1_1 = $0_1 + 8 | 0;
      $29($1_1, 689435, 63);
      $30($1_1, $0_1 + 112 | 0);
      while (1) {
        $4_1 = HEAPU8[($0_1 + 112 | 0) + $3_1 | 0] - HEAPU8[$3_1 + 690288 | 0] | 0;
        if (!$4_1) {
          $1_1 = ($3_1 | 0) != 31;
          $3_1 = $3_1 + 1 | 0;
          if ($1_1) {
            continue;
          }
        }
        break;
      }
      ;
      if ($4_1) {
        $28(689418, 0);
      }
      HEAP32[163880] = 0;
      HEAP32[163881] = 0;
      HEAP32[163878] = 1;
      HEAP32[163879] = 0;
      $1_1 = HEAP32[172349];
      HEAP32[163892] = HEAP32[172348];
      HEAP32[163893] = $1_1;
      $1_1 = HEAP32[172559];
      HEAP32[163890] = HEAP32[172558];
      HEAP32[163891] = $1_1;
      $1_1 = HEAP32[172595];
      HEAP32[163858] = HEAP32[172594];
      HEAP32[163859] = $1_1;
      $1_1 = HEAP32[172597];
      HEAP32[163860] = HEAP32[172596];
      HEAP32[163861] = $1_1;
      $1_1 = HEAP32[172599];
      HEAP32[163862] = HEAP32[172598];
      HEAP32[163863] = $1_1;
      $1_1 = HEAP32[172601];
      HEAP32[163864] = HEAP32[172600];
      HEAP32[163865] = $1_1;
      $1_1 = HEAP32[172603];
      HEAP32[163866] = HEAP32[172602];
      HEAP32[163867] = $1_1;
      HEAP32[163882] = 0;
      HEAP32[163883] = 0;
      HEAP32[163884] = 0;
      HEAP32[163885] = 0;
      HEAP32[163886] = 0;
      HEAP32[163887] = 0;
      HEAP32[163888] = 0;
      HEAP32[163876] = 629725529;
      HEAP32[163877] = 243653;
      HEAP32[163874] = 632307772;
      HEAP32[163875] = 3389866;
      HEAP32[163872] = 1459808328;
      HEAP32[163873] = 3272439;
      HEAP32[163870] = -1430362568;
      HEAP32[163871] = 3896727;
      HEAP32[163868] = 82779140;
      HEAP32[163869] = 3682156;
      HEAP32[163856] = 0;
      HEAP32[163857] = 0;
      HEAP32[163850] = 1;
      HEAP32[163851] = 0;
      HEAP32[163854] = 0;
      HEAP32[163855] = 0;
      HEAP32[163852] = 0;
      HEAP32[163853] = 0;
      HEAP32[163894] = 0;
      HEAP32[163848] = 1;
      global$0 = $0_1 + 144 | 0;
      $47_1 = 655392;
      wasm2js_i32$0 = 690756, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690760, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690764, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690768, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690772, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690776, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690780, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      wasm2js_i32$0 = 690784, wasm2js_i32$1 = fimport$0() | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      $14_1 = global$0 - 720 | 0;
      global$0 = $14_1;
      if (HEAP32[163848]) {
        $0_1 = HEAPU8[690760] | HEAPU8[690761] << 8 | (HEAPU8[690762] << 16 | HEAPU8[690763] << 24);
        $12_1 = $14_1 + 336 | 0;
        $13_1 = $12_1 + 32 | 0;
        HEAP32[$13_1 >> 2] = HEAPU8[690756] | HEAPU8[690757] << 8 | (HEAPU8[690758] << 16 | HEAPU8[690759] << 24);
        HEAP32[$13_1 + 4 >> 2] = $0_1;
        $0_1 = HEAPU8[690768] | HEAPU8[690769] << 8 | (HEAPU8[690770] << 16 | HEAPU8[690771] << 24);
        $10_1 = $12_1 + 40 | 0;
        HEAP32[$10_1 >> 2] = HEAPU8[690764] | HEAPU8[690765] << 8 | (HEAPU8[690766] << 16 | HEAPU8[690767] << 24);
        HEAP32[$10_1 + 4 >> 2] = $0_1;
        $0_1 = HEAPU8[690776] | HEAPU8[690777] << 8 | (HEAPU8[690778] << 16 | HEAPU8[690779] << 24);
        $7_1 = $14_1 + 384 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[690772] | HEAPU8[690773] << 8 | (HEAPU8[690774] << 16 | HEAPU8[690775] << 24);
        HEAP32[$7_1 + 4 >> 2] = $0_1;
        $0_1 = HEAPU8[690784] | HEAPU8[690785] << 8 | (HEAPU8[690786] << 16 | HEAPU8[690787] << 24);
        $8_1 = $14_1 + 392 | 0;
        HEAP32[$8_1 >> 2] = HEAPU8[690780] | HEAPU8[690781] << 8 | (HEAPU8[690782] << 16 | HEAPU8[690783] << 24);
        HEAP32[$8_1 + 4 >> 2] = $0_1;
        $4_1 = HEAP32[163850];
        $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
        $2_1 = $4_1 >>> 8 | 0;
        $1_1 = HEAP32[163851];
        $3_1 = ($2_1 | $1_1 << 24) & 65280;
        $4_1 = $4_1 >>> 24 | 0;
        $5_1 = $5_1 | ($3_1 | ($4_1 | $1_1 << 8) & 255);
        $0_1 = $1_1;
        $3_1 = ($2_1 | ($0_1 & 255) << 24) & -16777216;
        $3_1 = $3_1 | ($4_1 | ($0_1 & 16777215) << 8) & 16711680;
        $9_1 = $12_1 + 24 | 0;
        HEAP32[$9_1 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
        HEAP32[$9_1 + 4 >> 2] = $5_1;
        $4_1 = HEAP32[163852];
        $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
        $1_1 = HEAP32[163853];
        $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
        $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
        $0_1 = $1_1;
        $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
        $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
        $11_1 = $12_1 + 16 | 0;
        HEAP32[$11_1 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
        HEAP32[$11_1 + 4 >> 2] = $5_1;
        $4_1 = HEAP32[163856];
        $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
        $1_1 = HEAP32[163857];
        $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
        $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
        $0_1 = $1_1;
        $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
        $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
        $2_1 = $14_1;
        HEAP32[$2_1 + 336 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
        HEAP32[$2_1 + 340 >> 2] = $5_1;
        $4_1 = HEAP32[163854];
        $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
        $1_1 = HEAP32[163855];
        $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
        $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
        $0_1 = $1_1;
        $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
        $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
        HEAP32[$2_1 + 344 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
        HEAP32[$2_1 + 348 >> 2] = $5_1;
        $39_1 = $2_1 + 408 | 0;
        $45($39_1, $12_1, 64);
        HEAP32[$8_1 >> 2] = 0;
        HEAP32[$8_1 + 4 >> 2] = 0;
        HEAP32[$7_1 >> 2] = 0;
        HEAP32[$7_1 + 4 >> 2] = 0;
        HEAP32[$10_1 >> 2] = 0;
        HEAP32[$10_1 + 4 >> 2] = 0;
        HEAP32[$13_1 >> 2] = 0;
        HEAP32[$13_1 + 4 >> 2] = 0;
        HEAP32[$9_1 >> 2] = 0;
        HEAP32[$9_1 + 4 >> 2] = 0;
        HEAP32[$11_1 >> 2] = 0;
        HEAP32[$11_1 + 4 >> 2] = 0;
        HEAP32[$2_1 + 344 >> 2] = 0;
        HEAP32[$2_1 + 348 >> 2] = 0;
        HEAP32[$2_1 + 336 >> 2] = 0;
        HEAP32[$2_1 + 340 >> 2] = 0;
        $34_1 = $2_1 + 480 | 0;
        $46($39_1, $34_1);
        $1_1 = HEAPU8[$2_1 + 497 | 0];
        $0_1 = $1_1 >>> 24 | 0;
        $3_1 = HEAPU8[$2_1 + 498 | 0] | $1_1 << 8;
        $1_1 = $0_1;
        $45_1 = $34_1 + 16 | 0;
        $4_1 = HEAPU8[$45_1 | 0];
        $0_1 = $4_1 >>> 16 | 0;
        $3_1 = $4_1 << 16 | $3_1;
        $4_1 = $0_1 | $1_1;
        $1_1 = HEAPU8[$2_1 + 495 | 0];
        $0_1 = $1_1 >>> 8 | 0;
        $3_1 = $3_1 | $1_1 << 24;
        $11_1 = HEAPU8[$2_1 + 492 | 0];
        $4_1 = HEAPU8[$2_1 + 494 | 0] | ($0_1 | $4_1) | HEAPU8[$2_1 + 493 | 0] << 8 | ($11_1 & 15) << 16;
        $1_1 = HEAPU8[$2_1 + 484 | 0];
        $0_1 = $1_1 >>> 24 | 0;
        $6_1 = HEAPU8[$2_1 + 485 | 0] | $1_1 << 8;
        $1_1 = $0_1;
        $5_1 = HEAPU8[$2_1 + 483 | 0];
        $0_1 = $5_1 >>> 16 | 0;
        $6_1 = $5_1 << 16 | $6_1;
        $5_1 = $0_1 | $1_1;
        $1_1 = HEAPU8[$2_1 + 482 | 0];
        $0_1 = $1_1 >>> 8 | 0;
        $12_1 = $1_1 << 24 | $6_1;
        $13_1 = HEAPU8[$2_1 + 481 | 0] | ($0_1 | $5_1) | HEAPU8[$2_1 + 480 | 0] << 8;
        $1_1 = HEAPU8[$2_1 + 491 | 0];
        $0_1 = $1_1 >>> 28 | 0;
        $6_1 = $1_1 << 4 | $11_1 >>> 4;
        $1_1 = $0_1;
        $5_1 = HEAPU8[$2_1 + 490 | 0];
        $0_1 = $5_1 >>> 20 | 0;
        $6_1 = $5_1 << 12 | $6_1;
        $5_1 = $0_1 | $1_1;
        $1_1 = HEAPU8[$2_1 + 489 | 0];
        $0_1 = $1_1 >>> 12 | 0;
        $6_1 = $1_1 << 20 | $6_1;
        $5_1 = $0_1 | $5_1;
        $1_1 = HEAPU8[$2_1 + 488 | 0];
        $0_1 = $1_1 >>> 4 | 0;
        $10_1 = $1_1 << 28 | $6_1;
        $7_1 = $0_1 | $5_1 | HEAPU8[$2_1 + 487 | 0] << 4 | HEAPU8[$2_1 + 486 | 0] << 12;
        $46_1 = $34_1 + 24 | 0;
        $1_1 = HEAPU8[$46_1 | 0];
        $0_1 = $1_1 >>> 28 | 0;
        $8_1 = HEAPU8[$2_1 + 505 | 0];
        $6_1 = $1_1 << 4 | $8_1 >>> 4;
        $1_1 = $0_1;
        $5_1 = HEAPU8[$2_1 + 503 | 0];
        $0_1 = $5_1 >>> 20 | 0;
        $6_1 = $5_1 << 12 | $6_1;
        $5_1 = $0_1 | $1_1;
        $1_1 = HEAPU8[$2_1 + 502 | 0];
        $0_1 = $1_1 >>> 12 | 0;
        $6_1 = $1_1 << 20 | $6_1;
        $5_1 = $0_1 | $5_1;
        $1_1 = HEAPU8[$2_1 + 501 | 0];
        $0_1 = $1_1 >>> 4 | 0;
        $9_1 = $1_1 << 28 | $6_1;
        $20_1 = $0_1 | $5_1 | HEAPU8[$2_1 + 500 | 0] << 4 | HEAPU8[$2_1 + 499 | 0] << 12;
        $11_1 = $20_1;
        $1_1 = HEAPU8[$2_1 + 510 | 0];
        $0_1 = $1_1 >>> 24 | 0;
        $6_1 = HEAPU8[$2_1 + 511 | 0] | $1_1 << 8;
        $1_1 = $0_1;
        $5_1 = HEAPU8[$2_1 + 509 | 0];
        $0_1 = $5_1 >>> 16 | 0;
        $6_1 = $5_1 << 16 | $6_1;
        $5_1 = $0_1 | $1_1;
        $1_1 = HEAPU8[$2_1 + 508 | 0];
        $0_1 = $1_1 >>> 8 | 0;
        $29_1 = $2_1 + 520 | 0;
        $40_1 = $29_1 + 32 | 0;
        $1_1 = $6_1 | $1_1 << 24;
        $8_1 = HEAPU8[$2_1 + 507 | 0] | ($0_1 | $5_1) | HEAPU8[$2_1 + 506 | 0] << 8 | ($8_1 & 15) << 16;
        $0_1 = !($12_1 | ($10_1 | ($3_1 | ($1_1 | $9_1))) | ($13_1 | ($7_1 | ($4_1 | ($8_1 | $11_1))))) | ($3_1 & $9_1 & $10_1) == -1 & ($4_1 & $11_1 & $7_1) == 1048575 & (($12_1 | 0) == -1 & ($13_1 | 0) == 65535) & (($8_1 | 0) == 1048574 & $1_1 >>> 0 > 4294966318 | $8_1 >>> 0 > 1048574);
        $5_1 = $0_1 - 1 | 0;
        $11_1 = $5_1 & $12_1;
        HEAP32[$40_1 >> 2] = $11_1;
        $6_1 = $13_1;
        $13_1 = 0 - !$0_1 | 0;
        $6_1 = $6_1 & $13_1;
        HEAP32[$40_1 + 4 >> 2] = $6_1;
        $41_1 = $29_1 + 24 | 0;
        $23_1 = $5_1 & $10_1;
        HEAP32[$41_1 >> 2] = $23_1;
        $24_1 = $7_1 & $13_1;
        HEAP32[$41_1 + 4 >> 2] = $24_1;
        $42_1 = $29_1 + 16 | 0;
        $18_1 = $3_1 & $5_1;
        HEAP32[$42_1 >> 2] = $18_1;
        $15_1 = $4_1 & $13_1;
        HEAP32[$42_1 + 4 >> 2] = $15_1;
        $43_1 = $29_1 + 8 | 0;
        $21_1 = $5_1 & $9_1;
        HEAP32[$43_1 >> 2] = $21_1;
        $16_1 = $13_1 & $20_1;
        HEAP32[$43_1 + 4 >> 2] = $16_1;
        $5_1 = $1_1 & $5_1 | $0_1;
        HEAP32[$2_1 + 520 >> 2] = $5_1;
        $0_1 = $8_1 & $13_1;
        $20_1 = $0_1;
        HEAP32[$2_1 + 524 >> 2] = $0_1;
        $12_1 = $2_1 + 128 | 0;
        $30_1 = $5_1 << 1;
        $25_1 = $0_1 << 1 | $5_1 >>> 31;
        $69($12_1, $30_1, $25_1, 0, 0, $23_1, $24_1, 0, 0);
        $13_1 = $2_1 + 192 | 0;
        $4_1 = $21_1 << 1;
        $3_1 = $16_1 << 1 | $21_1 >>> 31;
        $69($13_1, $4_1, $3_1, 0, 0, $18_1, $15_1, 0, 0);
        $7_1 = $2_1 + 320 | 0;
        $69($7_1, $11_1, $6_1, 0, 0, $11_1, $6_1, 0, 0);
        $8_1 = $2_1 + 304 | 0;
        $69($8_1, HEAP32[$2_1 + 320 >> 2], HEAP32[$2_1 + 324 >> 2], 0, 0, 15632, 16, 0, 0);
        $1_1 = $11_1;
        $0_1 = $6_1 << 1 | $1_1 >>> 31;
        $35_1 = $2_1 + 80 | 0;
        $44_1 = $1_1 << 1;
        $26_1 = $0_1;
        $69($35_1, $44_1, $0_1, 0, 0, $5_1, $20_1, 0, 0);
        $36_1 = $2_1 + 176 | 0;
        $69($36_1, $4_1, $3_1, 0, 0, $23_1, $24_1, 0, 0);
        $37_1 = $2_1 + 240 | 0;
        $69($37_1, $18_1, $15_1, 0, 0, $18_1, $15_1, 0, 0);
        $10_1 = $2_1 + 288 | 0;
        $0_1 = $7_1 + 8 | 0;
        $69($10_1, HEAP32[$0_1 >> 2], HEAP32[$0_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $69($2_1, $5_1, $20_1, 0, 0, $5_1, $20_1, 0, 0);
        $48_1 = $2_1 + 160 | 0;
        $69($48_1, $44_1, $26_1, 0, 0, $21_1, $16_1, 0, 0);
        $31_1 = $2_1 + 208 | 0;
        $69($31_1, $18_1 << 1, $15_1 << 1 | $18_1 >>> 31, 0, 0, $23_1, $24_1, 0, 0);
        $7_1 = HEAP32[$2_1 + 132 >> 2];
        $0_1 = $7_1 + HEAP32[$2_1 + 196 >> 2] | 0;
        $5_1 = HEAP32[$2_1 + 128 >> 2];
        $4_1 = HEAP32[$2_1 + 192 >> 2];
        $1_1 = $5_1 + $4_1 | 0;
        $3_1 = HEAP32[$2_1 + 304 >> 2];
        $20_1 = $1_1 + $3_1 | 0;
        $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $4_1 + HEAP32[$2_1 + 308 >> 2] | 0;
        $3_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $9_1 = ($4_1 | 0) == ($3_1 | 0) & $1_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $0_1 = $8_1 + 8 | 0;
        $11_1 = HEAP32[$0_1 >> 2];
        $6_1 = HEAP32[$0_1 + 4 >> 2];
        $5_1 = ($4_1 | 0) == ($7_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
        $4_1 = $13_1 + 8 | 0;
        $1_1 = HEAP32[$4_1 >> 2];
        $0_1 = $12_1 + 8 | 0;
        $8_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = $5_1 + $8_1 | 0;
        $0_1 = ($1_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $6_1 | 0;
        $4_1 = $1_1;
        $1_1 = $1_1 + $11_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $1_1;
        $1_1 = $1_1 + $9_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $12_1 = $3_1;
        $11_1 = $1_1 << 12 | $3_1 >>> 20;
        $4_1 = $0_1;
        $5_1 = $0_1 << 12 | $1_1 >>> 20;
        $38_1 = HEAP32[$2_1 + 176 >> 2];
        $1_1 = HEAP32[$2_1 + 240 >> 2];
        $9_1 = $38_1 + $1_1 | 0;
        $32_1 = HEAP32[$2_1 + 180 >> 2];
        $0_1 = $32_1 + HEAP32[$2_1 + 244 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = HEAP32[$2_1 + 80 >> 2];
        $6_1 = $1_1 + $9_1 | 0;
        $7_1 = $0_1;
        $0_1 = $0_1 + HEAP32[$2_1 + 84 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = HEAP32[$2_1 + 288 >> 2];
        $3_1 = $1_1 + $6_1 | 0;
        $8_1 = $0_1;
        $0_1 = $0_1 + HEAP32[$2_1 + 292 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $1_1 + $5_1 | 0;
        $27_1 = $2_1 + 16 | 0;
        $11_1 = $3_1 + $11_1 | 0;
        $5_1 = $11_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $22_1 = ($1_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
        $28_1 = ($1_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 > $3_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
        $0_1 = $10_1 + 8 | 0;
        $17_1 = HEAP32[$0_1 >> 2];
        $19_1 = HEAP32[$0_1 + 4 >> 2];
        $13_1 = ($7_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $9_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $0_1 = $35_1 + 8 | 0;
        $10_1 = HEAP32[$0_1 >> 2];
        $8_1 = HEAP32[$0_1 + 4 >> 2];
        $6_1 = ($7_1 | 0) == ($32_1 | 0) & $9_1 >>> 0 < $38_1 >>> 0 | $7_1 >>> 0 < $32_1 >>> 0;
        $3_1 = $37_1 + 8 | 0;
        $1_1 = HEAP32[$3_1 >> 2];
        $0_1 = $36_1 + 8 | 0;
        $9_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = $6_1 + $9_1 | 0;
        $0_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $8_1 | 0;
        $3_1 = $1_1;
        $1_1 = $1_1 + $10_1 | 0;
        $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $1_1;
        $1_1 = $1_1 + $13_1 | 0;
        $0_1 = ($3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $19_1 | 0;
        $3_1 = $1_1;
        $1_1 = $1_1 + $17_1 | 0;
        $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $1_1 + $28_1 | 0;
        $0_1 = $3_1 >>> 0 < $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $4_1 >>> 20 | 0;
        $1_1 = $3_1 + $4_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $1_1;
        $1_1 = $1_1 + $22_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $5_1;
        $6_1 = $1_1 << 12 | $4_1 >>> 20;
        $3_1 = $0_1;
        $9_1 = $0_1 << 12 | $1_1 >>> 20;
        $17_1 = HEAP32[$2_1 + 164 >> 2];
        $0_1 = $17_1 + HEAP32[$2_1 + 212 >> 2] | 0;
        $10_1 = HEAP32[$2_1 + 160 >> 2];
        $1_1 = HEAP32[$2_1 + 208 >> 2];
        $5_1 = $10_1 + $1_1 | 0;
        $8_1 = $5_1;
        $6_1 = $5_1 + $6_1 | 0;
        $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $1_1 + $9_1 | 0;
        $7_1 = $6_1 << 4 & -16;
        $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $9_1 = ($5_1 << 4 | $6_1 >>> 28) & 16777215;
        $13_1 = $4_1;
        $69($27_1, $7_1 | $4_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
        $22_1 = HEAP32[$2_1 + 20 >> 2];
        $0_1 = $22_1 + HEAP32[$2_1 + 4 >> 2] | 0;
        $28_1 = HEAP32[$2_1 + 16 >> 2];
        $4_1 = HEAP32[$2_1 >> 2];
        $9_1 = $28_1 + $4_1 | 0;
        HEAP32[$2_1 + 560 >> 2] = $9_1;
        $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        HEAP32[$2_1 + 564 >> 2] = $4_1 & 1048575;
        $35_1 = $2_1 + 112 | 0;
        $69($35_1, $30_1, $25_1, 0, 0, $21_1, $16_1, 0, 0);
        $36_1 = $2_1 + 224 | 0;
        $69($36_1, $44_1, $26_1, 0, 0, $18_1, $15_1, 0, 0);
        $37_1 = $2_1 + 272 | 0;
        $69($37_1, $23_1, $24_1, 0, 0, $23_1, $24_1, 0, 0);
        $38_1 = $2_1 - -64 | 0;
        $19_1 = $38_1;
        $7_1 = ($1_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
        $8_1 = ($1_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
        $6_1 = $31_1 + 8 | 0;
        $1_1 = HEAP32[$6_1 >> 2];
        $0_1 = $48_1 + 8 | 0;
        $10_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $8_1 + $10_1 | 0;
        $0_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $3_1 >>> 20 | 0;
        $1_1 = $6_1 + $3_1 | 0;
        $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $1_1;
        $1_1 = $1_1 + $7_1 | 0;
        $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $8_1 = $1_1 << 12 | $5_1 >>> 20;
        $6_1 = $0_1;
        $5_1 = $0_1 << 12 | $1_1 >>> 20;
        $32_1 = HEAP32[$2_1 + 224 >> 2];
        $1_1 = HEAP32[$2_1 + 272 >> 2];
        $17_1 = $32_1 + $1_1 | 0;
        $31_1 = HEAP32[$2_1 + 228 >> 2];
        $0_1 = $31_1 + HEAP32[$2_1 + 276 >> 2] | 0;
        $3_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $3_1 + $5_1 | 0;
        $10_1 = $8_1 + $17_1 | 0;
        $0_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $8_1 = $0_1;
        $69($19_1, $10_1, $0_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $9_1 = ($4_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $28_1 >>> 0 | $4_1 >>> 0 < $22_1 >>> 0;
        $5_1 = $2_1 + 8 | 0;
        $1_1 = HEAP32[$5_1 >> 2];
        $0_1 = $27_1 + 8 | 0;
        $7_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = $7_1 + $9_1 | 0;
        $0_1 = $1_1 >>> 0 < $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $7_1 = $1_1 << 12 | $4_1 >>> 20;
        $5_1 = $0_1;
        $9_1 = $0_1 << 12 | $1_1 >>> 20;
        $22_1 = HEAP32[$2_1 + 64 >> 2];
        $1_1 = HEAP32[$2_1 + 112 >> 2];
        $19_1 = $22_1 + $1_1 | 0;
        $27_1 = HEAP32[$2_1 + 68 >> 2];
        $0_1 = $27_1 + HEAP32[$2_1 + 116 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $19_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $4_1 + $9_1 | 0;
        $7_1 = $7_1 + $19_1 | 0;
        $0_1 = $7_1 >>> 0 < $19_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        HEAP32[$2_1 + 568 >> 2] = $7_1;
        $9_1 = $0_1;
        HEAP32[$2_1 + 572 >> 2] = $0_1 & 1048575;
        $28_1 = $2_1 + 96 | 0;
        $69($28_1, $30_1, $25_1, 0, 0, $18_1, $15_1, 0, 0);
        $30_1 = $2_1 + 144 | 0;
        $69($30_1, $21_1, $16_1, 0, 0, $21_1, $16_1, 0, 0);
        $21_1 = $2_1 + 256 | 0;
        $69($21_1, $44_1, $26_1, 0, 0, $23_1, $24_1, 0, 0);
        $18_1 = $2_1 + 48 | 0;
        $15_1 = ($3_1 | 0) == ($8_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $10_1 = ($3_1 | 0) == ($31_1 | 0) & $17_1 >>> 0 < $32_1 >>> 0 | $3_1 >>> 0 < $31_1 >>> 0;
        $3_1 = $37_1 + 8 | 0;
        $1_1 = HEAP32[$3_1 >> 2];
        $0_1 = $36_1 + 8 | 0;
        $16_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $10_1 + $16_1 | 0;
        $0_1 = $3_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $6_1 + $3_1 | 0;
        $0_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $1_1;
        $1_1 = $1_1 + $15_1 | 0;
        $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $16_1 = $1_1 << 12 | $8_1 >>> 20;
        $6_1 = HEAP32[$2_1 + 256 >> 2];
        $8_1 = $16_1 + $6_1 | 0;
        $3_1 = $0_1;
        $25_1 = $0_1 << 12 | $1_1 >>> 20;
        $0_1 = $25_1 + HEAP32[$2_1 + 260 >> 2] | 0;
        $10_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $69($18_1, $8_1, $10_1, 0, 0, 15632, 16, 0, 0);
        $6_1 = $2_1;
        $7_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
        $2_1 = ($4_1 | 0) == ($27_1 | 0) & $19_1 >>> 0 < $22_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
        $4_1 = $35_1 + 8 | 0;
        $1_1 = HEAP32[$4_1 >> 2];
        $0_1 = $38_1 + 8 | 0;
        $15_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $2_1 + $15_1 | 0;
        $0_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $5_1 = $5_1 >>> 20 | 0;
        $1_1 = $5_1 + $4_1 | 0;
        $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $1_1;
        $1_1 = $1_1 + $7_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $2_1 = $1_1 << 12 | $9_1 >>> 20;
        $4_1 = $0_1;
        $5_1 = $0_1 << 12 | $1_1 >>> 20;
        $17_1 = HEAP32[$6_1 + 96 >> 2];
        $1_1 = HEAP32[$6_1 + 144 >> 2];
        $7_1 = $17_1 + $1_1 | 0;
        $26_1 = HEAP32[$6_1 + 100 >> 2];
        $0_1 = $26_1 + HEAP32[$6_1 + 148 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = HEAP32[$6_1 + 48 >> 2];
        $9_1 = $1_1 + $7_1 | 0;
        $15_1 = $0_1;
        $0_1 = $0_1 + HEAP32[$6_1 + 52 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $1_1 + $5_1 | 0;
        $2_1 = $2_1 + $9_1 | 0;
        $0_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        HEAP32[$6_1 + 576 >> 2] = $2_1;
        $5_1 = $0_1;
        HEAP32[$6_1 + 580 >> 2] = $0_1 & 1048575;
        $19_1 = $6_1 + 32 | 0;
        $16_1 = ($10_1 | 0) == ($25_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $10_1 >>> 0 < $25_1 >>> 0;
        $0_1 = $21_1 + 8 | 0;
        $10_1 = HEAP32[$0_1 >> 2];
        $0_1 = HEAP32[$0_1 + 4 >> 2];
        $3_1 = $3_1 >>> 20 | 0;
        $8_1 = $3_1;
        $3_1 = $3_1 + $10_1 | 0;
        $0_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $8_1 = $3_1;
        $3_1 = $3_1 + $16_1 | 0;
        $0_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $69($19_1, $3_1, $0_1, 0, 0, 64028672, 65536, 0, 0);
        $3_1 = $6_1;
        $16_1 = ($1_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
        $10_1 = ($1_1 | 0) == ($15_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
        $0_1 = $18_1 + 8 | 0;
        $8_1 = HEAP32[$0_1 >> 2];
        $9_1 = HEAP32[$0_1 + 4 >> 2];
        $2_1 = ($15_1 | 0) == ($26_1 | 0) & $7_1 >>> 0 < $17_1 >>> 0 | $15_1 >>> 0 < $26_1 >>> 0;
        $6_1 = $30_1 + 8 | 0;
        $1_1 = HEAP32[$6_1 >> 2];
        $0_1 = $28_1 + 8 | 0;
        $7_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
        $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = $2_1 + $7_1 | 0;
        $0_1 = ($1_1 >>> 0 < $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $9_1 | 0;
        $6_1 = $1_1;
        $1_1 = $1_1 + $8_1 | 0;
        $0_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $6_1 = $1_1 + $10_1 | 0;
        $0_1 = $6_1 >>> 0 < $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $4_1 >>> 20 | 0;
        $1_1 = $6_1 + $4_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $9_1 = $1_1 << 12 | $5_1 >>> 20;
        $4_1 = $0_1;
        $5_1 = $0_1 << 12 | $1_1 >>> 20;
        $7_1 = HEAP32[$3_1 + 32 >> 2];
        $1_1 = $20_1 & -2;
        $6_1 = $7_1 + $1_1 | 0;
        $10_1 = HEAP32[$3_1 + 36 >> 2];
        $0_1 = $10_1 + ($12_1 & 1048575) | 0;
        $2_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $2_1 + $5_1 | 0;
        $5_1 = $6_1 + $9_1 | 0;
        $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        HEAP32[$3_1 + 584 >> 2] = $5_1;
        $1_1 = $0_1;
        HEAP32[$3_1 + 588 >> 2] = $0_1 & 1048575;
        $8_1 = $13_1 & 65535;
        $9_1 = ($0_1 | 0) == ($2_1 | 0) & $6_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
        $3_1 = ($2_1 | 0) == ($10_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
        $0_1 = $19_1 + 8 | 0;
        $5_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
        $0_1 = HEAP32[$0_1 + 4 >> 2];
        $0_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1;
        $4_1 = $5_1 + $4_1 | 0;
        $0_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $3_1 = $4_1;
        $4_1 = $4_1 + $9_1 | 0;
        $0_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $1_1 = $4_1 << 12 | $1_1 >>> 20;
        $3_1 = $1_1 + $11_1 | 0;
        $0_1 = $8_1 + ($0_1 << 12 | $4_1 >>> 20) | 0;
        HEAP32[$14_1 + 592 >> 2] = $3_1;
        HEAP32[$14_1 + 596 >> 2] = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $18_1 = $14_1 + 560 | 0;
        $34(655432, 655432, $18_1);
        $34(655472, 655472, $18_1);
        $34(655472, 655472, $29_1);
        $34(655512, 655512, $29_1);
        HEAP32[$43_1 >> 2] = 0;
        HEAP32[$43_1 + 4 >> 2] = 0;
        HEAP32[$42_1 >> 2] = 0;
        HEAP32[$42_1 + 4 >> 2] = 0;
        HEAP32[$41_1 >> 2] = 0;
        HEAP32[$41_1 + 4 >> 2] = 0;
        HEAP32[$40_1 >> 2] = 0;
        HEAP32[$40_1 + 4 >> 2] = 0;
        HEAP32[$14_1 + 520 >> 2] = 0;
        HEAP32[$14_1 + 524 >> 2] = 0;
        $46($39_1, $34_1);
        $17_1 = $14_1 + 688 | 0;
        $38($17_1, $34_1, 0);
        $1_1 = $17_1 + 24 | 0;
        $7_1 = HEAP32[$1_1 >> 2];
        $4_1 = $17_1 + 16 | 0;
        $10_1 = HEAP32[$4_1 >> 2];
        $3_1 = $17_1 + 8 | 0;
        $12_1 = HEAP32[$3_1 >> 2];
        $13_1 = HEAP32[$14_1 + 688 >> 2];
        $8_1 = $7_1 | ($10_1 | ($12_1 | $13_1));
        $6_1 = HEAP32[$1_1 + 4 >> 2];
        $11_1 = HEAP32[$4_1 + 4 >> 2];
        $9_1 = HEAP32[$3_1 + 4 >> 2];
        $2_1 = HEAP32[$14_1 + 692 >> 2];
        $5_1 = $6_1 | ($11_1 | ($9_1 | $2_1));
        $0_1 = $8_1 | $5_1 ? -1 : 0;
        $19_1 = $0_1 & $7_1;
        HEAP32[$1_1 >> 2] = $19_1;
        $16_1 = $0_1 & $6_1;
        HEAP32[$1_1 + 4 >> 2] = $16_1;
        $15_1 = $0_1 & $10_1;
        HEAP32[$4_1 >> 2] = $15_1;
        $20_1 = $0_1 & $11_1;
        HEAP32[$4_1 + 4 >> 2] = $20_1;
        $12_1 = $0_1 & $12_1;
        HEAP32[$3_1 >> 2] = $12_1;
        $10_1 = $0_1 & $9_1;
        HEAP32[$3_1 + 4 >> 2] = $10_1;
        $5_1 = !($5_1 | $8_1) | $0_1 & $13_1;
        HEAP32[$14_1 + 688 >> 2] = $5_1;
        $6_1 = $0_1 & $2_1;
        HEAP32[$14_1 + 692 >> 2] = $6_1;
        $68($39_1, 68);
        HEAP32[$46_1 >> 2] = 0;
        HEAP32[$46_1 + 4 >> 2] = 0;
        HEAP32[$45_1 >> 2] = 0;
        HEAP32[$45_1 + 4 >> 2] = 0;
        HEAP32[$14_1 + 488 >> 2] = 0;
        HEAP32[$14_1 + 492 >> 2] = 0;
        HEAP32[$14_1 + 480 >> 2] = 0;
        HEAP32[$14_1 + 484 >> 2] = 0;
        $48(655392, $18_1, $17_1);
        $0_1 = $12_1 | $15_1 | $19_1 | $5_1 | ($10_1 | $20_1 | $16_1 | $6_1) ? -1 : 0;
        $7_1 = $5_1 ^ -1;
        $2_1 = $7_1 - 801750718 | 0;
        $5_1 = $0_1;
        $11_1 = $6_1 ^ -1;
        $6_1 = $11_1 - (($7_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
        $0_1 = $0_1 & $6_1;
        $8_1 = $0_1;
        $9_1 = $2_1 & $5_1;
        HEAP32[163850] = $9_1;
        HEAP32[163851] = $0_1;
        $10_1 = $10_1 ^ -1;
        $0_1 = $10_1;
        $13_1 = $12_1 ^ -1;
        $12_1 = $13_1 + (($6_1 | 0) == ($11_1 | 0) & $2_1 >>> 0 < $7_1 >>> 0 | $6_1 >>> 0 < $11_1 >>> 0) | 0;
        $2_1 = $12_1 - 1354194885 | 0;
        $11_1 = $2_1 & $5_1;
        HEAP32[$3_1 >> 2] = $11_1;
        $0_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $7_1 = $0_1 - (($12_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
        $6_1 = $7_1 & $5_1;
        HEAP32[$3_1 + 4 >> 2] = $6_1;
        HEAP32[163852] = $11_1;
        HEAP32[163853] = $6_1;
        $6_1 = ($0_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
        $11_1 = $6_1 + (($0_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0) | 0;
        $13_1 = $15_1 ^ -1;
        $12_1 = $13_1 + $11_1 | 0;
        $10_1 = $20_1 ^ -1;
        $0_1 = $10_1 + ($6_1 >>> 0 > $11_1 >>> 0) | 0;
        $2_1 = $12_1 - 2 | 0;
        $11_1 = $2_1 & $5_1;
        HEAP32[$4_1 >> 2] = $11_1;
        $0_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $7_1 = $0_1 - ($12_1 >>> 0 < 2) | 0;
        $6_1 = $7_1 & $5_1;
        HEAP32[$4_1 + 4 >> 2] = $6_1;
        HEAP32[163854] = $11_1;
        HEAP32[163855] = $6_1;
        $6_1 = ($0_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
        $2_1 = $6_1 + (($0_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0) | 0;
        $0_1 = $2_1 >>> 0 < $6_1 >>> 0;
        $11_1 = $2_1 - $19_1 | 0;
        $6_1 = $11_1 - 2 & $5_1;
        HEAP32[$1_1 >> 2] = $6_1;
        $0_1 = ($0_1 - (($2_1 >>> 0 < $19_1 >>> 0) + $16_1 | 0) | 0) - ($11_1 >>> 0 < 2) & $5_1;
        HEAP32[$1_1 + 4 >> 2] = $0_1;
        HEAP32[163856] = $6_1;
        HEAP32[163857] = $0_1;
        HEAP32[$14_1 + 688 >> 2] = $9_1;
        HEAP32[$14_1 + 692 >> 2] = $8_1;
        $70(655432, $18_1, 128);
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        HEAP32[$4_1 >> 2] = 0;
        HEAP32[$4_1 + 4 >> 2] = 0;
        HEAP32[$3_1 >> 2] = 0;
        HEAP32[$3_1 + 4 >> 2] = 0;
        HEAP32[$14_1 + 688 >> 2] = 0;
        HEAP32[$14_1 + 692 >> 2] = 0;
        $68($18_1, 124);
      }
      global$0 = $14_1 + 720 | 0;
      HEAP8[690757] = 0;
      HEAP8[690758] = 0;
      HEAP8[690759] = 0;
      HEAP8[690760] = 0;
      HEAP8[690761] = 0;
      HEAP8[690762] = 0;
      HEAP8[690763] = 0;
      HEAP8[690764] = 0;
      HEAP8[690756] = 1;
      HEAP8[690765] = 0;
      HEAP8[690766] = 0;
      HEAP8[690767] = 0;
      HEAP8[690768] = 0;
      HEAP8[690769] = 0;
      HEAP8[690770] = 0;
      HEAP8[690771] = 0;
      HEAP8[690772] = 0;
      HEAP8[690773] = 0;
      HEAP8[690774] = 0;
      HEAP8[690775] = 0;
      HEAP8[690776] = 0;
      HEAP8[690777] = 0;
      HEAP8[690778] = 0;
      HEAP8[690779] = 0;
      HEAP8[690780] = 0;
      HEAP8[690780] = 0;
      HEAP8[690781] = 0;
      HEAP8[690782] = 0;
      HEAP8[690783] = 0;
      HEAP8[690784] = 0;
      HEAP8[690785] = 0;
      HEAP8[690786] = 0;
      HEAP8[690787] = 0;
      HEAP32[$33_1 + 4 >> 2] = 1;
      HEAP32[172762] = 655392;
    }
    global$0 = $33_1 + 32 | 0;
    return $47_1;
  }
  function $7() {
    $6();
  }
  function $8($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0;
    $1_1 = global$0 + -64 | 0;
    global$0 = $1_1;
    label$1: {
      if (($0_1 | 0) != 32) {
        $2_1 = $1_1 + 56 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $1_1 + 48 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $1_1 + 40 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $1_1 + 32 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $1_1 + 24 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $1_1 + 16 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        $2_1 = $1_1 + 8 | 0;
        HEAP32[$2_1 >> 2] = 0;
        HEAP32[$2_1 + 4 >> 2] = 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $0_1 = $31(HEAP32[172688], $1_1, 690820, $0_1);
        break label$1;
      }
      $0_1 = $1_1 + 56 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 48 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 40 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 32 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 8 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $0_1 = $57(HEAP32[172688], $1_1, 690820);
    }
    global$0 = $1_1 - -64 | 0;
    return ($0_1 | 0) == 1 | 0;
  }
  function $9($0_1, $1_1, $2_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    $2_1 = $2_1 | 0;
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
    $5_1 = global$0 - 272 | 0;
    global$0 = $5_1;
    $3_1 = $5_1 + 200 | 0;
    $26_1 = $3_1 + 56 | 0;
    HEAP32[$26_1 >> 2] = 0;
    HEAP32[$26_1 + 4 >> 2] = 0;
    $9_1 = $3_1 + 48 | 0;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    $16_1 = $3_1 + 40 | 0;
    HEAP32[$16_1 >> 2] = 0;
    HEAP32[$16_1 + 4 >> 2] = 0;
    $18_1 = $3_1 + 32 | 0;
    HEAP32[$18_1 >> 2] = 0;
    HEAP32[$18_1 + 4 >> 2] = 0;
    $17_1 = $3_1 + 24 | 0;
    HEAP32[$17_1 >> 2] = 0;
    HEAP32[$17_1 + 4 >> 2] = 0;
    $19_1 = $3_1 + 16 | 0;
    HEAP32[$19_1 >> 2] = 0;
    HEAP32[$19_1 + 4 >> 2] = 0;
    $25_1 = $3_1 + 8 | 0;
    HEAP32[$25_1 >> 2] = 0;
    HEAP32[$25_1 + 4 >> 2] = 0;
    HEAP32[$5_1 + 200 >> 2] = 0;
    HEAP32[$5_1 + 204 >> 2] = 0;
    label$1: {
      label$2: {
        if (($31(HEAP32[172688], $3_1, 690820, $0_1) | 0) == 1) {
          $20_1 = $5_1 + 200 | 0;
          $14_1 = $20_1 + 15 | 0;
          $3_1 = $14_1;
          $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $10_1 = $5_1 - -64 | 0;
          $22_1 = $10_1 + 8 | 0;
          HEAP32[$22_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$22_1 + 4 >> 2] = $0_1;
          $13_1 = $20_1 + 23 | 0;
          $3_1 = $13_1;
          $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $23_1 = $10_1 + 16 | 0;
          HEAP32[$23_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$23_1 + 4 >> 2] = $0_1;
          $11_1 = $20_1 + 31 | 0;
          $3_1 = $11_1;
          $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $24_1 = $10_1 + 24 | 0;
          HEAP32[$24_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$24_1 + 4 >> 2] = $0_1;
          $12_1 = $20_1 + 39 | 0;
          $3_1 = $12_1;
          $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $27_1 = $10_1 + 32 | 0;
          HEAP32[$27_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$27_1 + 4 >> 2] = $0_1;
          $6_1 = $20_1 + 47 | 0;
          $3_1 = $6_1;
          $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $4_1 = $10_1 + 40 | 0;
          HEAP32[$4_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$4_1 + 4 >> 2] = $0_1;
          $3_1 = $20_1 + 55 | 0;
          $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $7_1 = $10_1 + 48 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $0_1;
          $8_1 = $10_1 + 56 | 0;
          $10_1 = $20_1 + 63 | 0;
          HEAP8[$8_1 | 0] = HEAPU8[$10_1 | 0];
          HEAP8[$5_1 + 2 | 0] = HEAPU8[$5_1 + 202 | 0];
          HEAP16[$5_1 >> 1] = HEAPU16[$5_1 + 200 >> 1];
          $0_1 = HEAPU8[$5_1 + 211 | 0] | HEAPU8[$5_1 + 212 | 0] << 8 | (HEAPU8[$5_1 + 213 | 0] << 16 | HEAPU8[$5_1 + 214 | 0] << 24);
          HEAP32[$5_1 + 64 >> 2] = HEAPU8[$5_1 + 207 | 0] | HEAPU8[$5_1 + 208 | 0] << 8 | (HEAPU8[$5_1 + 209 | 0] << 16 | HEAPU8[$5_1 + 210 | 0] << 24);
          HEAP32[$5_1 + 68 >> 2] = $0_1;
          $0_1 = HEAPU8[$5_1 + 203 | 0] | HEAPU8[$5_1 + 204 | 0] << 8 | (HEAPU8[$5_1 + 205 | 0] << 16 | HEAPU8[$5_1 + 206 | 0] << 24);
          HEAP8[$5_1 + 63 | 0] = HEAPU8[$8_1 | 0];
          $15_1 = HEAP32[$7_1 + 4 >> 2];
          $21_1 = $5_1 + 55 | 0;
          $8_1 = HEAP32[$7_1 >> 2];
          HEAP8[$21_1 | 0] = $8_1;
          HEAP8[$21_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$21_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$21_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$21_1 + 4 | 0] = $15_1;
          HEAP8[$21_1 + 5 | 0] = $15_1 >>> 8;
          HEAP8[$21_1 + 6 | 0] = $15_1 >>> 16;
          HEAP8[$21_1 + 7 | 0] = $15_1 >>> 24;
          $7_1 = HEAP32[$4_1 + 4 >> 2];
          $15_1 = $5_1 + 47 | 0;
          $8_1 = HEAP32[$4_1 >> 2];
          HEAP8[$15_1 | 0] = $8_1;
          HEAP8[$15_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$15_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$15_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$15_1 + 4 | 0] = $7_1;
          HEAP8[$15_1 + 5 | 0] = $7_1 >>> 8;
          HEAP8[$15_1 + 6 | 0] = $7_1 >>> 16;
          HEAP8[$15_1 + 7 | 0] = $7_1 >>> 24;
          $7_1 = HEAP32[$27_1 + 4 >> 2];
          $4_1 = $5_1 + 39 | 0;
          $8_1 = HEAP32[$27_1 >> 2];
          HEAP8[$4_1 | 0] = $8_1;
          HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $7_1;
          HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
          $7_1 = HEAP32[$24_1 + 4 >> 2];
          $4_1 = $5_1 + 31 | 0;
          $8_1 = HEAP32[$24_1 >> 2];
          HEAP8[$4_1 | 0] = $8_1;
          HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $7_1;
          HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
          $7_1 = HEAP32[$23_1 + 4 >> 2];
          $4_1 = $5_1 + 23 | 0;
          $8_1 = HEAP32[$23_1 >> 2];
          HEAP8[$4_1 | 0] = $8_1;
          HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $7_1;
          HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
          $7_1 = HEAP32[$22_1 + 4 >> 2];
          $4_1 = $5_1 + 15 | 0;
          $8_1 = HEAP32[$22_1 >> 2];
          HEAP8[$4_1 | 0] = $8_1;
          HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $7_1;
          HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
          HEAP8[$5_1 + 3 | 0] = $0_1;
          HEAP8[$5_1 + 4 | 0] = $0_1 >>> 8;
          HEAP8[$5_1 + 5 | 0] = $0_1 >>> 16;
          HEAP8[$5_1 + 6 | 0] = $0_1 >>> 24;
          $8_1 = HEAP32[$5_1 + 68 >> 2];
          $0_1 = HEAP32[$5_1 + 64 >> 2];
          HEAP8[$5_1 + 7 | 0] = $0_1;
          HEAP8[$5_1 + 8 | 0] = $0_1 >>> 8;
          HEAP8[$5_1 + 9 | 0] = $0_1 >>> 16;
          HEAP8[$5_1 + 10 | 0] = $0_1 >>> 24;
          HEAP8[$5_1 + 11 | 0] = $8_1;
          HEAP8[$5_1 + 12 | 0] = $8_1 >>> 8;
          HEAP8[$5_1 + 13 | 0] = $8_1 >>> 16;
          HEAP8[$5_1 + 14 | 0] = $8_1 >>> 24;
          HEAP32[$26_1 >> 2] = 0;
          HEAP32[$26_1 + 4 >> 2] = 0;
          HEAP32[$9_1 >> 2] = 0;
          HEAP32[$9_1 + 4 >> 2] = 0;
          HEAP32[$16_1 >> 2] = 0;
          HEAP32[$16_1 + 4 >> 2] = 0;
          HEAP32[$18_1 >> 2] = 0;
          HEAP32[$18_1 + 4 >> 2] = 0;
          HEAP32[$17_1 >> 2] = 0;
          HEAP32[$17_1 + 4 >> 2] = 0;
          HEAP32[$19_1 >> 2] = 0;
          HEAP32[$19_1 + 4 >> 2] = 0;
          HEAP32[$25_1 >> 2] = 0;
          HEAP32[$25_1 + 4 >> 2] = 0;
          HEAP32[$5_1 + 200 >> 2] = 0;
          HEAP32[$5_1 + 204 >> 2] = 0;
          $15_1 = 0;
          if (($31(HEAP32[172688], $20_1, 655584, $1_1) | 0) == 1) {
            $0_1 = HEAPU8[$14_1 + 4 | 0] | HEAPU8[$14_1 + 5 | 0] << 8 | (HEAPU8[$14_1 + 6 | 0] << 16 | HEAPU8[$14_1 + 7 | 0] << 24);
            $1_1 = $5_1 + 128 | 0;
            $8_1 = $1_1 + 8 | 0;
            HEAP32[$8_1 >> 2] = HEAPU8[$14_1 | 0] | HEAPU8[$14_1 + 1 | 0] << 8 | (HEAPU8[$14_1 + 2 | 0] << 16 | HEAPU8[$14_1 + 3 | 0] << 24);
            HEAP32[$8_1 + 4 >> 2] = $0_1;
            $0_1 = HEAPU8[$13_1 + 4 | 0] | HEAPU8[$13_1 + 5 | 0] << 8 | (HEAPU8[$13_1 + 6 | 0] << 16 | HEAPU8[$13_1 + 7 | 0] << 24);
            $14_1 = $1_1 + 16 | 0;
            HEAP32[$14_1 >> 2] = HEAPU8[$13_1 | 0] | HEAPU8[$13_1 + 1 | 0] << 8 | (HEAPU8[$13_1 + 2 | 0] << 16 | HEAPU8[$13_1 + 3 | 0] << 24);
            HEAP32[$14_1 + 4 >> 2] = $0_1;
            $0_1 = HEAPU8[$11_1 + 4 | 0] | HEAPU8[$11_1 + 5 | 0] << 8 | (HEAPU8[$11_1 + 6 | 0] << 16 | HEAPU8[$11_1 + 7 | 0] << 24);
            $13_1 = $1_1 + 24 | 0;
            HEAP32[$13_1 >> 2] = HEAPU8[$11_1 | 0] | HEAPU8[$11_1 + 1 | 0] << 8 | (HEAPU8[$11_1 + 2 | 0] << 16 | HEAPU8[$11_1 + 3 | 0] << 24);
            HEAP32[$13_1 + 4 >> 2] = $0_1;
            $0_1 = HEAPU8[$12_1 + 4 | 0] | HEAPU8[$12_1 + 5 | 0] << 8 | (HEAPU8[$12_1 + 6 | 0] << 16 | HEAPU8[$12_1 + 7 | 0] << 24);
            $11_1 = $1_1 + 32 | 0;
            HEAP32[$11_1 >> 2] = HEAPU8[$12_1 | 0] | HEAPU8[$12_1 + 1 | 0] << 8 | (HEAPU8[$12_1 + 2 | 0] << 16 | HEAPU8[$12_1 + 3 | 0] << 24);
            HEAP32[$11_1 + 4 >> 2] = $0_1;
            $0_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
            $12_1 = $1_1 + 40 | 0;
            HEAP32[$12_1 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
            HEAP32[$12_1 + 4 >> 2] = $0_1;
            $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $6_1 = $1_1 + 48 | 0;
            HEAP32[$6_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$6_1 + 4 >> 2] = $0_1;
            $1_1 = $1_1 + 56 | 0;
            HEAP8[$1_1 | 0] = HEAPU8[$10_1 | 0];
            HEAP8[$5_1 + 66 | 0] = HEAPU8[$5_1 + 202 | 0];
            HEAP16[$5_1 + 64 >> 1] = HEAPU16[$5_1 + 200 >> 1];
            $0_1 = HEAPU8[$5_1 + 211 | 0] | HEAPU8[$5_1 + 212 | 0] << 8 | (HEAPU8[$5_1 + 213 | 0] << 16 | HEAPU8[$5_1 + 214 | 0] << 24);
            HEAP32[$5_1 + 128 >> 2] = HEAPU8[$5_1 + 207 | 0] | HEAPU8[$5_1 + 208 | 0] << 8 | (HEAPU8[$5_1 + 209 | 0] << 16 | HEAPU8[$5_1 + 210 | 0] << 24);
            HEAP32[$5_1 + 132 >> 2] = $0_1;
            $0_1 = HEAPU8[$5_1 + 203 | 0] | HEAPU8[$5_1 + 204 | 0] << 8 | (HEAPU8[$5_1 + 205 | 0] << 16 | HEAPU8[$5_1 + 206 | 0] << 24);
            $7_1 = $5_1 - -64 | 0;
            HEAP8[$7_1 + 63 | 0] = HEAPU8[$1_1 | 0];
            $3_1 = HEAP32[$6_1 + 4 >> 2];
            $10_1 = $7_1 + 55 | 0;
            $1_1 = HEAP32[$6_1 >> 2];
            HEAP8[$10_1 | 0] = $1_1;
            HEAP8[$10_1 + 1 | 0] = $1_1 >>> 8;
            HEAP8[$10_1 + 2 | 0] = $1_1 >>> 16;
            HEAP8[$10_1 + 3 | 0] = $1_1 >>> 24;
            HEAP8[$10_1 + 4 | 0] = $3_1;
            HEAP8[$10_1 + 5 | 0] = $3_1 >>> 8;
            HEAP8[$10_1 + 6 | 0] = $3_1 >>> 16;
            HEAP8[$10_1 + 7 | 0] = $3_1 >>> 24;
            $3_1 = HEAP32[$12_1 + 4 >> 2];
            $6_1 = $7_1 + 47 | 0;
            $1_1 = HEAP32[$12_1 >> 2];
            HEAP8[$6_1 | 0] = $1_1;
            HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
            HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
            HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
            HEAP8[$6_1 + 4 | 0] = $3_1;
            HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
            HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
            HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
            $3_1 = HEAP32[$11_1 + 4 >> 2];
            $6_1 = $7_1 + 39 | 0;
            $1_1 = HEAP32[$11_1 >> 2];
            HEAP8[$6_1 | 0] = $1_1;
            HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
            HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
            HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
            HEAP8[$6_1 + 4 | 0] = $3_1;
            HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
            HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
            HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
            $3_1 = HEAP32[$13_1 + 4 >> 2];
            $6_1 = $7_1 + 31 | 0;
            $1_1 = HEAP32[$13_1 >> 2];
            HEAP8[$6_1 | 0] = $1_1;
            HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
            HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
            HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
            HEAP8[$6_1 + 4 | 0] = $3_1;
            HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
            HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
            HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
            $3_1 = HEAP32[$14_1 + 4 >> 2];
            $6_1 = $7_1 + 23 | 0;
            $1_1 = HEAP32[$14_1 >> 2];
            HEAP8[$6_1 | 0] = $1_1;
            HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
            HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
            HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
            HEAP8[$6_1 + 4 | 0] = $3_1;
            HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
            HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
            HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
            $3_1 = HEAP32[$8_1 + 4 >> 2];
            $6_1 = $7_1 + 15 | 0;
            $1_1 = HEAP32[$8_1 >> 2];
            HEAP8[$6_1 | 0] = $1_1;
            HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
            HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
            HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
            HEAP8[$6_1 + 4 | 0] = $3_1;
            HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
            HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
            HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
            HEAP8[$5_1 + 67 | 0] = $0_1;
            HEAP8[$5_1 + 68 | 0] = $0_1 >>> 8;
            HEAP8[$5_1 + 69 | 0] = $0_1 >>> 16;
            HEAP8[$5_1 + 70 | 0] = $0_1 >>> 24;
            $1_1 = HEAP32[$5_1 + 132 >> 2];
            $0_1 = HEAP32[$5_1 + 128 >> 2];
            HEAP8[$5_1 + 71 | 0] = $0_1;
            HEAP8[$5_1 + 72 | 0] = $0_1 >>> 8;
            HEAP8[$5_1 + 73 | 0] = $0_1 >>> 16;
            HEAP8[$5_1 + 74 | 0] = $0_1 >>> 24;
            HEAP8[$5_1 + 75 | 0] = $1_1;
            HEAP8[$5_1 + 76 | 0] = $1_1 >>> 8;
            HEAP8[$5_1 + 77 | 0] = $1_1 >>> 16;
            HEAP8[$5_1 + 78 | 0] = $1_1 >>> 24;
            $9_1 = $5_1 + 200 | 0;
            $0_1 = $9_1 + 56 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $9_1 + 48 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $9_1 + 40 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $9_1 + 32 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $9_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $9_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $9_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$5_1 + 200 >> 2] = 0;
            HEAP32[$5_1 + 204 >> 2] = 0;
            HEAP32[$5_1 + 196 >> 2] = $7_1;
            HEAP32[$5_1 + 192 >> 2] = $5_1;
            $16_1 = HEAP32[172688];
            $17_1 = $5_1 + 192 | 0;
            $19_1 = 2;
            $7_1 = global$0 - 224 | 0;
            global$0 = $7_1;
            label$5: {
              if (!$9_1) {
                FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689778, HEAP32[$16_1 + 172 >> 2]);
                $0_1 = 0;
                break label$5;
              }
              HEAP8[$9_1 | 0] = 0;
              HEAP8[$9_1 + 1 | 0] = 0;
              HEAP8[$9_1 + 2 | 0] = 0;
              HEAP8[$9_1 + 3 | 0] = 0;
              HEAP8[$9_1 + 4 | 0] = 0;
              HEAP8[$9_1 + 5 | 0] = 0;
              HEAP8[$9_1 + 6 | 0] = 0;
              HEAP8[$9_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 56 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 48 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 40 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 32 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 24 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 16 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $9_1 + 8 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              if (!$17_1) {
                FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689682, HEAP32[$16_1 + 172 >> 2]);
                $0_1 = 0;
                break label$5;
              }
              HEAP32[$7_1 + 216 >> 2] = 1;
              $68($7_1 + 96 | 0, 120);
              $25_1 = $16_1 + 172 | 0;
              while (1) {
                $4_1 = HEAP32[$17_1 >> 2];
                if (!$4_1) {
                  FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689809, HEAP32[$16_1 + 172 >> 2]);
                  $0_1 = 0;
                  break label$5;
                }
                HEAP32[$7_1 + 88 >> 2] = 0;
                $1_1 = HEAPU8[$4_1 + 60 | 0] | HEAPU8[$4_1 + 61 | 0] << 8 | (HEAPU8[$4_1 + 62 | 0] << 16 | HEAPU8[$4_1 + 63 | 0] << 24);
                $11_1 = $1_1 >>> 16 | 0;
                $0_1 = $7_1;
                $3_1 = HEAPU8[$4_1 + 56 | 0] | HEAPU8[$4_1 + 57 | 0] << 8 | (HEAPU8[$4_1 + 58 | 0] << 16 | HEAPU8[$4_1 + 59 | 0] << 24);
                HEAP32[$0_1 + 80 >> 2] = ($1_1 & 65535) << 16 | $3_1 >>> 16;
                HEAP32[$0_1 + 84 >> 2] = $11_1;
                $6_1 = HEAPU8[$4_1 + 36 | 0] | HEAPU8[$4_1 + 37 | 0] << 8 | (HEAPU8[$4_1 + 38 | 0] << 16 | HEAPU8[$4_1 + 39 | 0] << 24);
                HEAP32[$0_1 + 48 >> 2] = HEAPU8[$4_1 + 32 | 0] | HEAPU8[$4_1 + 33 | 0] << 8 | (HEAPU8[$4_1 + 34 | 0] << 16 | HEAPU8[$4_1 + 35 | 0] << 24);
                HEAP32[$0_1 + 52 >> 2] = $6_1 & 1048575;
                $11_1 = $3_1 << 4 & 1048560;
                $1_1 = HEAPU8[$4_1 + 52 | 0] | HEAPU8[$4_1 + 53 | 0] << 8 | (HEAPU8[$4_1 + 54 | 0] << 16 | HEAPU8[$4_1 + 55 | 0] << 24);
                $8_1 = $1_1 >>> 28 | 0;
                $3_1 = HEAPU8[$4_1 + 48 | 0] | HEAPU8[$4_1 + 49 | 0] << 8 | (HEAPU8[$4_1 + 50 | 0] << 16 | HEAPU8[$4_1 + 51 | 0] << 24);
                HEAP32[$0_1 + 72 >> 2] = ($1_1 & 268435455) << 4 | $3_1 >>> 28;
                HEAP32[$0_1 + 76 >> 2] = $8_1 | $11_1;
                $11_1 = $1_1 << 24 | $3_1 >>> 8;
                $13_1 = $3_1 << 24 & -16777216;
                $3_1 = HEAPU8[$4_1 + 40 | 0] | HEAPU8[$4_1 + 41 | 0] << 8 | (HEAPU8[$4_1 + 42 | 0] << 16 | HEAPU8[$4_1 + 43 | 0] << 24);
                $1_1 = HEAPU8[$4_1 + 44 | 0] | HEAPU8[$4_1 + 45 | 0] << 8 | (HEAPU8[$4_1 + 46 | 0] << 16 | HEAPU8[$4_1 + 47 | 0] << 24);
                HEAP32[$0_1 + 64 >> 2] = $1_1 >>> 8 | $13_1;
                HEAP32[$0_1 + 68 >> 2] = $11_1 & 1048575;
                $18_1 = $1_1 << 12 | $3_1 >>> 20;
                HEAP32[$0_1 + 56 >> 2] = $3_1 << 12 & -4096 | $6_1 >>> 20;
                HEAP32[$0_1 + 60 >> 2] = $18_1 & 1048575;
                $3_1 = HEAPU8[$4_1 + 12 | 0] | HEAPU8[$4_1 + 13 | 0] << 8 | (HEAPU8[$4_1 + 14 | 0] << 16 | HEAPU8[$4_1 + 15 | 0] << 24);
                $10_1 = $3_1;
                $1_1 = HEAPU8[$4_1 + 8 | 0] | HEAPU8[$4_1 + 9 | 0] << 8 | (HEAPU8[$4_1 + 10 | 0] << 16 | HEAPU8[$4_1 + 11 | 0] << 24);
                $18_1 = $3_1 << 12 | $1_1 >>> 20;
                $12_1 = $1_1 << 12 & -4096;
                $14_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
                $1_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
                $3_1 = $1_1;
                $22_1 = $3_1 >>> 20 | $12_1;
                HEAP32[$0_1 + 16 >> 2] = $22_1;
                $23_1 = $18_1 & 1048575;
                HEAP32[$0_1 + 20 >> 2] = $23_1;
                HEAP32[$0_1 + 8 >> 2] = $14_1;
                $24_1 = $3_1 & 1048575;
                HEAP32[$0_1 + 12 >> 2] = $24_1;
                $1_1 = HEAPU8[$4_1 + 24 | 0] | HEAPU8[$4_1 + 25 | 0] << 8 | (HEAPU8[$4_1 + 26 | 0] << 16 | HEAPU8[$4_1 + 27 | 0] << 24);
                $13_1 = $1_1;
                $3_1 = HEAPU8[$4_1 + 28 | 0] | HEAPU8[$4_1 + 29 | 0] << 8 | (HEAPU8[$4_1 + 30 | 0] << 16 | HEAPU8[$4_1 + 31 | 0] << 24);
                $6_1 = ($3_1 & 65535) << 16 | $1_1 >>> 16;
                HEAP32[$0_1 + 40 >> 2] = $6_1;
                $12_1 = $3_1 >>> 16 | 0;
                HEAP32[$0_1 + 44 >> 2] = $12_1;
                $1_1 = HEAPU8[$4_1 + 16 | 0] | HEAPU8[$4_1 + 17 | 0] << 8 | (HEAPU8[$4_1 + 18 | 0] << 16 | HEAPU8[$4_1 + 19 | 0] << 24);
                $3_1 = HEAPU8[$4_1 + 20 | 0] | HEAPU8[$4_1 + 21 | 0] << 8 | (HEAPU8[$4_1 + 22 | 0] << 16 | HEAPU8[$4_1 + 23 | 0] << 24);
                $8_1 = $3_1 << 24 | $1_1 >>> 8;
                $4_1 = $1_1 << 24 & -16777216 | $10_1 >>> 8;
                HEAP32[$0_1 + 24 >> 2] = $4_1;
                $10_1 = $8_1 & 1048575;
                HEAP32[$0_1 + 28 >> 2] = $10_1;
                $11_1 = $13_1 << 4 & 1048560;
                $1_1 = ($3_1 & 268435455) << 4 | $1_1 >>> 28;
                HEAP32[$0_1 + 32 >> 2] = $1_1;
                $0_1 = $3_1 >>> 28 | $11_1;
                HEAP32[$7_1 + 36 >> 2] = $0_1;
                if (!($14_1 | $22_1 | $6_1 | $4_1 | $1_1 | ($23_1 | $24_1 | $12_1 | $10_1 | $0_1))) {
                  FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](690116, HEAP32[$25_1 >> 2]);
                }
                $17_1 = $17_1 + 4 | 0;
                $0_1 = $7_1 + 96 | 0;
                $53($0_1, $0_1, $7_1 + 8 | 0);
                $19_1 = $19_1 - 1 | 0;
                if ($19_1) {
                  continue;
                }
                break;
              }
              ;
              $0_1 = 0;
              if (HEAP32[$7_1 + 216 >> 2]) {
                break label$5;
              }
              $0_1 = $7_1 + 8 | 0;
              $49($0_1, $7_1 + 96 | 0);
              $35($9_1, $0_1);
              $0_1 = 1;
            }
            global$0 = $7_1 + 224 | 0;
            if (!$0_1) {
              break label$1;
            }
            HEAP32[$5_1 + 264 >> 2] = $2_1;
            $0_1 = $36(HEAP32[172688], $5_1 + 264 | 0, $5_1 + 200 | 0, ($2_1 | 0) == 33 ? 258 : 2);
            HEAP32[$5_1 + 268 >> 2] = $0_1;
            if (($0_1 | 0) != 1) {
              break label$2;
            }
            $15_1 = 1;
            break label$1;
          }
          fimport$1(1);
          break label$1;
        }
        fimport$1(1);
        break label$1;
      }
      HEAP32[$5_1 + 136 >> 2] = 0;
      $5($5_1 + 128 | 0);
      wasm2js_trap();
    }
    global$0 = $5_1 + 272 | 0;
    return $15_1 | 0;
  }
  function $10($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0;
    $6_1 = global$0 - 208 | 0;
    global$0 = $6_1;
    $2_1 = $6_1 + 136 | 0;
    $3_1 = $2_1 + 56 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 48 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 40 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 32 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 24 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 16 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 8 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    HEAP32[$6_1 + 136 >> 2] = 0;
    HEAP32[$6_1 + 140 >> 2] = 0;
    label$1: {
      if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
        $9_1 = $6_1 + 136 | 0;
        $2_1 = $9_1 + 15 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $3_1 = $6_1 + 72 | 0;
        $13_1 = $3_1 + 8 | 0;
        HEAP32[$13_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$13_1 + 4 >> 2] = $0_1;
        $2_1 = $9_1 + 23 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $11_1 = $3_1 + 16 | 0;
        HEAP32[$11_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$11_1 + 4 >> 2] = $0_1;
        $2_1 = $9_1 + 31 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $12_1 = $3_1 + 24 | 0;
        HEAP32[$12_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$12_1 + 4 >> 2] = $0_1;
        $2_1 = $9_1 + 39 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $10_1 = $3_1 + 32 | 0;
        HEAP32[$10_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$10_1 + 4 >> 2] = $0_1;
        $2_1 = $9_1 + 47 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $7_1 = $3_1 + 40 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $0_1;
        $8_1 = $9_1 + 55 | 0;
        $0_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
        $2_1 = $3_1 + 48 | 0;
        HEAP32[$2_1 >> 2] = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
        HEAP32[$2_1 + 4 >> 2] = $0_1;
        $3_1 = $3_1 + 56 | 0;
        HEAP8[$3_1 | 0] = HEAPU8[$9_1 + 63 | 0];
        HEAP8[$6_1 + 10 | 0] = HEAPU8[$6_1 + 138 | 0];
        HEAP16[$6_1 + 8 >> 1] = HEAPU16[$6_1 + 136 >> 1];
        $0_1 = HEAPU8[$6_1 + 147 | 0] | HEAPU8[$6_1 + 148 | 0] << 8 | (HEAPU8[$6_1 + 149 | 0] << 16 | HEAPU8[$6_1 + 150 | 0] << 24);
        HEAP32[$6_1 + 72 >> 2] = HEAPU8[$6_1 + 143 | 0] | HEAPU8[$6_1 + 144 | 0] << 8 | (HEAPU8[$6_1 + 145 | 0] << 16 | HEAPU8[$6_1 + 146 | 0] << 24);
        HEAP32[$6_1 + 76 >> 2] = $0_1;
        $9_1 = HEAPU8[$6_1 + 139 | 0] | HEAPU8[$6_1 + 140 | 0] << 8 | (HEAPU8[$6_1 + 141 | 0] << 16 | HEAPU8[$6_1 + 142 | 0] << 24);
        $4_1 = $6_1 + 8 | 0;
        HEAP8[$4_1 + 63 | 0] = HEAPU8[$3_1 | 0];
        $3_1 = HEAP32[$2_1 + 4 >> 2];
        $8_1 = $4_1 + 55 | 0;
        $0_1 = HEAP32[$2_1 >> 2];
        HEAP8[$8_1 | 0] = $0_1;
        HEAP8[$8_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$8_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$8_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$8_1 + 4 | 0] = $3_1;
        HEAP8[$8_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$8_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$8_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = HEAP32[$7_1 + 4 >> 2];
        $2_1 = $4_1 + 47 | 0;
        $0_1 = HEAP32[$7_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = HEAP32[$10_1 + 4 >> 2];
        $2_1 = $4_1 + 39 | 0;
        $0_1 = HEAP32[$10_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = HEAP32[$12_1 + 4 >> 2];
        $2_1 = $4_1 + 31 | 0;
        $0_1 = HEAP32[$12_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = HEAP32[$11_1 + 4 >> 2];
        $2_1 = $4_1 + 23 | 0;
        $0_1 = HEAP32[$11_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = HEAP32[$13_1 + 4 >> 2];
        $2_1 = $4_1 + 15 | 0;
        $0_1 = HEAP32[$13_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        HEAP8[$6_1 + 11 | 0] = $9_1;
        HEAP8[$6_1 + 12 | 0] = $9_1 >>> 8;
        HEAP8[$6_1 + 13 | 0] = $9_1 >>> 16;
        HEAP8[$6_1 + 14 | 0] = $9_1 >>> 24;
        $3_1 = HEAP32[$6_1 + 76 >> 2];
        $0_1 = HEAP32[$6_1 + 72 >> 2];
        HEAP8[$6_1 + 15 | 0] = $0_1;
        HEAP8[$6_1 + 16 | 0] = $0_1 >>> 8;
        HEAP8[$6_1 + 17 | 0] = $0_1 >>> 16;
        HEAP8[$6_1 + 18 | 0] = $0_1 >>> 24;
        HEAP8[$6_1 + 19 | 0] = $3_1;
        HEAP8[$6_1 + 20 | 0] = $3_1 >>> 8;
        HEAP8[$6_1 + 21 | 0] = $3_1 >>> 16;
        HEAP8[$6_1 + 22 | 0] = $3_1 >>> 24;
        $14_1 = $6();
        $5_1 = global$0 - 288 | 0;
        global$0 = $5_1;
        label$3: {
          if (!$4_1) {
            FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](689638, HEAP32[$14_1 + 172 >> 2]);
            break label$3;
          }
          $0_1 = HEAPU8[$4_1 + 60 | 0] | HEAPU8[$4_1 + 61 | 0] << 8 | (HEAPU8[$4_1 + 62 | 0] << 16 | HEAPU8[$4_1 + 63 | 0] << 24);
          $11_1 = $0_1 >>> 16 | 0;
          $7_1 = $5_1 + 72 | 0;
          $3_1 = HEAPU8[$4_1 + 56 | 0] | HEAPU8[$4_1 + 57 | 0] << 8 | (HEAPU8[$4_1 + 58 | 0] << 16 | HEAPU8[$4_1 + 59 | 0] << 24);
          HEAP32[$7_1 >> 2] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
          HEAP32[$7_1 + 4 >> 2] = $11_1;
          $7_1 = $3_1 << 4 & 1048560;
          $0_1 = HEAPU8[$4_1 + 52 | 0] | HEAPU8[$4_1 + 53 | 0] << 8 | (HEAPU8[$4_1 + 54 | 0] << 16 | HEAPU8[$4_1 + 55 | 0] << 24);
          $8_1 = $0_1 >>> 28 | 0;
          $10_1 = $5_1 - -64 | 0;
          $3_1 = HEAPU8[$4_1 + 48 | 0] | HEAPU8[$4_1 + 49 | 0] << 8 | (HEAPU8[$4_1 + 50 | 0] << 16 | HEAPU8[$4_1 + 51 | 0] << 24);
          HEAP32[$10_1 >> 2] = ($0_1 & 268435455) << 4 | $3_1 >>> 28;
          HEAP32[$10_1 + 4 >> 2] = $7_1 | $8_1;
          $11_1 = $0_1 << 24 | $3_1 >>> 8;
          $10_1 = $3_1 << 24 & -16777216;
          $3_1 = HEAPU8[$4_1 + 40 | 0] | HEAPU8[$4_1 + 41 | 0] << 8 | (HEAPU8[$4_1 + 42 | 0] << 16 | HEAPU8[$4_1 + 43 | 0] << 24);
          $12_1 = $5_1 + 56 | 0;
          $0_1 = HEAPU8[$4_1 + 44 | 0] | HEAPU8[$4_1 + 45 | 0] << 8 | (HEAPU8[$4_1 + 46 | 0] << 16 | HEAPU8[$4_1 + 47 | 0] << 24);
          HEAP32[$12_1 >> 2] = $0_1 >>> 8 | $10_1;
          HEAP32[$12_1 + 4 >> 2] = $11_1 & 1048575;
          $11_1 = $0_1 << 12 | $3_1 >>> 20;
          $10_1 = $3_1 << 12 & -4096;
          $2_1 = HEAPU8[$4_1 + 32 | 0] | HEAPU8[$4_1 + 33 | 0] << 8 | (HEAPU8[$4_1 + 34 | 0] << 16 | HEAPU8[$4_1 + 35 | 0] << 24);
          $0_1 = HEAPU8[$4_1 + 36 | 0] | HEAPU8[$4_1 + 37 | 0] << 8 | (HEAPU8[$4_1 + 38 | 0] << 16 | HEAPU8[$4_1 + 39 | 0] << 24);
          $12_1 = $5_1 + 48 | 0;
          HEAP32[$12_1 >> 2] = $0_1 >>> 20 | $10_1;
          HEAP32[$12_1 + 4 >> 2] = $11_1 & 1048575;
          HEAP32[$5_1 + 80 >> 2] = 0;
          HEAP32[$5_1 + 40 >> 2] = $2_1;
          HEAP32[$5_1 + 44 >> 2] = $0_1 & 1048575;
          $2_1 = HEAPU8[$4_1 + 12 | 0] | HEAPU8[$4_1 + 13 | 0] << 8 | (HEAPU8[$4_1 + 14 | 0] << 16 | HEAPU8[$4_1 + 15 | 0] << 24);
          $9_1 = $2_1;
          $3_1 = HEAPU8[$4_1 + 8 | 0] | HEAPU8[$4_1 + 9 | 0] << 8 | (HEAPU8[$4_1 + 10 | 0] << 16 | HEAPU8[$4_1 + 11 | 0] << 24);
          $11_1 = $2_1 << 12 | $3_1 >>> 20;
          $10_1 = $3_1 << 12 & -4096;
          $13_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
          $3_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
          $2_1 = $3_1;
          $0_1 = $5_1;
          $15_1 = $2_1 >>> 20 | $10_1;
          HEAP32[$0_1 + 8 >> 2] = $15_1;
          $16_1 = $11_1 & 1048575;
          HEAP32[$0_1 + 12 >> 2] = $16_1;
          HEAP32[$0_1 >> 2] = $13_1;
          $17_1 = $2_1 & 1048575;
          HEAP32[$0_1 + 4 >> 2] = $17_1;
          $3_1 = HEAPU8[$4_1 + 24 | 0] | HEAPU8[$4_1 + 25 | 0] << 8 | (HEAPU8[$4_1 + 26 | 0] << 16 | HEAPU8[$4_1 + 27 | 0] << 24);
          $11_1 = $3_1;
          $2_1 = HEAPU8[$4_1 + 28 | 0] | HEAPU8[$4_1 + 29 | 0] << 8 | (HEAPU8[$4_1 + 30 | 0] << 16 | HEAPU8[$4_1 + 31 | 0] << 24);
          $7_1 = ($2_1 & 65535) << 16 | $3_1 >>> 16;
          HEAP32[$0_1 + 32 >> 2] = $7_1;
          $10_1 = $2_1 >>> 16 | 0;
          HEAP32[$0_1 + 36 >> 2] = $10_1;
          $3_1 = HEAPU8[$4_1 + 16 | 0] | HEAPU8[$4_1 + 17 | 0] << 8 | (HEAPU8[$4_1 + 18 | 0] << 16 | HEAPU8[$4_1 + 19 | 0] << 24);
          $2_1 = HEAPU8[$4_1 + 20 | 0] | HEAPU8[$4_1 + 21 | 0] << 8 | (HEAPU8[$4_1 + 22 | 0] << 16 | HEAPU8[$4_1 + 23 | 0] << 24);
          $8_1 = $2_1 << 24 | $3_1 >>> 8;
          $18_1 = $3_1 << 24 & -16777216 | $9_1 >>> 8;
          HEAP32[$0_1 + 16 >> 2] = $18_1;
          $9_1 = $8_1 & 1048575;
          HEAP32[$0_1 + 20 >> 2] = $9_1;
          $12_1 = $11_1 << 4 & 1048560;
          $3_1 = ($2_1 & 268435455) << 4 | $3_1 >>> 28;
          HEAP32[$0_1 + 24 >> 2] = $3_1;
          $0_1 = $2_1 >>> 28 | $12_1;
          HEAP32[$5_1 + 28 >> 2] = $0_1;
          if (!($13_1 | $15_1 | $7_1 | $18_1 | $3_1 | ($16_1 | $17_1 | $10_1 | $9_1 | $0_1))) {
            FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](690116, HEAP32[$14_1 + 172 >> 2]);
            $0_1 = $4_1 + 56 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 48 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 40 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 32 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 24 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 16 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $4_1 + 8 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            HEAP8[$4_1 | 0] = 0;
            HEAP8[$4_1 + 1 | 0] = 0;
            HEAP8[$4_1 + 2 | 0] = 0;
            HEAP8[$4_1 + 3 | 0] = 0;
            HEAP8[$4_1 + 4 | 0] = 0;
            HEAP8[$4_1 + 5 | 0] = 0;
            HEAP8[$4_1 + 6 | 0] = 0;
            HEAP8[$4_1 + 7 | 0] = 0;
            break label$3;
          }
          HEAP8[$4_1 | 0] = 0;
          HEAP8[$4_1 + 1 | 0] = 0;
          HEAP8[$4_1 + 2 | 0] = 0;
          HEAP8[$4_1 + 3 | 0] = 0;
          HEAP8[$4_1 + 4 | 0] = 0;
          HEAP8[$4_1 + 5 | 0] = 0;
          HEAP8[$4_1 + 6 | 0] = 0;
          HEAP8[$4_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 56 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 48 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 40 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 32 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 24 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 16 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $4_1 + 8 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          HEAP32[$5_1 + 92 >> 2] = 0;
          $38($5_1 + 96 | 0, 690949, $5_1 + 92 | 0);
          if (HEAP32[$5_1 + 92 >> 2]) {
            break label$3;
          }
          $2_1 = $5_1 + 8 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $7_1 = $5_1 + 160 | 0;
          $0_1 = $7_1 + 8 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 + 16 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 + 16 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 + 24 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 + 24 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 + 32 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 + 32 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 + 48 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 + 48 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 + 56 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 + 56 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 - -64 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 - -64 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          $2_1 = $5_1 + 72 | 0;
          $3_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $7_1 + 72 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $3_1;
          HEAP32[$5_1 + 280 >> 2] = 0;
          $0_1 = HEAP32[$5_1 + 4 >> 2];
          HEAP32[$5_1 + 160 >> 2] = HEAP32[$5_1 >> 2];
          HEAP32[$5_1 + 164 >> 2] = $0_1;
          $0_1 = HEAP32[$5_1 + 44 >> 2];
          HEAP32[$5_1 + 200 >> 2] = HEAP32[$5_1 + 40 >> 2];
          HEAP32[$5_1 + 204 >> 2] = $0_1;
          $0_1 = $5_1 + 248 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $5_1 + 256 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $5_1 + 264 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $5_1 + 272 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $3_1 = $5_1 + 128 | 0;
          $0_1 = $3_1 + 16 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $3_1 + 24 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          HEAP32[$5_1 + 240 >> 2] = 1;
          HEAP32[$5_1 + 244 >> 2] = 0;
          HEAP32[$5_1 + 136 >> 2] = 0;
          HEAP32[$5_1 + 140 >> 2] = 0;
          HEAP32[$5_1 + 128 >> 2] = 1;
          HEAP32[$5_1 + 132 >> 2] = 0;
          $42($7_1, $7_1, $3_1, $5_1 + 96 | 0);
          if (HEAP32[$5_1 + 280 >> 2]) {
            break label$3;
          }
          $49($5_1, $5_1 + 160 | 0);
          $35($4_1, $5_1);
          $19_1 = 1;
        }
        global$0 = $5_1 + 288 | 0;
        if (!$19_1) {
          break label$1;
        }
        HEAP32[$6_1 + 204 >> 2] = $1_1;
        $0_1 = $36(HEAP32[172688], $6_1 + 204 | 0, $6_1 + 8 | 0, ($1_1 | 0) == 33 ? 258 : 2);
        HEAP32[$6_1 + 72 >> 2] = $0_1;
        $20_1 = 1;
        if (($0_1 | 0) == 1) {
          break label$1;
        }
        HEAP32[$6_1 + 144 >> 2] = 0;
        $5($6_1 + 136 | 0);
        wasm2js_trap();
      }
      fimport$1(1);
    }
    global$0 = $6_1 + 208 | 0;
    return $20_1 | 0;
  }
  function $11() {
    var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0;
    $6_1 = global$0 - 208 | 0;
    global$0 = $6_1;
    $2_1 = $6_1 + 136 | 0;
    $16_1 = $2_1 + 56 | 0;
    HEAP32[$16_1 >> 2] = 0;
    HEAP32[$16_1 + 4 >> 2] = 0;
    $17_1 = $2_1 + 48 | 0;
    HEAP32[$17_1 >> 2] = 0;
    HEAP32[$17_1 + 4 >> 2] = 0;
    $12_1 = $2_1 + 40 | 0;
    HEAP32[$12_1 >> 2] = 0;
    HEAP32[$12_1 + 4 >> 2] = 0;
    $18_1 = $2_1 + 32 | 0;
    HEAP32[$18_1 >> 2] = 0;
    HEAP32[$18_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $15_1 = $2_1 + 16 | 0;
    HEAP32[$15_1 >> 2] = 0;
    HEAP32[$15_1 + 4 >> 2] = 0;
    $14_1 = $2_1 + 8 | 0;
    HEAP32[$14_1 >> 2] = 0;
    HEAP32[$14_1 + 4 >> 2] = 0;
    HEAP32[$6_1 + 136 >> 2] = 0;
    HEAP32[$6_1 + 140 >> 2] = 0;
    label$1: {
      label$2: {
        if (($57(HEAP32[172688], $2_1, 690885) | 0) == 1) {
          $8_1 = $6_1 + 136 | 0;
          $1_1 = $8_1 + 15 | 0;
          $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $2_1 = $6_1 + 72 | 0;
          $19_1 = $2_1 + 8 | 0;
          HEAP32[$19_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$19_1 + 4 >> 2] = $0_1;
          $1_1 = $8_1 + 23 | 0;
          $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $10_1 = $2_1 + 16 | 0;
          HEAP32[$10_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$10_1 + 4 >> 2] = $0_1;
          $1_1 = $8_1 + 31 | 0;
          $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $11_1 = $2_1 + 24 | 0;
          HEAP32[$11_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$11_1 + 4 >> 2] = $0_1;
          $1_1 = $8_1 + 39 | 0;
          $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $9_1 = $2_1 + 32 | 0;
          HEAP32[$9_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$9_1 + 4 >> 2] = $0_1;
          $1_1 = $8_1 + 47 | 0;
          $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
          $4_1 = $2_1 + 40 | 0;
          HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
          HEAP32[$4_1 + 4 >> 2] = $0_1;
          $7_1 = $8_1 + 55 | 0;
          $0_1 = HEAPU8[$7_1 + 4 | 0] | HEAPU8[$7_1 + 5 | 0] << 8 | (HEAPU8[$7_1 + 6 | 0] << 16 | HEAPU8[$7_1 + 7 | 0] << 24);
          $1_1 = $2_1 + 48 | 0;
          HEAP32[$1_1 >> 2] = HEAPU8[$7_1 | 0] | HEAPU8[$7_1 + 1 | 0] << 8 | (HEAPU8[$7_1 + 2 | 0] << 16 | HEAPU8[$7_1 + 3 | 0] << 24);
          HEAP32[$1_1 + 4 >> 2] = $0_1;
          $2_1 = $2_1 + 56 | 0;
          HEAP8[$2_1 | 0] = HEAPU8[$8_1 + 63 | 0];
          HEAP8[$6_1 + 10 | 0] = HEAPU8[$6_1 + 138 | 0];
          HEAP16[$6_1 + 8 >> 1] = HEAPU16[$6_1 + 136 >> 1];
          $0_1 = HEAPU8[$6_1 + 147 | 0] | HEAPU8[$6_1 + 148 | 0] << 8 | (HEAPU8[$6_1 + 149 | 0] << 16 | HEAPU8[$6_1 + 150 | 0] << 24);
          HEAP32[$6_1 + 72 >> 2] = HEAPU8[$6_1 + 143 | 0] | HEAPU8[$6_1 + 144 | 0] << 8 | (HEAPU8[$6_1 + 145 | 0] << 16 | HEAPU8[$6_1 + 146 | 0] << 24);
          HEAP32[$6_1 + 76 >> 2] = $0_1;
          $0_1 = HEAPU8[$6_1 + 139 | 0] | HEAPU8[$6_1 + 140 | 0] << 8 | (HEAPU8[$6_1 + 141 | 0] << 16 | HEAPU8[$6_1 + 142 | 0] << 24);
          $3_1 = $6_1 + 8 | 0;
          HEAP8[$3_1 + 63 | 0] = HEAPU8[$2_1 | 0];
          $7_1 = HEAP32[$1_1 + 4 >> 2];
          $13_1 = $3_1 + 55 | 0;
          $2_1 = HEAP32[$1_1 >> 2];
          HEAP8[$13_1 | 0] = $2_1;
          HEAP8[$13_1 + 1 | 0] = $2_1 >>> 8;
          HEAP8[$13_1 + 2 | 0] = $2_1 >>> 16;
          HEAP8[$13_1 + 3 | 0] = $2_1 >>> 24;
          HEAP8[$13_1 + 4 | 0] = $7_1;
          HEAP8[$13_1 + 5 | 0] = $7_1 >>> 8;
          HEAP8[$13_1 + 6 | 0] = $7_1 >>> 16;
          HEAP8[$13_1 + 7 | 0] = $7_1 >>> 24;
          $1_1 = HEAP32[$4_1 + 4 >> 2];
          $7_1 = $3_1 + 47 | 0;
          $2_1 = HEAP32[$4_1 >> 2];
          HEAP8[$7_1 | 0] = $2_1;
          HEAP8[$7_1 + 1 | 0] = $2_1 >>> 8;
          HEAP8[$7_1 + 2 | 0] = $2_1 >>> 16;
          HEAP8[$7_1 + 3 | 0] = $2_1 >>> 24;
          HEAP8[$7_1 + 4 | 0] = $1_1;
          HEAP8[$7_1 + 5 | 0] = $1_1 >>> 8;
          HEAP8[$7_1 + 6 | 0] = $1_1 >>> 16;
          HEAP8[$7_1 + 7 | 0] = $1_1 >>> 24;
          $1_1 = HEAP32[$9_1 + 4 >> 2];
          $4_1 = $3_1 + 39 | 0;
          $2_1 = HEAP32[$9_1 >> 2];
          HEAP8[$4_1 | 0] = $2_1;
          HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $1_1;
          HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
          $1_1 = HEAP32[$11_1 + 4 >> 2];
          $4_1 = $3_1 + 31 | 0;
          $2_1 = HEAP32[$11_1 >> 2];
          HEAP8[$4_1 | 0] = $2_1;
          HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $1_1;
          HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
          $1_1 = HEAP32[$10_1 + 4 >> 2];
          $4_1 = $3_1 + 23 | 0;
          $2_1 = HEAP32[$10_1 >> 2];
          HEAP8[$4_1 | 0] = $2_1;
          HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $1_1;
          HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
          $1_1 = HEAP32[$19_1 + 4 >> 2];
          $4_1 = $3_1 + 15 | 0;
          $2_1 = HEAP32[$19_1 >> 2];
          HEAP8[$4_1 | 0] = $2_1;
          HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
          HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
          HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
          HEAP8[$4_1 + 4 | 0] = $1_1;
          HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
          HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
          HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
          HEAP8[$6_1 + 11 | 0] = $0_1;
          HEAP8[$6_1 + 12 | 0] = $0_1 >>> 8;
          HEAP8[$6_1 + 13 | 0] = $0_1 >>> 16;
          HEAP8[$6_1 + 14 | 0] = $0_1 >>> 24;
          $2_1 = HEAP32[$6_1 + 76 >> 2];
          $0_1 = HEAP32[$6_1 + 72 >> 2];
          HEAP8[$6_1 + 15 | 0] = $0_1;
          HEAP8[$6_1 + 16 | 0] = $0_1 >>> 8;
          HEAP8[$6_1 + 17 | 0] = $0_1 >>> 16;
          HEAP8[$6_1 + 18 | 0] = $0_1 >>> 24;
          HEAP8[$6_1 + 19 | 0] = $2_1;
          HEAP8[$6_1 + 20 | 0] = $2_1 >>> 8;
          HEAP8[$6_1 + 21 | 0] = $2_1 >>> 16;
          HEAP8[$6_1 + 22 | 0] = $2_1 >>> 24;
          HEAP32[$16_1 >> 2] = 0;
          HEAP32[$16_1 + 4 >> 2] = 0;
          HEAP32[$17_1 >> 2] = 0;
          HEAP32[$17_1 + 4 >> 2] = 0;
          HEAP32[$12_1 >> 2] = 0;
          HEAP32[$12_1 + 4 >> 2] = 0;
          HEAP32[$18_1 >> 2] = 0;
          HEAP32[$18_1 + 4 >> 2] = 0;
          HEAP32[$5_1 >> 2] = 0;
          HEAP32[$5_1 + 4 >> 2] = 0;
          HEAP32[$15_1 >> 2] = 0;
          HEAP32[$15_1 + 4 >> 2] = 0;
          HEAP32[$14_1 >> 2] = 0;
          HEAP32[$14_1 + 4 >> 2] = 0;
          HEAP32[$6_1 + 136 >> 2] = 0;
          HEAP32[$6_1 + 140 >> 2] = 0;
          $12_1 = $6();
          $13_1 = 0;
          $5_1 = global$0 - 288 | 0;
          global$0 = $5_1;
          label$4: {
            if (!$8_1) {
              FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](689607, HEAP32[$12_1 + 172 >> 2]);
              break label$4;
            }
            HEAP8[$8_1 | 0] = 0;
            HEAP8[$8_1 + 1 | 0] = 0;
            HEAP8[$8_1 + 2 | 0] = 0;
            HEAP8[$8_1 + 3 | 0] = 0;
            HEAP8[$8_1 + 4 | 0] = 0;
            HEAP8[$8_1 + 5 | 0] = 0;
            HEAP8[$8_1 + 6 | 0] = 0;
            HEAP8[$8_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 56 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 48 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 40 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 32 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 24 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 16 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $8_1 + 8 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            if (!$3_1) {
              FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](689629, HEAP32[$12_1 + 172 >> 2]);
              break label$4;
            }
            $0_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
            $10_1 = $0_1 >>> 16 | 0;
            $4_1 = $5_1 + 72 | 0;
            $2_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
            HEAP32[$4_1 >> 2] = ($0_1 & 65535) << 16 | $2_1 >>> 16;
            HEAP32[$4_1 + 4 >> 2] = $10_1;
            $4_1 = $2_1 << 4 & 1048560;
            $0_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
            $15_1 = $0_1 >>> 28 | 0;
            $9_1 = $5_1 - -64 | 0;
            $2_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
            HEAP32[$9_1 >> 2] = ($0_1 & 268435455) << 4 | $2_1 >>> 28;
            HEAP32[$9_1 + 4 >> 2] = $4_1 | $15_1;
            $10_1 = $0_1 << 24 | $2_1 >>> 8;
            $9_1 = $2_1 << 24 & -16777216;
            $2_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
            $11_1 = $5_1 + 56 | 0;
            $0_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
            HEAP32[$11_1 >> 2] = $0_1 >>> 8 | $9_1;
            HEAP32[$11_1 + 4 >> 2] = $10_1 & 1048575;
            $10_1 = $0_1 << 12 | $2_1 >>> 20;
            $9_1 = $2_1 << 12 & -4096;
            $1_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
            $0_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
            $11_1 = $5_1 + 48 | 0;
            HEAP32[$11_1 >> 2] = $0_1 >>> 20 | $9_1;
            HEAP32[$11_1 + 4 >> 2] = $10_1 & 1048575;
            HEAP32[$5_1 + 80 >> 2] = 0;
            HEAP32[$5_1 + 40 >> 2] = $1_1;
            HEAP32[$5_1 + 44 >> 2] = $0_1 & 1048575;
            $1_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
            $14_1 = $1_1;
            $2_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
            $10_1 = $1_1 << 12 | $2_1 >>> 20;
            $9_1 = $2_1 << 12 & -4096;
            $19_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            $2_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $1_1 = $2_1;
            $0_1 = $5_1;
            $7_1 = $1_1 >>> 20 | $9_1;
            HEAP32[$0_1 + 8 >> 2] = $7_1;
            $16_1 = $10_1 & 1048575;
            HEAP32[$0_1 + 12 >> 2] = $16_1;
            HEAP32[$0_1 >> 2] = $19_1;
            $17_1 = $1_1 & 1048575;
            HEAP32[$0_1 + 4 >> 2] = $17_1;
            $2_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
            $10_1 = $2_1;
            $1_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
            $4_1 = ($1_1 & 65535) << 16 | $2_1 >>> 16;
            HEAP32[$0_1 + 32 >> 2] = $4_1;
            $9_1 = $1_1 >>> 16 | 0;
            HEAP32[$0_1 + 36 >> 2] = $9_1;
            $2_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
            $1_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
            $15_1 = $1_1 << 24 | $2_1 >>> 8;
            $18_1 = $2_1 << 24 & -16777216 | $14_1 >>> 8;
            HEAP32[$0_1 + 16 >> 2] = $18_1;
            $14_1 = $15_1 & 1048575;
            HEAP32[$0_1 + 20 >> 2] = $14_1;
            $11_1 = $10_1 << 4 & 1048560;
            $2_1 = ($1_1 & 268435455) << 4 | $2_1 >>> 28;
            HEAP32[$0_1 + 24 >> 2] = $2_1;
            $0_1 = $1_1 >>> 28 | $11_1;
            HEAP32[$5_1 + 28 >> 2] = $0_1;
            if (!($7_1 | $19_1 | $4_1 | $18_1 | $2_1 | ($16_1 | $17_1 | $9_1 | $14_1 | $0_1))) {
              FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](690116, HEAP32[$12_1 + 172 >> 2]);
              break label$4;
            }
            HEAP32[$5_1 + 92 >> 2] = 0;
            $38($5_1 + 96 | 0, 690949, $5_1 + 92 | 0);
            if (HEAP32[$5_1 + 92 >> 2]) {
              break label$4;
            }
            $1_1 = $5_1 + 8 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $5_1 + 160 | 0;
            $0_1 = $4_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 + 16 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 + 24 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 + 32 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 + 32 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 + 48 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 + 48 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 + 56 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 + 56 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 - -64 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 - -64 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            $1_1 = $5_1 + 72 | 0;
            $2_1 = HEAP32[$1_1 + 4 >> 2];
            $0_1 = $4_1 + 72 | 0;
            HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$0_1 + 4 >> 2] = $2_1;
            HEAP32[$5_1 + 280 >> 2] = 0;
            $0_1 = HEAP32[$5_1 + 4 >> 2];
            HEAP32[$5_1 + 160 >> 2] = HEAP32[$5_1 >> 2];
            HEAP32[$5_1 + 164 >> 2] = $0_1;
            $0_1 = HEAP32[$5_1 + 44 >> 2];
            HEAP32[$5_1 + 200 >> 2] = HEAP32[$5_1 + 40 >> 2];
            HEAP32[$5_1 + 204 >> 2] = $0_1;
            $0_1 = $5_1 + 248 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $5_1 + 256 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $5_1 + 264 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $5_1 + 272 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $2_1 = $5_1 + 128 | 0;
            $0_1 = $2_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $2_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$5_1 + 240 >> 2] = 1;
            HEAP32[$5_1 + 244 >> 2] = 0;
            HEAP32[$5_1 + 136 >> 2] = 0;
            HEAP32[$5_1 + 140 >> 2] = 0;
            HEAP32[$5_1 + 128 >> 2] = 1;
            HEAP32[$5_1 + 132 >> 2] = 0;
            $42($4_1, $4_1, $2_1, $5_1 + 96 | 0);
            if (HEAP32[$5_1 + 280 >> 2]) {
              break label$4;
            }
            $49($5_1, $5_1 + 160 | 0);
            $35($8_1, $5_1);
            $13_1 = 1;
          }
          global$0 = $5_1 + 288 | 0;
          if ($13_1) {
            HEAP32[$6_1 + 132 >> 2] = 0;
            $0_1 = $59($6(), $6_1 + 8 | 0, $6_1 + 132 | 0, $6_1 + 136 | 0);
            HEAP32[$6_1 + 204 >> 2] = $0_1;
            if (($0_1 | 0) != 1) {
              break label$1;
            }
            $0_1 = $58(HEAP32[172688], $6_1 + 8 | 0);
            HEAP32[$6_1 + 204 >> 2] = $0_1;
            if (($0_1 | 0) != 1) {
              break label$1;
            }
            $0_1 = HEAP32[$6_1 + 132 >> 2];
            break label$2;
          }
          $0_1 = -1;
          break label$2;
        }
        fimport$1(1);
      }
      global$0 = $6_1 + 208 | 0;
      return $0_1 | 0;
    }
    HEAP32[$6_1 + 80 >> 2] = 0;
    $5($6_1 + 72 | 0);
    wasm2js_trap();
  }
  function $12($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0;
    $3_1 = global$0 - 192 | 0;
    global$0 = $3_1;
    $2_1 = $3_1 + 128 | 0;
    $9_1 = $2_1 + 56 | 0;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    $10_1 = $2_1 + 48 | 0;
    HEAP32[$10_1 >> 2] = 0;
    HEAP32[$10_1 + 4 >> 2] = 0;
    $7_1 = $2_1 + 40 | 0;
    HEAP32[$7_1 >> 2] = 0;
    HEAP32[$7_1 + 4 >> 2] = 0;
    $13_1 = $2_1 + 32 | 0;
    HEAP32[$13_1 >> 2] = 0;
    HEAP32[$13_1 + 4 >> 2] = 0;
    $18_1 = $2_1 + 24 | 0;
    HEAP32[$18_1 >> 2] = 0;
    HEAP32[$18_1 + 4 >> 2] = 0;
    $19_1 = $2_1 + 16 | 0;
    HEAP32[$19_1 >> 2] = 0;
    HEAP32[$19_1 + 4 >> 2] = 0;
    $17_1 = $2_1 + 8 | 0;
    HEAP32[$17_1 >> 2] = 0;
    HEAP32[$17_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 128 >> 2] = 0;
    HEAP32[$3_1 + 132 >> 2] = 0;
    label$1: {
      if (($57(HEAP32[172688], $2_1, 690885) | 0) == 1) {
        $2_1 = $3_1 + 128 | 0;
        $1_1 = $2_1 + 15 | 0;
        $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $5_1 = $3_1 - -64 | 0;
        $11_1 = $5_1 + 8 | 0;
        HEAP32[$11_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$11_1 + 4 >> 2] = $4_1;
        $1_1 = $2_1 + 23 | 0;
        $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $14_1 = $5_1 + 16 | 0;
        HEAP32[$14_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$14_1 + 4 >> 2] = $4_1;
        $1_1 = $2_1 + 31 | 0;
        $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $12_1 = $5_1 + 24 | 0;
        HEAP32[$12_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$12_1 + 4 >> 2] = $4_1;
        $1_1 = $2_1 + 39 | 0;
        $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $15_1 = $5_1 + 32 | 0;
        HEAP32[$15_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$15_1 + 4 >> 2] = $4_1;
        $1_1 = $2_1 + 47 | 0;
        $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $16_1 = $5_1 + 40 | 0;
        HEAP32[$16_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$16_1 + 4 >> 2] = $4_1;
        $1_1 = $2_1 + 55 | 0;
        $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
        $8_1 = $5_1 + 48 | 0;
        HEAP32[$8_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
        HEAP32[$8_1 + 4 >> 2] = $4_1;
        $1_1 = $5_1 + 56 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$2_1 + 63 | 0];
        HEAP8[$3_1 + 2 | 0] = HEAPU8[$3_1 + 130 | 0];
        HEAP16[$3_1 >> 1] = HEAPU16[$3_1 + 128 >> 1];
        $5_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
        HEAP32[$3_1 + 64 >> 2] = HEAPU8[$3_1 + 135 | 0] | HEAPU8[$3_1 + 136 | 0] << 8 | (HEAPU8[$3_1 + 137 | 0] << 16 | HEAPU8[$3_1 + 138 | 0] << 24);
        HEAP32[$3_1 + 68 >> 2] = $5_1;
        $5_1 = HEAPU8[$3_1 + 131 | 0] | HEAPU8[$3_1 + 132 | 0] << 8 | (HEAPU8[$3_1 + 133 | 0] << 16 | HEAPU8[$3_1 + 134 | 0] << 24);
        HEAP8[$3_1 + 63 | 0] = HEAPU8[$1_1 | 0];
        $4_1 = HEAP32[$8_1 + 4 >> 2];
        $1_1 = $3_1 + 55 | 0;
        $8_1 = HEAP32[$8_1 >> 2];
        HEAP8[$1_1 | 0] = $8_1;
        HEAP8[$1_1 + 1 | 0] = $8_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $8_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $8_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$16_1 + 4 >> 2];
        $1_1 = $3_1 + 47 | 0;
        $16_1 = HEAP32[$16_1 >> 2];
        HEAP8[$1_1 | 0] = $16_1;
        HEAP8[$1_1 + 1 | 0] = $16_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $16_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $16_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$15_1 + 4 >> 2];
        $1_1 = $3_1 + 39 | 0;
        $15_1 = HEAP32[$15_1 >> 2];
        HEAP8[$1_1 | 0] = $15_1;
        HEAP8[$1_1 + 1 | 0] = $15_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $15_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $15_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $1_1 = $3_1 + 31 | 0;
        $12_1 = HEAP32[$12_1 >> 2];
        HEAP8[$1_1 | 0] = $12_1;
        HEAP8[$1_1 + 1 | 0] = $12_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $12_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $12_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$14_1 + 4 >> 2];
        $1_1 = $3_1 + 23 | 0;
        $14_1 = HEAP32[$14_1 >> 2];
        HEAP8[$1_1 | 0] = $14_1;
        HEAP8[$1_1 + 1 | 0] = $14_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $14_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $14_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $1_1 = $3_1 + 15 | 0;
        $11_1 = HEAP32[$11_1 >> 2];
        HEAP8[$1_1 | 0] = $11_1;
        HEAP8[$1_1 + 1 | 0] = $11_1 >>> 8;
        HEAP8[$1_1 + 2 | 0] = $11_1 >>> 16;
        HEAP8[$1_1 + 3 | 0] = $11_1 >>> 24;
        HEAP8[$1_1 + 4 | 0] = $4_1;
        HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
        HEAP8[$3_1 + 3 | 0] = $5_1;
        HEAP8[$3_1 + 4 | 0] = $5_1 >>> 8;
        HEAP8[$3_1 + 5 | 0] = $5_1 >>> 16;
        HEAP8[$3_1 + 6 | 0] = $5_1 >>> 24;
        $1_1 = HEAP32[$3_1 + 68 >> 2];
        $5_1 = HEAP32[$3_1 + 64 >> 2];
        HEAP8[$3_1 + 7 | 0] = $5_1;
        HEAP8[$3_1 + 8 | 0] = $5_1 >>> 8;
        HEAP8[$3_1 + 9 | 0] = $5_1 >>> 16;
        HEAP8[$3_1 + 10 | 0] = $5_1 >>> 24;
        HEAP8[$3_1 + 11 | 0] = $1_1;
        HEAP8[$3_1 + 12 | 0] = $1_1 >>> 8;
        HEAP8[$3_1 + 13 | 0] = $1_1 >>> 16;
        HEAP8[$3_1 + 14 | 0] = $1_1 >>> 24;
        HEAP32[$9_1 >> 2] = 0;
        HEAP32[$9_1 + 4 >> 2] = 0;
        HEAP32[$10_1 >> 2] = 0;
        HEAP32[$10_1 + 4 >> 2] = 0;
        HEAP32[$7_1 >> 2] = 0;
        HEAP32[$7_1 + 4 >> 2] = 0;
        HEAP32[$13_1 >> 2] = 0;
        HEAP32[$13_1 + 4 >> 2] = 0;
        HEAP32[$18_1 >> 2] = 0;
        HEAP32[$18_1 + 4 >> 2] = 0;
        HEAP32[$19_1 >> 2] = 0;
        HEAP32[$19_1 + 4 >> 2] = 0;
        HEAP32[$17_1 >> 2] = 0;
        HEAP32[$17_1 + 4 >> 2] = 0;
        HEAP32[$3_1 + 128 >> 2] = 0;
        HEAP32[$3_1 + 132 >> 2] = 0;
        if (($57(HEAP32[172688], $2_1, 690917) | 0) == 1) {
          $17_1 = $6();
          $6_1 = global$0 - 288 | 0;
          global$0 = $6_1;
          label$4: {
            if (!$3_1) {
              FUNCTION_TABLE[HEAP32[$17_1 + 168 >> 2]](689629, HEAP32[$17_1 + 172 >> 2]);
              break label$4;
            }
            $5_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
            $2_1 = $5_1 >>> 16 | 0;
            $4_1 = $6_1 + 72 | 0;
            $1_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
            HEAP32[$4_1 >> 2] = ($5_1 & 65535) << 16 | $1_1 >>> 16;
            HEAP32[$4_1 + 4 >> 2] = $2_1;
            $9_1 = $1_1 << 4 & 1048560;
            $5_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
            $2_1 = $5_1 >>> 28 | 0;
            $4_1 = $6_1 - -64 | 0;
            $1_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
            HEAP32[$4_1 >> 2] = ($5_1 & 268435455) << 4 | $1_1 >>> 28;
            HEAP32[$4_1 + 4 >> 2] = $2_1 | $9_1;
            $2_1 = $5_1 << 24 | $1_1 >>> 8;
            $9_1 = $1_1 << 24 & -16777216;
            $1_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
            $4_1 = $6_1 + 56 | 0;
            $5_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
            HEAP32[$4_1 >> 2] = $5_1 >>> 8 | $9_1;
            HEAP32[$4_1 + 4 >> 2] = $2_1 & 1048575;
            $5_1 = ($5_1 << 12 | $1_1 >>> 20) & 1048575;
            $9_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
            $4_1 = $6_1 + 48 | 0;
            $10_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
            HEAP32[$4_1 >> 2] = $1_1 << 12 & -4096 | $10_1 >>> 20;
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            HEAP32[$6_1 + 40 >> 2] = $9_1;
            HEAP32[$6_1 + 44 >> 2] = $10_1 & 1048575;
            $2_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
            $4_1 = $2_1;
            $5_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
            $2_1 = $2_1 << 12 | $5_1 >>> 20;
            $9_1 = $5_1 << 12 & -4096;
            $5_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            $1_1 = $6_1;
            $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            $11_1 = $7_1 >>> 20 | $9_1;
            HEAP32[$1_1 + 8 >> 2] = $11_1;
            $14_1 = $2_1 & 1048575;
            HEAP32[$1_1 + 12 >> 2] = $14_1;
            $9_1 = $5_1;
            HEAP32[$1_1 >> 2] = $5_1;
            $12_1 = $7_1 & 1048575;
            HEAP32[$1_1 + 4 >> 2] = $12_1;
            $5_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
            $2_1 = $5_1 >>> 16 | 0;
            $10_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
            $18_1 = ($5_1 & 65535) << 16 | $10_1 >>> 16;
            HEAP32[$1_1 + 32 >> 2] = $18_1;
            $13_1 = $2_1;
            HEAP32[$1_1 + 36 >> 2] = $2_1;
            $2_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
            $5_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
            $16_1 = ($2_1 << 24 | $5_1 >>> 8) & 1048575;
            $4_1 = $5_1 << 24 & -16777216 | $4_1 >>> 8;
            HEAP32[$1_1 + 16 >> 2] = $4_1;
            $15_1 = $16_1;
            HEAP32[$1_1 + 20 >> 2] = $15_1;
            $10_1 = $10_1 << 4 & 1048560;
            $1_1 = $2_1;
            $2_1 = $1_1 >>> 28 | 0;
            $1_1 = ($1_1 & 268435455) << 4 | $5_1 >>> 28;
            HEAP32[$6_1 + 24 >> 2] = $1_1;
            $2_1 = $2_1 | $10_1;
            HEAP32[$6_1 + 28 >> 2] = $2_1;
            if (!($9_1 | $11_1 | $18_1 | $4_1 | $1_1 | ($14_1 | $12_1 | $13_1 | $15_1 | $2_1))) {
              FUNCTION_TABLE[HEAP32[$17_1 + 168 >> 2]](690116, HEAP32[$17_1 + 172 >> 2]);
              break label$4;
            }
            HEAP32[$6_1 + 92 >> 2] = 0;
            $38($6_1 + 96 | 0, 690949, $6_1 + 92 | 0);
            if (HEAP32[$6_1 + 92 >> 2]) {
              break label$4;
            }
            $1_1 = $6_1 + 8 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $2_1 = $6_1 + 160 | 0;
            $4_1 = $2_1 + 8 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 + 16 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 + 16 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 + 24 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 + 24 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 + 32 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 + 32 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 + 48 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 + 48 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 + 56 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 + 56 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 - -64 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 - -64 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $6_1 + 72 | 0;
            $5_1 = HEAP32[$1_1 + 4 >> 2];
            $4_1 = $2_1 + 72 | 0;
            HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            HEAP32[$6_1 + 280 >> 2] = 0;
            $1_1 = HEAP32[$6_1 + 4 >> 2];
            HEAP32[$6_1 + 160 >> 2] = HEAP32[$6_1 >> 2];
            HEAP32[$6_1 + 164 >> 2] = $1_1;
            $1_1 = HEAP32[$6_1 + 44 >> 2];
            HEAP32[$6_1 + 200 >> 2] = HEAP32[$6_1 + 40 >> 2];
            HEAP32[$6_1 + 204 >> 2] = $1_1;
            $1_1 = $6_1 + 248 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $6_1 + 256 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $6_1 + 264 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $6_1 + 272 | 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
            $1_1 = $6_1 + 128 | 0;
            $5_1 = $1_1 + 16 | 0;
            HEAP32[$5_1 >> 2] = 0;
            HEAP32[$5_1 + 4 >> 2] = 0;
            $5_1 = $1_1 + 24 | 0;
            HEAP32[$5_1 >> 2] = 0;
            HEAP32[$5_1 + 4 >> 2] = 0;
            HEAP32[$6_1 + 240 >> 2] = 1;
            HEAP32[$6_1 + 244 >> 2] = 0;
            HEAP32[$6_1 + 136 >> 2] = 0;
            HEAP32[$6_1 + 140 >> 2] = 0;
            HEAP32[$6_1 + 128 >> 2] = 1;
            HEAP32[$6_1 + 132 >> 2] = 0;
            $42($2_1, $2_1, $1_1, $6_1 + 96 | 0);
            if (HEAP32[$6_1 + 280 >> 2]) {
              break label$4;
            }
            $49($6_1, $6_1 + 160 | 0);
            $5_1 = HEAP32[$6_1 + 8 >> 2];
            $4_1 = HEAP32[$6_1 + 12 >> 2];
            $9_1 = HEAP32[$6_1 + 4 >> 2];
            $7_1 = HEAP32[$6_1 + 32 >> 2];
            $10_1 = HEAP32[$6_1 + 36 >> 2];
            $18_1 = $10_1;
            $2_1 = HEAP32[$6_1 >> 2];
            $1_1 = __wasm_i64_mul($10_1 >>> 16 | 0, 0, 977, 1);
            $15_1 = $2_1 + $1_1 | 0;
            $2_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
            $13_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $4_1;
            $1_1 = $13_1 >>> 20 | 0;
            $4_1 = $1_1;
            $1_1 = $1_1 + $5_1 | 0;
            $4_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $17_1 = $4_1 & 1048575;
            $19_1 = HEAP32[$6_1 + 24 >> 2];
            $11_1 = HEAP32[$6_1 + 28 >> 2];
            $2_1 = HEAP32[$6_1 + 20 >> 2];
            $5_1 = $4_1 >>> 20 | 0;
            $10_1 = $5_1 + HEAP32[$6_1 + 16 >> 2] | 0;
            $9_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $11_1;
            $5_1 = $9_1 >>> 20 | 0;
            $8_1 = $5_1;
            $5_1 = $5_1 + $19_1 | 0;
            $2_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $11_1 = $2_1 & 1048575;
            $9_1 = $9_1 & 1048575;
            $19_1 = ($1_1 & $10_1 & $5_1) == -1 & ($4_1 & $9_1 & $2_1) == 1048575;
            $4_1 = $2_1;
            $2_1 = $18_1 & 65535;
            $4_1 = $4_1 >>> 20 | 0;
            $12_1 = $4_1 + $7_1 | 0;
            $2_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $4_1 = $2_1;
            $14_1 = $13_1 & 1048575;
            if ($19_1 & (($12_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($14_1 | 0) == 1048574 & $15_1 >>> 0 > 4294966318 | $14_1 >>> 0 > 1048574) | $2_1 >>> 16) {
              $2_1 = $14_1 + 1 | 0;
              $15_1 = $15_1 + 977 | 0;
              $2_1 = $15_1 >>> 0 < 977 ? $2_1 + 1 | 0 : $2_1;
              $14_1 = $2_1 & 1048575;
              $7_1 = $2_1;
              $2_1 = $17_1;
              $7_1 = $7_1 >>> 20 | 0;
              $1_1 = $1_1 + $7_1 | 0;
              $2_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $17_1 = $2_1 & 1048575;
              $7_1 = $2_1;
              $2_1 = $9_1;
              $7_1 = $7_1 >>> 20 | 0;
              $10_1 = $7_1 + $10_1 | 0;
              $2_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $9_1 = $2_1 & 1048575;
              $7_1 = $2_1;
              $2_1 = $11_1;
              $7_1 = $7_1 >>> 20 | 0;
              $5_1 = $5_1 + $7_1 | 0;
              $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $11_1 = $2_1 & 1048575;
              $7_1 = $2_1;
              $2_1 = $4_1;
              $4_1 = $12_1;
              $12_1 = ($7_1 >>> 20 | 0) + $12_1 | 0;
              $4_1 = ($4_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) & 65535;
            }
            HEAP32[$6_1 + 32 >> 2] = $12_1;
            HEAP32[$6_1 + 36 >> 2] = $4_1;
            HEAP32[$6_1 + 24 >> 2] = $5_1;
            HEAP32[$6_1 + 28 >> 2] = $11_1;
            HEAP32[$6_1 + 16 >> 2] = $10_1;
            HEAP32[$6_1 + 20 >> 2] = $9_1;
            HEAP32[$6_1 + 8 >> 2] = $1_1;
            HEAP32[$6_1 + 12 >> 2] = $17_1;
            HEAP32[$6_1 >> 2] = $15_1;
            HEAP32[$6_1 + 4 >> 2] = $14_1;
            $18_1 = HEAP32[$6_1 + 48 >> 2];
            $19_1 = HEAP32[$6_1 + 52 >> 2];
            $8_1 = HEAP32[$6_1 + 44 >> 2];
            $7_1 = HEAP32[$6_1 + 72 >> 2];
            $16_1 = HEAP32[$6_1 + 76 >> 2];
            $23_1 = $16_1;
            $2_1 = HEAP32[$6_1 + 40 >> 2];
            $13_1 = __wasm_i64_mul($16_1 >>> 16 | 0, 0, 977, 1);
            $16_1 = $2_1 + $13_1 | 0;
            $2_1 = $8_1 + i64toi32_i32$HIGH_BITS | 0;
            $21_1 = $13_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $19_1;
            $13_1 = $21_1 >>> 20 | 0;
            $18_1 = $13_1 + $18_1 | 0;
            $8_1 = $13_1 >>> 0 > $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $24_1 = $8_1 & 1048575;
            $22_1 = $7_1;
            $25_1 = $23_1 & 65535;
            $13_1 = HEAP32[$6_1 + 64 >> 2];
            $20_1 = HEAP32[$6_1 + 68 >> 2];
            $2_1 = HEAP32[$6_1 + 60 >> 2];
            $7_1 = $8_1 >>> 20 | 0;
            $19_1 = $7_1 + HEAP32[$6_1 + 56 >> 2] | 0;
            $23_1 = $7_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $20_1;
            $7_1 = $23_1 >>> 20 | 0;
            $20_1 = $7_1;
            $7_1 = $7_1 + $13_1 | 0;
            $13_1 = $20_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $2_1 = $25_1;
            $20_1 = $13_1 >>> 20 | 0;
            $25_1 = $20_1;
            $20_1 = $22_1 + $20_1 | 0;
            $2_1 = $25_1 >>> 0 > $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            $22_1 = $23_1 & 1048575;
            $21_1 = $21_1 & 1048575;
            if (($19_1 & $18_1 & $7_1) == -1 & ($8_1 & $22_1 & $13_1) == 1048575 & (($20_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($21_1 | 0) == 1048574 & $16_1 >>> 0 > 4294966318 | $21_1 >>> 0 > 1048574) | $2_1 >>> 16) {
              $2_1 = $21_1 + 1 | 0;
              $16_1 = $16_1 + 977 | 0;
              $2_1 = $16_1 >>> 0 < 977 ? $2_1 + 1 | 0 : $2_1;
              $21_1 = $2_1 & 1048575;
              $8_1 = $2_1;
              $2_1 = $24_1;
              $8_1 = $8_1 >>> 20 | 0;
              $18_1 = $8_1 + $18_1 | 0;
              $2_1 = $8_1 >>> 0 > $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $24_1 = $2_1 & 1048575;
              $8_1 = $2_1;
              $2_1 = $22_1;
              $8_1 = $8_1 >>> 20 | 0;
              $19_1 = $8_1 + $19_1 | 0;
              $2_1 = $8_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
              $22_1 = $2_1 & 1048575;
              $8_1 = $2_1;
              $2_1 = $13_1;
              $8_1 = $8_1 >>> 20 | 0;
              $7_1 = $7_1 + $8_1 | 0;
              $13_1 = $8_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
            }
            HEAP32[$6_1 + 56 >> 2] = $19_1;
            HEAP32[$6_1 + 60 >> 2] = $22_1;
            HEAP32[$6_1 + 48 >> 2] = $18_1;
            HEAP32[$6_1 + 52 >> 2] = $24_1;
            HEAP32[$6_1 + 40 >> 2] = $16_1;
            HEAP32[$6_1 + 44 >> 2] = $21_1;
            HEAP32[$6_1 + 64 >> 2] = $7_1;
            HEAP32[$6_1 + 68 >> 2] = $13_1 & 1048575;
            if (HEAPU8[690917] != ($4_1 >>> 8 & 255)) {
              break label$4;
            }
            if (HEAPU8[690918] != ($4_1 & 255)) {
              break label$4;
            }
            if (HEAPU8[690919] != ((($4_1 & 16777215) << 8 | $12_1 >>> 24) & 255)) {
              break label$4;
            }
            if (HEAPU8[690920] != ((($4_1 & 65535) << 16 | $12_1 >>> 16) & 255)) {
              break label$4;
            }
            if (HEAPU8[690921] != ((($4_1 & 255) << 24 | $12_1 >>> 8) & 255)) {
              break label$4;
            }
            if (HEAPU8[690922] != ($12_1 & 255)) {
              break label$4;
            }
            if (HEAPU8[690923] != ($11_1 >>> 12 | 0)) {
              break label$4;
            }
            if (HEAPU8[690924] != ($11_1 >>> 4 & 255)) {
              break label$4;
            }
            if (HEAPU8[690925] != ((($11_1 & 268435455) << 4 | $5_1 >>> 28) & 255)) {
              break label$4;
            }
            if (HEAPU8[690926] != ((($11_1 & 1048575) << 12 | $5_1 >>> 20) & 255)) {
              break label$4;
            }
            if (HEAPU8[690927] != ((($11_1 & 4095) << 20 | $5_1 >>> 12) & 255)) {
              break label$4;
            }
            if (HEAPU8[690928] != ((($11_1 & 15) << 28 | $5_1 >>> 4) & 255)) {
              break label$4;
            }
            if (HEAPU8[690929] != (($5_1 << 4 | $9_1 >>> 16) & 255)) {
              break label$4;
            }
            $2_1 = $9_1;
            if (HEAPU8[690930] != ($2_1 >>> 8 & 255)) {
              break label$4;
            }
            if (HEAPU8[690931] != ($2_1 & 255)) {
              break label$4;
            }
            if (HEAPU8[690932] != ((($9_1 & 16777215) << 8 | $10_1 >>> 24) & 255)) {
              break label$4;
            }
            if (HEAPU8[690933] != ((($9_1 & 65535) << 16 | $10_1 >>> 16) & 255)) {
              break label$4;
            }
            if (HEAPU8[690934] != ((($9_1 & 255) << 24 | $10_1 >>> 8) & 255)) {
              break label$4;
            }
            if (HEAPU8[690935] != ($10_1 & 255)) {
              break label$4;
            }
            if (HEAPU8[690936] != ($17_1 >>> 12 | 0)) {
              break label$4;
            }
            if (HEAPU8[690937] != ($17_1 >>> 4 & 255)) {
              break label$4;
            }
            if (HEAPU8[690938] != ((($17_1 & 268435455) << 4 | $1_1 >>> 28) & 255)) {
              break label$4;
            }
            if (HEAPU8[690939] != ((($17_1 & 1048575) << 12 | $1_1 >>> 20) & 255)) {
              break label$4;
            }
            if (HEAPU8[690940] != ((($17_1 & 4095) << 20 | $1_1 >>> 12) & 255)) {
              break label$4;
            }
            if (HEAPU8[690941] != ((($17_1 & 15) << 28 | $1_1 >>> 4) & 255)) {
              break label$4;
            }
            if (HEAPU8[690942] != (($1_1 << 4 | $14_1 >>> 16) & 255)) {
              break label$4;
            }
            $2_1 = $14_1;
            if (HEAPU8[690943] != ($2_1 >>> 8 & 255)) {
              break label$4;
            }
            if (HEAPU8[690944] != ($2_1 & 255)) {
              break label$4;
            }
            if (HEAPU8[690945] != ((($14_1 & 16777215) << 8 | $15_1 >>> 24) & 255)) {
              break label$4;
            }
            if (HEAPU8[690946] != ((($14_1 & 65535) << 16 | $15_1 >>> 16) & 255)) {
              break label$4;
            }
            if (HEAPU8[690947] != ((($14_1 & 255) << 24 | $15_1 >>> 8) & 255)) {
              break label$4;
            }
            if (HEAPU8[690948] != ($15_1 & 255)) {
              break label$4;
            }
            $26_1 = ($16_1 & 1) == ($0_1 | 0);
          }
          global$0 = $6_1 + 288 | 0;
          break label$1;
        }
        fimport$1(1);
        break label$1;
      }
      fimport$1(1);
    }
    global$0 = $3_1 + 192 | 0;
    return $26_1 | 0;
  }
  function $13($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0;
    $3_1 = global$0 - 208 | 0;
    global$0 = $3_1;
    $2_1 = $3_1 + 136 | 0;
    $5_1 = $2_1 + 56 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 48 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 40 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 32 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $5_1 = $2_1 + 8 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 136 >> 2] = 0;
    HEAP32[$3_1 + 140 >> 2] = 0;
    label$1: {
      if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
        $2_1 = $3_1 + 136 | 0;
        $0_1 = $2_1 + 15 | 0;
        $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $5_1 = $3_1 + 72 | 0;
        $6_1 = $5_1 + 8 | 0;
        HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$6_1 + 4 >> 2] = $4_1;
        $0_1 = $2_1 + 23 | 0;
        $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $7_1 = $5_1 + 16 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $4_1;
        $0_1 = $2_1 + 31 | 0;
        $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $8_1 = $5_1 + 24 | 0;
        HEAP32[$8_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$8_1 + 4 >> 2] = $4_1;
        $0_1 = $2_1 + 39 | 0;
        $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $9_1 = $5_1 + 32 | 0;
        HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$9_1 + 4 >> 2] = $4_1;
        $0_1 = $2_1 + 47 | 0;
        $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $10_1 = $5_1 + 40 | 0;
        HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$10_1 + 4 >> 2] = $4_1;
        $0_1 = $2_1 + 55 | 0;
        $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $11_1 = $5_1 + 48 | 0;
        HEAP32[$11_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$11_1 + 4 >> 2] = $4_1;
        $4_1 = $5_1 + 56 | 0;
        HEAP8[$4_1 | 0] = HEAPU8[$2_1 + 63 | 0];
        HEAP8[$3_1 + 10 | 0] = HEAPU8[$3_1 + 138 | 0];
        HEAP16[$3_1 + 8 >> 1] = HEAPU16[$3_1 + 136 >> 1];
        $0_1 = HEAPU8[$3_1 + 147 | 0] | HEAPU8[$3_1 + 148 | 0] << 8 | (HEAPU8[$3_1 + 149 | 0] << 16 | HEAPU8[$3_1 + 150 | 0] << 24);
        HEAP32[$3_1 + 72 >> 2] = HEAPU8[$3_1 + 143 | 0] | HEAPU8[$3_1 + 144 | 0] << 8 | (HEAPU8[$3_1 + 145 | 0] << 16 | HEAPU8[$3_1 + 146 | 0] << 24);
        HEAP32[$3_1 + 76 >> 2] = $0_1;
        $5_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
        $0_1 = $3_1 + 8 | 0;
        HEAP8[$0_1 + 63 | 0] = HEAPU8[$4_1 | 0];
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $2_1 = $0_1 + 55 | 0;
        $11_1 = HEAP32[$11_1 >> 2];
        HEAP8[$2_1 | 0] = $11_1;
        HEAP8[$2_1 + 1 | 0] = $11_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $11_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $11_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$10_1 + 4 >> 2];
        $2_1 = $0_1 + 47 | 0;
        $10_1 = HEAP32[$10_1 >> 2];
        HEAP8[$2_1 | 0] = $10_1;
        HEAP8[$2_1 + 1 | 0] = $10_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $10_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $10_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $2_1 = $0_1 + 39 | 0;
        $9_1 = HEAP32[$9_1 >> 2];
        HEAP8[$2_1 | 0] = $9_1;
        HEAP8[$2_1 + 1 | 0] = $9_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $9_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $9_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$8_1 + 4 >> 2];
        $2_1 = $0_1 + 31 | 0;
        $8_1 = HEAP32[$8_1 >> 2];
        HEAP8[$2_1 | 0] = $8_1;
        HEAP8[$2_1 + 1 | 0] = $8_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $8_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $8_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$7_1 + 4 >> 2];
        $2_1 = $0_1 + 23 | 0;
        $7_1 = HEAP32[$7_1 >> 2];
        HEAP8[$2_1 | 0] = $7_1;
        HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$6_1 + 4 >> 2];
        $2_1 = $0_1 + 15 | 0;
        $6_1 = HEAP32[$6_1 >> 2];
        HEAP8[$2_1 | 0] = $6_1;
        HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        HEAP8[$3_1 + 11 | 0] = $5_1;
        HEAP8[$3_1 + 12 | 0] = $5_1 >>> 8;
        HEAP8[$3_1 + 13 | 0] = $5_1 >>> 16;
        HEAP8[$3_1 + 14 | 0] = $5_1 >>> 24;
        $2_1 = HEAP32[$3_1 + 76 >> 2];
        $5_1 = HEAP32[$3_1 + 72 >> 2];
        HEAP8[$3_1 + 15 | 0] = $5_1;
        HEAP8[$3_1 + 16 | 0] = $5_1 >>> 8;
        HEAP8[$3_1 + 17 | 0] = $5_1 >>> 16;
        HEAP8[$3_1 + 18 | 0] = $5_1 >>> 24;
        HEAP8[$3_1 + 19 | 0] = $2_1;
        HEAP8[$3_1 + 20 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 21 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 22 | 0] = $2_1 >>> 24;
        HEAP32[$3_1 + 204 >> 2] = $1_1;
        $0_1 = $36(HEAP32[172688], $3_1 + 204 | 0, $0_1, ($1_1 | 0) == 33 ? 258 : 2);
        HEAP32[$3_1 + 72 >> 2] = $0_1;
        if (($0_1 | 0) == 1) {
          break label$1;
        }
        HEAP32[$3_1 + 144 >> 2] = 0;
        $5($3_1 + 136 | 0);
        wasm2js_trap();
      }
      fimport$1(1);
    }
    global$0 = $3_1 + 208 | 0;
  }
  function $14($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
    $2_1 = global$0 - 96 | 0;
    global$0 = $2_1;
    $1_1 = $2_1 + 56 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $2_1 + 48 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $2_1 + 40 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $2_1 + 32 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $2_1 + 24 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $2_1 + 16 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $2_1 + 8 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $4_1 = $6();
    $3_1 = global$0 - 256 | 0;
    global$0 = $3_1;
    label$1: {
      if (!$2_1) {
        FUNCTION_TABLE[HEAP32[$4_1 + 168 >> 2]](689638, HEAP32[$4_1 + 172 >> 2]);
        $1_1 = 0;
        break label$1;
      }
      HEAP8[$2_1 | 0] = 0;
      HEAP8[$2_1 + 1 | 0] = 0;
      HEAP8[$2_1 + 2 | 0] = 0;
      HEAP8[$2_1 + 3 | 0] = 0;
      HEAP8[$2_1 + 4 | 0] = 0;
      HEAP8[$2_1 + 5 | 0] = 0;
      HEAP8[$2_1 + 6 | 0] = 0;
      HEAP8[$2_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 56 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 48 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 40 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 32 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 24 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 16 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $2_1 + 8 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      if (!HEAP32[$4_1 >> 2]) {
        FUNCTION_TABLE[HEAP32[$4_1 + 168 >> 2]](690045, HEAP32[$4_1 + 172 >> 2]);
        $1_1 = 0;
        break label$1;
      }
      $8_1 = $3_1 + 8 | 0;
      $6_1 = $3_1 + 128 | 0;
      $38($8_1, 690788, $6_1);
      $9_1 = HEAP32[$3_1 + 32 >> 2];
      $10_1 = HEAP32[$3_1 + 24 >> 2];
      $5_1 = HEAP32[$3_1 + 16 >> 2];
      $11_1 = HEAP32[$3_1 + 8 >> 2];
      $12_1 = HEAP32[$3_1 + 36 >> 2];
      $13_1 = HEAP32[$3_1 + 28 >> 2];
      $14_1 = HEAP32[$3_1 + 20 >> 2];
      $15_1 = HEAP32[$3_1 + 12 >> 2];
      $7_1 = HEAP32[$3_1 + 128 >> 2] | !($9_1 | ($10_1 | ($5_1 | $11_1)) | ($12_1 | ($13_1 | ($14_1 | $15_1))));
      $1_1 = $7_1 ? 0 : -1;
      HEAP32[$3_1 + 32 >> 2] = $1_1 & $9_1;
      HEAP32[$3_1 + 36 >> 2] = $1_1 & $12_1;
      HEAP32[$3_1 + 24 >> 2] = $1_1 & $10_1;
      HEAP32[$3_1 + 28 >> 2] = $1_1 & $13_1;
      HEAP32[$3_1 + 16 >> 2] = $1_1 & $5_1;
      HEAP32[$3_1 + 20 >> 2] = $1_1 & $14_1;
      $5_1 = ($7_1 | 0) != 0;
      HEAP32[$3_1 + 8 >> 2] = $5_1 | $1_1 & $11_1;
      HEAP32[$3_1 + 12 >> 2] = $1_1 & $15_1;
      $48($4_1, $6_1, $8_1);
      $1_1 = $3_1 + 40 | 0;
      $49($1_1, $6_1);
      $35($2_1, $1_1);
      HEAP32[$3_1 + 128 >> 2] = $5_1;
      $1_1 = HEAP32[$3_1 + 128 >> 2] - 1 | 0;
      HEAP8[$2_1 | 0] = $1_1 & HEAPU8[$2_1 | 0];
      HEAP8[$2_1 + 1 | 0] = HEAPU8[$2_1 + 1 | 0] & $1_1;
      HEAP8[$2_1 + 2 | 0] = HEAPU8[$2_1 + 2 | 0] & $1_1;
      HEAP8[$2_1 + 3 | 0] = HEAPU8[$2_1 + 3 | 0] & $1_1;
      HEAP8[$2_1 + 4 | 0] = HEAPU8[$2_1 + 4 | 0] & $1_1;
      HEAP8[$2_1 + 5 | 0] = HEAPU8[$2_1 + 5 | 0] & $1_1;
      HEAP8[$2_1 + 6 | 0] = HEAPU8[$2_1 + 6 | 0] & $1_1;
      HEAP8[$2_1 + 7 | 0] = HEAPU8[$2_1 + 7 | 0] & $1_1;
      HEAP8[$2_1 + 8 | 0] = HEAPU8[$2_1 + 8 | 0] & $1_1;
      HEAP8[$2_1 + 9 | 0] = HEAPU8[$2_1 + 9 | 0] & $1_1;
      HEAP8[$2_1 + 10 | 0] = HEAPU8[$2_1 + 10 | 0] & $1_1;
      HEAP8[$2_1 + 11 | 0] = HEAPU8[$2_1 + 11 | 0] & $1_1;
      HEAP8[$2_1 + 12 | 0] = HEAPU8[$2_1 + 12 | 0] & $1_1;
      HEAP8[$2_1 + 13 | 0] = HEAPU8[$2_1 + 13 | 0] & $1_1;
      HEAP8[$2_1 + 14 | 0] = HEAPU8[$2_1 + 14 | 0] & $1_1;
      HEAP8[$2_1 + 15 | 0] = HEAPU8[$2_1 + 15 | 0] & $1_1;
      HEAP8[$2_1 + 16 | 0] = HEAPU8[$2_1 + 16 | 0] & $1_1;
      HEAP8[$2_1 + 17 | 0] = HEAPU8[$2_1 + 17 | 0] & $1_1;
      HEAP8[$2_1 + 18 | 0] = HEAPU8[$2_1 + 18 | 0] & $1_1;
      HEAP8[$2_1 + 19 | 0] = HEAPU8[$2_1 + 19 | 0] & $1_1;
      HEAP8[$2_1 + 20 | 0] = HEAPU8[$2_1 + 20 | 0] & $1_1;
      HEAP8[$2_1 + 21 | 0] = HEAPU8[$2_1 + 21 | 0] & $1_1;
      HEAP8[$2_1 + 22 | 0] = HEAPU8[$2_1 + 22 | 0] & $1_1;
      HEAP8[$2_1 + 23 | 0] = HEAPU8[$2_1 + 23 | 0] & $1_1;
      HEAP8[$2_1 + 24 | 0] = HEAPU8[$2_1 + 24 | 0] & $1_1;
      HEAP8[$2_1 + 25 | 0] = HEAPU8[$2_1 + 25 | 0] & $1_1;
      HEAP8[$2_1 + 26 | 0] = HEAPU8[$2_1 + 26 | 0] & $1_1;
      HEAP8[$2_1 + 27 | 0] = HEAPU8[$2_1 + 27 | 0] & $1_1;
      HEAP8[$2_1 + 28 | 0] = HEAPU8[$2_1 + 28 | 0] & $1_1;
      HEAP8[$2_1 + 29 | 0] = HEAPU8[$2_1 + 29 | 0] & $1_1;
      HEAP8[$2_1 + 30 | 0] = HEAPU8[$2_1 + 30 | 0] & $1_1;
      HEAP8[$2_1 + 31 | 0] = HEAPU8[$2_1 + 31 | 0] & $1_1;
      HEAP8[$2_1 + 32 | 0] = HEAPU8[$2_1 + 32 | 0] & $1_1;
      HEAP8[$2_1 + 33 | 0] = HEAPU8[$2_1 + 33 | 0] & $1_1;
      HEAP8[$2_1 + 34 | 0] = HEAPU8[$2_1 + 34 | 0] & $1_1;
      HEAP8[$2_1 + 35 | 0] = HEAPU8[$2_1 + 35 | 0] & $1_1;
      HEAP8[$2_1 + 36 | 0] = HEAPU8[$2_1 + 36 | 0] & $1_1;
      HEAP8[$2_1 + 37 | 0] = HEAPU8[$2_1 + 37 | 0] & $1_1;
      HEAP8[$2_1 + 38 | 0] = HEAPU8[$2_1 + 38 | 0] & $1_1;
      HEAP8[$2_1 + 39 | 0] = HEAPU8[$2_1 + 39 | 0] & $1_1;
      HEAP8[$2_1 + 40 | 0] = HEAPU8[$2_1 + 40 | 0] & $1_1;
      HEAP8[$2_1 + 41 | 0] = HEAPU8[$2_1 + 41 | 0] & $1_1;
      HEAP8[$2_1 + 42 | 0] = HEAPU8[$2_1 + 42 | 0] & $1_1;
      HEAP8[$2_1 + 43 | 0] = HEAPU8[$2_1 + 43 | 0] & $1_1;
      HEAP8[$2_1 + 44 | 0] = HEAPU8[$2_1 + 44 | 0] & $1_1;
      HEAP8[$2_1 + 45 | 0] = HEAPU8[$2_1 + 45 | 0] & $1_1;
      HEAP8[$2_1 + 46 | 0] = HEAPU8[$2_1 + 46 | 0] & $1_1;
      HEAP8[$2_1 + 47 | 0] = HEAPU8[$2_1 + 47 | 0] & $1_1;
      HEAP8[$2_1 + 48 | 0] = HEAPU8[$2_1 + 48 | 0] & $1_1;
      HEAP8[$2_1 + 49 | 0] = HEAPU8[$2_1 + 49 | 0] & $1_1;
      HEAP8[$2_1 + 50 | 0] = HEAPU8[$2_1 + 50 | 0] & $1_1;
      HEAP8[$2_1 + 51 | 0] = HEAPU8[$2_1 + 51 | 0] & $1_1;
      HEAP8[$2_1 + 52 | 0] = HEAPU8[$2_1 + 52 | 0] & $1_1;
      HEAP8[$2_1 + 53 | 0] = HEAPU8[$2_1 + 53 | 0] & $1_1;
      HEAP8[$2_1 + 54 | 0] = HEAPU8[$2_1 + 54 | 0] & $1_1;
      HEAP8[$2_1 + 55 | 0] = HEAPU8[$2_1 + 55 | 0] & $1_1;
      HEAP8[$2_1 + 56 | 0] = HEAPU8[$2_1 + 56 | 0] & $1_1;
      HEAP8[$2_1 + 57 | 0] = HEAPU8[$2_1 + 57 | 0] & $1_1;
      HEAP8[$2_1 + 58 | 0] = HEAPU8[$2_1 + 58 | 0] & $1_1;
      HEAP8[$2_1 + 59 | 0] = HEAPU8[$2_1 + 59 | 0] & $1_1;
      HEAP8[$2_1 + 60 | 0] = HEAPU8[$2_1 + 60 | 0] & $1_1;
      HEAP8[$2_1 + 61 | 0] = HEAPU8[$2_1 + 61 | 0] & $1_1;
      HEAP8[$2_1 + 62 | 0] = HEAPU8[$2_1 + 62 | 0] & $1_1;
      HEAP8[$2_1 + 63 | 0] = HEAPU8[$2_1 + 63 | 0] & $1_1;
      $1_1 = !$7_1;
    }
    global$0 = $3_1 + 256 | 0;
    label$4: {
      if ($1_1) {
        HEAP32[$2_1 + 64 >> 2] = $0_1;
        $0_1 = $36(HEAP32[172688], $2_1 - -64 | 0, $2_1, ($0_1 | 0) == 33 ? 258 : 2);
        HEAP32[$2_1 + 68 >> 2] = $0_1;
        if (($0_1 | 0) != 1) {
          break label$4;
        }
        $16_1 = 1;
      }
      global$0 = $2_1 + 96 | 0;
      return $16_1 | 0;
    }
    HEAP32[$2_1 + 80 >> 2] = 0;
    $5($2_1 + 72 | 0);
    wasm2js_trap();
  }
  function $15() {
    var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
    $3_1 = global$0 - 304 | 0;
    global$0 = $3_1;
    $2_1 = $3_1 + 200 | 0;
    $68($2_1, 96);
    label$1: {
      label$2: {
        label$3: {
          if (($60($6(), $2_1) | 0) == 1) {
            HEAP8[$3_1 + 10 | 0] = HEAPU8[$3_1 + 202 | 0];
            HEAP16[$3_1 + 8 >> 1] = HEAPU16[$3_1 + 200 >> 1];
            $2_1 = HEAPU8[$3_1 + 203 | 0] | HEAPU8[$3_1 + 204 | 0] << 8 | (HEAPU8[$3_1 + 205 | 0] << 16 | HEAPU8[$3_1 + 206 | 0] << 24);
            $0_1 = $3_1 + 104 | 0;
            $5_1 = $3_1 + 200 | 0;
            $70($0_1, $5_1 | 7, 89);
            $1_1 = $3_1 + 8 | 0;
            $70($1_1 | 7, $0_1, 89);
            HEAP8[$3_1 + 11 | 0] = $2_1;
            HEAP8[$3_1 + 12 | 0] = $2_1 >>> 8;
            HEAP8[$3_1 + 13 | 0] = $2_1 >>> 16;
            HEAP8[$3_1 + 14 | 0] = $2_1 >>> 24;
            $2_1 = $3_1 + 256 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 248 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 240 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 232 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 224 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 216 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $3_1 + 208 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            HEAP32[$3_1 + 200 >> 2] = 0;
            HEAP32[$3_1 + 204 >> 2] = 0;
            HEAP32[$3_1 + 196 >> 2] = 0;
            $10_1 = $6();
            $15_1 = $3_1 + 196 | 0;
            $2_1 = global$0 - 96 | 0;
            global$0 = $2_1;
            label$5: {
              if (!$5_1) {
                FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](689638, HEAP32[$10_1 + 172 >> 2]);
                $0_1 = 0;
                break label$5;
              }
              HEAP8[$5_1 | 0] = 0;
              HEAP8[$5_1 + 1 | 0] = 0;
              HEAP8[$5_1 + 2 | 0] = 0;
              HEAP8[$5_1 + 3 | 0] = 0;
              HEAP8[$5_1 + 4 | 0] = 0;
              HEAP8[$5_1 + 5 | 0] = 0;
              HEAP8[$5_1 + 6 | 0] = 0;
              HEAP8[$5_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 56 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 48 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 40 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 32 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 24 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 16 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              $0_1 = $5_1 + 8 | 0;
              HEAP8[$0_1 | 0] = 0;
              HEAP8[$0_1 + 1 | 0] = 0;
              HEAP8[$0_1 + 2 | 0] = 0;
              HEAP8[$0_1 + 3 | 0] = 0;
              HEAP8[$0_1 + 4 | 0] = 0;
              HEAP8[$0_1 + 5 | 0] = 0;
              HEAP8[$0_1 + 6 | 0] = 0;
              HEAP8[$0_1 + 7 | 0] = 0;
              if (!$1_1) {
                FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](689700, HEAP32[$10_1 + 172 >> 2]);
                $0_1 = 0;
                break label$5;
              }
              $11_1 = HEAPU8[$1_1 + 92 | 0] | HEAPU8[$1_1 + 93 | 0] << 8 | (HEAPU8[$1_1 + 94 | 0] << 16 | HEAPU8[$1_1 + 95 | 0] << 24);
              $0_1 = $11_1 >>> 16 | 0;
              $6_1 = $2_1 + 80 | 0;
              $7_1 = HEAPU8[$1_1 + 88 | 0] | HEAPU8[$1_1 + 89 | 0] << 8 | (HEAPU8[$1_1 + 90 | 0] << 16 | HEAPU8[$1_1 + 91 | 0] << 24);
              $11_1 = ($11_1 & 65535) << 16 | $7_1 >>> 16;
              HEAP32[$6_1 >> 2] = $11_1;
              $24_1 = $0_1;
              HEAP32[$6_1 + 4 >> 2] = $0_1;
              $9_1 = $7_1 << 4 & 1048560;
              $4_1 = HEAPU8[$1_1 + 84 | 0] | HEAPU8[$1_1 + 85 | 0] << 8 | (HEAPU8[$1_1 + 86 | 0] << 16 | HEAPU8[$1_1 + 87 | 0] << 24);
              $0_1 = $4_1 >>> 28 | 0;
              $6_1 = $2_1 + 72 | 0;
              $7_1 = HEAPU8[$1_1 + 80 | 0] | HEAPU8[$1_1 + 81 | 0] << 8 | (HEAPU8[$1_1 + 82 | 0] << 16 | HEAPU8[$1_1 + 83 | 0] << 24);
              $12_1 = ($4_1 & 268435455) << 4 | $7_1 >>> 28;
              HEAP32[$6_1 >> 2] = $12_1;
              $16_1 = $0_1 | $9_1;
              HEAP32[$6_1 + 4 >> 2] = $16_1;
              $0_1 = $4_1 << 24 | $7_1 >>> 8;
              $8_1 = $7_1 << 24 & -16777216;
              $7_1 = HEAPU8[$1_1 + 72 | 0] | HEAPU8[$1_1 + 73 | 0] << 8 | (HEAPU8[$1_1 + 74 | 0] << 16 | HEAPU8[$1_1 + 75 | 0] << 24);
              $9_1 = $2_1 + 8 | 0;
              $6_1 = $9_1 + 56 | 0;
              $4_1 = HEAPU8[$1_1 + 76 | 0] | HEAPU8[$1_1 + 77 | 0] << 8 | (HEAPU8[$1_1 + 78 | 0] << 16 | HEAPU8[$1_1 + 79 | 0] << 24);
              $13_1 = $4_1 >>> 8 | $8_1;
              HEAP32[$6_1 >> 2] = $13_1;
              $17_1 = $0_1 & 1048575;
              HEAP32[$6_1 + 4 >> 2] = $17_1;
              $0_1 = $7_1;
              $4_1 = $4_1 << 12 | $0_1 >>> 20;
              $7_1 = HEAPU8[$1_1 + 64 | 0] | HEAPU8[$1_1 + 65 | 0] << 8 | (HEAPU8[$1_1 + 66 | 0] << 16 | HEAPU8[$1_1 + 67 | 0] << 24);
              $6_1 = $9_1 + 48 | 0;
              $8_1 = HEAPU8[$1_1 + 68 | 0] | HEAPU8[$1_1 + 69 | 0] << 8 | (HEAPU8[$1_1 + 70 | 0] << 16 | HEAPU8[$1_1 + 71 | 0] << 24);
              $14_1 = $0_1 << 12 & -4096 | $8_1 >>> 20;
              HEAP32[$6_1 >> 2] = $14_1;
              $18_1 = $4_1 & 1048575;
              HEAP32[$6_1 + 4 >> 2] = $18_1;
              HEAP32[$2_1 + 88 >> 2] = 0;
              HEAP32[$2_1 + 48 >> 2] = $7_1;
              $19_1 = $8_1 & 1048575;
              HEAP32[$2_1 + 52 >> 2] = $19_1;
              $0_1 = HEAPU8[$1_1 + 44 | 0] | HEAPU8[$1_1 + 45 | 0] << 8 | (HEAPU8[$1_1 + 46 | 0] << 16 | HEAPU8[$1_1 + 47 | 0] << 24);
              $6_1 = $0_1;
              $4_1 = HEAPU8[$1_1 + 40 | 0] | HEAPU8[$1_1 + 41 | 0] << 8 | (HEAPU8[$1_1 + 42 | 0] << 16 | HEAPU8[$1_1 + 43 | 0] << 24);
              $8_1 = ($0_1 << 12 | $4_1 >>> 20) & 1048575;
              $0_1 = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
              $9_1 = $4_1 << 12 & -4096;
              $4_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
              $20_1 = $9_1 | $4_1 >>> 20;
              HEAP32[$2_1 + 16 >> 2] = $20_1;
              $25_1 = $8_1;
              HEAP32[$2_1 + 20 >> 2] = $8_1;
              $9_1 = $0_1;
              HEAP32[$2_1 + 8 >> 2] = $0_1;
              $21_1 = $4_1 & 1048575;
              HEAP32[$2_1 + 12 >> 2] = $21_1;
              $4_1 = HEAPU8[$1_1 + 60 | 0] | HEAPU8[$1_1 + 61 | 0] << 8 | (HEAPU8[$1_1 + 62 | 0] << 16 | HEAPU8[$1_1 + 63 | 0] << 24);
              $0_1 = $4_1 >>> 16 | 0;
              $8_1 = HEAPU8[$1_1 + 56 | 0] | HEAPU8[$1_1 + 57 | 0] << 8 | (HEAPU8[$1_1 + 58 | 0] << 16 | HEAPU8[$1_1 + 59 | 0] << 24);
              $22_1 = ($4_1 & 65535) << 16 | $8_1 >>> 16;
              HEAP32[$2_1 + 40 >> 2] = $22_1;
              $26_1 = $0_1;
              HEAP32[$2_1 + 44 >> 2] = $0_1;
              $4_1 = HEAPU8[$1_1 + 48 | 0] | HEAPU8[$1_1 + 49 | 0] << 8 | (HEAPU8[$1_1 + 50 | 0] << 16 | HEAPU8[$1_1 + 51 | 0] << 24);
              $0_1 = HEAPU8[$1_1 + 52 | 0] | HEAPU8[$1_1 + 53 | 0] << 8 | (HEAPU8[$1_1 + 54 | 0] << 16 | HEAPU8[$1_1 + 55 | 0] << 24);
              $1_1 = $0_1;
              $23_1 = ($0_1 << 24 | $4_1 >>> 8) & 1048575;
              $6_1 = $4_1 << 24 & -16777216 | $6_1 >>> 8;
              HEAP32[$2_1 + 24 >> 2] = $6_1;
              HEAP32[$2_1 + 28 >> 2] = $23_1;
              $8_1 = $8_1 << 4 & 1048560;
              $0_1 = $0_1 >>> 28 | 0;
              $4_1 = ($1_1 & 268435455) << 4 | $4_1 >>> 28;
              HEAP32[$2_1 + 32 >> 2] = $4_1;
              $0_1 = $0_1 | $8_1;
              HEAP32[$2_1 + 36 >> 2] = $0_1;
              if (!($9_1 | $20_1 | $22_1 | $6_1 | $4_1 | ($25_1 | $21_1 | $26_1 | $23_1 | $0_1))) {
                FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](690116, HEAP32[$10_1 + 172 >> 2]);
                $0_1 = 0;
                break label$5;
              }
              if ($7_1 & 1) {
                HEAP32[$2_1 + 80 >> 2] = -4 - $11_1;
                HEAP32[$2_1 + 84 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $24_1 | 0);
                HEAP32[$2_1 + 72 >> 2] = -4 - $12_1;
                HEAP32[$2_1 + 76 >> 2] = 4194303 - (($12_1 >>> 0 > 4294967292) + $16_1 | 0);
                HEAP32[$2_1 + 64 >> 2] = -4 - $13_1;
                HEAP32[$2_1 + 68 >> 2] = 4194303 - (($13_1 >>> 0 > 4294967292) + $17_1 | 0);
                HEAP32[$2_1 + 56 >> 2] = -4 - $14_1;
                HEAP32[$2_1 + 60 >> 2] = 4194303 - (($14_1 >>> 0 > 4294967292) + $18_1 | 0);
                HEAP32[$2_1 + 48 >> 2] = -3908 - $7_1;
                HEAP32[$2_1 + 52 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $19_1 | 0);
                $27_1 = 1;
              }
              if ($15_1) {
                HEAP32[$15_1 >> 2] = $27_1;
              }
              $35($5_1, $2_1 + 8 | 0);
              $0_1 = 1;
            }
            global$0 = $2_1 + 96 | 0;
            HEAP32[$3_1 + 300 >> 2] = $0_1;
            if (($0_1 | 0) == 1) {
              break label$3;
            }
            break label$1;
          }
          fimport$1(0);
          break label$2;
        }
        $2_1 = $58(HEAP32[172688], $3_1 + 200 | 0);
        HEAP32[$3_1 + 300 >> 2] = $2_1;
        $0_1 = 1;
        if (($2_1 | 0) == 1) {
          break label$2;
        }
        break label$1;
      }
      global$0 = $3_1 + 304 | 0;
      return $0_1 | 0;
    }
    HEAP32[$3_1 + 112 >> 2] = 0;
    $5($3_1 + 104 | 0);
    wasm2js_trap();
  }
  function $16($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
    $3_1 = global$0 - 272 | 0;
    global$0 = $3_1;
    $1_1 = $3_1 + 8 | 0;
    $4_1 = $1_1 + 56 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 48 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $5_1 = $1_1 + 40 | 0;
    HEAP32[$5_1 >> 2] = 0;
    HEAP32[$5_1 + 4 >> 2] = 0;
    $6_1 = $1_1 + 32 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $7_1 = $1_1 + 24 | 0;
    HEAP32[$7_1 >> 2] = 0;
    HEAP32[$7_1 + 4 >> 2] = 0;
    $8_1 = $1_1 + 16 | 0;
    HEAP32[$8_1 >> 2] = 0;
    HEAP32[$8_1 + 4 >> 2] = 0;
    $9_1 = $1_1 + 8 | 0;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 8 >> 2] = 0;
    HEAP32[$3_1 + 12 >> 2] = 0;
    HEAP32[$3_1 + 76 >> 2] = 0;
    $1_1 = $3_1 + 208 | 0;
    $10_1 = $1_1 + 56 | 0;
    HEAP32[$10_1 >> 2] = 0;
    HEAP32[$10_1 + 4 >> 2] = 0;
    $11_1 = $1_1 + 48 | 0;
    HEAP32[$11_1 >> 2] = 0;
    HEAP32[$11_1 + 4 >> 2] = 0;
    $12_1 = $1_1 + 40 | 0;
    HEAP32[$12_1 >> 2] = 0;
    HEAP32[$12_1 + 4 >> 2] = 0;
    $13_1 = $1_1 + 32 | 0;
    HEAP32[$13_1 >> 2] = 0;
    HEAP32[$13_1 + 4 >> 2] = 0;
    $14_1 = $1_1 + 24 | 0;
    HEAP32[$14_1 >> 2] = 0;
    HEAP32[$14_1 + 4 >> 2] = 0;
    $15_1 = $1_1 + 16 | 0;
    HEAP32[$15_1 >> 2] = 0;
    HEAP32[$15_1 + 4 >> 2] = 0;
    $16_1 = $1_1 + 8 | 0;
    HEAP32[$16_1 >> 2] = 0;
    HEAP32[$16_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 208 >> 2] = 0;
    HEAP32[$3_1 + 212 >> 2] = 0;
    folding_inner0: {
      label$3: {
        if (($31(HEAP32[172688], $1_1, 690820, $0_1) | 0) == 1) {
          $1_1 = $3_1 + 208 | 0;
          $0_1 = $1_1 + 15 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $4_1 = $3_1 + 144 | 0;
          $5_1 = $4_1 + 8 | 0;
          HEAP32[$5_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $0_1 = $1_1 + 23 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $6_1 = $4_1 + 16 | 0;
          HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$6_1 + 4 >> 2] = $2_1;
          $0_1 = $1_1 + 31 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $7_1 = $4_1 + 24 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $2_1;
          $0_1 = $1_1 + 39 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $8_1 = $4_1 + 32 | 0;
          HEAP32[$8_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$8_1 + 4 >> 2] = $2_1;
          $0_1 = $1_1 + 47 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $9_1 = $4_1 + 40 | 0;
          HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$9_1 + 4 >> 2] = $2_1;
          $0_1 = $1_1 + 55 | 0;
          $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
          $10_1 = $4_1 + 48 | 0;
          HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
          HEAP32[$10_1 + 4 >> 2] = $2_1;
          $2_1 = $4_1 + 56 | 0;
          HEAP8[$2_1 | 0] = HEAPU8[$1_1 + 63 | 0];
          HEAP8[$3_1 + 82 | 0] = HEAPU8[$3_1 + 210 | 0];
          HEAP16[$3_1 + 80 >> 1] = HEAPU16[$3_1 + 208 >> 1];
          $0_1 = HEAPU8[$3_1 + 219 | 0] | HEAPU8[$3_1 + 220 | 0] << 8 | (HEAPU8[$3_1 + 221 | 0] << 16 | HEAPU8[$3_1 + 222 | 0] << 24);
          HEAP32[$3_1 + 144 >> 2] = HEAPU8[$3_1 + 215 | 0] | HEAPU8[$3_1 + 216 | 0] << 8 | (HEAPU8[$3_1 + 217 | 0] << 16 | HEAPU8[$3_1 + 218 | 0] << 24);
          HEAP32[$3_1 + 148 >> 2] = $0_1;
          $4_1 = HEAPU8[$3_1 + 211 | 0] | HEAPU8[$3_1 + 212 | 0] << 8 | (HEAPU8[$3_1 + 213 | 0] << 16 | HEAPU8[$3_1 + 214 | 0] << 24);
          $0_1 = $3_1 + 80 | 0;
          HEAP8[$0_1 + 63 | 0] = HEAPU8[$2_1 | 0];
          $2_1 = HEAP32[$10_1 + 4 >> 2];
          $1_1 = $0_1 + 55 | 0;
          $10_1 = HEAP32[$10_1 >> 2];
          HEAP8[$1_1 | 0] = $10_1;
          HEAP8[$1_1 + 1 | 0] = $10_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $10_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $10_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $2_1;
          HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$9_1 + 4 >> 2];
          $1_1 = $0_1 + 47 | 0;
          $9_1 = HEAP32[$9_1 >> 2];
          HEAP8[$1_1 | 0] = $9_1;
          HEAP8[$1_1 + 1 | 0] = $9_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $9_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $9_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $2_1;
          HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$8_1 + 4 >> 2];
          $1_1 = $0_1 + 39 | 0;
          $8_1 = HEAP32[$8_1 >> 2];
          HEAP8[$1_1 | 0] = $8_1;
          HEAP8[$1_1 + 1 | 0] = $8_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $8_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $8_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $2_1;
          HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$7_1 + 4 >> 2];
          $1_1 = $0_1 + 31 | 0;
          $7_1 = HEAP32[$7_1 >> 2];
          HEAP8[$1_1 | 0] = $7_1;
          HEAP8[$1_1 + 1 | 0] = $7_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $7_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $7_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $2_1;
          HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$6_1 + 4 >> 2];
          $1_1 = $0_1 + 23 | 0;
          $6_1 = HEAP32[$6_1 >> 2];
          HEAP8[$1_1 | 0] = $6_1;
          HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $2_1;
          HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
          $2_1 = HEAP32[$5_1 + 4 >> 2];
          $1_1 = $0_1 + 15 | 0;
          $5_1 = HEAP32[$5_1 >> 2];
          HEAP8[$1_1 | 0] = $5_1;
          HEAP8[$1_1 + 1 | 0] = $5_1 >>> 8;
          HEAP8[$1_1 + 2 | 0] = $5_1 >>> 16;
          HEAP8[$1_1 + 3 | 0] = $5_1 >>> 24;
          HEAP8[$1_1 + 4 | 0] = $2_1;
          HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
          HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
          HEAP8[$3_1 + 83 | 0] = $4_1;
          HEAP8[$3_1 + 84 | 0] = $4_1 >>> 8;
          HEAP8[$3_1 + 85 | 0] = $4_1 >>> 16;
          HEAP8[$3_1 + 86 | 0] = $4_1 >>> 24;
          $1_1 = HEAP32[$3_1 + 148 >> 2];
          $4_1 = HEAP32[$3_1 + 144 >> 2];
          HEAP8[$3_1 + 87 | 0] = $4_1;
          HEAP8[$3_1 + 88 | 0] = $4_1 >>> 8;
          HEAP8[$3_1 + 89 | 0] = $4_1 >>> 16;
          HEAP8[$3_1 + 90 | 0] = $4_1 >>> 24;
          HEAP8[$3_1 + 91 | 0] = $1_1;
          HEAP8[$3_1 + 92 | 0] = $1_1 >>> 8;
          HEAP8[$3_1 + 93 | 0] = $1_1 >>> 16;
          HEAP8[$3_1 + 94 | 0] = $1_1 >>> 24;
          $0_1 = $59($6(), $3_1 + 8 | 0, $3_1 + 76 | 0, $0_1);
          HEAP32[$3_1 + 144 >> 2] = $0_1;
          if (($0_1 | 0) != 1) {
            break folding_inner0;
          }
          $0_1 = $3_1 + 8 | 0;
          $4_1 = $0_1 + 8 | 0;
          $2_1 = HEAP32[$4_1 + 4 >> 2];
          $1_1 = $3_1 + 208 | 0;
          $5_1 = $1_1 + 8 | 0;
          HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $4_1 = $0_1 + 16 | 0;
          $2_1 = HEAP32[$4_1 + 4 >> 2];
          $5_1 = $1_1 + 16 | 0;
          HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $4_1 = $0_1 + 24 | 0;
          $2_1 = HEAP32[$4_1 + 4 >> 2];
          $5_1 = $1_1 + 24 | 0;
          HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $4_1 = $0_1 + 32 | 0;
          $2_1 = HEAP32[$4_1 + 4 >> 2];
          $5_1 = $1_1 + 32 | 0;
          HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $4_1 = $0_1 + 40 | 0;
          $2_1 = HEAP32[$4_1 + 4 >> 2];
          $5_1 = $1_1 + 40 | 0;
          HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $4_1 = $0_1 + 48 | 0;
          $2_1 = HEAP32[$4_1 + 4 >> 2];
          $5_1 = $1_1 + 48 | 0;
          HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
          HEAP32[$5_1 + 4 >> 2] = $2_1;
          $0_1 = $0_1 + 56 | 0;
          $4_1 = HEAP32[$0_1 + 4 >> 2];
          $1_1 = $1_1 + 56 | 0;
          HEAP32[$1_1 >> 2] = HEAP32[$0_1 >> 2];
          HEAP32[$1_1 + 4 >> 2] = $4_1;
          break label$3;
        }
        fimport$1(1);
        $0_1 = HEAP32[$4_1 + 4 >> 2];
        HEAP32[$10_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$10_1 + 4 >> 2] = $0_1;
        $0_1 = HEAP32[$2_1 + 4 >> 2];
        HEAP32[$11_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$11_1 + 4 >> 2] = $0_1;
        $0_1 = HEAP32[$5_1 + 4 >> 2];
        HEAP32[$12_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$12_1 + 4 >> 2] = $0_1;
        $0_1 = HEAP32[$6_1 + 4 >> 2];
        HEAP32[$13_1 >> 2] = HEAP32[$6_1 >> 2];
        HEAP32[$13_1 + 4 >> 2] = $0_1;
        $0_1 = HEAP32[$7_1 + 4 >> 2];
        HEAP32[$14_1 >> 2] = HEAP32[$7_1 >> 2];
        HEAP32[$14_1 + 4 >> 2] = $0_1;
        $0_1 = HEAP32[$8_1 + 4 >> 2];
        HEAP32[$15_1 >> 2] = HEAP32[$8_1 >> 2];
        HEAP32[$15_1 + 4 >> 2] = $0_1;
        $0_1 = HEAP32[$9_1 + 4 >> 2];
        HEAP32[$16_1 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$16_1 + 4 >> 2] = $0_1;
      }
      $0_1 = HEAP32[$3_1 + 12 >> 2];
      HEAP32[$3_1 + 208 >> 2] = HEAP32[$3_1 + 8 >> 2];
      HEAP32[$3_1 + 212 >> 2] = $0_1;
      $1_1 = $3_1 + 208 | 0;
      $4_1 = $1_1 + 56 | 0;
      $2_1 = HEAP32[$4_1 + 4 >> 2];
      $0_1 = $3_1 + 80 | 0;
      $5_1 = $0_1 + 56 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $4_1 = $1_1 + 48 | 0;
      $2_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $0_1 + 48 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $4_1 = $1_1 + 40 | 0;
      $2_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $0_1 + 40 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $4_1 = $1_1 + 32 | 0;
      $2_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $0_1 + 32 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $4_1 = $1_1 + 24 | 0;
      $2_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $0_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $4_1 = $1_1 + 16 | 0;
      $2_1 = HEAP32[$4_1 + 4 >> 2];
      $5_1 = $0_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$5_1 + 4 >> 2] = $2_1;
      $1_1 = $1_1 + 8 | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $2_1 = $0_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $1_1 = HEAP32[$3_1 + 212 >> 2];
      HEAP32[$3_1 + 80 >> 2] = HEAP32[$3_1 + 208 >> 2];
      HEAP32[$3_1 + 84 >> 2] = $1_1;
      $0_1 = $58(HEAP32[172688], $0_1);
      HEAP32[$3_1 + 8 >> 2] = $0_1;
      if (($0_1 | 0) != 1) {
        break folding_inner0;
      }
      global$0 = $3_1 + 272 | 0;
      return 1;
    }
    HEAP32[$3_1 + 216 >> 2] = 0;
    $5($3_1 + 208 | 0);
    wasm2js_trap();
  }
  function $17($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0;
    $5_1 = global$0 - 208 | 0;
    global$0 = $5_1;
    $2_1 = $5_1 + 136 | 0;
    $4_1 = $2_1 + 56 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $2_1 + 48 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $2_1 + 40 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $2_1 + 32 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $2_1 + 24 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $2_1 + 16 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $2_1 + 8 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    HEAP32[$5_1 + 136 >> 2] = 0;
    HEAP32[$5_1 + 140 >> 2] = 0;
    label$1: {
      if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
        $10_1 = $5_1 + 136 | 0;
        $2_1 = $10_1 + 15 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $4_1 = $5_1 + 72 | 0;
        $13_1 = $4_1 + 8 | 0;
        HEAP32[$13_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$13_1 + 4 >> 2] = $0_1;
        $2_1 = $10_1 + 23 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $12_1 = $4_1 + 16 | 0;
        HEAP32[$12_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$12_1 + 4 >> 2] = $0_1;
        $2_1 = $10_1 + 31 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $9_1 = $4_1 + 24 | 0;
        HEAP32[$9_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$9_1 + 4 >> 2] = $0_1;
        $2_1 = $10_1 + 39 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $7_1 = $4_1 + 32 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $0_1;
        $2_1 = $10_1 + 47 | 0;
        $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $11_1 = $4_1 + 40 | 0;
        HEAP32[$11_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$11_1 + 4 >> 2] = $0_1;
        $8_1 = $10_1 + 55 | 0;
        $0_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
        $2_1 = $4_1 + 48 | 0;
        HEAP32[$2_1 >> 2] = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
        HEAP32[$2_1 + 4 >> 2] = $0_1;
        $4_1 = $4_1 + 56 | 0;
        HEAP8[$4_1 | 0] = HEAPU8[$10_1 + 63 | 0];
        HEAP8[$5_1 + 10 | 0] = HEAPU8[$5_1 + 138 | 0];
        HEAP16[$5_1 + 8 >> 1] = HEAPU16[$5_1 + 136 >> 1];
        $0_1 = HEAPU8[$5_1 + 147 | 0] | HEAPU8[$5_1 + 148 | 0] << 8 | (HEAPU8[$5_1 + 149 | 0] << 16 | HEAPU8[$5_1 + 150 | 0] << 24);
        HEAP32[$5_1 + 72 >> 2] = HEAPU8[$5_1 + 143 | 0] | HEAPU8[$5_1 + 144 | 0] << 8 | (HEAPU8[$5_1 + 145 | 0] << 16 | HEAPU8[$5_1 + 146 | 0] << 24);
        HEAP32[$5_1 + 76 >> 2] = $0_1;
        $10_1 = HEAPU8[$5_1 + 139 | 0] | HEAPU8[$5_1 + 140 | 0] << 8 | (HEAPU8[$5_1 + 141 | 0] << 16 | HEAPU8[$5_1 + 142 | 0] << 24);
        $3_1 = $5_1 + 8 | 0;
        HEAP8[$3_1 + 63 | 0] = HEAPU8[$4_1 | 0];
        $4_1 = HEAP32[$2_1 + 4 >> 2];
        $8_1 = $3_1 + 55 | 0;
        $0_1 = HEAP32[$2_1 >> 2];
        HEAP8[$8_1 | 0] = $0_1;
        HEAP8[$8_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$8_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$8_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$8_1 + 4 | 0] = $4_1;
        HEAP8[$8_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$8_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$8_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $2_1 = $3_1 + 47 | 0;
        $0_1 = HEAP32[$11_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$7_1 + 4 >> 2];
        $2_1 = $3_1 + 39 | 0;
        $0_1 = HEAP32[$7_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $2_1 = $3_1 + 31 | 0;
        $0_1 = HEAP32[$9_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$12_1 + 4 >> 2];
        $2_1 = $3_1 + 23 | 0;
        $0_1 = HEAP32[$12_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$13_1 + 4 >> 2];
        $2_1 = $3_1 + 15 | 0;
        $0_1 = HEAP32[$13_1 >> 2];
        HEAP8[$2_1 | 0] = $0_1;
        HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $4_1;
        HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
        HEAP8[$5_1 + 11 | 0] = $10_1;
        HEAP8[$5_1 + 12 | 0] = $10_1 >>> 8;
        HEAP8[$5_1 + 13 | 0] = $10_1 >>> 16;
        HEAP8[$5_1 + 14 | 0] = $10_1 >>> 24;
        $4_1 = HEAP32[$5_1 + 76 >> 2];
        $0_1 = HEAP32[$5_1 + 72 >> 2];
        HEAP8[$5_1 + 15 | 0] = $0_1;
        HEAP8[$5_1 + 16 | 0] = $0_1 >>> 8;
        HEAP8[$5_1 + 17 | 0] = $0_1 >>> 16;
        HEAP8[$5_1 + 18 | 0] = $0_1 >>> 24;
        HEAP8[$5_1 + 19 | 0] = $4_1;
        HEAP8[$5_1 + 20 | 0] = $4_1 >>> 8;
        HEAP8[$5_1 + 21 | 0] = $4_1 >>> 16;
        HEAP8[$5_1 + 22 | 0] = $4_1 >>> 24;
        $14_1 = $6();
        $6_1 = global$0 - 288 | 0;
        global$0 = $6_1;
        HEAP32[$6_1 + 4 >> 2] = 0;
        label$3: {
          if (!$3_1) {
            FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](689638, HEAP32[$14_1 + 172 >> 2]);
            break label$3;
          }
          $38($6_1 + 8 | 0, 690949, $6_1 + 4 | 0);
          if (HEAP32[$6_1 + 4 >> 2]) {
            HEAP8[$3_1 | 0] = 0;
            HEAP8[$3_1 + 1 | 0] = 0;
            HEAP8[$3_1 + 2 | 0] = 0;
            HEAP8[$3_1 + 3 | 0] = 0;
            HEAP8[$3_1 + 4 | 0] = 0;
            HEAP8[$3_1 + 5 | 0] = 0;
            HEAP8[$3_1 + 6 | 0] = 0;
            HEAP8[$3_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 56 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 48 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 40 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 32 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 24 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 16 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 8 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            break label$3;
          }
          $0_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
          $8_1 = $0_1 >>> 16 | 0;
          $11_1 = $6_1 + 112 | 0;
          $4_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
          HEAP32[$11_1 >> 2] = ($0_1 & 65535) << 16 | $4_1 >>> 16;
          HEAP32[$11_1 + 4 >> 2] = $8_1;
          $11_1 = $4_1 << 4 & 1048560;
          $0_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
          $8_1 = $0_1 >>> 28 | 0;
          $7_1 = $6_1 + 104 | 0;
          $4_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
          HEAP32[$7_1 >> 2] = ($0_1 & 268435455) << 4 | $4_1 >>> 28;
          HEAP32[$7_1 + 4 >> 2] = $8_1 | $11_1;
          $8_1 = $0_1 << 24 | $4_1 >>> 8;
          $7_1 = $4_1 << 24 & -16777216;
          $4_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
          $9_1 = $6_1 + 40 | 0;
          $12_1 = $9_1 + 56 | 0;
          $0_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
          HEAP32[$12_1 >> 2] = $0_1 >>> 8 | $7_1;
          HEAP32[$12_1 + 4 >> 2] = $8_1 & 1048575;
          $12_1 = $0_1 << 12 | $4_1 >>> 20;
          $7_1 = $4_1 << 12 & -4096;
          $2_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
          $0_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
          $9_1 = $9_1 + 48 | 0;
          HEAP32[$9_1 >> 2] = $0_1 >>> 20 | $7_1;
          HEAP32[$9_1 + 4 >> 2] = $12_1 & 1048575;
          HEAP32[$6_1 + 120 >> 2] = 0;
          HEAP32[$6_1 + 80 >> 2] = $2_1;
          HEAP32[$6_1 + 84 >> 2] = $0_1 & 1048575;
          $2_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
          $10_1 = $2_1;
          $4_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
          $8_1 = $2_1 << 12 | $4_1 >>> 20;
          $7_1 = $4_1 << 12 & -4096;
          $13_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $2_1 = $4_1;
          $0_1 = $6_1;
          $15_1 = $2_1 >>> 20 | $7_1;
          HEAP32[$0_1 + 48 >> 2] = $15_1;
          $16_1 = $8_1 & 1048575;
          HEAP32[$0_1 + 52 >> 2] = $16_1;
          HEAP32[$0_1 + 40 >> 2] = $13_1;
          $17_1 = $2_1 & 1048575;
          HEAP32[$0_1 + 44 >> 2] = $17_1;
          $4_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
          $12_1 = $4_1;
          $2_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
          $11_1 = ($2_1 & 65535) << 16 | $4_1 >>> 16;
          HEAP32[$0_1 + 72 >> 2] = $11_1;
          $7_1 = $2_1 >>> 16 | 0;
          HEAP32[$0_1 + 76 >> 2] = $7_1;
          $4_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
          $2_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
          $8_1 = $2_1 << 24 | $4_1 >>> 8;
          $18_1 = $4_1 << 24 & -16777216 | $10_1 >>> 8;
          HEAP32[$0_1 + 56 >> 2] = $18_1;
          $10_1 = $8_1 & 1048575;
          HEAP32[$0_1 + 60 >> 2] = $10_1;
          $9_1 = $12_1 << 4 & 1048560;
          $4_1 = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
          HEAP32[$0_1 + 64 >> 2] = $4_1;
          $0_1 = $2_1 >>> 28 | $9_1;
          HEAP32[$6_1 + 68 >> 2] = $0_1;
          if (!($13_1 | $15_1 | $11_1 | $18_1 | $4_1 | ($16_1 | $17_1 | $7_1 | $10_1 | $0_1))) {
            FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](690116, HEAP32[$14_1 + 172 >> 2]);
            $0_1 = $3_1 + 56 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 48 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 40 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 32 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 24 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 16 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            $0_1 = $3_1 + 8 | 0;
            HEAP8[$0_1 | 0] = 0;
            HEAP8[$0_1 + 1 | 0] = 0;
            HEAP8[$0_1 + 2 | 0] = 0;
            HEAP8[$0_1 + 3 | 0] = 0;
            HEAP8[$0_1 + 4 | 0] = 0;
            HEAP8[$0_1 + 5 | 0] = 0;
            HEAP8[$0_1 + 6 | 0] = 0;
            HEAP8[$0_1 + 7 | 0] = 0;
            HEAP8[$3_1 | 0] = 0;
            HEAP8[$3_1 + 1 | 0] = 0;
            HEAP8[$3_1 + 2 | 0] = 0;
            HEAP8[$3_1 + 3 | 0] = 0;
            HEAP8[$3_1 + 4 | 0] = 0;
            HEAP8[$3_1 + 5 | 0] = 0;
            HEAP8[$3_1 + 6 | 0] = 0;
            HEAP8[$3_1 + 7 | 0] = 0;
            break label$3;
          }
          HEAP8[$3_1 | 0] = 0;
          HEAP8[$3_1 + 1 | 0] = 0;
          HEAP8[$3_1 + 2 | 0] = 0;
          HEAP8[$3_1 + 3 | 0] = 0;
          HEAP8[$3_1 + 4 | 0] = 0;
          HEAP8[$3_1 + 5 | 0] = 0;
          HEAP8[$3_1 + 6 | 0] = 0;
          HEAP8[$3_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 56 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 48 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 40 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 32 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 24 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 16 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          $0_1 = $3_1 + 8 | 0;
          HEAP8[$0_1 | 0] = 0;
          HEAP8[$0_1 + 1 | 0] = 0;
          HEAP8[$0_1 + 2 | 0] = 0;
          HEAP8[$0_1 + 3 | 0] = 0;
          HEAP8[$0_1 + 4 | 0] = 0;
          HEAP8[$0_1 + 5 | 0] = 0;
          HEAP8[$0_1 + 6 | 0] = 0;
          HEAP8[$0_1 + 7 | 0] = 0;
          if (!(HEAP32[$6_1 + 32 >> 2] | (HEAP32[$6_1 + 24 >> 2] | (HEAP32[$6_1 + 16 >> 2] | HEAP32[$6_1 + 8 >> 2])) | (HEAP32[$6_1 + 36 >> 2] | (HEAP32[$6_1 + 28 >> 2] | (HEAP32[$6_1 + 20 >> 2] | HEAP32[$6_1 + 12 >> 2]))))) {
            break label$3;
          }
          $11_1 = $6_1 + 256 | 0;
          $0_1 = $11_1 + 24 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $11_1 + 16 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $11_1 + 8 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $7_1 = $6_1 + 40 | 0;
          $2_1 = $7_1 + 8 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $9_1 = $6_1 + 128 | 0;
          $0_1 = $9_1 + 8 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 + 16 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 + 16 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 + 24 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 + 24 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 + 32 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 + 32 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 + 48 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 + 48 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 + 56 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 + 56 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 - -64 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 - -64 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          $2_1 = $7_1 + 72 | 0;
          $4_1 = HEAP32[$2_1 + 4 >> 2];
          $0_1 = $9_1 + 72 | 0;
          HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
          HEAP32[$0_1 + 4 >> 2] = $4_1;
          HEAP32[$6_1 + 256 >> 2] = 0;
          HEAP32[$6_1 + 260 >> 2] = 0;
          HEAP32[$6_1 + 248 >> 2] = 0;
          $0_1 = HEAP32[$6_1 + 44 >> 2];
          HEAP32[$6_1 + 128 >> 2] = HEAP32[$6_1 + 40 >> 2];
          HEAP32[$6_1 + 132 >> 2] = $0_1;
          $0_1 = HEAP32[$6_1 + 84 >> 2];
          HEAP32[$6_1 + 168 >> 2] = HEAP32[$6_1 + 80 >> 2];
          HEAP32[$6_1 + 172 >> 2] = $0_1;
          $0_1 = $6_1 + 240 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $6_1 + 232 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $6_1 + 224 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $6_1 + 216 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          HEAP32[$6_1 + 208 >> 2] = 1;
          HEAP32[$6_1 + 212 >> 2] = 0;
          $42($9_1, $9_1, $6_1 + 8 | 0, $11_1);
          $49($7_1, $9_1);
          $35($3_1, $7_1);
          $19_1 = 1;
        }
        global$0 = $6_1 + 288 | 0;
        if (!$19_1) {
          break label$1;
        }
        HEAP32[$5_1 + 204 >> 2] = $1_1;
        $0_1 = $36(HEAP32[172688], $5_1 + 204 | 0, $5_1 + 8 | 0, ($1_1 | 0) == 33 ? 258 : 2);
        HEAP32[$5_1 + 72 >> 2] = $0_1;
        $20_1 = 1;
        if (($0_1 | 0) == 1) {
          break label$1;
        }
        HEAP32[$5_1 + 144 >> 2] = 0;
        $5($5_1 + 136 | 0);
        wasm2js_trap();
      }
      fimport$1(1);
    }
    global$0 = $5_1 + 208 | 0;
    return $20_1 | 0;
  }
  function $18() {
    return ($52() | 0) == 1 | 0;
  }
  function $19() {
    var $0_1 = 0, $1_1 = 0;
    $0_1 = global$0 - 32 | 0;
    global$0 = $0_1;
    $1_1 = $51(HEAP32[172688], 690949);
    HEAP32[$0_1 + 4 >> 2] = $1_1;
    if (($1_1 | 0) == 1) {
      $1_1 = $52();
      global$0 = $0_1 + 32 | 0;
      return ($1_1 | 0) == 1 | 0;
    }
    HEAP32[$0_1 + 16 >> 2] = 0;
    $5($0_1 + 8 | 0);
    wasm2js_trap();
  }
  function $20() {
    var $0_1 = 0, $1_1 = 0;
    $0_1 = global$0 - 32 | 0;
    global$0 = $0_1;
    $1_1 = $51(HEAP32[172688], 690788);
    HEAP32[$0_1 + 4 >> 2] = $1_1;
    if (($1_1 | 0) == 1) {
      global$0 = $0_1 + 32 | 0;
      return;
    }
    HEAP32[$0_1 + 16 >> 2] = 0;
    $5($0_1 + 8 | 0);
    wasm2js_trap();
  }
  function $21($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0;
    $3_1 = global$0 - 96 | 0;
    global$0 = $3_1;
    $1_1 = $3_1 + 56 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 48 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 40 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 32 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 24 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 16 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 8 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $2_1 = $6();
    $5_1 = HEAP32[172560];
    $0_1 = $0_1 ? 655681 : 0;
    $1_1 = global$0 + -64 | 0;
    global$0 = $1_1;
    label$1: {
      if (!HEAP32[$2_1 >> 2]) {
        FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](690045, HEAP32[$2_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      if (!$3_1) {
        FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689760, HEAP32[$2_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      $4_1 = $1_1 + 32 | 0;
      $0_1 = $47($2_1, $4_1, $1_1, 0, $5_1, $0_1);
      $6_1 = $4_1 + 24 | 0;
      $5_1 = HEAP32[$6_1 + 4 >> 2];
      $2_1 = $3_1 + 24 | 0;
      $6_1 = HEAP32[$6_1 >> 2];
      HEAP8[$2_1 | 0] = $6_1;
      HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $5_1;
      HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
      $6_1 = $4_1 + 16 | 0;
      $5_1 = HEAP32[$6_1 + 4 >> 2];
      $2_1 = $3_1 + 16 | 0;
      $6_1 = HEAP32[$6_1 >> 2];
      HEAP8[$2_1 | 0] = $6_1;
      HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $5_1;
      HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
      $4_1 = $4_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 + 4 >> 2];
      $2_1 = $3_1 + 8 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$2_1 | 0] = $4_1;
      HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $5_1;
      HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
      $2_1 = HEAP32[$1_1 + 36 >> 2];
      $5_1 = HEAP32[$1_1 + 32 >> 2];
      HEAP8[$3_1 | 0] = $5_1;
      HEAP8[$3_1 + 1 | 0] = $5_1 >>> 8;
      HEAP8[$3_1 + 2 | 0] = $5_1 >>> 16;
      HEAP8[$3_1 + 3 | 0] = $5_1 >>> 24;
      HEAP8[$3_1 + 4 | 0] = $2_1;
      HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $5_1 = HEAP32[$1_1 >> 2];
      HEAP8[$3_1 + 32 | 0] = $5_1;
      HEAP8[$3_1 + 33 | 0] = $5_1 >>> 8;
      HEAP8[$3_1 + 34 | 0] = $5_1 >>> 16;
      HEAP8[$3_1 + 35 | 0] = $5_1 >>> 24;
      HEAP8[$3_1 + 36 | 0] = $2_1;
      HEAP8[$3_1 + 37 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 38 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 39 | 0] = $2_1 >>> 24;
      $4_1 = $1_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 + 4 >> 2];
      $2_1 = $3_1 + 40 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$2_1 | 0] = $4_1;
      HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $5_1;
      HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
      $4_1 = $1_1 + 16 | 0;
      $5_1 = HEAP32[$4_1 + 4 >> 2];
      $2_1 = $3_1 + 48 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$2_1 | 0] = $4_1;
      HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $5_1;
      HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
      $4_1 = $1_1 + 24 | 0;
      $5_1 = HEAP32[$4_1 + 4 >> 2];
      $2_1 = $3_1 + 56 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$2_1 | 0] = $4_1;
      HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $5_1;
      HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
    }
    global$0 = $1_1 - -64 | 0;
    HEAP32[$3_1 + 68 >> 2] = $0_1;
    label$4: {
      label$5: {
        if (($0_1 | 0) == 1) {
          $1_1 = HEAP32[172688];
          $0_1 = global$0 + -64 | 0;
          global$0 = $0_1;
          label$7: {
            if (!$3_1) {
              FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](689748, HEAP32[$1_1 + 172 >> 2]);
              $1_1 = 0;
              break label$7;
            }
            $1_1 = $3_1 + 24 | 0;
            $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $2_1 = $0_1 + 32 | 0;
            $4_1 = $2_1 + 24 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $3_1 + 16 | 0;
            $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $4_1 = $2_1 + 16 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $3_1 + 8 | 0;
            $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $4_1 = $2_1 + 8 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $3_1 + 40 | 0;
            $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $4_1 = $0_1 + 8 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $3_1 + 48 | 0;
            $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $4_1 = $0_1 + 16 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = $3_1 + 56 | 0;
            $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $4_1 = $0_1 + 24 | 0;
            HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            HEAP32[$4_1 + 4 >> 2] = $5_1;
            $1_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
            HEAP32[$0_1 + 32 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
            HEAP32[$0_1 + 36 >> 2] = $1_1;
            $1_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
            HEAP32[$0_1 >> 2] = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
            HEAP32[$0_1 + 4 >> 2] = $1_1;
            $39(690981, $2_1);
            $39(691013, $0_1);
            $1_1 = 1;
          }
          global$0 = $0_1 - -64 | 0;
          HEAP32[$3_1 + 68 >> 2] = $1_1;
          if (($1_1 | 0) == 1) {
            break label$5;
          }
          break label$4;
        }
        break label$4;
      }
      global$0 = $3_1 + 96 | 0;
      return;
    }
    HEAP32[$3_1 + 80 >> 2] = 0;
    $5($3_1 + 72 | 0);
    wasm2js_trap();
  }
  function $22($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
    $8_1 = global$0 - 112 | 0;
    global$0 = $8_1;
    $5_1 = $8_1 + 16 | 0;
    $68($5_1, 65);
    $1_1 = $6();
    $3_1 = HEAP32[172560];
    $0_1 = $0_1 ? 655681 : 0;
    $2_1 = global$0 - 80 | 0;
    global$0 = $2_1;
    label$1: {
      if (!HEAP32[$1_1 >> 2]) {
        FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](690045, HEAP32[$1_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      if (!$5_1) {
        FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](689760, HEAP32[$1_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      $4_1 = $2_1 + 48 | 0;
      $7_1 = $2_1 + 16 | 0;
      $0_1 = $47($1_1, $4_1, $7_1, $2_1 + 12 | 0, $3_1, $0_1);
      $1_1 = HEAP32[$2_1 + 52 >> 2];
      $3_1 = HEAP32[$2_1 + 48 >> 2];
      HEAP8[$5_1 | 0] = $3_1;
      HEAP8[$5_1 + 1 | 0] = $3_1 >>> 8;
      HEAP8[$5_1 + 2 | 0] = $3_1 >>> 16;
      HEAP8[$5_1 + 3 | 0] = $3_1 >>> 24;
      HEAP8[$5_1 + 4 | 0] = $1_1;
      HEAP8[$5_1 + 5 | 0] = $1_1 >>> 8;
      HEAP8[$5_1 + 6 | 0] = $1_1 >>> 16;
      HEAP8[$5_1 + 7 | 0] = $1_1 >>> 24;
      $6_1 = $4_1 + 8 | 0;
      $3_1 = HEAP32[$6_1 + 4 >> 2];
      $1_1 = $5_1 + 8 | 0;
      $6_1 = HEAP32[$6_1 >> 2];
      HEAP8[$1_1 | 0] = $6_1;
      HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $3_1;
      HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
      $6_1 = $4_1 + 16 | 0;
      $3_1 = HEAP32[$6_1 + 4 >> 2];
      $1_1 = $5_1 + 16 | 0;
      $6_1 = HEAP32[$6_1 >> 2];
      HEAP8[$1_1 | 0] = $6_1;
      HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $3_1;
      HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
      $4_1 = $4_1 + 24 | 0;
      $3_1 = HEAP32[$4_1 + 4 >> 2];
      $1_1 = $5_1 + 24 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$1_1 | 0] = $4_1;
      HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $3_1;
      HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
      $1_1 = HEAP32[$2_1 + 20 >> 2];
      $3_1 = HEAP32[$2_1 + 16 >> 2];
      HEAP8[$5_1 + 32 | 0] = $3_1;
      HEAP8[$5_1 + 33 | 0] = $3_1 >>> 8;
      HEAP8[$5_1 + 34 | 0] = $3_1 >>> 16;
      HEAP8[$5_1 + 35 | 0] = $3_1 >>> 24;
      HEAP8[$5_1 + 36 | 0] = $1_1;
      HEAP8[$5_1 + 37 | 0] = $1_1 >>> 8;
      HEAP8[$5_1 + 38 | 0] = $1_1 >>> 16;
      HEAP8[$5_1 + 39 | 0] = $1_1 >>> 24;
      $4_1 = $7_1 + 8 | 0;
      $3_1 = HEAP32[$4_1 + 4 >> 2];
      $1_1 = $5_1 + 40 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$1_1 | 0] = $4_1;
      HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $3_1;
      HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
      $4_1 = $7_1 + 16 | 0;
      $3_1 = HEAP32[$4_1 + 4 >> 2];
      $1_1 = $5_1 + 48 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$1_1 | 0] = $4_1;
      HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $3_1;
      HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
      $4_1 = $7_1 + 24 | 0;
      $3_1 = HEAP32[$4_1 + 4 >> 2];
      $1_1 = $5_1 + 56 | 0;
      $4_1 = HEAP32[$4_1 >> 2];
      HEAP8[$1_1 | 0] = $4_1;
      HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $3_1;
      HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
      HEAP8[$5_1 + 64 | 0] = HEAP32[$2_1 + 12 >> 2];
    }
    global$0 = $2_1 + 80 | 0;
    HEAP32[$8_1 + 84 >> 2] = $0_1;
    if (($0_1 | 0) == 1) {
      HEAP32[$8_1 + 12 >> 2] = 0;
      $2_1 = HEAP32[172688];
      $3_1 = $8_1 + 12 | 0;
      $5_1 = global$0 + -64 | 0;
      global$0 = $5_1;
      $0_1 = $8_1 + 16 | 0;
      label$5: {
        if (!$0_1) {
          FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689748, HEAP32[$2_1 + 172 >> 2]);
          break label$5;
        }
        if (!$3_1) {
          FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689795, HEAP32[$2_1 + 172 >> 2]);
          break label$5;
        }
        $2_1 = $0_1 + 24 | 0;
        $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $1_1 = $5_1 + 32 | 0;
        $7_1 = $1_1 + 24 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $4_1;
        $2_1 = $0_1 + 16 | 0;
        $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $7_1 = $1_1 + 16 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $4_1;
        $2_1 = $0_1 + 8 | 0;
        $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $7_1 = $1_1 + 8 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $4_1;
        $2_1 = $0_1 + 56 | 0;
        $4_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        $7_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $2_1 = $0_1 + 48 | 0;
        $6_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        $9_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $2_1 = $0_1 + 40 | 0;
        $10_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
        $2_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
        $11_1 = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
        $12_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
        $13_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        $14_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        HEAP32[$3_1 >> 2] = HEAPU8[$0_1 + 64 | 0];
        $0_1 = $5_1 + 8 | 0;
        HEAP32[$0_1 >> 2] = $10_1;
        HEAP32[$0_1 + 4 >> 2] = $2_1;
        $0_1 = $5_1 + 16 | 0;
        HEAP32[$0_1 >> 2] = $6_1;
        HEAP32[$0_1 + 4 >> 2] = $9_1;
        $0_1 = $5_1 + 24 | 0;
        HEAP32[$0_1 >> 2] = $4_1;
        HEAP32[$0_1 + 4 >> 2] = $7_1;
        HEAP32[$5_1 + 32 >> 2] = $13_1;
        HEAP32[$5_1 + 36 >> 2] = $14_1;
        HEAP32[$5_1 >> 2] = $11_1;
        HEAP32[$5_1 + 4 >> 2] = $12_1;
        $39(690981, $1_1);
        $39(691013, $5_1);
      }
      global$0 = $5_1 - -64 | 0;
      global$0 = $8_1 + 112 | 0;
      return HEAP32[$8_1 + 12 >> 2];
    }
    HEAP32[$8_1 + 96 >> 2] = 0;
    $5($8_1 + 88 | 0);
    wasm2js_trap();
  }
  function $23($0_1) {
    $0_1 = $0_1 | 0;
    var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0;
    $2_1 = global$0 - 128 | 0;
    global$0 = $2_1;
    $7_1 = $68($2_1, 96);
    $2_1 = $60($6(), $7_1);
    HEAP32[$7_1 + 100 >> 2] = $2_1;
    label$1: {
      label$2: {
        if (($2_1 | 0) == 1) {
          $15_1 = $6();
          $26_1 = $0_1 ? 655681 : 0;
          $1_1 = global$0 - 640 | 0;
          global$0 = $1_1;
          $0_1 = $1_1 + 88 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $1_1 + 80 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          HEAP32[$1_1 + 72 >> 2] = 0;
          HEAP32[$1_1 + 76 >> 2] = 0;
          HEAP32[$1_1 + 64 >> 2] = 0;
          HEAP32[$1_1 + 68 >> 2] = 0;
          label$4: {
            if (!HEAP32[$15_1 >> 2]) {
              FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](690045, HEAP32[$15_1 + 172 >> 2]);
              break label$4;
            }
            if (!$7_1) {
              FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](689700, HEAP32[$15_1 + 172 >> 2]);
              break label$4;
            }
            $17_1 = $1_1 + 472 | 0;
            $23_1 = global$0 - 16 | 0;
            global$0 = $23_1;
            $18_1 = HEAPU8[$7_1 + 40 | 0] | HEAPU8[$7_1 + 41 | 0] << 8 | (HEAPU8[$7_1 + 42 | 0] << 16 | HEAPU8[$7_1 + 43 | 0] << 24);
            $6_1 = HEAPU8[$7_1 + 44 | 0] | HEAPU8[$7_1 + 45 | 0] << 8 | (HEAPU8[$7_1 + 46 | 0] << 16 | HEAPU8[$7_1 + 47 | 0] << 24);
            $10_1 = HEAPU8[$7_1 + 48 | 0] | HEAPU8[$7_1 + 49 | 0] << 8 | (HEAPU8[$7_1 + 50 | 0] << 16 | HEAPU8[$7_1 + 51 | 0] << 24);
            $5_1 = HEAPU8[$7_1 + 52 | 0] | HEAPU8[$7_1 + 53 | 0] << 8 | (HEAPU8[$7_1 + 54 | 0] << 16 | HEAPU8[$7_1 + 55 | 0] << 24);
            $19_1 = HEAPU8[$7_1 + 72 | 0] | HEAPU8[$7_1 + 73 | 0] << 8 | (HEAPU8[$7_1 + 74 | 0] << 16 | HEAPU8[$7_1 + 75 | 0] << 24);
            $12_1 = HEAPU8[$7_1 + 76 | 0] | HEAPU8[$7_1 + 77 | 0] << 8 | (HEAPU8[$7_1 + 78 | 0] << 16 | HEAPU8[$7_1 + 79 | 0] << 24);
            $8_1 = HEAPU8[$7_1 + 80 | 0] | HEAPU8[$7_1 + 81 | 0] << 8 | (HEAPU8[$7_1 + 82 | 0] << 16 | HEAPU8[$7_1 + 83 | 0] << 24);
            $3_1 = HEAPU8[$7_1 + 84 | 0] | HEAPU8[$7_1 + 85 | 0] << 8 | (HEAPU8[$7_1 + 86 | 0] << 16 | HEAPU8[$7_1 + 87 | 0] << 24);
            $16_1 = HEAPU8[$7_1 + 32 | 0] | HEAPU8[$7_1 + 33 | 0] << 8 | (HEAPU8[$7_1 + 34 | 0] << 16 | HEAPU8[$7_1 + 35 | 0] << 24);
            $13_1 = HEAPU8[$7_1 + 36 | 0] | HEAPU8[$7_1 + 37 | 0] << 8 | (HEAPU8[$7_1 + 38 | 0] << 16 | HEAPU8[$7_1 + 39 | 0] << 24);
            $11_1 = HEAPU8[$7_1 + 56 | 0] | HEAPU8[$7_1 + 57 | 0] << 8 | (HEAPU8[$7_1 + 58 | 0] << 16 | HEAPU8[$7_1 + 59 | 0] << 24);
            $4_1 = HEAPU8[$7_1 + 60 | 0] | HEAPU8[$7_1 + 61 | 0] << 8 | (HEAPU8[$7_1 + 62 | 0] << 16 | HEAPU8[$7_1 + 63 | 0] << 24);
            $22_1 = HEAPU8[$7_1 + 64 | 0] | HEAPU8[$7_1 + 65 | 0] << 8 | (HEAPU8[$7_1 + 66 | 0] << 16 | HEAPU8[$7_1 + 67 | 0] << 24);
            $14_1 = HEAPU8[$7_1 + 68 | 0] | HEAPU8[$7_1 + 69 | 0] << 8 | (HEAPU8[$7_1 + 70 | 0] << 16 | HEAPU8[$7_1 + 71 | 0] << 24);
            $9_1 = HEAPU8[$7_1 + 88 | 0] | HEAPU8[$7_1 + 89 | 0] << 8 | (HEAPU8[$7_1 + 90 | 0] << 16 | HEAPU8[$7_1 + 91 | 0] << 24);
            $20_1 = HEAPU8[$7_1 + 92 | 0] | HEAPU8[$7_1 + 93 | 0] << 8 | (HEAPU8[$7_1 + 94 | 0] << 16 | HEAPU8[$7_1 + 95 | 0] << 24);
            $2_1 = $1_1 + 192 | 0;
            HEAP32[$2_1 + 80 >> 2] = 0;
            $21_1 = $2_1 + 72 | 0;
            HEAP32[$21_1 >> 2] = ($20_1 & 65535) << 16 | $9_1 >>> 16;
            HEAP32[$21_1 + 4 >> 2] = $20_1 >>> 16;
            HEAP32[$2_1 + 40 >> 2] = $22_1;
            HEAP32[$2_1 + 44 >> 2] = $14_1 & 1048575;
            $21_1 = ($4_1 & 65535) << 16 | $11_1 >>> 16;
            HEAP32[$2_1 + 32 >> 2] = $21_1;
            $22_1 = $4_1 >>> 16 | 0;
            HEAP32[$2_1 + 36 >> 2] = $22_1;
            HEAP32[$2_1 >> 2] = $16_1;
            $20_1 = $13_1 & 1048575;
            HEAP32[$2_1 + 4 >> 2] = $20_1;
            $24_1 = $2_1 - -64 | 0;
            HEAP32[$24_1 >> 2] = ($3_1 & 268435455) << 4 | $8_1 >>> 28;
            HEAP32[$24_1 + 4 >> 2] = $9_1 << 4 & 1048560 | $3_1 >>> 28;
            $0_1 = $3_1 << 24 | $8_1 >>> 8;
            $9_1 = $2_1 + 56 | 0;
            $3_1 = $12_1;
            HEAP32[$9_1 >> 2] = $8_1 << 24 & -16777216 | $3_1 >>> 8;
            HEAP32[$9_1 + 4 >> 2] = $0_1 & 1048575;
            $0_1 = $3_1 << 12;
            $3_1 = $19_1;
            $8_1 = ($0_1 | $3_1 >>> 20) & 1048575;
            $12_1 = $2_1 + 48 | 0;
            HEAP32[$12_1 >> 2] = $3_1 << 12 & -4096 | $14_1 >>> 20;
            HEAP32[$12_1 + 4 >> 2] = $8_1;
            $3_1 = $11_1 << 4 & 1048560;
            $4_1 = $5_1;
            $0_1 = $4_1 >>> 28 | 0;
            $5_1 = ($4_1 & 268435455) << 4 | $10_1 >>> 28;
            HEAP32[$2_1 + 24 >> 2] = $5_1;
            $3_1 = $0_1 | $3_1;
            HEAP32[$2_1 + 28 >> 2] = $3_1;
            $0_1 = $4_1 << 24 | $10_1 >>> 8;
            $4_1 = $6_1;
            $6_1 = $10_1 << 24 & -16777216 | $4_1 >>> 8;
            HEAP32[$2_1 + 16 >> 2] = $6_1;
            $10_1 = $0_1 & 1048575;
            HEAP32[$2_1 + 20 >> 2] = $10_1;
            $0_1 = $4_1 << 12;
            $4_1 = $18_1;
            $12_1 = ($0_1 | $4_1 >>> 20) & 1048575;
            $4_1 = $4_1 << 12 & -4096 | $13_1 >>> 20;
            HEAP32[$2_1 + 8 >> 2] = $4_1;
            $0_1 = $12_1;
            HEAP32[$2_1 + 12 >> 2] = $0_1;
            label$7: {
              label$8: {
                if (!($4_1 | $16_1 | $21_1 | $6_1 | $5_1 | ($0_1 | $20_1 | $22_1 | $10_1 | $3_1))) {
                  FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](690116, HEAP32[$15_1 + 172 >> 2]);
                  $70($2_1, 690376, 88);
                  if ($17_1) {
                    break label$8;
                  }
                  break label$7;
                }
                $25_1 = 1;
                if (!$17_1) {
                  break label$7;
                }
                $38($17_1, $7_1, $23_1 + 12 | 0);
                if (!(HEAP32[$23_1 + 12 >> 2] | !(HEAP32[$17_1 + 24 >> 2] | (HEAP32[$17_1 + 16 >> 2] | (HEAP32[$17_1 + 8 >> 2] | HEAP32[$17_1 >> 2])) | (HEAP32[$17_1 + 28 >> 2] | (HEAP32[$17_1 + 20 >> 2] | (HEAP32[$17_1 + 12 >> 2] | HEAP32[$17_1 + 4 >> 2])))))) {
                  break label$7;
                }
                FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](689400, HEAP32[$15_1 + 172 >> 2]);
                $70($2_1, 690376, 88);
              }
              $25_1 = 0;
              $0_1 = HEAP32[172569];
              $2_1 = $17_1 + 24 | 0;
              HEAP32[$2_1 >> 2] = HEAP32[172568];
              HEAP32[$2_1 + 4 >> 2] = $0_1;
              $0_1 = HEAP32[172567];
              $2_1 = $17_1 + 16 | 0;
              HEAP32[$2_1 >> 2] = HEAP32[172566];
              HEAP32[$2_1 + 4 >> 2] = $0_1;
              $0_1 = HEAP32[172565];
              $2_1 = $17_1 + 8 | 0;
              HEAP32[$2_1 >> 2] = HEAP32[172564];
              HEAP32[$2_1 + 4 >> 2] = $0_1;
              $0_1 = HEAP32[172563];
              HEAP32[$17_1 >> 2] = HEAP32[172562];
              HEAP32[$17_1 + 4 >> 2] = $0_1;
            }
            global$0 = $23_1 + 16 | 0;
            label$10: {
              if (!(HEAP8[$1_1 + 232 | 0] & 1)) {
                $18_1 = HEAP32[$1_1 + 472 >> 2];
                $12_1 = HEAP32[$1_1 + 476 >> 2];
                $8_1 = HEAP32[$1_1 + 480 >> 2];
                $2_1 = HEAP32[$1_1 + 484 >> 2];
                $3_1 = HEAP32[$1_1 + 488 >> 2];
                $5_1 = HEAP32[$1_1 + 492 >> 2];
                $19_1 = HEAP32[$1_1 + 496 >> 2];
                $10_1 = HEAP32[$1_1 + 500 >> 2];
                break label$10;
              }
              $13_1 = HEAP32[$1_1 + 496 >> 2];
              $14_1 = HEAP32[$1_1 + 488 >> 2];
              $3_1 = HEAP32[$1_1 + 480 >> 2];
              $0_1 = HEAP32[$1_1 + 472 >> 2];
              $16_1 = HEAP32[$1_1 + 500 >> 2];
              $19_1 = HEAP32[$1_1 + 492 >> 2];
              $5_1 = HEAP32[$1_1 + 484 >> 2];
              $2_1 = HEAP32[$1_1 + 476 >> 2];
              $6_1 = $13_1 | ($14_1 | ($3_1 | $0_1)) | ($16_1 | ($19_1 | ($5_1 | $2_1))) ? -1 : 0;
              $0_1 = $0_1 ^ -1;
              $10_1 = $0_1 - 801750718 | 0;
              $18_1 = $6_1 & $10_1;
              HEAP32[$1_1 + 472 >> 2] = $18_1;
              $2_1 = $2_1 ^ -1;
              $4_1 = $2_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
              $12_1 = $4_1 & $6_1;
              HEAP32[$1_1 + 476 >> 2] = $12_1;
              $0_1 = ($2_1 | 0) == ($4_1 | 0) & $0_1 >>> 0 > $10_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
              $10_1 = $3_1 ^ -1;
              $3_1 = $0_1 + $10_1 | 0;
              $5_1 = $5_1 ^ -1;
              $0_1 = $5_1;
              $9_1 = $3_1 - 1354194885 | 0;
              $8_1 = $9_1 & $6_1;
              HEAP32[$1_1 + 480 >> 2] = $8_1;
              $0_1 = $3_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $11_1 = $0_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
              $2_1 = $11_1 & $6_1;
              HEAP32[$1_1 + 484 >> 2] = $2_1;
              $4_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
              $10_1 = ($0_1 | 0) == ($11_1 | 0) & $3_1 >>> 0 > $9_1 >>> 0 | $0_1 >>> 0 > $11_1 >>> 0;
              $3_1 = $4_1 + $10_1 | 0;
              $0_1 = $3_1 >>> 0 < $10_1 >>> 0;
              $11_1 = $14_1 ^ -1;
              $10_1 = $11_1 + $3_1 | 0;
              $14_1 = $19_1 ^ -1;
              $0_1 = $14_1 + $0_1 | 0;
              $9_1 = $10_1 - 2 | 0;
              $3_1 = $9_1 & $6_1;
              HEAP32[$1_1 + 488 >> 2] = $3_1;
              $0_1 = $10_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $19_1 = $0_1 - ($10_1 >>> 0 < 2) | 0;
              $5_1 = $19_1 & $6_1;
              HEAP32[$1_1 + 492 >> 2] = $5_1;
              $4_1 = ($0_1 | 0) == ($14_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $14_1 >>> 0;
              $10_1 = ($0_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 > $19_1 >>> 0;
              $4_1 = $4_1 + $10_1 | 0;
              $0_1 = $4_1 >>> 0 < $10_1 >>> 0;
              $10_1 = $4_1 - $13_1 | 0;
              $19_1 = $10_1 - 2 & $6_1;
              HEAP32[$1_1 + 496 >> 2] = $19_1;
              $10_1 = ($0_1 - (($4_1 >>> 0 < $13_1 >>> 0) + $16_1 | 0) | 0) - ($10_1 >>> 0 < 2) & $6_1;
              HEAP32[$1_1 + 500 >> 2] = $10_1;
            }
            HEAP8[$1_1 + 31 | 0] = $18_1;
            HEAP8[$1_1 + 30 | 0] = ($12_1 & 255) << 24 | $18_1 >>> 8;
            HEAP8[$1_1 + 29 | 0] = ($12_1 & 65535) << 16 | $18_1 >>> 16;
            HEAP8[$1_1 + 28 | 0] = ($12_1 & 16777215) << 8 | $18_1 >>> 24;
            HEAP8[$1_1 + 27 | 0] = $12_1;
            HEAP8[$1_1 + 26 | 0] = $12_1 >>> 8;
            HEAP8[$1_1 + 25 | 0] = $12_1 >>> 16;
            HEAP8[$1_1 + 24 | 0] = $12_1 >>> 24;
            HEAP8[$1_1 + 23 | 0] = $8_1;
            HEAP8[$1_1 + 22 | 0] = ($2_1 & 255) << 24 | $8_1 >>> 8;
            HEAP8[$1_1 + 21 | 0] = ($2_1 & 65535) << 16 | $8_1 >>> 16;
            HEAP8[$1_1 + 20 | 0] = ($2_1 & 16777215) << 8 | $8_1 >>> 24;
            HEAP8[$1_1 + 19 | 0] = $2_1;
            HEAP8[$1_1 + 18 | 0] = $2_1 >>> 8;
            HEAP8[$1_1 + 17 | 0] = $2_1 >>> 16;
            HEAP8[$1_1 + 16 | 0] = $2_1 >>> 24;
            HEAP8[$1_1 + 15 | 0] = $3_1;
            HEAP8[$1_1 + 14 | 0] = ($5_1 & 255) << 24 | $3_1 >>> 8;
            HEAP8[$1_1 + 13 | 0] = ($5_1 & 65535) << 16 | $3_1 >>> 16;
            HEAP8[$1_1 + 12 | 0] = ($5_1 & 16777215) << 8 | $3_1 >>> 24;
            HEAP8[$1_1 + 11 | 0] = $5_1;
            HEAP8[$1_1 + 10 | 0] = $5_1 >>> 8;
            HEAP8[$1_1 + 9 | 0] = $5_1 >>> 16;
            HEAP8[$1_1 + 8 | 0] = $5_1 >>> 24;
            HEAP8[$1_1 + 7 | 0] = $19_1;
            HEAP8[$1_1 + 6 | 0] = ($10_1 & 255) << 24 | $19_1 >>> 8;
            HEAP8[$1_1 + 5 | 0] = ($10_1 & 65535) << 16 | $19_1 >>> 16;
            HEAP8[$1_1 + 4 | 0] = ($10_1 & 16777215) << 8 | $19_1 >>> 24;
            HEAP8[$1_1 + 3 | 0] = $10_1;
            HEAP8[$1_1 + 2 | 0] = $10_1 >>> 8;
            HEAP8[$1_1 + 1 | 0] = $10_1 >>> 16;
            HEAP8[$1_1 | 0] = $10_1 >>> 24;
            $2_1 = HEAP32[$1_1 + 228 >> 2];
            $4_1 = HEAP32[$1_1 + 224 >> 2];
            HEAP8[$1_1 + 37 | 0] = $4_1;
            $0_1 = HEAP32[$1_1 + 212 >> 2];
            $3_1 = HEAP32[$1_1 + 208 >> 2];
            HEAP8[$1_1 + 50 | 0] = $3_1;
            HEAP8[$1_1 + 36 | 0] = ($2_1 & 255) << 24 | $4_1 >>> 8;
            HEAP8[$1_1 + 35 | 0] = ($2_1 & 65535) << 16 | $4_1 >>> 16;
            HEAP8[$1_1 + 34 | 0] = ($2_1 & 16777215) << 8 | $4_1 >>> 24;
            HEAP8[$1_1 + 33 | 0] = $2_1;
            HEAP8[$1_1 + 32 | 0] = $2_1 >>> 8;
            $2_1 = HEAP32[$1_1 + 220 >> 2];
            $4_1 = HEAP32[$1_1 + 216 >> 2];
            HEAP8[$1_1 + 43 | 0] = ($2_1 & 15) << 28 | $4_1 >>> 4;
            HEAP8[$1_1 + 42 | 0] = ($2_1 & 4095) << 20 | $4_1 >>> 12;
            HEAP8[$1_1 + 41 | 0] = ($2_1 & 1048575) << 12 | $4_1 >>> 20;
            HEAP8[$1_1 + 40 | 0] = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
            HEAP8[$1_1 + 39 | 0] = $2_1 >>> 4;
            HEAP8[$1_1 + 38 | 0] = $2_1 >>> 12;
            HEAP8[$1_1 + 49 | 0] = ($0_1 & 255) << 24 | $3_1 >>> 8;
            HEAP8[$1_1 + 48 | 0] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
            HEAP8[$1_1 + 47 | 0] = ($0_1 & 16777215) << 8 | $3_1 >>> 24;
            HEAP8[$1_1 + 46 | 0] = $0_1;
            HEAP8[$1_1 + 45 | 0] = $0_1 >>> 8;
            HEAP8[$1_1 + 44 | 0] = $0_1 >>> 16 & 15 | $4_1 << 4;
            $0_1 = HEAP32[$1_1 + 196 >> 2];
            $3_1 = HEAP32[$1_1 + 192 >> 2];
            HEAP8[$1_1 + 63 | 0] = $3_1;
            $2_1 = HEAP32[$1_1 + 204 >> 2];
            $4_1 = HEAP32[$1_1 + 200 >> 2];
            HEAP8[$1_1 + 56 | 0] = ($2_1 & 15) << 28 | $4_1 >>> 4;
            HEAP8[$1_1 + 55 | 0] = ($2_1 & 4095) << 20 | $4_1 >>> 12;
            HEAP8[$1_1 + 54 | 0] = ($2_1 & 1048575) << 12 | $4_1 >>> 20;
            HEAP8[$1_1 + 53 | 0] = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
            HEAP8[$1_1 + 52 | 0] = $2_1 >>> 4;
            HEAP8[$1_1 + 51 | 0] = $2_1 >>> 12;
            HEAP8[$1_1 + 62 | 0] = ($0_1 & 255) << 24 | $3_1 >>> 8;
            HEAP8[$1_1 + 61 | 0] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
            HEAP8[$1_1 + 60 | 0] = ($0_1 & 16777215) << 8 | $3_1 >>> 24;
            HEAP8[$1_1 + 59 | 0] = $0_1;
            HEAP8[$1_1 + 58 | 0] = $0_1 >>> 8;
            HEAP8[$1_1 + 57 | 0] = $0_1 >>> 16 & 15 | $4_1 << 4;
            $0_1 = $1_1 - -64 | 0;
            $2_1 = $61($0_1, 655649, 32, $1_1, $1_1 + 32 | 0, 690736, 13, $26_1);
            $4_1 = $1_1 + 408 | 0;
            $38($4_1, $0_1, 0);
            $0_1 = $25_1 & ($2_1 | 0) != 0;
            $2_1 = HEAP32[$1_1 + 432 >> 2];
            $5_1 = HEAP32[$1_1 + 424 >> 2];
            $3_1 = HEAP32[$1_1 + 416 >> 2];
            $6_1 = HEAP32[$1_1 + 408 >> 2];
            $10_1 = HEAP32[$1_1 + 436 >> 2];
            $13_1 = HEAP32[$1_1 + 428 >> 2];
            $12_1 = HEAP32[$1_1 + 420 >> 2];
            $8_1 = HEAP32[$1_1 + 412 >> 2];
            $24_1 = $0_1 & ($2_1 | ($5_1 | ($3_1 | $6_1)) | ($10_1 | ($13_1 | ($12_1 | $8_1)))) != 0;
            $23_1 = !$24_1;
            $0_1 = $23_1 - 1 | 0;
            $19_1 = $0_1 & $2_1;
            HEAP32[$1_1 + 432 >> 2] = $19_1;
            $2_1 = 0 - !$23_1 | 0;
            $10_1 = $2_1 & $10_1;
            HEAP32[$1_1 + 436 >> 2] = $10_1;
            $20_1 = $0_1 & $5_1;
            HEAP32[$1_1 + 424 >> 2] = $20_1;
            $22_1 = $2_1 & $13_1;
            HEAP32[$1_1 + 428 >> 2] = $22_1;
            $21_1 = $0_1 & $3_1;
            HEAP32[$1_1 + 416 >> 2] = $21_1;
            $17_1 = $2_1 & $12_1;
            HEAP32[$1_1 + 420 >> 2] = $17_1;
            $18_1 = $0_1 & $6_1 | $23_1;
            HEAP32[$1_1 + 408 >> 2] = $18_1;
            $12_1 = $2_1 & $8_1;
            HEAP32[$1_1 + 412 >> 2] = $12_1;
            $0_1 = $1_1 + 280 | 0;
            $48($15_1, $0_1, $4_1);
            $49($1_1 + 104 | 0, $0_1);
            $0_1 = $1_1 + 152 | 0;
            $4_1 = HEAP32[$0_1 >> 2];
            $6_1 = HEAP32[$0_1 + 4 >> 2];
            $5_1 = HEAP32[$1_1 + 148 >> 2];
            $0_1 = $1_1 + 176 | 0;
            $8_1 = HEAP32[$0_1 >> 2];
            $3_1 = HEAP32[$0_1 + 4 >> 2];
            $14_1 = $3_1;
            $0_1 = HEAP32[$1_1 + 144 >> 2];
            $2_1 = __wasm_i64_mul($3_1 >>> 16 | 0, 0, 977, 1);
            $3_1 = $0_1 + $2_1 | 0;
            $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
            $9_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $6_1;
            $2_1 = $9_1 >>> 20 | 0;
            $5_1 = $2_1;
            $2_1 = $2_1 + $4_1 | 0;
            $5_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $13_1 = $5_1 & 1048575;
            $0_1 = $1_1 + 168 | 0;
            $16_1 = HEAP32[$0_1 >> 2];
            $15_1 = HEAP32[$0_1 + 4 >> 2];
            $0_1 = $1_1 + 160 | 0;
            $6_1 = HEAP32[$0_1 >> 2];
            $0_1 = HEAP32[$0_1 + 4 >> 2];
            $4_1 = $5_1 >>> 20 | 0;
            $11_1 = $4_1;
            $4_1 = $4_1 + $6_1 | 0;
            $11_1 = $11_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $15_1;
            $6_1 = $11_1 >>> 20 | 0;
            $15_1 = $6_1;
            $6_1 = $6_1 + $16_1 | 0;
            $0_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $16_1 = $0_1 & 1048575;
            $11_1 = $11_1 & 1048575;
            $15_1 = ($2_1 & $4_1 & $6_1) == -1 & ($5_1 & $11_1 & $0_1) == 1048575;
            $5_1 = $0_1;
            $0_1 = $14_1 & 65535;
            $5_1 = $5_1 >>> 20 | 0;
            $14_1 = $5_1 + $8_1 | 0;
            $0_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $8_1 = $0_1;
            $5_1 = $9_1 & 1048575;
            if ($15_1 & (($14_1 | 0) == -1 & ($0_1 | 0) == 65535) & (($5_1 | 0) == 1048574 & $3_1 >>> 0 > 4294966318 | $5_1 >>> 0 > 1048574) | $0_1 >>> 16) {
              $0_1 = $5_1 + 1 | 0;
              $3_1 = $3_1 + 977 | 0;
              $0_1 = $3_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
              $5_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $13_1;
              $9_1 = $9_1 >>> 20 | 0;
              $2_1 = $2_1 + $9_1 | 0;
              $0_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $13_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $11_1;
              $9_1 = $9_1 >>> 20 | 0;
              $4_1 = $4_1 + $9_1 | 0;
              $0_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $11_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $16_1;
              $9_1 = $9_1 >>> 20 | 0;
              $6_1 = $6_1 + $9_1 | 0;
              $0_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $16_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $8_1;
              $8_1 = $14_1;
              $14_1 = ($9_1 >>> 20 | 0) + $14_1 | 0;
              $8_1 = ($8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
            }
            HEAP32[$1_1 + 176 >> 2] = $14_1;
            HEAP32[$1_1 + 180 >> 2] = $8_1;
            HEAP32[$1_1 + 168 >> 2] = $6_1;
            HEAP32[$1_1 + 172 >> 2] = $16_1;
            HEAP32[$1_1 + 160 >> 2] = $4_1;
            HEAP32[$1_1 + 164 >> 2] = $11_1;
            HEAP32[$1_1 + 152 >> 2] = $2_1;
            HEAP32[$1_1 + 156 >> 2] = $13_1;
            HEAP32[$1_1 + 144 >> 2] = $3_1;
            HEAP32[$1_1 + 148 >> 2] = $5_1;
            if ($3_1 & 1) {
              $4_1 = $18_1 | $21_1 | $20_1 | $19_1 | ($12_1 | $17_1 | $22_1 | $10_1) ? -1 : 0;
              $0_1 = $18_1 ^ -1;
              $6_1 = $0_1 - 801750718 | 0;
              $18_1 = $4_1 & $6_1;
              HEAP32[$1_1 + 408 >> 2] = $18_1;
              $2_1 = $12_1 ^ -1;
              $3_1 = $2_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
              $12_1 = $3_1 & $4_1;
              HEAP32[$1_1 + 412 >> 2] = $12_1;
              $0_1 = ($2_1 | 0) == ($3_1 | 0) & $0_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
              $6_1 = $21_1 ^ -1;
              $3_1 = $0_1 + $6_1 | 0;
              $5_1 = $17_1 ^ -1;
              $0_1 = $5_1;
              $13_1 = $3_1 - 1354194885 | 0;
              $21_1 = $13_1 & $4_1;
              HEAP32[$1_1 + 416 >> 2] = $21_1;
              $0_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $8_1 = $0_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
              $17_1 = $8_1 & $4_1;
              HEAP32[$1_1 + 420 >> 2] = $17_1;
              $2_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
              $6_1 = ($0_1 | 0) == ($8_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
              $3_1 = $2_1 + $6_1 | 0;
              $5_1 = $22_1 ^ -1;
              $0_1 = $5_1 + ($3_1 >>> 0 < $6_1 >>> 0) | 0;
              $6_1 = $20_1 ^ -1;
              $3_1 = $6_1 + $3_1 | 0;
              $13_1 = $3_1 - 2 | 0;
              $20_1 = $13_1 & $4_1;
              HEAP32[$1_1 + 424 >> 2] = $20_1;
              $0_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $8_1 = $0_1 - ($3_1 >>> 0 < 2) | 0;
              $22_1 = $8_1 & $4_1;
              HEAP32[$1_1 + 428 >> 2] = $22_1;
              $2_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
              $3_1 = ($0_1 | 0) == ($8_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
              $2_1 = $2_1 + $3_1 | 0;
              $0_1 = $2_1 >>> 0 < $3_1 >>> 0;
              $3_1 = $2_1 - $19_1 | 0;
              $6_1 = $3_1 - 2 | 0;
              $10_1 = ($0_1 - (($2_1 >>> 0 < $19_1 >>> 0) + $10_1 | 0) | 0) - ($3_1 >>> 0 < 2) & $4_1;
              $19_1 = $4_1 & $6_1;
              HEAP32[$1_1 + 432 >> 2] = $19_1;
              HEAP32[$1_1 + 436 >> 2] = $10_1;
            }
            $4_1 = HEAP32[$1_1 + 112 >> 2];
            $3_1 = HEAP32[$1_1 + 116 >> 2];
            $5_1 = HEAP32[$1_1 + 108 >> 2];
            $14_1 = HEAP32[$1_1 + 136 >> 2];
            $6_1 = HEAP32[$1_1 + 140 >> 2];
            $9_1 = $6_1;
            $0_1 = HEAP32[$1_1 + 104 >> 2];
            $2_1 = __wasm_i64_mul($6_1 >>> 16 | 0, 0, 977, 1);
            $6_1 = $0_1 + $2_1 | 0;
            $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
            $16_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $3_1;
            $2_1 = $16_1 >>> 20 | 0;
            $3_1 = $2_1 + $4_1 | 0;
            $8_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $5_1 = $8_1 & 1048575;
            $13_1 = HEAP32[$1_1 + 128 >> 2];
            $15_1 = HEAP32[$1_1 + 132 >> 2];
            $0_1 = HEAP32[$1_1 + 124 >> 2];
            $2_1 = $8_1 >>> 20 | 0;
            $4_1 = $2_1 + HEAP32[$1_1 + 120 >> 2] | 0;
            $11_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $15_1;
            $2_1 = $11_1 >>> 20 | 0;
            $15_1 = $2_1;
            $2_1 = $2_1 + $13_1 | 0;
            $0_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $13_1 = $0_1 & 1048575;
            $11_1 = $11_1 & 1048575;
            $15_1 = ($3_1 & $4_1 & $2_1) == -1 & ($8_1 & $11_1 & $0_1) == 1048575;
            $8_1 = $0_1;
            $0_1 = $9_1 & 65535;
            $8_1 = $8_1 >>> 20 | 0;
            $14_1 = $8_1 + $14_1 | 0;
            $0_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $8_1 = $0_1;
            $16_1 = $16_1 & 1048575;
            if ($15_1 & (($14_1 | 0) == -1 & ($0_1 | 0) == 65535) & (($16_1 | 0) == 1048574 & $6_1 >>> 0 > 4294966318 | $16_1 >>> 0 > 1048574) | $0_1 >>> 16) {
              $0_1 = $16_1 + 1 | 0;
              $6_1 = $6_1 + 977 | 0;
              $0_1 = $6_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
              $16_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $5_1;
              $9_1 = $9_1 >>> 20 | 0;
              $3_1 = $3_1 + $9_1 | 0;
              $0_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $5_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $11_1;
              $9_1 = $9_1 >>> 20 | 0;
              $4_1 = $4_1 + $9_1 | 0;
              $0_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $11_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $13_1;
              $9_1 = $9_1 >>> 20 | 0;
              $2_1 = $2_1 + $9_1 | 0;
              $0_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
              $13_1 = $0_1 & 1048575;
              $9_1 = $0_1;
              $0_1 = $8_1;
              $8_1 = $14_1;
              $14_1 = ($9_1 >>> 20 | 0) + $14_1 | 0;
              $8_1 = ($8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
            }
            HEAP32[$1_1 + 136 >> 2] = $14_1;
            HEAP32[$1_1 + 140 >> 2] = $8_1;
            HEAP32[$1_1 + 128 >> 2] = $2_1;
            HEAP32[$1_1 + 132 >> 2] = $13_1;
            HEAP32[$1_1 + 120 >> 2] = $4_1;
            HEAP32[$1_1 + 124 >> 2] = $11_1;
            HEAP32[$1_1 + 112 >> 2] = $3_1;
            HEAP32[$1_1 + 116 >> 2] = $5_1;
            HEAP32[$1_1 + 104 >> 2] = $6_1;
            HEAP32[$1_1 + 108 >> 2] = $16_1;
            $37(690981, $1_1 + 104 | 0);
            HEAP32[$1_1 + 600 >> 2] = 64;
            HEAP32[$1_1 + 604 >> 2] = 0;
            HEAP32[$1_1 + 528 >> 2] = -1862921884;
            HEAP32[$1_1 + 532 >> 2] = 870954602;
            HEAP32[$1_1 + 520 >> 2] = -1748470448;
            HEAP32[$1_1 + 524 >> 2] = 3983205;
            HEAP32[$1_1 + 512 >> 2] = 292000018;
            HEAP32[$1_1 + 516 >> 2] = -782074353;
            HEAP32[$1_1 + 504 >> 2] = -1662207471;
            HEAP32[$1_1 + 508 >> 2] = 596792193;
            $0_1 = $1_1 + 504 | 0;
            $29($0_1, 690981, 32);
            $29($0_1, $1_1 + 32 | 0, 32);
            $29($0_1, 655649, 32);
            $2_1 = $0_1;
            $0_1 = $1_1 + 608 | 0;
            $30($2_1, $0_1);
            $9_1 = $1_1 + 440 | 0;
            $38($9_1, $0_1, 0);
            $15_1 = $1_1 + 472 | 0;
            $41($9_1, $9_1, $15_1);
            $2_1 = HEAP32[$1_1 + 440 >> 2];
            $8_1 = $2_1 + $18_1 | 0;
            $0_1 = $12_1 + HEAP32[$1_1 + 444 >> 2] | 0;
            $5_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $3_1 = ($12_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
            $2_1 = HEAP32[$1_1 + 448 >> 2];
            $4_1 = $3_1 + $2_1 | 0;
            $0_1 = HEAP32[$1_1 + 452 >> 2];
            $2_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $2_1 + $17_1 | 0;
            $3_1 = !$2_1 & $3_1 >>> 0 > $4_1 >>> 0;
            $12_1 = $4_1 + $21_1 | 0;
            $6_1 = $12_1 >>> 0 < $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $4_1 = ($2_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
            $2_1 = $3_1 + $4_1 | 0;
            $0_1 = $2_1 >>> 0 < $4_1 >>> 0;
            $11_1 = $2_1;
            $2_1 = HEAP32[$1_1 + 456 >> 2];
            $4_1 = $11_1 + $2_1 | 0;
            $3_1 = $0_1;
            $0_1 = $0_1 + HEAP32[$1_1 + 460 >> 2] | 0;
            $2_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $2_1 + $22_1 | 0;
            $13_1 = $4_1;
            $14_1 = $4_1 + $20_1 | 0;
            $0_1 = $14_1 >>> 0 < $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $18_1 = $10_1;
            $11_1 = ($2_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $3_1 >>> 0;
            $4_1 = $0_1;
            $10_1 = $14_1;
            $3_1 = ($2_1 | 0) == ($0_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
            $2_1 = $11_1 + $3_1 | 0;
            $0_1 = $2_1 >>> 0 < $3_1 >>> 0;
            $16_1 = $2_1;
            $3_1 = HEAP32[$1_1 + 464 >> 2];
            $2_1 = $2_1 + $3_1 | 0;
            $13_1 = $0_1;
            $0_1 = $0_1 + HEAP32[$1_1 + 468 >> 2] | 0;
            $3_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $3_1 + $18_1 | 0;
            $11_1 = $2_1;
            $2_1 = $2_1 + $19_1 | 0;
            $18_1 = $11_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $14_1 = $2_1;
            $16_1 = (($3_1 | 0) == ($18_1 | 0) & $11_1 >>> 0 > $2_1 >>> 0 | $3_1 >>> 0 > $18_1 >>> 0) + (($3_1 | 0) == ($13_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0) | 0;
            $3_1 = ($4_1 | 0) == -1;
            $13_1 = $3_1 & $10_1 >>> 0 < 4294967294 | ($4_1 | 0) != -1 | ($2_1 & $18_1) != -1;
            $0_1 = ($6_1 | 0) == -1162945306;
            $11_1 = ($13_1 | ($0_1 & $12_1 >>> 0 < 2940772411 | $6_1 >>> 0 < 3132021990)) ^ -1;
            $13_1 = $16_1 + ($11_1 & (($5_1 | 0) == -1076732276 & $8_1 >>> 0 > 3493216576 | $5_1 >>> 0 > 3218235020) | ($11_1 & ($0_1 & $12_1 >>> 0 > 2940772411 | $6_1 >>> 0 > 3132021990) | ($10_1 | 0) == -1 & $3_1 & ($13_1 ^ -1))) | 0;
            $3_1 = __wasm_i64_mul($13_1, 0, 801750719, 1076732275);
            $11_1 = $3_1 + $8_1 | 0;
            $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
            HEAP32[$1_1 + 440 >> 2] = $11_1;
            $0_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            HEAP32[$1_1 + 444 >> 2] = $0_1;
            $8_1 = ($0_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
            $5_1 = __wasm_i64_mul($13_1, 0, 1354194884, 1162945305);
            $2_1 = $5_1 + $12_1 | 0;
            $0_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
            $0_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $5_1 = $2_1;
            $2_1 = $0_1;
            $8_1 = $5_1 + $8_1 | 0;
            $0_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            HEAP32[$1_1 + 448 >> 2] = $8_1;
            HEAP32[$1_1 + 452 >> 2] = $0_1;
            $3_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
            $6_1 = ($0_1 | 0) == ($2_1 | 0) & $5_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
            $2_1 = $3_1 + $6_1 | 0;
            $5_1 = $2_1;
            $6_1 = $2_1 >>> 0 < $6_1 >>> 0;
            $0_1 = $4_1;
            $12_1 = $10_1 + $13_1 | 0;
            $2_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $0_1 = $2_1 + $6_1 | 0;
            $6_1 = $12_1;
            $5_1 = $5_1 + $6_1 | 0;
            $0_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            HEAP32[$1_1 + 456 >> 2] = $5_1;
            HEAP32[$1_1 + 460 >> 2] = $0_1;
            $3_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
            $4_1 = ($0_1 | 0) == ($2_1 | 0) & $5_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
            $2_1 = $3_1 + $4_1 | 0;
            $0_1 = $18_1 + ($2_1 >>> 0 < $4_1 >>> 0) | 0;
            $2_1 = $2_1 + $14_1 | 0;
            $0_1 = $2_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            HEAP32[$1_1 + 464 >> 2] = $2_1;
            HEAP32[$1_1 + 468 >> 2] = $0_1;
            $39(691013, $9_1);
            HEAP32[$1_1 + 504 >> 2] = $23_1;
            $0_1 = HEAP32[$1_1 + 504 >> 2] - 1 | 0;
            HEAP8[690981] = $0_1 & HEAPU8[690981];
            HEAP8[690982] = HEAPU8[690982] & $0_1;
            HEAP8[690983] = HEAPU8[690983] & $0_1;
            HEAP8[690984] = HEAPU8[690984] & $0_1;
            HEAP8[690985] = HEAPU8[690985] & $0_1;
            HEAP8[690986] = HEAPU8[690986] & $0_1;
            HEAP8[690987] = HEAPU8[690987] & $0_1;
            HEAP8[690988] = HEAPU8[690988] & $0_1;
            HEAP8[690989] = HEAPU8[690989] & $0_1;
            HEAP8[690990] = HEAPU8[690990] & $0_1;
            HEAP8[690991] = HEAPU8[690991] & $0_1;
            HEAP8[690992] = HEAPU8[690992] & $0_1;
            HEAP8[690993] = HEAPU8[690993] & $0_1;
            HEAP8[690994] = HEAPU8[690994] & $0_1;
            HEAP8[690995] = HEAPU8[690995] & $0_1;
            HEAP8[690996] = HEAPU8[690996] & $0_1;
            HEAP8[690997] = HEAPU8[690997] & $0_1;
            HEAP8[690998] = HEAPU8[690998] & $0_1;
            HEAP8[690999] = HEAPU8[690999] & $0_1;
            HEAP8[691e3] = HEAPU8[691e3] & $0_1;
            HEAP8[691001] = HEAPU8[691001] & $0_1;
            HEAP8[691002] = HEAPU8[691002] & $0_1;
            HEAP8[691003] = HEAPU8[691003] & $0_1;
            HEAP8[691004] = HEAPU8[691004] & $0_1;
            HEAP8[691005] = HEAPU8[691005] & $0_1;
            HEAP8[691006] = HEAPU8[691006] & $0_1;
            HEAP8[691007] = HEAPU8[691007] & $0_1;
            HEAP8[691008] = HEAPU8[691008] & $0_1;
            HEAP8[691009] = HEAPU8[691009] & $0_1;
            HEAP8[691010] = HEAPU8[691010] & $0_1;
            HEAP8[691011] = HEAPU8[691011] & $0_1;
            HEAP8[691012] = HEAPU8[691012] & $0_1;
            HEAP8[691013] = HEAPU8[691013] & $0_1;
            HEAP8[691014] = HEAPU8[691014] & $0_1;
            HEAP8[691015] = HEAPU8[691015] & $0_1;
            HEAP8[691016] = HEAPU8[691016] & $0_1;
            HEAP8[691017] = HEAPU8[691017] & $0_1;
            HEAP8[691018] = HEAPU8[691018] & $0_1;
            HEAP8[691019] = HEAPU8[691019] & $0_1;
            HEAP8[691020] = HEAPU8[691020] & $0_1;
            HEAP8[691021] = HEAPU8[691021] & $0_1;
            HEAP8[691022] = HEAPU8[691022] & $0_1;
            HEAP8[691023] = HEAPU8[691023] & $0_1;
            HEAP8[691024] = HEAPU8[691024] & $0_1;
            HEAP8[691025] = HEAPU8[691025] & $0_1;
            HEAP8[691026] = HEAPU8[691026] & $0_1;
            HEAP8[691027] = HEAPU8[691027] & $0_1;
            HEAP8[691028] = HEAPU8[691028] & $0_1;
            HEAP8[691029] = HEAPU8[691029] & $0_1;
            HEAP8[691030] = HEAPU8[691030] & $0_1;
            HEAP8[691031] = HEAPU8[691031] & $0_1;
            HEAP8[691032] = HEAPU8[691032] & $0_1;
            HEAP8[691033] = HEAPU8[691033] & $0_1;
            HEAP8[691034] = HEAPU8[691034] & $0_1;
            HEAP8[691035] = HEAPU8[691035] & $0_1;
            HEAP8[691036] = HEAPU8[691036] & $0_1;
            HEAP8[691037] = HEAPU8[691037] & $0_1;
            HEAP8[691038] = HEAPU8[691038] & $0_1;
            HEAP8[691039] = HEAPU8[691039] & $0_1;
            HEAP8[691040] = HEAPU8[691040] & $0_1;
            HEAP8[691041] = HEAPU8[691041] & $0_1;
            HEAP8[691042] = HEAPU8[691042] & $0_1;
            HEAP8[691043] = HEAPU8[691043] & $0_1;
            HEAP8[691044] = HEAPU8[691044] & $0_1;
            $0_1 = $1_1 + 408 | 0;
            $2_1 = $0_1 + 24 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $2_1 = $0_1 + 16 | 0;
            HEAP32[$2_1 >> 2] = 0;
            HEAP32[$2_1 + 4 >> 2] = 0;
            $0_1 = $0_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$1_1 + 408 >> 2] = 0;
            HEAP32[$1_1 + 412 >> 2] = 0;
            $0_1 = $15_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $15_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $15_1 + 8 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$1_1 + 472 >> 2] = 0;
            HEAP32[$1_1 + 476 >> 2] = 0;
            $0_1 = $1_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $1_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            HEAP32[$1_1 + 8 >> 2] = 0;
            HEAP32[$1_1 + 12 >> 2] = 0;
            HEAP32[$1_1 >> 2] = 0;
            HEAP32[$1_1 + 4 >> 2] = 0;
          }
          global$0 = $1_1 + 640 | 0;
          HEAP32[$7_1 + 100 >> 2] = $24_1;
          if ($24_1) {
            break label$2;
          }
          break label$1;
        }
        break label$1;
      }
      global$0 = $7_1 + 128 | 0;
      return;
    }
    HEAP32[$7_1 + 112 >> 2] = 0;
    $5($7_1 + 104 | 0);
    wasm2js_trap();
  }
  function $24($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
    $5_1 = global$0 - 192 | 0;
    global$0 = $5_1;
    $4_1 = $5_1 + 128 | 0;
    $6_1 = $4_1 + 56 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $7_1 = $4_1 + 48 | 0;
    HEAP32[$7_1 >> 2] = 0;
    HEAP32[$7_1 + 4 >> 2] = 0;
    $8_1 = $4_1 + 40 | 0;
    HEAP32[$8_1 >> 2] = 0;
    HEAP32[$8_1 + 4 >> 2] = 0;
    $12_1 = $4_1 + 32 | 0;
    HEAP32[$12_1 >> 2] = 0;
    HEAP32[$12_1 + 4 >> 2] = 0;
    $9_1 = $4_1 + 24 | 0;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    $11_1 = $4_1 + 16 | 0;
    HEAP32[$11_1 >> 2] = 0;
    HEAP32[$11_1 + 4 >> 2] = 0;
    $17_1 = $4_1 + 8 | 0;
    HEAP32[$17_1 >> 2] = 0;
    HEAP32[$17_1 + 4 >> 2] = 0;
    HEAP32[$5_1 + 128 >> 2] = 0;
    HEAP32[$5_1 + 132 >> 2] = 0;
    label$1: {
      if (($31(HEAP32[172688], $4_1, 690820, $0_1) | 0) == 1) {
        $4_1 = $5_1 + 128 | 0;
        $0_1 = $4_1 + 15 | 0;
        $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $3_1 = $5_1 - -64 | 0;
        $10_1 = $3_1 + 8 | 0;
        HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$10_1 + 4 >> 2] = $2_1;
        $0_1 = $4_1 + 23 | 0;
        $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $14_1 = $3_1 + 16 | 0;
        HEAP32[$14_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$14_1 + 4 >> 2] = $2_1;
        $0_1 = $4_1 + 31 | 0;
        $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $16_1 = $3_1 + 24 | 0;
        HEAP32[$16_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$16_1 + 4 >> 2] = $2_1;
        $0_1 = $4_1 + 39 | 0;
        $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $15_1 = $3_1 + 32 | 0;
        HEAP32[$15_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$15_1 + 4 >> 2] = $2_1;
        $0_1 = $4_1 + 47 | 0;
        $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $13_1 = $3_1 + 40 | 0;
        HEAP32[$13_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$13_1 + 4 >> 2] = $2_1;
        $0_1 = $4_1 + 55 | 0;
        $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $18_1 = $3_1 + 48 | 0;
        HEAP32[$18_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$18_1 + 4 >> 2] = $2_1;
        $3_1 = $3_1 + 56 | 0;
        HEAP8[$3_1 | 0] = HEAPU8[$4_1 + 63 | 0];
        HEAP8[$5_1 + 2 | 0] = HEAPU8[$5_1 + 130 | 0];
        HEAP16[$5_1 >> 1] = HEAPU16[$5_1 + 128 >> 1];
        $0_1 = HEAPU8[$5_1 + 139 | 0] | HEAPU8[$5_1 + 140 | 0] << 8 | (HEAPU8[$5_1 + 141 | 0] << 16 | HEAPU8[$5_1 + 142 | 0] << 24);
        HEAP32[$5_1 + 64 >> 2] = HEAPU8[$5_1 + 135 | 0] | HEAPU8[$5_1 + 136 | 0] << 8 | (HEAPU8[$5_1 + 137 | 0] << 16 | HEAPU8[$5_1 + 138 | 0] << 24);
        HEAP32[$5_1 + 68 >> 2] = $0_1;
        $0_1 = HEAPU8[$5_1 + 131 | 0] | HEAPU8[$5_1 + 132 | 0] << 8 | (HEAPU8[$5_1 + 133 | 0] << 16 | HEAPU8[$5_1 + 134 | 0] << 24);
        HEAP8[$5_1 + 63 | 0] = HEAPU8[$3_1 | 0];
        $2_1 = HEAP32[$18_1 + 4 >> 2];
        $3_1 = $5_1 + 55 | 0;
        $18_1 = HEAP32[$18_1 >> 2];
        HEAP8[$3_1 | 0] = $18_1;
        HEAP8[$3_1 + 1 | 0] = $18_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $18_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $18_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$13_1 + 4 >> 2];
        $3_1 = $5_1 + 47 | 0;
        $13_1 = HEAP32[$13_1 >> 2];
        HEAP8[$3_1 | 0] = $13_1;
        HEAP8[$3_1 + 1 | 0] = $13_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $13_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $13_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$15_1 + 4 >> 2];
        $3_1 = $5_1 + 39 | 0;
        $15_1 = HEAP32[$15_1 >> 2];
        HEAP8[$3_1 | 0] = $15_1;
        HEAP8[$3_1 + 1 | 0] = $15_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $15_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $15_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$16_1 + 4 >> 2];
        $3_1 = $5_1 + 31 | 0;
        $16_1 = HEAP32[$16_1 >> 2];
        HEAP8[$3_1 | 0] = $16_1;
        HEAP8[$3_1 + 1 | 0] = $16_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $16_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $16_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$14_1 + 4 >> 2];
        $3_1 = $5_1 + 23 | 0;
        $14_1 = HEAP32[$14_1 >> 2];
        HEAP8[$3_1 | 0] = $14_1;
        HEAP8[$3_1 + 1 | 0] = $14_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $14_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $14_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$10_1 + 4 >> 2];
        $3_1 = $5_1 + 15 | 0;
        $10_1 = HEAP32[$10_1 >> 2];
        HEAP8[$3_1 | 0] = $10_1;
        HEAP8[$3_1 + 1 | 0] = $10_1 >>> 8;
        HEAP8[$3_1 + 2 | 0] = $10_1 >>> 16;
        HEAP8[$3_1 + 3 | 0] = $10_1 >>> 24;
        HEAP8[$3_1 + 4 | 0] = $2_1;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
        HEAP8[$5_1 + 3 | 0] = $0_1;
        HEAP8[$5_1 + 4 | 0] = $0_1 >>> 8;
        HEAP8[$5_1 + 5 | 0] = $0_1 >>> 16;
        HEAP8[$5_1 + 6 | 0] = $0_1 >>> 24;
        $0_1 = HEAP32[$5_1 + 68 >> 2];
        $3_1 = HEAP32[$5_1 + 64 >> 2];
        HEAP8[$5_1 + 7 | 0] = $3_1;
        HEAP8[$5_1 + 8 | 0] = $3_1 >>> 8;
        HEAP8[$5_1 + 9 | 0] = $3_1 >>> 16;
        HEAP8[$5_1 + 10 | 0] = $3_1 >>> 24;
        HEAP8[$5_1 + 11 | 0] = $0_1;
        HEAP8[$5_1 + 12 | 0] = $0_1 >>> 8;
        HEAP8[$5_1 + 13 | 0] = $0_1 >>> 16;
        HEAP8[$5_1 + 14 | 0] = $0_1 >>> 24;
        HEAP32[$6_1 >> 2] = 0;
        HEAP32[$6_1 + 4 >> 2] = 0;
        HEAP32[$7_1 >> 2] = 0;
        HEAP32[$7_1 + 4 >> 2] = 0;
        HEAP32[$8_1 >> 2] = 0;
        HEAP32[$8_1 + 4 >> 2] = 0;
        HEAP32[$12_1 >> 2] = 0;
        HEAP32[$12_1 + 4 >> 2] = 0;
        HEAP32[$9_1 >> 2] = 0;
        HEAP32[$9_1 + 4 >> 2] = 0;
        HEAP32[$11_1 >> 2] = 0;
        HEAP32[$11_1 + 4 >> 2] = 0;
        HEAP32[$17_1 >> 2] = 0;
        HEAP32[$17_1 + 4 >> 2] = 0;
        HEAP32[$5_1 + 128 >> 2] = 0;
        HEAP32[$5_1 + 132 >> 2] = 0;
        $3_1 = 0;
        $6_1 = HEAP32[172688];
        $2_1 = 0;
        $0_1 = global$0 - 80 | 0;
        global$0 = $0_1;
        HEAP32[$0_1 + 12 >> 2] = 0;
        label$3: {
          if (!$4_1) {
            FUNCTION_TABLE[HEAP32[$6_1 + 168 >> 2]](689748, HEAP32[$6_1 + 172 >> 2]);
            break label$3;
          }
          $2_1 = $0_1 + 12 | 0;
          $38($0_1 + 48 | 0, 690981, $2_1);
          $6_1 = HEAP32[$0_1 + 12 >> 2];
          $38($0_1 + 16 | 0, 691013, $2_1);
          if (!($6_1 | HEAP32[$0_1 + 12 >> 2])) {
            $2_1 = HEAP32[$0_1 + 52 >> 2];
            $6_1 = HEAP32[$0_1 + 48 >> 2];
            HEAP8[$4_1 | 0] = $6_1;
            HEAP8[$4_1 + 1 | 0] = $6_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $6_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $6_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $2_1;
            HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = HEAP32[$0_1 + 20 >> 2];
            $6_1 = HEAP32[$0_1 + 16 >> 2];
            HEAP8[$4_1 + 32 | 0] = $6_1;
            HEAP8[$4_1 + 33 | 0] = $6_1 >>> 8;
            HEAP8[$4_1 + 34 | 0] = $6_1 >>> 16;
            HEAP8[$4_1 + 35 | 0] = $6_1 >>> 24;
            HEAP8[$4_1 + 36 | 0] = $2_1;
            HEAP8[$4_1 + 37 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 38 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 39 | 0] = $2_1 >>> 24;
            $8_1 = $0_1 + 48 | 0;
            $7_1 = $8_1 + 24 | 0;
            $6_1 = HEAP32[$7_1 + 4 >> 2];
            $2_1 = $4_1 + 24 | 0;
            $7_1 = HEAP32[$7_1 >> 2];
            HEAP8[$2_1 | 0] = $7_1;
            HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
            HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
            HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
            HEAP8[$2_1 + 4 | 0] = $6_1;
            HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
            HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
            HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
            $7_1 = $8_1 + 16 | 0;
            $6_1 = HEAP32[$7_1 + 4 >> 2];
            $2_1 = $4_1 + 16 | 0;
            $7_1 = HEAP32[$7_1 >> 2];
            HEAP8[$2_1 | 0] = $7_1;
            HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
            HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
            HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
            HEAP8[$2_1 + 4 | 0] = $6_1;
            HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
            HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
            HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
            $7_1 = $8_1 + 8 | 0;
            $6_1 = HEAP32[$7_1 + 4 >> 2];
            $2_1 = $4_1 + 8 | 0;
            $7_1 = HEAP32[$7_1 >> 2];
            HEAP8[$2_1 | 0] = $7_1;
            HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
            HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
            HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
            HEAP8[$2_1 + 4 | 0] = $6_1;
            HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
            HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
            HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
            $8_1 = $0_1 + 16 | 0;
            $7_1 = $8_1 + 8 | 0;
            $6_1 = HEAP32[$7_1 + 4 >> 2];
            $2_1 = $4_1 + 40 | 0;
            $7_1 = HEAP32[$7_1 >> 2];
            HEAP8[$2_1 | 0] = $7_1;
            HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
            HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
            HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
            HEAP8[$2_1 + 4 | 0] = $6_1;
            HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
            HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
            HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
            $7_1 = $8_1 + 16 | 0;
            $6_1 = HEAP32[$7_1 + 4 >> 2];
            $2_1 = $4_1 + 48 | 0;
            $7_1 = HEAP32[$7_1 >> 2];
            HEAP8[$2_1 | 0] = $7_1;
            HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
            HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
            HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
            HEAP8[$2_1 + 4 | 0] = $6_1;
            HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
            HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
            HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
            $6_1 = $8_1 + 24 | 0;
            $2_1 = HEAP32[$6_1 + 4 >> 2];
            $4_1 = $4_1 + 56 | 0;
            $6_1 = HEAP32[$6_1 >> 2];
            HEAP8[$4_1 | 0] = $6_1;
            HEAP8[$4_1 + 1 | 0] = $6_1 >>> 8;
            HEAP8[$4_1 + 2 | 0] = $6_1 >>> 16;
            HEAP8[$4_1 + 3 | 0] = $6_1 >>> 24;
            HEAP8[$4_1 + 4 | 0] = $2_1;
            HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
            HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
            HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
            $2_1 = 1;
            break label$3;
          }
          HEAP8[$4_1 | 0] = 0;
          HEAP8[$4_1 + 1 | 0] = 0;
          HEAP8[$4_1 + 2 | 0] = 0;
          HEAP8[$4_1 + 3 | 0] = 0;
          HEAP8[$4_1 + 4 | 0] = 0;
          HEAP8[$4_1 + 5 | 0] = 0;
          HEAP8[$4_1 + 6 | 0] = 0;
          HEAP8[$4_1 + 7 | 0] = 0;
          $2_1 = $4_1 + 56 | 0;
          HEAP8[$2_1 | 0] = 0;
          HEAP8[$2_1 + 1 | 0] = 0;
          HEAP8[$2_1 + 2 | 0] = 0;
          HEAP8[$2_1 + 3 | 0] = 0;
          HEAP8[$2_1 + 4 | 0] = 0;
          HEAP8[$2_1 + 5 | 0] = 0;
          HEAP8[$2_1 + 6 | 0] = 0;
          HEAP8[$2_1 + 7 | 0] = 0;
          $2_1 = $4_1 + 48 | 0;
          HEAP8[$2_1 | 0] = 0;
          HEAP8[$2_1 + 1 | 0] = 0;
          HEAP8[$2_1 + 2 | 0] = 0;
          HEAP8[$2_1 + 3 | 0] = 0;
          HEAP8[$2_1 + 4 | 0] = 0;
          HEAP8[$2_1 + 5 | 0] = 0;
          HEAP8[$2_1 + 6 | 0] = 0;
          HEAP8[$2_1 + 7 | 0] = 0;
          $2_1 = $4_1 + 40 | 0;
          HEAP8[$2_1 | 0] = 0;
          HEAP8[$2_1 + 1 | 0] = 0;
          HEAP8[$2_1 + 2 | 0] = 0;
          HEAP8[$2_1 + 3 | 0] = 0;
          HEAP8[$2_1 + 4 | 0] = 0;
          HEAP8[$2_1 + 5 | 0] = 0;
          HEAP8[$2_1 + 6 | 0] = 0;
          HEAP8[$2_1 + 7 | 0] = 0;
          $2_1 = $4_1 + 32 | 0;
          HEAP8[$2_1 | 0] = 0;
          HEAP8[$2_1 + 1 | 0] = 0;
          HEAP8[$2_1 + 2 | 0] = 0;
          HEAP8[$2_1 + 3 | 0] = 0;
          HEAP8[$2_1 + 4 | 0] = 0;
          HEAP8[$2_1 + 5 | 0] = 0;
          HEAP8[$2_1 + 6 | 0] = 0;
          HEAP8[$2_1 + 7 | 0] = 0;
          $2_1 = $4_1 + 24 | 0;
          HEAP8[$2_1 | 0] = 0;
          HEAP8[$2_1 + 1 | 0] = 0;
          HEAP8[$2_1 + 2 | 0] = 0;
          HEAP8[$2_1 + 3 | 0] = 0;
          HEAP8[$2_1 + 4 | 0] = 0;
          HEAP8[$2_1 + 5 | 0] = 0;
          HEAP8[$2_1 + 6 | 0] = 0;
          HEAP8[$2_1 + 7 | 0] = 0;
          $2_1 = $4_1 + 16 | 0;
          HEAP8[$2_1 | 0] = 0;
          HEAP8[$2_1 + 1 | 0] = 0;
          HEAP8[$2_1 + 2 | 0] = 0;
          HEAP8[$2_1 + 3 | 0] = 0;
          HEAP8[$2_1 + 4 | 0] = 0;
          HEAP8[$2_1 + 5 | 0] = 0;
          HEAP8[$2_1 + 6 | 0] = 0;
          HEAP8[$2_1 + 7 | 0] = 0;
          $4_1 = $4_1 + 8 | 0;
          HEAP8[$4_1 | 0] = 0;
          HEAP8[$4_1 + 1 | 0] = 0;
          HEAP8[$4_1 + 2 | 0] = 0;
          HEAP8[$4_1 + 3 | 0] = 0;
          HEAP8[$4_1 + 4 | 0] = 0;
          HEAP8[$4_1 + 5 | 0] = 0;
          HEAP8[$4_1 + 6 | 0] = 0;
          HEAP8[$4_1 + 7 | 0] = 0;
          $2_1 = 0;
        }
        global$0 = $0_1 + 80 | 0;
        if (!$2_1) {
          fimport$1(4);
          break label$1;
        }
        if (!$1_1) {
          label$8: {
            $0_1 = HEAP32[172688];
            $2_1 = $5_1 + 128 | 0;
            if (!$2_1) {
              FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689716, HEAP32[$0_1 + 172 >> 2]);
              break label$8;
            }
            $1_1 = HEAPU8[$2_1 + 60 | 0] | HEAPU8[$2_1 + 61 | 0] << 8 | (HEAPU8[$2_1 + 62 | 0] << 16 | HEAPU8[$2_1 + 63 | 0] << 24);
            $12_1 = $1_1;
            $1_1 = $1_1 >>> 31 | 0;
            $3_1 = $1_1 ^ -1;
            $9_1 = HEAPU8[$2_1 + 44 | 0] | HEAPU8[$2_1 + 45 | 0] << 8 | (HEAPU8[$2_1 + 46 | 0] << 16 | HEAPU8[$2_1 + 47 | 0] << 24);
            $4_1 = ($9_1 | 0) == 1566010995;
            $11_1 = HEAPU8[$2_1 + 40 | 0] | HEAPU8[$2_1 + 41 | 0] << 8 | (HEAPU8[$2_1 + 42 | 0] << 16 | HEAPU8[$2_1 + 43 | 0] << 24);
            $10_1 = HEAPU8[$2_1 + 48 | 0] | HEAPU8[$2_1 + 49 | 0] << 8 | (HEAPU8[$2_1 + 50 | 0] << 16 | HEAPU8[$2_1 + 51 | 0] << 24);
            $14_1 = HEAPU8[$2_1 + 52 | 0] | HEAPU8[$2_1 + 53 | 0] << 8 | (HEAPU8[$2_1 + 54 | 0] << 16 | HEAPU8[$2_1 + 55 | 0] << 24);
            $0_1 = HEAPU8[$2_1 + 56 | 0] | HEAPU8[$2_1 + 57 | 0] << 8 | (HEAPU8[$2_1 + 58 | 0] << 16 | HEAPU8[$2_1 + 59 | 0] << 24);
            $3_1 = ($3_1 & ($4_1 & $11_1 >>> 0 < 1470386205 | $9_1 >>> 0 < 1566010995) | ($3_1 & ($10_1 & $14_1) != -1 | (($12_1 | 0) == 2147483647 & ($0_1 | 0) != -1 | $12_1 >>> 0 < 2147483647))) ^ -1;
            $17_1 = HEAPU8[$2_1 + 36 | 0] | HEAPU8[$2_1 + 37 | 0] << 8 | (HEAPU8[$2_1 + 38 | 0] << 16 | HEAPU8[$2_1 + 39 | 0] << 24);
            $16_1 = HEAPU8[$2_1 + 32 | 0] | HEAPU8[$2_1 + 33 | 0] << 8 | (HEAPU8[$2_1 + 34 | 0] << 16 | HEAPU8[$2_1 + 35 | 0] << 24);
            $1_1 = $3_1 & (($17_1 | 0) == -538366138 & $16_1 >>> 0 > 1746608288 | $17_1 >>> 0 > 3756601158) | ($3_1 & ($4_1 & $11_1 >>> 0 > 1470386205 | $9_1 >>> 0 > 1566010995) | $1_1);
            if ($2_1) {
              if ($1_1) {
                $1_1 = $16_1 ^ -1;
                $4_1 = $1_1 - 801750718 | 0;
                $13_1 = $4_1;
                $3_1 = $17_1 ^ -1;
                $7_1 = $3_1 - (($1_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
                $4_1 = ($3_1 | 0) == ($7_1 | 0) & $1_1 >>> 0 > $4_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
                $15_1 = $11_1 ^ -1;
                $1_1 = $4_1 + $15_1 | 0;
                $3_1 = $9_1 ^ -1;
                $6_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
                $4_1 = $1_1 - 1354194885 | 0;
                $18_1 = $4_1;
                $19_1 = $10_1 ^ -1;
                $3_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 > $6_1 >>> 0;
                $15_1 = $6_1 - (($1_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
                $4_1 = ($15_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $4_1 >>> 0 | $6_1 >>> 0 > $15_1 >>> 0;
                $1_1 = $3_1 + $4_1 | 0;
                $8_1 = $14_1 ^ -1;
                $3_1 = $8_1 + ($1_1 >>> 0 < $4_1 >>> 0) | 0;
                $4_1 = $1_1 + $19_1 | 0;
                $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
                $6_1 = $4_1 - 2 | 0;
                $20_1 = $6_1;
                $1_1 = $11_1 | $16_1 | $10_1 | $0_1 | ($9_1 | $17_1 | $14_1 | $12_1) ? -1 : 0;
                $14_1 = ($3_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 < $19_1 >>> 0 | $3_1 >>> 0 < $8_1 >>> 0;
                $8_1 = $3_1 - ($4_1 >>> 0 < 2) | 0;
                $3_1 = ($8_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
                $4_1 = $14_1 + $3_1 | 0;
                $6_1 = $3_1 >>> 0 > $4_1 >>> 0;
                $3_1 = $0_1;
                $9_1 = $4_1 - $3_1 | 0;
                $0_1 = $9_1 - 2 & $1_1;
                $12_1 = $1_1 & ($6_1 - (($3_1 >>> 0 > $4_1 >>> 0) + $12_1 | 0) | 0) - ($9_1 >>> 0 < 2);
                $3_1 = $1_1;
                $10_1 = $3_1 & $20_1;
                $14_1 = $3_1 & $8_1;
                $16_1 = $3_1 & $13_1;
                $17_1 = $3_1 & $7_1;
                $11_1 = $3_1 & $18_1;
                $9_1 = $3_1 & $15_1;
              }
              $6_1 = $2_1 + 8 | 0;
              $15_1 = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
              $3_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
              $7_1 = $2_1 + 16 | 0;
              $13_1 = HEAPU8[$7_1 | 0] | HEAPU8[$7_1 + 1 | 0] << 8 | (HEAPU8[$7_1 + 2 | 0] << 16 | HEAPU8[$7_1 + 3 | 0] << 24);
              $1_1 = HEAPU8[$7_1 + 4 | 0] | HEAPU8[$7_1 + 5 | 0] << 8 | (HEAPU8[$7_1 + 6 | 0] << 16 | HEAPU8[$7_1 + 7 | 0] << 24);
              $18_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
              $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
              $8_1 = $2_1 + 24 | 0;
              $19_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
              $20_1 = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
              HEAP8[$8_1 | 0] = $20_1;
              HEAP8[$8_1 + 1 | 0] = $20_1 >>> 8;
              HEAP8[$8_1 + 2 | 0] = $20_1 >>> 16;
              HEAP8[$8_1 + 3 | 0] = $20_1 >>> 24;
              HEAP8[$8_1 + 4 | 0] = $19_1;
              HEAP8[$8_1 + 5 | 0] = $19_1 >>> 8;
              HEAP8[$8_1 + 6 | 0] = $19_1 >>> 16;
              HEAP8[$8_1 + 7 | 0] = $19_1 >>> 24;
              HEAP8[$7_1 | 0] = $13_1;
              HEAP8[$7_1 + 1 | 0] = $13_1 >>> 8;
              HEAP8[$7_1 + 2 | 0] = $13_1 >>> 16;
              HEAP8[$7_1 + 3 | 0] = $13_1 >>> 24;
              HEAP8[$7_1 + 4 | 0] = $1_1;
              HEAP8[$7_1 + 5 | 0] = $1_1 >>> 8;
              HEAP8[$7_1 + 6 | 0] = $1_1 >>> 16;
              HEAP8[$7_1 + 7 | 0] = $1_1 >>> 24;
              HEAP8[$6_1 | 0] = $15_1;
              HEAP8[$6_1 + 1 | 0] = $15_1 >>> 8;
              HEAP8[$6_1 + 2 | 0] = $15_1 >>> 16;
              HEAP8[$6_1 + 3 | 0] = $15_1 >>> 24;
              HEAP8[$6_1 + 4 | 0] = $3_1;
              HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
              HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
              HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
              HEAP8[$2_1 | 0] = $18_1;
              HEAP8[$2_1 + 1 | 0] = $18_1 >>> 8;
              HEAP8[$2_1 + 2 | 0] = $18_1 >>> 16;
              HEAP8[$2_1 + 3 | 0] = $18_1 >>> 24;
              HEAP8[$2_1 + 4 | 0] = $4_1;
              HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
              HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
              HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
              HEAP8[$2_1 + 56 | 0] = $0_1;
              HEAP8[$2_1 + 57 | 0] = $0_1 >>> 8;
              HEAP8[$2_1 + 58 | 0] = $0_1 >>> 16;
              HEAP8[$2_1 + 59 | 0] = $0_1 >>> 24;
              HEAP8[$2_1 + 60 | 0] = $12_1;
              HEAP8[$2_1 + 61 | 0] = $12_1 >>> 8;
              HEAP8[$2_1 + 62 | 0] = $12_1 >>> 16;
              HEAP8[$2_1 + 63 | 0] = $12_1 >>> 24;
              HEAP8[$2_1 + 48 | 0] = $10_1;
              HEAP8[$2_1 + 49 | 0] = $10_1 >>> 8;
              HEAP8[$2_1 + 50 | 0] = $10_1 >>> 16;
              HEAP8[$2_1 + 51 | 0] = $10_1 >>> 24;
              HEAP8[$2_1 + 52 | 0] = $14_1;
              HEAP8[$2_1 + 53 | 0] = $14_1 >>> 8;
              HEAP8[$2_1 + 54 | 0] = $14_1 >>> 16;
              HEAP8[$2_1 + 55 | 0] = $14_1 >>> 24;
              HEAP8[$2_1 + 40 | 0] = $11_1;
              HEAP8[$2_1 + 41 | 0] = $11_1 >>> 8;
              HEAP8[$2_1 + 42 | 0] = $11_1 >>> 16;
              HEAP8[$2_1 + 43 | 0] = $11_1 >>> 24;
              HEAP8[$2_1 + 44 | 0] = $9_1;
              HEAP8[$2_1 + 45 | 0] = $9_1 >>> 8;
              HEAP8[$2_1 + 46 | 0] = $9_1 >>> 16;
              HEAP8[$2_1 + 47 | 0] = $9_1 >>> 24;
              HEAP8[$2_1 + 32 | 0] = $16_1;
              HEAP8[$2_1 + 33 | 0] = $16_1 >>> 8;
              HEAP8[$2_1 + 34 | 0] = $16_1 >>> 16;
              HEAP8[$2_1 + 35 | 0] = $16_1 >>> 24;
              HEAP8[$2_1 + 36 | 0] = $17_1;
              HEAP8[$2_1 + 37 | 0] = $17_1 >>> 8;
              HEAP8[$2_1 + 38 | 0] = $17_1 >>> 16;
              HEAP8[$2_1 + 39 | 0] = $17_1 >>> 24;
            }
          }
        }
        $13_1 = $6();
        $0_1 = 0;
        $1_1 = global$0 - 464 | 0;
        global$0 = $1_1;
        $3_1 = $5_1 + 128 | 0;
        label$12: {
          if (!$3_1) {
            FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](689748, HEAP32[$13_1 + 172 >> 2]);
            break label$12;
          }
          if (!$5_1) {
            FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](689638, HEAP32[$13_1 + 172 >> 2]);
            break label$12;
          }
          $38($1_1 + 8 | 0, 655649, 0);
          $4_1 = $3_1 + 24 | 0;
          $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
          $2_1 = $1_1 + 40 | 0;
          $7_1 = $2_1 + 24 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $6_1;
          $4_1 = $3_1 + 16 | 0;
          $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
          $7_1 = $2_1 + 16 | 0;
          HEAP32[$7_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
          HEAP32[$7_1 + 4 >> 2] = $6_1;
          $4_1 = $3_1 + 8 | 0;
          $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
          $2_1 = $2_1 + 8 | 0;
          HEAP32[$2_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
          HEAP32[$2_1 + 4 >> 2] = $6_1;
          $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          HEAP32[$1_1 + 40 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          HEAP32[$1_1 + 44 >> 2] = $4_1;
          $6_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
          $21_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
          $4_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
          $8_1 = $4_1 >>> 31 | 0;
          $10_1 = $8_1 ^ -1;
          $2_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
          $11_1 = ($2_1 | 0) == 1566010995;
          $7_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
          $17_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
          $9_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
          $12_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
          $3_1 = ($10_1 & ($11_1 & $7_1 >>> 0 < 1470386205 | $2_1 >>> 0 < 1566010995) | ($10_1 & ($17_1 & $9_1) != -1 | (($4_1 | 0) == 2147483647 & ($12_1 | 0) != -1 | $4_1 >>> 0 < 2147483647))) ^ -1;
          if ((($6_1 | 0) == -538366138 & $21_1 >>> 0 > 1746608288 | $6_1 >>> 0 > 3756601158) & $3_1 | ($3_1 & ($11_1 & $7_1 >>> 0 > 1470386205 | $2_1 >>> 0 > 1566010995) | $8_1)) {
            break label$12;
          }
          $3_1 = HEAPU8[$5_1 + 12 | 0] | HEAPU8[$5_1 + 13 | 0] << 8 | (HEAPU8[$5_1 + 14 | 0] << 16 | HEAPU8[$5_1 + 15 | 0] << 24);
          $11_1 = $3_1;
          $8_1 = HEAPU8[$5_1 + 8 | 0] | HEAPU8[$5_1 + 9 | 0] << 8 | (HEAPU8[$5_1 + 10 | 0] << 16 | HEAPU8[$5_1 + 11 | 0] << 24);
          $10_1 = ($3_1 << 12 | $8_1 >>> 20) & 1048575;
          $14_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
          $18_1 = $14_1;
          $22_1 = $8_1 << 12 & -4096 | $14_1 >>> 20;
          $23_1 = $10_1;
          $8_1 = HEAPU8[$5_1 + 16 | 0] | HEAPU8[$5_1 + 17 | 0] << 8 | (HEAPU8[$5_1 + 18 | 0] << 16 | HEAPU8[$5_1 + 19 | 0] << 24);
          $19_1 = $8_1;
          $3_1 = HEAPU8[$5_1 + 20 | 0] | HEAPU8[$5_1 + 21 | 0] << 8 | (HEAPU8[$5_1 + 22 | 0] << 16 | HEAPU8[$5_1 + 23 | 0] << 24);
          $15_1 = $3_1;
          $10_1 = ($3_1 << 24 | $8_1 >>> 8) & 1048575;
          $24_1 = $8_1 << 24 & -16777216 | $11_1 >>> 8;
          $25_1 = $10_1;
          $11_1 = HEAPU8[$5_1 + 28 | 0] | HEAPU8[$5_1 + 29 | 0] << 8 | (HEAPU8[$5_1 + 30 | 0] << 16 | HEAPU8[$5_1 + 31 | 0] << 24);
          $3_1 = $11_1 >>> 16 | 0;
          $8_1 = HEAPU8[$5_1 + 24 | 0] | HEAPU8[$5_1 + 25 | 0] << 8 | (HEAPU8[$5_1 + 26 | 0] << 16 | HEAPU8[$5_1 + 27 | 0] << 24);
          $10_1 = ($11_1 & 65535) << 16 | $8_1 >>> 16;
          $14_1 = $3_1;
          $11_1 = $8_1 << 4 & 1048560;
          $8_1 = $15_1;
          $3_1 = $8_1 >>> 28 | 0;
          $26_1 = ($8_1 & 268435455) << 4 | $19_1 >>> 28;
          $27_1 = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
          $28_1 = $3_1 | $11_1;
          $29_1 = $18_1 & 1048575;
          if (!($26_1 | ($24_1 | ($10_1 | ($22_1 | $27_1))) | ($28_1 | ($25_1 | ($14_1 | ($23_1 | $29_1)))))) {
            FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](690116, HEAP32[$13_1 + 172 >> 2]);
            break label$12;
          }
          $11_1 = HEAP32[$1_1 + 64 >> 2];
          $16_1 = HEAP32[$1_1 + 56 >> 2];
          $30_1 = HEAP32[$1_1 + 48 >> 2];
          $31_1 = HEAP32[$1_1 + 40 >> 2];
          $8_1 = HEAP32[$1_1 + 68 >> 2];
          $18_1 = HEAP32[$1_1 + 60 >> 2];
          $15_1 = HEAP32[$1_1 + 52 >> 2];
          $13_1 = HEAP32[$1_1 + 44 >> 2];
          if (!($11_1 | ($16_1 | ($30_1 | $31_1)) | ($8_1 | ($18_1 | ($15_1 | $13_1))))) {
            break label$12;
          }
          if (!($7_1 | $21_1 | $17_1 | $12_1 | ($2_1 | $6_1 | $9_1 | $4_1))) {
            break label$12;
          }
          $19_1 = HEAPU8[$5_1 + 48 | 0] | HEAPU8[$5_1 + 49 | 0] << 8 | (HEAPU8[$5_1 + 50 | 0] << 16 | HEAPU8[$5_1 + 51 | 0] << 24);
          $20_1 = HEAPU8[$5_1 + 52 | 0] | HEAPU8[$5_1 + 53 | 0] << 8 | (HEAPU8[$5_1 + 54 | 0] << 16 | HEAPU8[$5_1 + 55 | 0] << 24);
          $32_1 = HEAPU8[$5_1 + 56 | 0] | HEAPU8[$5_1 + 57 | 0] << 8 | (HEAPU8[$5_1 + 58 | 0] << 16 | HEAPU8[$5_1 + 59 | 0] << 24);
          $34_1 = HEAPU8[$5_1 + 60 | 0] | HEAPU8[$5_1 + 61 | 0] << 8 | (HEAPU8[$5_1 + 62 | 0] << 16 | HEAPU8[$5_1 + 63 | 0] << 24);
          $35_1 = HEAPU8[$5_1 + 40 | 0] | HEAPU8[$5_1 + 41 | 0] << 8 | (HEAPU8[$5_1 + 42 | 0] << 16 | HEAPU8[$5_1 + 43 | 0] << 24);
          $36_1 = HEAPU8[$5_1 + 44 | 0] | HEAPU8[$5_1 + 45 | 0] << 8 | (HEAPU8[$5_1 + 46 | 0] << 16 | HEAPU8[$5_1 + 47 | 0] << 24);
          $37_1 = HEAPU8[$5_1 + 32 | 0] | HEAPU8[$5_1 + 33 | 0] << 8 | (HEAPU8[$5_1 + 34 | 0] << 16 | HEAPU8[$5_1 + 35 | 0] << 24);
          $33_1 = HEAPU8[$5_1 + 36 | 0] | HEAPU8[$5_1 + 37 | 0] << 8 | (HEAPU8[$5_1 + 38 | 0] << 16 | HEAPU8[$5_1 + 39 | 0] << 24);
          HEAP32[$1_1 + 232 >> 2] = $4_1 >>> 24;
          HEAP32[$1_1 + 236 >> 2] = 0;
          HEAP32[$1_1 + 200 >> 2] = $21_1;
          HEAP32[$1_1 + 204 >> 2] = $6_1 & 1073741823;
          $3_1 = $4_1 << 6 | $12_1 >>> 26;
          $4_1 = $9_1;
          HEAP32[$1_1 + 224 >> 2] = $12_1 << 6 | $4_1 >>> 26;
          HEAP32[$1_1 + 228 >> 2] = $3_1 & 1073741823;
          $3_1 = $4_1 << 4 | $17_1 >>> 28;
          HEAP32[$1_1 + 216 >> 2] = $17_1 << 4 | $2_1 >>> 28;
          HEAP32[$1_1 + 220 >> 2] = $3_1 & 1073741823;
          $2_1 = $2_1 << 2 | $7_1 >>> 30;
          HEAP32[$1_1 + 208 >> 2] = $7_1 << 2 | $6_1 >>> 30;
          HEAP32[$1_1 + 212 >> 2] = $2_1 & 1073741823;
          $12_1 = $1_1 + 200 | 0;
          $40($12_1, 690320);
          $2_1 = HEAP32[$1_1 + 232 >> 2] << 24;
          $7_1 = HEAP32[$1_1 + 228 >> 2];
          $3_1 = $7_1 >>> 6 | 0;
          $6_1 = HEAP32[$1_1 + 224 >> 2];
          HEAP32[$1_1 + 456 >> 2] = ($7_1 & 63) << 26 | $6_1 >>> 6;
          HEAP32[$1_1 + 460 >> 2] = $2_1 | $3_1;
          $2_1 = $6_1 << 26;
          $7_1 = HEAP32[$1_1 + 220 >> 2];
          $3_1 = $7_1 >>> 4 | 0;
          $6_1 = HEAP32[$1_1 + 216 >> 2];
          HEAP32[$1_1 + 448 >> 2] = ($7_1 & 15) << 28 | $6_1 >>> 4;
          HEAP32[$1_1 + 452 >> 2] = $2_1 | $3_1;
          $2_1 = $6_1 << 28;
          $7_1 = HEAP32[$1_1 + 212 >> 2];
          $3_1 = $7_1 >>> 2 | 0;
          $6_1 = HEAP32[$1_1 + 208 >> 2];
          HEAP32[$1_1 + 440 >> 2] = ($7_1 & 3) << 30 | $6_1 >>> 2;
          HEAP32[$1_1 + 444 >> 2] = $2_1 | $3_1;
          $2_1 = HEAP32[$1_1 + 204 >> 2];
          $3_1 = $6_1 << 30;
          HEAP32[$1_1 + 432 >> 2] = HEAP32[$1_1 + 200 >> 2];
          HEAP32[$1_1 + 436 >> 2] = $2_1 | $3_1;
          $6_1 = $1_1 + 400 | 0;
          $3_1 = $1_1 + 432 | 0;
          $41($6_1, $3_1, $1_1 + 8 | 0);
          $7_1 = $1_1 + 368 | 0;
          $41($7_1, $3_1, $1_1 + 40 | 0);
          $3_1 = $1_1 + 288 | 0;
          HEAP32[$3_1 >> 2] = 0;
          HEAP32[$3_1 + 4 >> 2] = 0;
          $4_1 = $34_1;
          $3_1 = $4_1 >>> 16 | 0;
          $2_1 = $1_1 + 272 | 0;
          HEAP32[$2_1 >> 2] = ($4_1 & 65535) << 16 | $32_1 >>> 16;
          HEAP32[$2_1 + 4 >> 2] = $3_1;
          $9_1 = $32_1 << 4 & 1048560;
          $4_1 = $20_1;
          $3_1 = $4_1 >>> 28 | 0;
          $2_1 = $1_1 + 264 | 0;
          HEAP32[$2_1 >> 2] = ($4_1 & 268435455) << 4 | $19_1 >>> 28;
          HEAP32[$2_1 + 4 >> 2] = $3_1 | $9_1;
          $3_1 = $4_1 << 24 | $19_1 >>> 8;
          $2_1 = $1_1 + 256 | 0;
          $4_1 = $36_1;
          HEAP32[$2_1 >> 2] = $19_1 << 24 & -16777216 | $4_1 >>> 8;
          HEAP32[$2_1 + 4 >> 2] = $3_1 & 1048575;
          $3_1 = $4_1 << 12;
          $4_1 = $35_1;
          $9_1 = ($3_1 | $4_1 >>> 20) & 1048575;
          $2_1 = $1_1 + 248 | 0;
          HEAP32[$2_1 >> 2] = $4_1 << 12 & -4096 | $33_1 >>> 20;
          HEAP32[$2_1 + 4 >> 2] = $9_1;
          $3_1 = $1_1 + 296 | 0;
          HEAP32[$3_1 >> 2] = 0;
          HEAP32[$3_1 + 4 >> 2] = 0;
          $3_1 = $1_1 + 304 | 0;
          HEAP32[$3_1 >> 2] = 0;
          HEAP32[$3_1 + 4 >> 2] = 0;
          $3_1 = $1_1 + 312 | 0;
          HEAP32[$3_1 >> 2] = 0;
          HEAP32[$3_1 + 4 >> 2] = 0;
          HEAP32[$1_1 + 280 >> 2] = 1;
          HEAP32[$1_1 + 284 >> 2] = 0;
          HEAP32[$1_1 + 240 >> 2] = $37_1;
          HEAP32[$1_1 + 244 >> 2] = $33_1 & 1048575;
          HEAP32[$1_1 + 232 >> 2] = $10_1;
          HEAP32[$1_1 + 236 >> 2] = $14_1;
          HEAP32[$1_1 + 224 >> 2] = $26_1;
          HEAP32[$1_1 + 228 >> 2] = $28_1;
          HEAP32[$1_1 + 216 >> 2] = $24_1;
          HEAP32[$1_1 + 220 >> 2] = $25_1;
          HEAP32[$1_1 + 208 >> 2] = $22_1;
          HEAP32[$1_1 + 212 >> 2] = $23_1;
          HEAP32[$1_1 + 200 >> 2] = $27_1;
          HEAP32[$1_1 + 204 >> 2] = $29_1;
          HEAP32[$1_1 + 320 >> 2] = 0;
          $42($1_1 + 72 | 0, $12_1, $7_1, $6_1);
          if (HEAP32[$1_1 + 192 >> 2]) {
            break label$12;
          }
          $0_1 = $8_1;
          $3_1 = $0_1 >>> 16 | 0;
          HEAP32[$1_1 + 360 >> 2] = ($0_1 & 65535) << 16 | $11_1 >>> 16;
          HEAP32[$1_1 + 364 >> 2] = $3_1;
          $4_1 = $31_1;
          HEAP32[$1_1 + 328 >> 2] = $4_1;
          $8_1 = $13_1 & 1048575;
          HEAP32[$1_1 + 332 >> 2] = $8_1;
          $2_1 = $0_1;
          $0_1 = $18_1;
          $3_1 = $11_1 << 4 & 1048560 | $0_1 >>> 28;
          $17_1 = $3_1;
          $10_1 = ($0_1 & 268435455) << 4 | $16_1 >>> 28;
          HEAP32[$1_1 + 352 >> 2] = $10_1;
          HEAP32[$1_1 + 356 >> 2] = $3_1;
          $3_1 = $0_1 << 24 | $16_1 >>> 8;
          $0_1 = $15_1;
          $12_1 = $16_1 << 24 & -16777216 | $0_1 >>> 8;
          HEAP32[$1_1 + 344 >> 2] = $12_1;
          $6_1 = $3_1 & 1048575;
          HEAP32[$1_1 + 348 >> 2] = $6_1;
          $3_1 = $0_1 << 12;
          $0_1 = $30_1;
          $7_1 = ($3_1 | $0_1 >>> 20) & 1048575;
          $9_1 = $0_1 << 12 & -4096 | $13_1 >>> 20;
          HEAP32[$1_1 + 336 >> 2] = $9_1;
          HEAP32[$1_1 + 340 >> 2] = $7_1;
          $0_1 = 1;
          if ($43($1_1 + 328 | 0, $1_1 + 72 | 0)) {
            break label$12;
          }
          if ($2_1 | !$2_1 & $11_1 >>> 0 > 65535) {
            $0_1 = 0;
            break label$12;
          }
          if ($10_1 | $17_1) {
            $0_1 = 0;
            break label$12;
          }
          if ($6_1 | !$6_1 & $12_1 >>> 0 > 21319971) {
            $0_1 = 0;
            break label$12;
          }
          label$19: {
            if ($6_1 | ($12_1 | 0) != 21319971) {
              break label$19;
            }
            if (($7_1 | 0) == 103691 & $9_1 >>> 0 > 1979466754 | $7_1 >>> 0 > 103691) {
              $0_1 = 0;
              break label$12;
            }
            if (($9_1 | 0) != 1979466754 | ($7_1 | 0) != 103691) {
              break label$19;
            }
            $0_1 = 0;
            if (($8_1 | 0) == 893298 & $4_1 >>> 0 > 801749741 | $8_1 >>> 0 > 893298) {
              break label$12;
            }
          }
          HEAP32[$1_1 + 360 >> 2] = -1;
          HEAP32[$1_1 + 364 >> 2] = 65535;
          HEAP32[$1_1 + 352 >> 2] = -1;
          HEAP32[$1_1 + 356 >> 2] = 1048575;
          $3_1 = $6_1 + 1048575 | 0;
          $0_1 = $12_1 - 21319972 | 0;
          $3_1 = $0_1 >>> 0 < 4273647324 ? $3_1 + 1 | 0 : $3_1;
          HEAP32[$1_1 + 344 >> 2] = $0_1;
          HEAP32[$1_1 + 348 >> 2] = $3_1;
          $3_1 = $7_1 + 944884 | 0;
          $2_1 = $9_1 - 1979466755 | 0;
          $3_1 = $2_1 >>> 0 < 2315500541 ? $3_1 + 1 | 0 : $3_1;
          HEAP32[$1_1 + 336 >> 2] = $2_1;
          HEAP32[$1_1 + 340 >> 2] = $3_1;
          $6_1 = $8_1 + 155276 | 0;
          $0_1 = $4_1 - 801750719 | 0;
          $6_1 = $0_1 >>> 0 < 3493216577 ? $6_1 + 1 | 0 : $6_1;
          HEAP32[$1_1 + 328 >> 2] = $0_1;
          HEAP32[$1_1 + 332 >> 2] = $6_1;
          $0_1 = ($43($1_1 + 328 | 0, $1_1 + 72 | 0) | 0) != 0;
        }
        global$0 = $1_1 + 464 | 0;
        $3_1 = $0_1;
        break label$1;
      }
      fimport$1(1);
    }
    global$0 = $5_1 + 192 | 0;
    return $3_1 | 0;
  }
  function $25($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0;
    $10_1 = global$0 - 176 | 0;
    global$0 = $10_1;
    $7_1 = $10_1 + 8 | 0;
    $68($7_1, 65);
    $2_1 = HEAP32[172688];
    $5_1 = global$0 - 80 | 0;
    global$0 = $5_1;
    HEAP32[$5_1 + 12 >> 2] = 0;
    label$1: {
      if (!$7_1) {
        FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689748, HEAP32[$2_1 + 172 >> 2]);
        break label$1;
      }
      if ($1_1 >>> 0 >= 4) {
        FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689986, HEAP32[$2_1 + 172 >> 2]);
        break label$1;
      }
      $2_1 = $5_1 + 12 | 0;
      $38($5_1 + 48 | 0, 690981, $2_1);
      $3_1 = HEAP32[$5_1 + 12 >> 2];
      $38($5_1 + 16 | 0, 691013, $2_1);
      if (!($3_1 | HEAP32[$5_1 + 12 >> 2])) {
        $2_1 = HEAP32[$5_1 + 52 >> 2];
        $3_1 = HEAP32[$5_1 + 48 >> 2];
        HEAP8[$7_1 | 0] = $3_1;
        HEAP8[$7_1 + 1 | 0] = $3_1 >>> 8;
        HEAP8[$7_1 + 2 | 0] = $3_1 >>> 16;
        HEAP8[$7_1 + 3 | 0] = $3_1 >>> 24;
        HEAP8[$7_1 + 4 | 0] = $2_1;
        HEAP8[$7_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$7_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$7_1 + 7 | 0] = $2_1 >>> 24;
        $2_1 = HEAP32[$5_1 + 20 >> 2];
        $3_1 = HEAP32[$5_1 + 16 >> 2];
        HEAP8[$7_1 + 32 | 0] = $3_1;
        HEAP8[$7_1 + 33 | 0] = $3_1 >>> 8;
        HEAP8[$7_1 + 34 | 0] = $3_1 >>> 16;
        HEAP8[$7_1 + 35 | 0] = $3_1 >>> 24;
        HEAP8[$7_1 + 36 | 0] = $2_1;
        HEAP8[$7_1 + 37 | 0] = $2_1 >>> 8;
        HEAP8[$7_1 + 38 | 0] = $2_1 >>> 16;
        HEAP8[$7_1 + 39 | 0] = $2_1 >>> 24;
        HEAP8[$7_1 + 64 | 0] = $1_1;
        $3_1 = $5_1 + 48 | 0;
        $1_1 = $3_1 + 24 | 0;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $7_1 + 24 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$4_1 | 0] = $1_1;
        HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$4_1 + 4 | 0] = $2_1;
        HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
        $1_1 = $3_1 + 16 | 0;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $7_1 + 16 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$4_1 | 0] = $1_1;
        HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$4_1 + 4 | 0] = $2_1;
        HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
        $1_1 = $3_1 + 8 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $2_1 = $7_1 + 8 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$2_1 | 0] = $1_1;
        HEAP8[$2_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = $5_1 + 16 | 0;
        $1_1 = $3_1 + 8 | 0;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $7_1 + 40 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$4_1 | 0] = $1_1;
        HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$4_1 + 4 | 0] = $2_1;
        HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
        $1_1 = $3_1 + 16 | 0;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $7_1 + 48 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$4_1 | 0] = $1_1;
        HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$4_1 + 4 | 0] = $2_1;
        HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
        HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
        HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
        $1_1 = $3_1 + 24 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $2_1 = $7_1 + 56 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$2_1 | 0] = $1_1;
        HEAP8[$2_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$2_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$2_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$2_1 + 4 | 0] = $3_1;
        HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
        HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
        HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
        $3_1 = 1;
        break label$1;
      }
      $3_1 = 0;
      $68($7_1, 65);
    }
    global$0 = $5_1 + 80 | 0;
    label$5: {
      label$6: {
        if (!$3_1) {
          fimport$1(4);
          break label$6;
        }
        $1_1 = $10_1 + 136 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $10_1 + 128 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $10_1 + 120 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $10_1 + 112 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $10_1 + 104 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $10_1 + 96 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $10_1 + 88 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        HEAP32[$10_1 + 80 >> 2] = 0;
        HEAP32[$10_1 + 84 >> 2] = 0;
        $2_1 = $6();
        $12_1 = $10_1 + 80 | 0;
        $3_1 = global$0 - 640 | 0;
        global$0 = $3_1;
        $1_1 = $10_1 + 8 | 0;
        label$8: {
          label$9: {
            if (!$1_1) {
              FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689760, HEAP32[$2_1 + 172 >> 2]);
              break label$9;
            }
            if (!$12_1) {
              FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689638, HEAP32[$2_1 + 172 >> 2]);
              break label$9;
            }
            $5_1 = $1_1 + 40 | 0;
            $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
            $2_1 = $3_1 + 48 | 0;
            HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
            HEAP32[$2_1 + 4 >> 2] = $4_1;
            $5_1 = $1_1 + 48 | 0;
            $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
            $2_1 = $3_1 + 56 | 0;
            HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
            HEAP32[$2_1 + 4 >> 2] = $4_1;
            $5_1 = $1_1 + 56 | 0;
            $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
            $2_1 = $3_1 - -64 | 0;
            HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
            HEAP32[$2_1 + 4 >> 2] = $4_1;
            $2_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
            HEAP32[$3_1 + 40 >> 2] = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
            HEAP32[$3_1 + 44 >> 2] = $2_1;
            $17_1 = HEAPU8[$1_1 + 64 | 0];
            $11_1 = HEAPU8[$1_1 + 24 | 0] | HEAPU8[$1_1 + 25 | 0] << 8 | (HEAPU8[$1_1 + 26 | 0] << 16 | HEAPU8[$1_1 + 27 | 0] << 24);
            $2_1 = HEAPU8[$1_1 + 28 | 0] | HEAPU8[$1_1 + 29 | 0] << 8 | (HEAPU8[$1_1 + 30 | 0] << 16 | HEAPU8[$1_1 + 31 | 0] << 24);
            $14_1 = HEAPU8[$1_1 + 16 | 0] | HEAPU8[$1_1 + 17 | 0] << 8 | (HEAPU8[$1_1 + 18 | 0] << 16 | HEAPU8[$1_1 + 19 | 0] << 24);
            $7_1 = HEAPU8[$1_1 + 20 | 0] | HEAPU8[$1_1 + 21 | 0] << 8 | (HEAPU8[$1_1 + 22 | 0] << 16 | HEAPU8[$1_1 + 23 | 0] << 24);
            $18_1 = HEAPU8[$1_1 + 8 | 0] | HEAPU8[$1_1 + 9 | 0] << 8 | (HEAPU8[$1_1 + 10 | 0] << 16 | HEAPU8[$1_1 + 11 | 0] << 24);
            $5_1 = HEAPU8[$1_1 + 12 | 0] | HEAPU8[$1_1 + 13 | 0] << 8 | (HEAPU8[$1_1 + 14 | 0] << 16 | HEAPU8[$1_1 + 15 | 0] << 24);
            $19_1 = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
            $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
            $38($3_1 + 8 | 0, 655649, 0);
            label$12: {
              if (!($11_1 | ($14_1 | ($18_1 | $19_1)) | ($2_1 | ($7_1 | ($4_1 | $5_1))))) {
                break label$12;
              }
              if (!(HEAP32[$3_1 + 64 >> 2] | (HEAP32[$3_1 + 56 >> 2] | (HEAP32[$3_1 + 48 >> 2] | HEAP32[$3_1 + 40 >> 2])) | (HEAP32[$3_1 + 68 >> 2] | (HEAP32[$3_1 + 60 >> 2] | (HEAP32[$3_1 + 52 >> 2] | HEAP32[$3_1 + 44 >> 2]))))) {
                break label$12;
              }
              $1_1 = $3_1;
              HEAP32[$1_1 + 632 >> 2] = ($2_1 & 65535) << 16 | $11_1 >>> 16;
              HEAP32[$1_1 + 636 >> 2] = $2_1 >>> 16;
              HEAP32[$1_1 + 600 >> 2] = $19_1;
              $23_1 = $4_1 & 1048575;
              HEAP32[$1_1 + 604 >> 2] = $23_1;
              $15_1 = $11_1 << 4;
              $9_1 = $15_1 & 1044480;
              $6_1 = $9_1 | ($15_1 & 4080 | $7_1 >>> 28);
              $24_1 = $6_1;
              $21_1 = ($7_1 & 268435455) << 4 | $14_1 >>> 28;
              HEAP32[$1_1 + 624 >> 2] = $21_1;
              HEAP32[$1_1 + 628 >> 2] = $6_1;
              $15_1 = $7_1 << 24 | $14_1 >>> 8;
              $20_1 = $15_1 & 983040;
              $16_1 = $15_1 & 65280;
              $13_1 = $14_1 << 24 & -16777216 | $5_1 >>> 8;
              HEAP32[$1_1 + 616 >> 2] = $13_1;
              $22_1 = $20_1 | ($16_1 | $15_1 & 255);
              HEAP32[$1_1 + 620 >> 2] = $22_1;
              $6_1 = $5_1 << 12 | $18_1 >>> 20;
              $20_1 = $6_1 & 1044480;
              $16_1 = $6_1 & 4080;
              $1_1 = $18_1 << 12;
              $15_1 = $1_1 & -268435456;
              $9_1 = $6_1 & 15;
              $8_1 = $1_1 & 267386880;
              $8_1 = $15_1 | ($8_1 | ($1_1 & 1044480 | $4_1 >>> 20));
              HEAP32[$3_1 + 608 >> 2] = $8_1;
              $9_1 = $20_1 | ($9_1 | $16_1);
              HEAP32[$3_1 + 612 >> 2] = $9_1;
              if ($17_1 & 2) {
                if ($2_1 | !$2_1 & $11_1 >>> 0 > 65535) {
                  break label$12;
                }
                if ($24_1 | $21_1) {
                  break label$12;
                }
                if ($22_1 | !$22_1 & $13_1 >>> 0 > 21319971) {
                  break label$12;
                }
                label$14: {
                  if ($22_1 | ($13_1 | 0) != 21319971) {
                    break label$14;
                  }
                  if (($9_1 | 0) == 103691 & $8_1 >>> 0 > 1979466754 | $9_1 >>> 0 > 103691) {
                    break label$12;
                  }
                  if (($8_1 | 0) != 1979466754 | ($9_1 | 0) != 103691) {
                    break label$14;
                  }
                  if (($23_1 | 0) == 893298 & $19_1 >>> 0 > 801749741 | $23_1 >>> 0 > 893298) {
                    break label$12;
                  }
                }
                HEAP32[$3_1 + 632 >> 2] = -1;
                HEAP32[$3_1 + 636 >> 2] = 65535;
                HEAP32[$3_1 + 624 >> 2] = -1;
                HEAP32[$3_1 + 628 >> 2] = 1048575;
                $6_1 = $22_1 + 1048575 | 0;
                $1_1 = $13_1 - 21319972 | 0;
                $6_1 = $1_1 >>> 0 < 4273647324 ? $6_1 + 1 | 0 : $6_1;
                HEAP32[$3_1 + 616 >> 2] = $1_1;
                HEAP32[$3_1 + 620 >> 2] = $6_1;
                $1_1 = $9_1 + 944884 | 0;
                $8_1 = $8_1 - 1979466755 | 0;
                $1_1 = $8_1 >>> 0 < 2315500541 ? $1_1 + 1 | 0 : $1_1;
                HEAP32[$3_1 + 608 >> 2] = $8_1;
                HEAP32[$3_1 + 612 >> 2] = $1_1;
                $6_1 = $23_1 + 155276 | 0;
                $1_1 = $19_1 - 801750719 | 0;
                $6_1 = $1_1 >>> 0 < 3493216577 ? $6_1 + 1 | 0 : $6_1;
                HEAP32[$3_1 + 600 >> 2] = $1_1;
                HEAP32[$3_1 + 604 >> 2] = $6_1;
              }
              if (!$33($3_1 + 512 | 0, $3_1 + 600 | 0, $17_1 & 1)) {
                break label$12;
              }
              $9_1 = $3_1 + 512 | 0;
              $8_1 = $9_1 + 8 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $13_1 = $3_1 + 384 | 0;
              $1_1 = $13_1 + 8 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 + 16 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 + 16 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 + 24 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 + 24 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 + 32 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 + 32 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 + 48 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 + 48 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 + 56 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 + 56 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 - -64 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 - -64 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              $8_1 = $9_1 + 72 | 0;
              $6_1 = HEAP32[$8_1 + 4 >> 2];
              $1_1 = $13_1 + 72 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $6_1;
              HEAP32[$3_1 + 504 >> 2] = HEAP32[$3_1 + 592 >> 2];
              $1_1 = HEAP32[$3_1 + 516 >> 2];
              HEAP32[$3_1 + 384 >> 2] = HEAP32[$3_1 + 512 >> 2];
              HEAP32[$3_1 + 388 >> 2] = $1_1;
              $1_1 = HEAP32[$3_1 + 556 >> 2];
              HEAP32[$3_1 + 424 >> 2] = HEAP32[$3_1 + 552 >> 2];
              HEAP32[$3_1 + 428 >> 2] = $1_1;
              $1_1 = $3_1 + 472 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $3_1 + 480 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $3_1 + 488 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              $1_1 = $3_1 + 496 | 0;
              HEAP32[$1_1 >> 2] = 0;
              HEAP32[$1_1 + 4 >> 2] = 0;
              HEAP32[$3_1 + 464 >> 2] = 1;
              HEAP32[$3_1 + 468 >> 2] = 0;
              HEAP32[$3_1 + 104 >> 2] = $2_1 >>> 24;
              HEAP32[$3_1 + 108 >> 2] = 0;
              $2_1 = $2_1 << 6 | $11_1 >>> 26;
              $1_1 = $7_1;
              HEAP32[$3_1 + 96 >> 2] = $11_1 << 6 | $1_1 >>> 26;
              HEAP32[$3_1 + 100 >> 2] = $2_1 & 1073741823;
              $7_1 = $1_1 << 4 | $14_1 >>> 28;
              $2_1 = $3_1;
              $1_1 = $5_1;
              HEAP32[$2_1 + 88 >> 2] = $14_1 << 4 | $1_1 >>> 28;
              HEAP32[$2_1 + 92 >> 2] = $7_1 & 1073741823;
              HEAP32[$2_1 + 80 >> 2] = $18_1 << 2 | $4_1 >>> 30;
              HEAP32[$2_1 + 84 >> 2] = ($1_1 << 2 | $18_1 >>> 30) & 1073741823;
              HEAP32[$2_1 + 72 >> 2] = $19_1;
              HEAP32[$2_1 + 76 >> 2] = $4_1 & 1073741823;
              $15_1 = $2_1 + 72 | 0;
              $40($15_1, 690320);
              $7_1 = HEAP32[$2_1 + 104 >> 2] << 24;
              $4_1 = HEAP32[$2_1 + 100 >> 2];
              $1_1 = $4_1 >>> 6 | 0;
              $5_1 = HEAP32[$2_1 + 96 >> 2];
              HEAP32[$2_1 + 376 >> 2] = ($4_1 & 63) << 26 | $5_1 >>> 6;
              HEAP32[$2_1 + 380 >> 2] = $1_1 | $7_1;
              $5_1 = $5_1 << 26;
              $1_1 = HEAP32[$2_1 + 92 >> 2];
              $6_1 = $1_1 >>> 4 | 0;
              $4_1 = HEAP32[$2_1 + 88 >> 2];
              HEAP32[$2_1 + 368 >> 2] = ($1_1 & 15) << 28 | $4_1 >>> 4;
              HEAP32[$2_1 + 372 >> 2] = $6_1 | $5_1;
              $7_1 = $4_1 << 28;
              $4_1 = HEAP32[$2_1 + 84 >> 2];
              $1_1 = $4_1 >>> 2 | 0;
              $5_1 = HEAP32[$2_1 + 80 >> 2];
              HEAP32[$2_1 + 360 >> 2] = ($4_1 & 3) << 30 | $5_1 >>> 2;
              HEAP32[$2_1 + 364 >> 2] = $1_1 | $7_1;
              $7_1 = HEAP32[$2_1 + 76 >> 2];
              $6_1 = $5_1 << 30;
              HEAP32[$2_1 + 352 >> 2] = HEAP32[$2_1 + 72 >> 2];
              HEAP32[$2_1 + 356 >> 2] = $6_1 | $7_1;
              $9_1 = $2_1 + 320 | 0;
              $8_1 = $2_1 + 352 | 0;
              $41($9_1, $8_1, $2_1 + 8 | 0);
              $21_1 = HEAP32[$2_1 + 344 >> 2];
              $19_1 = HEAP32[$2_1 + 336 >> 2];
              $11_1 = HEAP32[$2_1 + 328 >> 2];
              $4_1 = HEAP32[$2_1 + 320 >> 2];
              $18_1 = HEAP32[$2_1 + 348 >> 2];
              $14_1 = HEAP32[$2_1 + 340 >> 2];
              $6_1 = HEAP32[$2_1 + 332 >> 2];
              $7_1 = HEAP32[$2_1 + 324 >> 2];
              $1_1 = $21_1 | ($19_1 | ($11_1 | $4_1)) | ($18_1 | ($14_1 | ($6_1 | $7_1))) ? -1 : 0;
              $16_1 = $4_1 ^ -1;
              $5_1 = $16_1 - 801750718 | 0;
              HEAP32[$2_1 + 320 >> 2] = $1_1 & $5_1;
              $4_1 = $1_1;
              $7_1 = $7_1 ^ -1;
              $1_1 = $7_1 - (($16_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
              HEAP32[$2_1 + 324 >> 2] = $4_1 & $1_1;
              $1_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
              $11_1 = $11_1 ^ -1;
              $17_1 = $1_1 + $11_1 | 0;
              $20_1 = $6_1 ^ -1;
              $6_1 = $20_1;
              $6_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
              $1_1 = $17_1 - 1354194885 | 0;
              HEAP32[$2_1 + 328 >> 2] = $1_1 & $4_1;
              $16_1 = $6_1 - (($17_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
              HEAP32[$2_1 + 332 >> 2] = $16_1 & $4_1;
              $7_1 = $19_1 ^ -1;
              $1_1 = ($6_1 | 0) == ($16_1 | 0) & $1_1 >>> 0 < $17_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
              $11_1 = $1_1 + (($6_1 | 0) == ($20_1 | 0) & $11_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 < $20_1 >>> 0) | 0;
              $14_1 = $14_1 ^ -1;
              $1_1 = $14_1 + ($1_1 >>> 0 > $11_1 >>> 0) | 0;
              $6_1 = $7_1 + $11_1 | 0;
              $1_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
              $5_1 = $6_1 - 2 | 0;
              HEAP32[$2_1 + 336 >> 2] = $5_1 & $4_1;
              $11_1 = $1_1 - ($6_1 >>> 0 < 2) | 0;
              HEAP32[$2_1 + 340 >> 2] = $11_1 & $4_1;
              $24_1 = ($1_1 | 0) == ($14_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
              $1_1 = ($1_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 > $11_1 >>> 0;
              $2_1 = $24_1 + $1_1 | 0;
              $6_1 = $1_1 >>> 0 > $2_1 >>> 0;
              $1_1 = $2_1 - $21_1 | 0;
              HEAP32[$3_1 + 344 >> 2] = $1_1 - 2 & $4_1;
              HEAP32[$3_1 + 348 >> 2] = ($6_1 - (($2_1 >>> 0 < $21_1 >>> 0) + $18_1 | 0) | 0) - ($1_1 >>> 0 < 2) & $4_1;
              $2_1 = $3_1 + 288 | 0;
              $41($2_1, $8_1, $3_1 + 40 | 0);
              $1_1 = $3_1 + 160 | 0;
              $42($1_1, $13_1, $2_1, $9_1);
              $56($15_1, $1_1);
              if (HEAP32[$3_1 + 280 >> 2]) {
                break label$12;
              }
              $35($12_1, $3_1 + 72 | 0);
              $1_1 = 1;
              break label$8;
            }
            HEAP8[$12_1 | 0] = 0;
            HEAP8[$12_1 + 1 | 0] = 0;
            HEAP8[$12_1 + 2 | 0] = 0;
            HEAP8[$12_1 + 3 | 0] = 0;
            HEAP8[$12_1 + 4 | 0] = 0;
            HEAP8[$12_1 + 5 | 0] = 0;
            HEAP8[$12_1 + 6 | 0] = 0;
            HEAP8[$12_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 56 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 48 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 40 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 32 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 24 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 16 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
            $1_1 = $12_1 + 8 | 0;
            HEAP8[$1_1 | 0] = 0;
            HEAP8[$1_1 + 1 | 0] = 0;
            HEAP8[$1_1 + 2 | 0] = 0;
            HEAP8[$1_1 + 3 | 0] = 0;
            HEAP8[$1_1 + 4 | 0] = 0;
            HEAP8[$1_1 + 5 | 0] = 0;
            HEAP8[$1_1 + 6 | 0] = 0;
            HEAP8[$1_1 + 7 | 0] = 0;
          }
          $1_1 = 0;
        }
        global$0 = $3_1 + 640 | 0;
        if (!$1_1) {
          break label$6;
        }
        HEAP32[$10_1 + 144 >> 2] = $0_1;
        $0_1 = $36(HEAP32[172688], $10_1 + 144 | 0, $10_1 + 80 | 0, ($0_1 | 0) == 33 ? 258 : 2);
        HEAP32[$10_1 + 148 >> 2] = $0_1;
        if (($0_1 | 0) != 1) {
          break label$5;
        }
        $25_1 = 1;
      }
      global$0 = $10_1 + 176 | 0;
      return $25_1 | 0;
    }
    HEAP32[$10_1 + 160 >> 2] = 0;
    $5($10_1 + 152 | 0);
    wasm2js_trap();
  }
  function $26() {
    var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0;
    $3_1 = global$0 - 192 | 0;
    global$0 = $3_1;
    $0_1 = $3_1 + 128 | 0;
    $2_1 = $0_1 + 56 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $0_1 + 48 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $0_1 + 40 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $0_1 + 32 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $0_1 + 24 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $0_1 + 16 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $0_1 + 8 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 128 >> 2] = 0;
    HEAP32[$3_1 + 132 >> 2] = 0;
    label$1: {
      if (($57(HEAP32[172688], $0_1, 690885) | 0) == 1) {
        $2_1 = $3_1 + 128 | 0;
        $0_1 = $2_1 + 15 | 0;
        $6_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $4_1 = $3_1 - -64 | 0;
        $5_1 = $4_1 + 8 | 0;
        HEAP32[$5_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$5_1 + 4 >> 2] = $6_1;
        $0_1 = $2_1 + 23 | 0;
        $1_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $6_1 = $4_1 + 16 | 0;
        HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$6_1 + 4 >> 2] = $1_1;
        $0_1 = $2_1 + 31 | 0;
        $9_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $1_1 = $4_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$1_1 + 4 >> 2] = $9_1;
        $0_1 = $2_1 + 39 | 0;
        $7_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $9_1 = $4_1 + 32 | 0;
        HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$9_1 + 4 >> 2] = $7_1;
        $0_1 = $2_1 + 47 | 0;
        $11_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $7_1 = $4_1 + 40 | 0;
        HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$7_1 + 4 >> 2] = $11_1;
        $0_1 = $2_1 + 55 | 0;
        $10_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
        $11_1 = $4_1 + 48 | 0;
        HEAP32[$11_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
        HEAP32[$11_1 + 4 >> 2] = $10_1;
        $0_1 = $4_1 + 56 | 0;
        HEAP8[$0_1 | 0] = HEAPU8[$2_1 + 63 | 0];
        HEAP8[$3_1 + 2 | 0] = HEAPU8[$3_1 + 130 | 0];
        HEAP16[$3_1 >> 1] = HEAPU16[$3_1 + 128 >> 1];
        $2_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
        HEAP32[$3_1 + 64 >> 2] = HEAPU8[$3_1 + 135 | 0] | HEAPU8[$3_1 + 136 | 0] << 8 | (HEAPU8[$3_1 + 137 | 0] << 16 | HEAPU8[$3_1 + 138 | 0] << 24);
        HEAP32[$3_1 + 68 >> 2] = $2_1;
        $2_1 = HEAPU8[$3_1 + 131 | 0] | HEAPU8[$3_1 + 132 | 0] << 8 | (HEAPU8[$3_1 + 133 | 0] << 16 | HEAPU8[$3_1 + 134 | 0] << 24);
        HEAP8[$3_1 + 63 | 0] = HEAPU8[$0_1 | 0];
        $4_1 = HEAP32[$11_1 + 4 >> 2];
        $0_1 = $3_1 + 55 | 0;
        $11_1 = HEAP32[$11_1 >> 2];
        HEAP8[$0_1 | 0] = $11_1;
        HEAP8[$0_1 + 1 | 0] = $11_1 >>> 8;
        HEAP8[$0_1 + 2 | 0] = $11_1 >>> 16;
        HEAP8[$0_1 + 3 | 0] = $11_1 >>> 24;
        HEAP8[$0_1 + 4 | 0] = $4_1;
        HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$7_1 + 4 >> 2];
        $0_1 = $3_1 + 47 | 0;
        $7_1 = HEAP32[$7_1 >> 2];
        HEAP8[$0_1 | 0] = $7_1;
        HEAP8[$0_1 + 1 | 0] = $7_1 >>> 8;
        HEAP8[$0_1 + 2 | 0] = $7_1 >>> 16;
        HEAP8[$0_1 + 3 | 0] = $7_1 >>> 24;
        HEAP8[$0_1 + 4 | 0] = $4_1;
        HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$9_1 + 4 >> 2];
        $0_1 = $3_1 + 39 | 0;
        $9_1 = HEAP32[$9_1 >> 2];
        HEAP8[$0_1 | 0] = $9_1;
        HEAP8[$0_1 + 1 | 0] = $9_1 >>> 8;
        HEAP8[$0_1 + 2 | 0] = $9_1 >>> 16;
        HEAP8[$0_1 + 3 | 0] = $9_1 >>> 24;
        HEAP8[$0_1 + 4 | 0] = $4_1;
        HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$1_1 + 4 >> 2];
        $0_1 = $3_1 + 31 | 0;
        $1_1 = HEAP32[$1_1 >> 2];
        HEAP8[$0_1 | 0] = $1_1;
        HEAP8[$0_1 + 1 | 0] = $1_1 >>> 8;
        HEAP8[$0_1 + 2 | 0] = $1_1 >>> 16;
        HEAP8[$0_1 + 3 | 0] = $1_1 >>> 24;
        HEAP8[$0_1 + 4 | 0] = $4_1;
        HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$6_1 + 4 >> 2];
        $0_1 = $3_1 + 23 | 0;
        $6_1 = HEAP32[$6_1 >> 2];
        HEAP8[$0_1 | 0] = $6_1;
        HEAP8[$0_1 + 1 | 0] = $6_1 >>> 8;
        HEAP8[$0_1 + 2 | 0] = $6_1 >>> 16;
        HEAP8[$0_1 + 3 | 0] = $6_1 >>> 24;
        HEAP8[$0_1 + 4 | 0] = $4_1;
        HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $0_1 = $3_1 + 15 | 0;
        $5_1 = HEAP32[$5_1 >> 2];
        HEAP8[$0_1 | 0] = $5_1;
        HEAP8[$0_1 + 1 | 0] = $5_1 >>> 8;
        HEAP8[$0_1 + 2 | 0] = $5_1 >>> 16;
        HEAP8[$0_1 + 3 | 0] = $5_1 >>> 24;
        HEAP8[$0_1 + 4 | 0] = $4_1;
        HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
        HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
        HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
        HEAP8[$3_1 + 3 | 0] = $2_1;
        HEAP8[$3_1 + 4 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 5 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 6 | 0] = $2_1 >>> 24;
        $0_1 = HEAP32[$3_1 + 68 >> 2];
        $2_1 = HEAP32[$3_1 + 64 >> 2];
        HEAP8[$3_1 + 7 | 0] = $2_1;
        HEAP8[$3_1 + 8 | 0] = $2_1 >>> 8;
        HEAP8[$3_1 + 9 | 0] = $2_1 >>> 16;
        HEAP8[$3_1 + 10 | 0] = $2_1 >>> 24;
        HEAP8[$3_1 + 11 | 0] = $0_1;
        HEAP8[$3_1 + 12 | 0] = $0_1 >>> 8;
        HEAP8[$3_1 + 13 | 0] = $0_1 >>> 16;
        HEAP8[$3_1 + 14 | 0] = $0_1 >>> 24;
        $16_1 = $6();
        $1_1 = global$0 - 496 | 0;
        global$0 = $1_1;
        label$3: {
          if (!$3_1) {
            FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689638, HEAP32[$16_1 + 172 >> 2]);
            break label$3;
          }
          if (!$32($1_1 + 136 | 0, 690981)) {
            break label$3;
          }
          $38($1_1 + 464 | 0, 691013, $1_1 + 12 | 0);
          if (HEAP32[$1_1 + 12 >> 2]) {
            break label$3;
          }
          $2_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
          $6_1 = $2_1;
          $10_1 = $2_1 >>> 20 | 0;
          $5_1 = $10_1;
          $0_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
          $12_1 = $0_1;
          $22_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
          $2_1 = $22_1;
          $0_1 = $0_1 << 12 | $2_1 >>> 20;
          $17_1 = $2_1 << 12;
          $23_1 = $5_1 | $17_1 & -4096;
          $11_1 = $0_1;
          $24_1 = $0_1 & 1048575;
          $25_1 = $12_1 >>> 8 | 0;
          $9_1 = $25_1;
          $0_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
          $7_1 = $0_1;
          $20_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
          $2_1 = $20_1;
          $0_1 = $0_1 << 24 | $2_1 >>> 8;
          $26_1 = $9_1 | $2_1 << 24 & -16777216;
          $2_1 = $0_1;
          $27_1 = $0_1 & 1048575;
          $5_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
          $9_1 = $5_1;
          $14_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
          $18_1 = ($5_1 & 65535) << 16 | $14_1 >>> 16;
          $15_1 = $5_1 >>> 16 | 0;
          $5_1 = $7_1 >>> 28 | 0;
          $8_1 = ($7_1 & 268435455) << 4 | $20_1 >>> 28;
          $19_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
          $4_1 = $14_1;
          $0_1 = $4_1 << 4;
          $28_1 = $5_1 | $0_1 & 1048560;
          $13_1 = $6_1 & 1048575;
          if (!($8_1 | ($26_1 | ($18_1 | ($19_1 | $23_1))) | ($28_1 | ($27_1 | ($15_1 | ($13_1 | $24_1)))))) {
            FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](690116, HEAP32[$16_1 + 172 >> 2]);
            break label$3;
          }
          $14_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
          $16_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
          $21_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
          $30_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
          $31_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
          $32_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
          $33_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
          $29_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
          HEAP8[$1_1 + 34 | 0] = $25_1;
          HEAP8[$1_1 + 21 | 0] = $18_1;
          HEAP8[$1_1 + 38 | 0] = ($11_1 & 1048575) << 12 | $17_1 >>> 20;
          HEAP8[$1_1 + 37 | 0] = ($11_1 & 268435455) << 4 | $17_1 >>> 28;
          HEAP8[$1_1 + 36 | 0] = $11_1 >>> 4;
          HEAP8[$1_1 + 35 | 0] = $11_1 >>> 12;
          HEAP8[$1_1 + 30 | 0] = $2_1;
          HEAP8[$1_1 + 29 | 0] = $2_1 >>> 8;
          HEAP8[$1_1 + 22 | 0] = $0_1 >>> 12;
          HEAP8[$1_1 + 47 | 0] = $19_1;
          HEAP8[$1_1 + 46 | 0] = ($6_1 & 255) << 24 | $19_1 >>> 8;
          HEAP8[$1_1 + 45 | 0] = ($6_1 & 65535) << 16 | $19_1 >>> 16;
          HEAP8[$1_1 + 44 | 0] = ($6_1 & 16777215) << 8 | $19_1 >>> 24;
          HEAP8[$1_1 + 43 | 0] = $6_1;
          HEAP8[$1_1 + 42 | 0] = $6_1 >>> 8;
          HEAP8[$1_1 + 41 | 0] = $10_1 << 4 | $13_1 >>> 16;
          HEAP8[$1_1 + 40 | 0] = $6_1 >>> 24;
          HEAP8[$1_1 + 39 | 0] = $22_1;
          HEAP8[$1_1 + 33 | 0] = $12_1 >>> 16;
          HEAP8[$1_1 + 32 | 0] = $12_1 >>> 24;
          HEAP8[$1_1 + 31 | 0] = $20_1;
          $0_1 = $7_1;
          HEAP8[$1_1 + 27 | 0] = $0_1;
          HEAP8[$1_1 + 26 | 0] = $0_1 >>> 8;
          HEAP8[$1_1 + 25 | 0] = $0_1 >>> 16;
          HEAP8[$1_1 + 24 | 0] = $0_1 >>> 24;
          HEAP8[$1_1 + 23 | 0] = $4_1;
          $0_1 = $9_1;
          HEAP8[$1_1 + 20 | 0] = ($0_1 & 16777215) << 8 | $4_1 >>> 24;
          HEAP8[$1_1 + 19 | 0] = $0_1;
          HEAP8[$1_1 + 18 | 0] = $0_1 >>> 8;
          HEAP8[$1_1 + 17 | 0] = $0_1 >>> 16;
          HEAP8[$1_1 + 16 | 0] = $0_1 >>> 24;
          HEAP8[$1_1 + 28 | 0] = $2_1 >>> 16 & 15 | $8_1 << 4;
          HEAP32[$1_1 + 400 >> 2] = 64;
          HEAP32[$1_1 + 404 >> 2] = 0;
          HEAP32[$1_1 + 328 >> 2] = -1862921884;
          HEAP32[$1_1 + 332 >> 2] = 870954602;
          HEAP32[$1_1 + 320 >> 2] = -1748470448;
          HEAP32[$1_1 + 324 >> 2] = 3983205;
          HEAP32[$1_1 + 312 >> 2] = 292000018;
          HEAP32[$1_1 + 316 >> 2] = -782074353;
          HEAP32[$1_1 + 304 >> 2] = -1662207471;
          HEAP32[$1_1 + 308 >> 2] = 596792193;
          $6_1 = $1_1 + 304 | 0;
          $29($6_1, 690981, 32);
          $29($6_1, $1_1 + 16 | 0, 32);
          $29($6_1, 655649, 32);
          $7_1 = $1_1 + 48 | 0;
          $30($6_1, $7_1);
          $17_1 = $1_1 + 432 | 0;
          $38($17_1, $7_1, 0);
          $2_1 = $16_1;
          $0_1 = $2_1 >>> 16 | 0;
          $9_1 = $1_1 + 176 | 0;
          $4_1 = $9_1 + 72 | 0;
          HEAP32[$4_1 >> 2] = ($2_1 & 65535) << 16 | $14_1 >>> 16;
          HEAP32[$4_1 + 4 >> 2] = $0_1;
          $5_1 = $14_1 << 4 & 1048560;
          $2_1 = $30_1;
          $0_1 = $2_1 >>> 28 | 0;
          $4_1 = $9_1 - -64 | 0;
          HEAP32[$4_1 >> 2] = ($2_1 & 268435455) << 4 | $21_1 >>> 28;
          HEAP32[$4_1 + 4 >> 2] = $0_1 | $5_1;
          $0_1 = $2_1 << 24 | $21_1 >>> 8;
          $4_1 = $9_1 + 56 | 0;
          $2_1 = $32_1;
          HEAP32[$4_1 >> 2] = $21_1 << 24 & -16777216 | $2_1 >>> 8;
          HEAP32[$4_1 + 4 >> 2] = $0_1 & 1048575;
          $0_1 = $2_1 << 12;
          $2_1 = $31_1;
          $5_1 = ($0_1 | $2_1 >>> 20) & 1048575;
          $4_1 = $9_1 + 48 | 0;
          HEAP32[$4_1 >> 2] = $2_1 << 12 & -4096 | $29_1 >>> 20;
          HEAP32[$4_1 + 4 >> 2] = $5_1;
          HEAP32[$1_1 + 296 >> 2] = 0;
          HEAP32[$1_1 + 256 >> 2] = 1;
          HEAP32[$1_1 + 260 >> 2] = 0;
          HEAP32[$1_1 + 216 >> 2] = $33_1;
          HEAP32[$1_1 + 220 >> 2] = $29_1 & 1048575;
          HEAP32[$1_1 + 208 >> 2] = $18_1;
          HEAP32[$1_1 + 212 >> 2] = $15_1;
          HEAP32[$1_1 + 200 >> 2] = $8_1;
          HEAP32[$1_1 + 204 >> 2] = $28_1;
          HEAP32[$1_1 + 192 >> 2] = $26_1;
          HEAP32[$1_1 + 196 >> 2] = $27_1;
          HEAP32[$1_1 + 184 >> 2] = $23_1;
          HEAP32[$1_1 + 188 >> 2] = $24_1;
          HEAP32[$1_1 + 176 >> 2] = $19_1;
          HEAP32[$1_1 + 180 >> 2] = $13_1;
          $11_1 = HEAP32[$1_1 + 456 >> 2];
          $13_1 = HEAP32[$1_1 + 448 >> 2];
          $12_1 = HEAP32[$1_1 + 440 >> 2];
          $0_1 = HEAP32[$1_1 + 432 >> 2];
          $18_1 = HEAP32[$1_1 + 460 >> 2];
          $14_1 = HEAP32[$1_1 + 452 >> 2];
          $8_1 = HEAP32[$1_1 + 444 >> 2];
          $2_1 = HEAP32[$1_1 + 436 >> 2];
          $4_1 = $11_1 | ($13_1 | ($12_1 | $0_1)) | ($18_1 | ($14_1 | ($8_1 | $2_1))) ? -1 : 0;
          $0_1 = $0_1 ^ -1;
          $15_1 = $0_1 - 801750718 | 0;
          HEAP32[$1_1 + 432 >> 2] = $4_1 & $15_1;
          $5_1 = $2_1 ^ -1;
          $10_1 = $5_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
          HEAP32[$1_1 + 436 >> 2] = $10_1 & $4_1;
          $0_1 = ($5_1 | 0) == ($10_1 | 0) & $0_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
          $10_1 = $12_1 ^ -1;
          $5_1 = $0_1 + $10_1 | 0;
          $12_1 = $8_1 ^ -1;
          $0_1 = $12_1;
          $15_1 = $5_1 - 1354194885 | 0;
          HEAP32[$1_1 + 440 >> 2] = $15_1 & $4_1;
          $0_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $8_1 = $0_1 - (($5_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
          HEAP32[$1_1 + 444 >> 2] = $8_1 & $4_1;
          $16_1 = $13_1 ^ -1;
          $2_1 = ($0_1 | 0) == ($12_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
          $10_1 = ($0_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $15_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
          $5_1 = $2_1 + $10_1 | 0;
          $13_1 = $14_1 ^ -1;
          $0_1 = $13_1 + ($5_1 >>> 0 < $10_1 >>> 0) | 0;
          $2_1 = $5_1;
          $5_1 = $5_1 + $16_1 | 0;
          $0_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $12_1 = $5_1 - 2 | 0;
          HEAP32[$1_1 + 448 >> 2] = $12_1 & $4_1;
          $10_1 = $0_1 - ($5_1 >>> 0 < 2) | 0;
          HEAP32[$1_1 + 452 >> 2] = $10_1 & $4_1;
          $2_1 = ($0_1 | 0) == ($13_1 | 0) & $5_1 >>> 0 < $16_1 >>> 0 | $0_1 >>> 0 < $13_1 >>> 0;
          $5_1 = ($0_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $0_1 >>> 0 > $10_1 >>> 0;
          $2_1 = $2_1 + $5_1 | 0;
          $0_1 = $2_1 >>> 0 < $5_1 >>> 0;
          $5_1 = $2_1 - $11_1 | 0;
          HEAP32[$1_1 + 456 >> 2] = $5_1 - 2 & $4_1;
          HEAP32[$1_1 + 460 >> 2] = ($0_1 - (($2_1 >>> 0 < $11_1 >>> 0) + $18_1 | 0) | 0) - ($5_1 >>> 0 < 2) & $4_1;
          $0_1 = $1_1 + 288 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $1_1 + 280 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $1_1 + 272 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $0_1 = $1_1 + 264 | 0;
          HEAP32[$0_1 >> 2] = 0;
          HEAP32[$0_1 + 4 >> 2] = 0;
          $42($6_1, $9_1, $17_1, $1_1 + 464 | 0);
          $56($7_1, $6_1);
          if (HEAP32[$1_1 + 128 >> 2]) {
            break label$3;
          }
          $5_1 = HEAP32[$1_1 + 92 >> 2];
          $4_1 = $1_1 + 48 | 0;
          $0_1 = $4_1 + 72 | 0;
          $8_1 = HEAP32[$0_1 >> 2];
          $6_1 = HEAP32[$0_1 + 4 >> 2];
          $13_1 = $6_1;
          $0_1 = HEAP32[$1_1 + 88 >> 2];
          $2_1 = __wasm_i64_mul($6_1 >>> 16 | 0, 0, 977, 1);
          $9_1 = $0_1 + $2_1 | 0;
          $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
          $7_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $4_1 + 48 | 0;
          $5_1 = HEAP32[$0_1 >> 2];
          $0_1 = HEAP32[$0_1 + 4 >> 2];
          $2_1 = $7_1 >>> 20 | 0;
          $6_1 = $2_1;
          $2_1 = $2_1 + $5_1 | 0;
          $6_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $11_1 = $6_1 & 1048575;
          $0_1 = $4_1 - -64 | 0;
          $10_1 = HEAP32[$0_1 >> 2];
          $14_1 = HEAP32[$0_1 + 4 >> 2];
          $0_1 = $4_1 + 56 | 0;
          $5_1 = HEAP32[$0_1 >> 2];
          $0_1 = HEAP32[$0_1 + 4 >> 2];
          $4_1 = $6_1 >>> 20 | 0;
          $5_1 = $4_1 + $5_1 | 0;
          $12_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $14_1;
          $4_1 = $12_1 >>> 20 | 0;
          $14_1 = $4_1;
          $4_1 = $4_1 + $10_1 | 0;
          $0_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $10_1 = $0_1 & 1048575;
          $12_1 = $12_1 & 1048575;
          $14_1 = ($2_1 & $5_1 & $4_1) == -1 & ($6_1 & $12_1 & $0_1) == 1048575;
          $6_1 = $0_1;
          $0_1 = $13_1 & 65535;
          $6_1 = $6_1 >>> 20 | 0;
          $8_1 = $6_1 + $8_1 | 0;
          $6_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $7_1 & 1048575;
          $13_1 = $0_1;
          $7_1 = $8_1;
          if ($14_1 & (($7_1 | 0) == -1 & ($6_1 | 0) == 65535) & (($0_1 | 0) == 1048574 & $9_1 >>> 0 > 4294966318 | $0_1 >>> 0 > 1048574) | $6_1 >>> 16) {
            $0_1 = $13_1 + 1 | 0;
            $9_1 = $9_1 + 977 | 0;
            $0_1 = $9_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
            $13_1 = $0_1 & 1048575;
            $8_1 = $0_1;
            $0_1 = $11_1;
            $8_1 = $8_1 >>> 20 | 0;
            $2_1 = $2_1 + $8_1 | 0;
            $0_1 = $8_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $11_1 = $0_1 & 1048575;
            $8_1 = $0_1;
            $0_1 = $12_1;
            $8_1 = $8_1 >>> 20 | 0;
            $5_1 = $5_1 + $8_1 | 0;
            $0_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $12_1 = $0_1 & 1048575;
            $8_1 = $0_1;
            $0_1 = $10_1;
            $8_1 = $8_1 >>> 20 | 0;
            $4_1 = $4_1 + $8_1 | 0;
            $0_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
            $10_1 = $0_1 & 1048575;
            $8_1 = $0_1;
            $0_1 = $6_1;
            $6_1 = $7_1;
            $7_1 = ($8_1 >>> 20 | 0) + $7_1 | 0;
            $6_1 = ($6_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
          }
          HEAP32[$1_1 + 120 >> 2] = $7_1;
          HEAP32[$1_1 + 124 >> 2] = $6_1;
          HEAP32[$1_1 + 112 >> 2] = $4_1;
          HEAP32[$1_1 + 116 >> 2] = $10_1;
          HEAP32[$1_1 + 104 >> 2] = $5_1;
          HEAP32[$1_1 + 108 >> 2] = $12_1;
          HEAP32[$1_1 + 96 >> 2] = $2_1;
          HEAP32[$1_1 + 100 >> 2] = $11_1;
          HEAP32[$1_1 + 88 >> 2] = $9_1;
          HEAP32[$1_1 + 92 >> 2] = $13_1;
          if ($9_1 & 1) {
            break label$3;
          }
          $0_1 = HEAP32[$1_1 + 48 >> 2];
          $2_1 = HEAP32[$1_1 + 136 >> 2];
          $4_1 = $0_1 - $2_1 | 0;
          $6_1 = HEAP32[$1_1 + 52 >> 2] - (HEAP32[$1_1 + 140 >> 2] + ($0_1 >>> 0 < $2_1 >>> 0) | 0) | 0;
          $0_1 = HEAP32[$1_1 + 80 >> 2];
          $5_1 = HEAP32[$1_1 + 168 >> 2];
          $2_1 = ($0_1 - $5_1 | 0) - 4 | 0;
          $0_1 = (HEAP32[$1_1 + 84 >> 2] - (HEAP32[$1_1 + 172 >> 2] + ($0_1 >>> 0 < $5_1 >>> 0) | 0) | 0) + 262143 | 0;
          $5_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
          $9_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
          $4_1 = $9_1 + $4_1 | 0;
          $0_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
          $0_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194299 | 0;
          $4_1 = $4_1 - 3908 | 0;
          $0_1 = $4_1 >>> 0 < 4294963388 ? $0_1 + 1 | 0 : $0_1;
          $6_1 = $0_1 & 1048575;
          $13_1 = $6_1;
          $12_1 = $4_1 ^ 976;
          $14_1 = $6_1 ^ 1;
          if ((($12_1 | 0) != -1 | ($14_1 | 0) != 1048575) & ($4_1 | $6_1) != 0) {
            break label$3;
          }
          $10_1 = $2_1;
          $18_1 = $5_1 & 65535;
          $2_1 = HEAP32[$1_1 + 72 >> 2];
          $5_1 = HEAP32[$1_1 + 160 >> 2];
          $11_1 = $2_1 - $5_1 | 0;
          $8_1 = HEAP32[$1_1 + 76 >> 2] - (HEAP32[$1_1 + 164 >> 2] + ($2_1 >>> 0 < $5_1 >>> 0) | 0) | 0;
          $2_1 = HEAP32[$1_1 + 64 >> 2];
          $5_1 = HEAP32[$1_1 + 152 >> 2];
          $9_1 = $2_1 - $5_1 | 0;
          $7_1 = HEAP32[$1_1 + 68 >> 2] - (HEAP32[$1_1 + 156 >> 2] + ($2_1 >>> 0 < $5_1 >>> 0) | 0) | 0;
          $2_1 = $0_1 >>> 20 | 0;
          $17_1 = HEAP32[$1_1 + 144 >> 2];
          $15_1 = $2_1 - $17_1 | 0;
          $5_1 = $15_1 + HEAP32[$1_1 + 56 >> 2] | 0;
          $0_1 = HEAP32[$1_1 + 60 >> 2] - (HEAP32[$1_1 + 148 >> 2] + ($2_1 >>> 0 < $17_1 >>> 0) | 0) | 0;
          $0_1 = ($5_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
          $2_1 = $5_1 - 4 | 0;
          $5_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $7_1;
          $6_1 = $5_1 >>> 20 | 0;
          $7_1 = $6_1;
          $6_1 = $6_1 + $9_1 | 0;
          $0_1 = ($7_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
          $6_1 = $6_1 - 4 | 0;
          $9_1 = $6_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $8_1;
          $7_1 = $9_1 >>> 20 | 0;
          $8_1 = $7_1;
          $7_1 = $7_1 + $11_1 | 0;
          $0_1 = ($8_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
          $7_1 = $7_1 - 4 | 0;
          $11_1 = $7_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
          $0_1 = $18_1;
          $8_1 = $11_1 >>> 20 | 0;
          $10_1 = $8_1 + $10_1 | 0;
          $0_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
          if (($2_1 & $12_1 & $6_1 & $7_1 & $10_1) == -1) {
            $8_1 = ($5_1 & $14_1 & $9_1 & $11_1 & ($0_1 ^ 983040)) == 1048575;
          } else {
            $8_1 = 0;
          }
          if ($8_1) {
            $2_1 = 0;
            $0_1 = 0;
          } else {
            $2_1 = $7_1 | ($6_1 | ($2_1 | $4_1)) | $10_1;
            $0_1 = $11_1 & 1048575 | ($9_1 & 1048575 | ($5_1 & 1048575 | $13_1)) | $0_1;
          }
          $34_1 = !($0_1 | $2_1);
        }
        global$0 = $1_1 + 496 | 0;
        break label$1;
      }
      fimport$1(1);
    }
    global$0 = $3_1 + 192 | 0;
    return $34_1 | 0;
  }
  function $27($0_1, $1_1, $2_1, $3_1, $4_1) {
    var $5_1 = 0;
    label$1: {
      label$2: {
        if (($2_1 | 0) != 1114112) {
          $5_1 = 1;
          if (FUNCTION_TABLE[HEAP32[$1_1 + 16 >> 2]]($0_1, $2_1) | 0) {
            break label$2;
          }
        }
        if ($3_1) {
          break label$1;
        }
        $5_1 = 0;
      }
      return $5_1;
    }
    return FUNCTION_TABLE[HEAP32[$1_1 + 12 >> 2]]($0_1, $3_1, $4_1) | 0;
  }
  function $28($0_1, $1_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    var $2_1 = 0;
    if (HEAPU8[$0_1 | 0]) {
      $1_1 = $0_1 + 1 | 0;
      $0_1 = 0;
      while (1) {
        $2_1 = $0_1 + $1_1 | 0;
        $0_1 = $0_1 + 1 | 0;
        if (HEAPU8[$2_1 | 0]) {
          continue;
        }
        break;
      }
      ;
    }
    wasm2js_trap();
  }
  function $29($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0, $65_1 = 0, $66_1 = 0, $67_1 = 0, $68_1 = 0, $69_1 = 0, $70_1 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
    $3_1 = HEAP32[$0_1 + 100 >> 2];
    $4_1 = HEAP32[$0_1 + 96 >> 2];
    $7_1 = $4_1 + $2_1 | 0;
    $3_1 = $7_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$0_1 + 96 >> 2] = $7_1;
    HEAP32[$0_1 + 100 >> 2] = $3_1;
    $3_1 = $4_1 & 63;
    $61_1 = 64 - $3_1 | 0;
    if ($61_1 >>> 0 <= $2_1 >>> 0) {
      $74 = $0_1 + 32 | 0;
      while (1) {
        $70($3_1 + $74 | 0, $1_1, $61_1);
        $4_1 = HEAPU8[$0_1 + 67 | 0];
        $3_1 = HEAPU8[$0_1 + 65 | 0] << 16 | HEAPU8[$0_1 + 64 | 0] << 24;
        $38_1 = $4_1 | ($3_1 | HEAPU8[$0_1 + 66 | 0] << 8);
        $9_1 = HEAPU8[$0_1 + 39 | 0];
        $7_1 = HEAPU8[$0_1 + 37 | 0] << 16 | HEAPU8[$0_1 + 36 | 0] << 24;
        $11_1 = $9_1 | ($7_1 | HEAPU8[$0_1 + 38 | 0] << 8);
        $22_1 = HEAPU8[$0_1 + 59 | 0];
        $23_1 = HEAPU8[$0_1 + 57 | 0] << 16 | HEAPU8[$0_1 + 56 | 0] << 24;
        $20_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 58 | 0] << 8);
        $6_1 = HEAPU8[$0_1 + 51 | 0];
        $17_1 = HEAPU8[$0_1 + 49 | 0] << 16 | HEAPU8[$0_1 + 48 | 0] << 24;
        $14_1 = $6_1 | ($17_1 | HEAPU8[$0_1 + 50 | 0] << 8);
        $12_1 = HEAPU8[$0_1 + 43 | 0];
        $10_1 = HEAPU8[$0_1 + 41 | 0] << 16 | HEAPU8[$0_1 + 40 | 0] << 24;
        $13_1 = $12_1 | ($10_1 | HEAPU8[$0_1 + 42 | 0] << 8);
        $59_1 = ($4_1 << 25 | $38_1 >>> 7) ^ ($38_1 << 14 | $3_1 >>> 18) ^ $38_1 >>> 3;
        $15_1 = HEAPU8[$0_1 + 63 | 0];
        $4_1 = HEAPU8[$0_1 + 61 | 0] << 16 | HEAPU8[$0_1 + 60 | 0] << 24;
        $21_1 = $15_1 | ($4_1 | HEAPU8[$0_1 + 62 | 0] << 8);
        $19_1 = HEAPU8[$0_1 + 71 | 0];
        $16_1 = HEAPU8[$0_1 + 69 | 0] << 16 | HEAPU8[$0_1 + 68 | 0] << 24;
        $43_1 = $19_1 | ($16_1 | HEAPU8[$0_1 + 70 | 0] << 8);
        $3_1 = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
        $52_1 = $3_1 << 8 & 16711680 | $3_1 << 24 | ($3_1 >>> 8 & 65280 | $3_1 >>> 24);
        $8_1 = $43_1 + ($52_1 + (($9_1 << 25 | $11_1 >>> 7) ^ ($11_1 << 14 | $7_1 >>> 18) ^ $11_1 >>> 3) | 0) | 0;
        $7_1 = HEAPU8[$0_1 + 89 | 0] << 16 | HEAPU8[$0_1 + 88 | 0] << 24;
        $3_1 = $7_1 | HEAPU8[$0_1 + 90 | 0] << 8;
        $24_1 = HEAPU8[$0_1 + 91 | 0];
        $26_1 = $3_1 | $24_1;
        $5_1 = $8_1 + (($26_1 << 15 | $7_1 >>> 17) ^ (($26_1 << 13 | $7_1 >>> 19) ^ $3_1 >>> 10)) | 0;
        $53_1 = ($22_1 << 25 | $20_1 >>> 7) ^ ($20_1 << 14 | $23_1 >>> 18) ^ $20_1 >>> 3;
        $22_1 = HEAPU8[$0_1 + 55 | 0];
        $23_1 = HEAPU8[$0_1 + 53 | 0] << 16 | HEAPU8[$0_1 + 52 | 0] << 24;
        $18_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 54 | 0] << 8);
        $33_1 = HEAPU8[$0_1 + 83 | 0];
        $28_1 = HEAPU8[$0_1 + 81 | 0] << 16 | HEAPU8[$0_1 + 80 | 0] << 24;
        $44_1 = $33_1 | ($28_1 | HEAPU8[$0_1 + 82 | 0] << 8);
        $8_1 = ($6_1 << 25 | $14_1 >>> 7) ^ ($14_1 << 14 | $17_1 >>> 18) ^ $14_1 >>> 3;
        $25_1 = HEAPU8[$0_1 + 47 | 0];
        $17_1 = HEAPU8[$0_1 + 45 | 0] << 16 | HEAPU8[$0_1 + 44 | 0] << 24;
        $54_1 = $25_1 | ($17_1 | HEAPU8[$0_1 + 46 | 0] << 8);
        $34_1 = HEAPU8[$0_1 + 75 | 0];
        $35_1 = HEAPU8[$0_1 + 73 | 0] << 16 | HEAPU8[$0_1 + 72 | 0] << 24;
        $45_1 = $34_1 | ($35_1 | HEAPU8[$0_1 + 74 | 0] << 8);
        $36_1 = HEAPU8[$0_1 + 95 | 0];
        $9_1 = HEAPU8[$0_1 + 93 | 0] << 16 | HEAPU8[$0_1 + 92 | 0] << 24;
        $3_1 = $9_1 | HEAPU8[$0_1 + 94 | 0] << 8;
        $27_1 = $36_1 | $3_1;
        $6_1 = ($45_1 + ((($12_1 << 25 | $13_1 >>> 7) ^ ($13_1 << 14 | $10_1 >>> 18) ^ $13_1 >>> 3) + $11_1 | 0) | 0) + (($27_1 << 15 | $9_1 >>> 17) ^ (($27_1 << 13 | $9_1 >>> 19) ^ $3_1 >>> 10)) | 0;
        $10_1 = ($44_1 + ($8_1 + $54_1 | 0) | 0) + (__wasm_rotl_i32($6_1, 15) ^ __wasm_rotl_i32($6_1, 13) ^ $6_1 >>> 10) | 0;
        $12_1 = (($53_1 + $18_1 | 0) + $26_1 | 0) + (__wasm_rotl_i32($10_1, 15) ^ __wasm_rotl_i32($10_1, 13) ^ $10_1 >>> 10) | 0;
        $3_1 = (($59_1 + $21_1 | 0) + $5_1 | 0) + (__wasm_rotl_i32($12_1, 15) ^ __wasm_rotl_i32($12_1, 13) ^ $12_1 >>> 10) | 0;
        $69_1 = ((($19_1 << 25 | $43_1 >>> 7) ^ ($43_1 << 14 | $16_1 >>> 18) ^ $43_1 >>> 3) + $38_1 | 0) + $6_1 | 0;
        $59_1 = ((($15_1 << 25 | $21_1 >>> 7) ^ ($21_1 << 14 | $4_1 >>> 18) ^ $21_1 >>> 3) + $20_1 | 0) + $27_1 | 0;
        $53_1 = (($22_1 << 25 | $18_1 >>> 7) ^ ($18_1 << 14 | $23_1 >>> 18) ^ $18_1 >>> 3) + $14_1 | 0;
        $22_1 = HEAPU8[$0_1 + 87 | 0];
        $23_1 = HEAPU8[$0_1 + 85 | 0] << 16 | HEAPU8[$0_1 + 84 | 0] << 24;
        $60_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 86 | 0] << 8);
        $8_1 = (($25_1 << 25 | $54_1 >>> 7) ^ ($54_1 << 14 | $17_1 >>> 18) ^ $54_1 >>> 3) + $13_1 | 0;
        $37_1 = HEAPU8[$0_1 + 79 | 0];
        $17_1 = HEAPU8[$0_1 + 77 | 0] << 16 | HEAPU8[$0_1 + 76 | 0] << 24;
        $46_1 = $37_1 | ($17_1 | HEAPU8[$0_1 + 78 | 0] << 8);
        $15_1 = ($8_1 + $46_1 | 0) + (__wasm_rotl_i32($5_1, 15) ^ __wasm_rotl_i32($5_1, 13) ^ $5_1 >>> 10) | 0;
        $16_1 = ($53_1 + $60_1 | 0) + (__wasm_rotl_i32($15_1, 15) ^ __wasm_rotl_i32($15_1, 13) ^ $15_1 >>> 10) | 0;
        $19_1 = $59_1 + (__wasm_rotl_i32($16_1, 15) ^ __wasm_rotl_i32($16_1, 13) ^ $16_1 >>> 10) | 0;
        $4_1 = $69_1 + (__wasm_rotl_i32($19_1, 15) ^ __wasm_rotl_i32($19_1, 13) ^ $19_1 >>> 10) | 0;
        $29_1 = $4_1 + ((__wasm_rotl_i32($5_1, 25) ^ __wasm_rotl_i32($5_1, 14) ^ $5_1 >>> 3) + $27_1 | 0) | 0;
        $8_1 = ((($24_1 << 25 | $26_1 >>> 7) ^ ($26_1 << 14 | $7_1 >>> 18) ^ $26_1 >>> 3) + $60_1 | 0) + $19_1 | 0;
        $24_1 = (((($34_1 << 25 | $45_1 >>> 7) ^ ($45_1 << 14 | $35_1 >>> 18) ^ $45_1 >>> 3) + $43_1 | 0) + $15_1 | 0) + (__wasm_rotl_i32($3_1, 15) ^ __wasm_rotl_i32($3_1, 13) ^ $3_1 >>> 10) | 0;
        $25_1 = (((($33_1 << 25 | $44_1 >>> 7) ^ ($44_1 << 14 | $28_1 >>> 18) ^ $44_1 >>> 3) + $46_1 | 0) + $16_1 | 0) + (__wasm_rotl_i32($24_1, 15) ^ __wasm_rotl_i32($24_1, 13) ^ $24_1 >>> 10) | 0;
        $28_1 = $8_1 + (__wasm_rotl_i32($25_1, 15) ^ __wasm_rotl_i32($25_1, 13) ^ $25_1 >>> 10) | 0;
        $7_1 = $29_1 + (__wasm_rotl_i32($28_1, 15) ^ __wasm_rotl_i32($28_1, 13) ^ $28_1 >>> 10) | 0;
        $39_1 = $7_1 + ((__wasm_rotl_i32($3_1, 25) ^ __wasm_rotl_i32($3_1, 14) ^ $3_1 >>> 3) + $19_1 | 0) | 0;
        $29_1 = ((__wasm_rotl_i32($12_1, 25) ^ __wasm_rotl_i32($12_1, 14) ^ $12_1 >>> 3) + $16_1 | 0) + $28_1 | 0;
        $30_1 = ((__wasm_rotl_i32($10_1, 25) ^ __wasm_rotl_i32($10_1, 14) ^ $10_1 >>> 3) + $15_1 | 0) + $25_1 | 0;
        $31_1 = ((__wasm_rotl_i32($6_1, 25) ^ __wasm_rotl_i32($6_1, 14) ^ $6_1 >>> 3) + $5_1 | 0) + $24_1 | 0;
        $33_1 = (((($37_1 << 25 | $46_1 >>> 7) ^ ($46_1 << 14 | $17_1 >>> 18) ^ $46_1 >>> 3) + $45_1 | 0) + $10_1 | 0) + (__wasm_rotl_i32($4_1, 15) ^ __wasm_rotl_i32($4_1, 13) ^ $4_1 >>> 10) | 0;
        $35_1 = (((($22_1 << 25 | $60_1 >>> 7) ^ ($60_1 << 14 | $23_1 >>> 18) ^ $60_1 >>> 3) + $44_1 | 0) + $12_1 | 0) + (__wasm_rotl_i32($33_1, 15) ^ __wasm_rotl_i32($33_1, 13) ^ $33_1 >>> 10) | 0;
        $34_1 = (((($36_1 << 25 | $27_1 >>> 7) ^ ($27_1 << 14 | $9_1 >>> 18) ^ $27_1 >>> 3) + $26_1 | 0) + $3_1 | 0) + (__wasm_rotl_i32($35_1, 15) ^ __wasm_rotl_i32($35_1, 13) ^ $35_1 >>> 10) | 0;
        $36_1 = $31_1 + (__wasm_rotl_i32($34_1, 15) ^ __wasm_rotl_i32($34_1, 13) ^ $34_1 >>> 10) | 0;
        $37_1 = $30_1 + (__wasm_rotl_i32($36_1, 15) ^ __wasm_rotl_i32($36_1, 13) ^ $36_1 >>> 10) | 0;
        $29_1 = $29_1 + (__wasm_rotl_i32($37_1, 15) ^ __wasm_rotl_i32($37_1, 13) ^ $37_1 >>> 10) | 0;
        $9_1 = $39_1 + (__wasm_rotl_i32($29_1, 15) ^ __wasm_rotl_i32($29_1, 13) ^ $29_1 >>> 10) | 0;
        $23_1 = $9_1 + ((__wasm_rotl_i32($34_1, 25) ^ __wasm_rotl_i32($34_1, 14) ^ $34_1 >>> 3) + $28_1 | 0) | 0;
        $22_1 = ((__wasm_rotl_i32($35_1, 25) ^ __wasm_rotl_i32($35_1, 14) ^ $35_1 >>> 3) + $25_1 | 0) + $29_1 | 0;
        $17_1 = ((__wasm_rotl_i32($33_1, 25) ^ __wasm_rotl_i32($33_1, 14) ^ $33_1 >>> 3) + $24_1 | 0) + $37_1 | 0;
        $40_1 = ((__wasm_rotl_i32($4_1, 25) ^ __wasm_rotl_i32($4_1, 14) ^ $4_1 >>> 3) + $3_1 | 0) + $36_1 | 0;
        $31_1 = ((__wasm_rotl_i32($19_1, 25) ^ __wasm_rotl_i32($19_1, 14) ^ $19_1 >>> 3) + $12_1 | 0) + $34_1 | 0;
        $30_1 = ((__wasm_rotl_i32($16_1, 25) ^ __wasm_rotl_i32($16_1, 14) ^ $16_1 >>> 3) + $10_1 | 0) + $35_1 | 0;
        $39_1 = (((__wasm_rotl_i32($15_1, 25) ^ __wasm_rotl_i32($15_1, 14) ^ $15_1 >>> 3) + $6_1 | 0) + $33_1 | 0) + (__wasm_rotl_i32($7_1, 15) ^ __wasm_rotl_i32($7_1, 13) ^ $7_1 >>> 10) | 0;
        $30_1 = $30_1 + (__wasm_rotl_i32($39_1, 15) ^ __wasm_rotl_i32($39_1, 13) ^ $39_1 >>> 10) | 0;
        $31_1 = $31_1 + (__wasm_rotl_i32($30_1, 15) ^ __wasm_rotl_i32($30_1, 13) ^ $30_1 >>> 10) | 0;
        $40_1 = $40_1 + (__wasm_rotl_i32($31_1, 15) ^ __wasm_rotl_i32($31_1, 13) ^ $31_1 >>> 10) | 0;
        $47_1 = $17_1 + (__wasm_rotl_i32($40_1, 15) ^ __wasm_rotl_i32($40_1, 13) ^ $40_1 >>> 10) | 0;
        $48_1 = $22_1 + (__wasm_rotl_i32($47_1, 15) ^ __wasm_rotl_i32($47_1, 13) ^ $47_1 >>> 10) | 0;
        $23_1 = $23_1 + (__wasm_rotl_i32($48_1, 15) ^ __wasm_rotl_i32($48_1, 13) ^ $48_1 >>> 10) | 0;
        $22_1 = ((__wasm_rotl_i32($7_1, 25) ^ __wasm_rotl_i32($7_1, 14) ^ $7_1 >>> 3) + $34_1 | 0) + $40_1 | 0;
        $17_1 = ((__wasm_rotl_i32($28_1, 25) ^ __wasm_rotl_i32($28_1, 14) ^ $28_1 >>> 3) + $35_1 | 0) + $31_1 | 0;
        $41_1 = ((__wasm_rotl_i32($25_1, 25) ^ __wasm_rotl_i32($25_1, 14) ^ $25_1 >>> 3) + $33_1 | 0) + $30_1 | 0;
        $49_1 = (((__wasm_rotl_i32($24_1, 25) ^ __wasm_rotl_i32($24_1, 14) ^ $24_1 >>> 3) + $4_1 | 0) + $39_1 | 0) + (__wasm_rotl_i32($9_1, 15) ^ __wasm_rotl_i32($9_1, 13) ^ $9_1 >>> 10) | 0;
        $41_1 = $41_1 + (__wasm_rotl_i32($49_1, 15) ^ __wasm_rotl_i32($49_1, 13) ^ $49_1 >>> 10) | 0;
        $50_1 = $17_1 + (__wasm_rotl_i32($41_1, 15) ^ __wasm_rotl_i32($41_1, 13) ^ $41_1 >>> 10) | 0;
        $22_1 = $22_1 + (__wasm_rotl_i32($50_1, 15) ^ __wasm_rotl_i32($50_1, 13) ^ $50_1 >>> 10) | 0;
        $17_1 = $22_1 + ((__wasm_rotl_i32($9_1, 25) ^ __wasm_rotl_i32($9_1, 14) ^ $9_1 >>> 3) + $31_1 | 0) | 0;
        $32_1 = ((__wasm_rotl_i32($29_1, 25) ^ __wasm_rotl_i32($29_1, 14) ^ $29_1 >>> 3) + $30_1 | 0) + $50_1 | 0;
        $42_1 = ((__wasm_rotl_i32($37_1, 25) ^ __wasm_rotl_i32($37_1, 14) ^ $37_1 >>> 3) + $39_1 | 0) + $41_1 | 0;
        $51_1 = (((__wasm_rotl_i32($36_1, 25) ^ __wasm_rotl_i32($36_1, 14) ^ $36_1 >>> 3) + $7_1 | 0) + $49_1 | 0) + (__wasm_rotl_i32($23_1, 15) ^ __wasm_rotl_i32($23_1, 13) ^ $23_1 >>> 10) | 0;
        $62_1 = $42_1 + (__wasm_rotl_i32($51_1, 15) ^ __wasm_rotl_i32($51_1, 13) ^ $51_1 >>> 10) | 0;
        $63_1 = $32_1 + (__wasm_rotl_i32($62_1, 15) ^ __wasm_rotl_i32($62_1, 13) ^ $62_1 >>> 10) | 0;
        $64_1 = $17_1 + (__wasm_rotl_i32($63_1, 15) ^ __wasm_rotl_i32($63_1, 13) ^ $63_1 >>> 10) | 0;
        $17_1 = $64_1 + ((__wasm_rotl_i32($23_1, 25) ^ __wasm_rotl_i32($23_1, 14) ^ $23_1 >>> 3) + $50_1 | 0) | 0;
        $32_1 = ((__wasm_rotl_i32($48_1, 25) ^ __wasm_rotl_i32($48_1, 14) ^ $48_1 >>> 3) + $41_1 | 0) + $63_1 | 0;
        $55_1 = ((__wasm_rotl_i32($47_1, 25) ^ __wasm_rotl_i32($47_1, 14) ^ $47_1 >>> 3) + $49_1 | 0) + $62_1 | 0;
        $56_1 = ((__wasm_rotl_i32($40_1, 25) ^ __wasm_rotl_i32($40_1, 14) ^ $40_1 >>> 3) + $9_1 | 0) + $51_1 | 0;
        $57_1 = ((__wasm_rotl_i32($31_1, 25) ^ __wasm_rotl_i32($31_1, 14) ^ $31_1 >>> 3) + $29_1 | 0) + $23_1 | 0;
        $58_1 = ((__wasm_rotl_i32($30_1, 25) ^ __wasm_rotl_i32($30_1, 14) ^ $30_1 >>> 3) + $37_1 | 0) + $48_1 | 0;
        $42_1 = (((__wasm_rotl_i32($39_1, 25) ^ __wasm_rotl_i32($39_1, 14) ^ $39_1 >>> 3) + $36_1 | 0) + $47_1 | 0) + (__wasm_rotl_i32($22_1, 15) ^ __wasm_rotl_i32($22_1, 13) ^ $22_1 >>> 10) | 0;
        $58_1 = $58_1 + (__wasm_rotl_i32($42_1, 15) ^ __wasm_rotl_i32($42_1, 13) ^ $42_1 >>> 10) | 0;
        $57_1 = $57_1 + (__wasm_rotl_i32($58_1, 15) ^ __wasm_rotl_i32($58_1, 13) ^ $58_1 >>> 10) | 0;
        $56_1 = $56_1 + (__wasm_rotl_i32($57_1, 15) ^ __wasm_rotl_i32($57_1, 13) ^ $57_1 >>> 10) | 0;
        $55_1 = $55_1 + (__wasm_rotl_i32($56_1, 15) ^ __wasm_rotl_i32($56_1, 13) ^ $56_1 >>> 10) | 0;
        $70_1 = $32_1 + (__wasm_rotl_i32($55_1, 15) ^ __wasm_rotl_i32($55_1, 13) ^ $55_1 >>> 10) | 0;
        $71 = $17_1 + (__wasm_rotl_i32($70_1, 15) ^ __wasm_rotl_i32($70_1, 13) ^ $70_1 >>> 10) | 0;
        $69_1 = HEAP32[$0_1 + 12 >> 2];
        $59_1 = HEAP32[$0_1 + 28 >> 2];
        $32_1 = HEAP32[$0_1 + 16 >> 2];
        $17_1 = $59_1 + (__wasm_rotl_i32($32_1, 26) ^ __wasm_rotl_i32($32_1, 21) ^ __wasm_rotl_i32($32_1, 7)) | 0;
        $65_1 = HEAP32[$0_1 + 20 >> 2];
        $72 = HEAP32[$0_1 + 24 >> 2];
        $66_1 = ($52_1 + ($17_1 + (($65_1 ^ $72) & $32_1 ^ $72) | 0) | 0) + 1116352408 | 0;
        $17_1 = $66_1 + $69_1 | 0;
        $52_1 = HEAP32[$0_1 + 4 >> 2];
        $8_1 = $13_1 + $65_1 | 0;
        $73 = HEAP32[$0_1 + 8 >> 2];
        $67_1 = ((($72 + ($17_1 & ($32_1 ^ $65_1) ^ $65_1) | 0) + $11_1 | 0) + (__wasm_rotl_i32($17_1, 26) ^ __wasm_rotl_i32($17_1, 21) ^ __wasm_rotl_i32($17_1, 7)) | 0) + 1899447441 | 0;
        $13_1 = $73 + $67_1 | 0;
        $68_1 = (($8_1 + ($13_1 & ($17_1 ^ $32_1) ^ $32_1) | 0) + (__wasm_rotl_i32($13_1, 26) ^ __wasm_rotl_i32($13_1, 21) ^ __wasm_rotl_i32($13_1, 7)) | 0) - 1245643825 | 0;
        $11_1 = $52_1 + $68_1 | 0;
        $8_1 = $14_1 + $17_1 | 0;
        $53_1 = ((($32_1 + $54_1 | 0) + ($11_1 & ($13_1 ^ $17_1) ^ $17_1) | 0) + (__wasm_rotl_i32($11_1, 26) ^ __wasm_rotl_i32($11_1, 21) ^ __wasm_rotl_i32($11_1, 7)) | 0) - 373957723 | 0;
        $17_1 = HEAP32[$0_1 >> 2];
        $14_1 = $53_1 + $17_1 | 0;
        $54_1 = (($8_1 + ($14_1 & ($11_1 ^ $13_1) ^ $13_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) + 961987163 | 0;
        $8_1 = $13_1 + $18_1 | 0;
        $13_1 = (($73 & ($17_1 | $52_1) | $17_1 & $52_1) + (__wasm_rotl_i32($17_1, 30) ^ __wasm_rotl_i32($17_1, 19) ^ __wasm_rotl_i32($17_1, 10)) | 0) + $66_1 | 0;
        $18_1 = $13_1 + $54_1 | 0;
        $66_1 = (($8_1 + ($18_1 & ($11_1 ^ $14_1) ^ $11_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) + 1508970993 | 0;
        $8_1 = $11_1 + $20_1 | 0;
        $11_1 = ((($13_1 | $17_1) & $52_1 | $13_1 & $17_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $67_1 | 0;
        $20_1 = $11_1 + $66_1 | 0;
        $67_1 = (($8_1 + ($20_1 & ($14_1 ^ $18_1) ^ $14_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) - 1841331548 | 0;
        $8_1 = $14_1 + $21_1 | 0;
        $14_1 = ((($11_1 | $13_1) & $17_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $68_1 | 0;
        $21_1 = $14_1 + $67_1 | 0;
        $68_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) - 1424204075 | 0;
        $8_1 = $18_1 + $38_1 | 0;
        $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $53_1 | 0;
        $18_1 = $13_1 + $68_1 | 0;
        $38_1 = (($8_1 + ($18_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) - 670586216 | 0;
        $8_1 = $20_1 + $43_1 | 0;
        $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $54_1 | 0;
        $20_1 = $11_1 + $38_1 | 0;
        $43_1 = (($8_1 + ($20_1 & ($18_1 ^ $21_1) ^ $21_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) + 310598401 | 0;
        $8_1 = $21_1 + $45_1 | 0;
        $14_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $66_1 | 0;
        $21_1 = $14_1 + $43_1 | 0;
        $45_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) + 607225278 | 0;
        $8_1 = $18_1 + $46_1 | 0;
        $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $67_1 | 0;
        $18_1 = $13_1 + $45_1 | 0;
        $46_1 = (($8_1 + ($18_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) + 1426881987 | 0;
        $8_1 = $20_1 + $44_1 | 0;
        $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $68_1 | 0;
        $20_1 = $11_1 + $46_1 | 0;
        $44_1 = (($8_1 + ($20_1 & ($18_1 ^ $21_1) ^ $21_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) + 1925078388 | 0;
        $8_1 = $21_1 + $60_1 | 0;
        $14_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $38_1 | 0;
        $21_1 = $14_1 + $44_1 | 0;
        $38_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) - 2132889090 | 0;
        $8_1 = $18_1 + $26_1 | 0;
        $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $43_1 | 0;
        $26_1 = $13_1 + $38_1 | 0;
        $18_1 = (($8_1 + ($26_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($26_1, 26) ^ __wasm_rotl_i32($26_1, 21) ^ __wasm_rotl_i32($26_1, 7)) | 0) - 1680079193 | 0;
        $8_1 = $20_1 + $27_1 | 0;
        $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $45_1 | 0;
        $27_1 = $11_1 + $18_1 | 0;
        $20_1 = (($8_1 + ($27_1 & ($21_1 ^ $26_1) ^ $21_1) | 0) + (__wasm_rotl_i32($27_1, 26) ^ __wasm_rotl_i32($27_1, 21) ^ __wasm_rotl_i32($27_1, 7)) | 0) - 1046744716 | 0;
        $8_1 = $5_1 + $21_1 | 0;
        $5_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $46_1 | 0;
        $14_1 = $5_1 + $20_1 | 0;
        $21_1 = (($8_1 + ($14_1 & ($26_1 ^ $27_1) ^ $26_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) - 459576895 | 0;
        $8_1 = $6_1 + $26_1 | 0;
        $6_1 = ((($5_1 | $11_1) & $13_1 | $5_1 & $11_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $44_1 | 0;
        $13_1 = $6_1 + $21_1 | 0;
        $26_1 = (($8_1 + ($13_1 & ($14_1 ^ $27_1) ^ $27_1) | 0) + (__wasm_rotl_i32($13_1, 26) ^ __wasm_rotl_i32($13_1, 21) ^ __wasm_rotl_i32($13_1, 7)) | 0) - 272742522 | 0;
        $8_1 = $15_1 + $27_1 | 0;
        $15_1 = ((($5_1 | $6_1) & $11_1 | $5_1 & $6_1) + (__wasm_rotl_i32($6_1, 30) ^ __wasm_rotl_i32($6_1, 19) ^ __wasm_rotl_i32($6_1, 10)) | 0) + $38_1 | 0;
        $11_1 = $15_1 + $26_1 | 0;
        $27_1 = (($8_1 + ($11_1 & ($13_1 ^ $14_1) ^ $14_1) | 0) + (__wasm_rotl_i32($11_1, 26) ^ __wasm_rotl_i32($11_1, 21) ^ __wasm_rotl_i32($11_1, 7)) | 0) + 264347078 | 0;
        $8_1 = $10_1 + $14_1 | 0;
        $5_1 = ((($6_1 | $15_1) & $5_1 | $6_1 & $15_1) + (__wasm_rotl_i32($15_1, 30) ^ __wasm_rotl_i32($15_1, 19) ^ __wasm_rotl_i32($15_1, 10)) | 0) + $18_1 | 0;
        $14_1 = $5_1 + $27_1 | 0;
        $18_1 = (($8_1 + ($14_1 & ($11_1 ^ $13_1) ^ $13_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) + 604807628 | 0;
        $8_1 = $13_1 + $16_1 | 0;
        $6_1 = ((($5_1 | $15_1) & $6_1 | $5_1 & $15_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $20_1 | 0;
        $16_1 = $6_1 + $18_1 | 0;
        $13_1 = (($8_1 + ($16_1 & ($11_1 ^ $14_1) ^ $11_1) | 0) + (__wasm_rotl_i32($16_1, 26) ^ __wasm_rotl_i32($16_1, 21) ^ __wasm_rotl_i32($16_1, 7)) | 0) + 770255983 | 0;
        $8_1 = $11_1 + $12_1 | 0;
        $10_1 = ((($5_1 | $6_1) & $15_1 | $5_1 & $6_1) + (__wasm_rotl_i32($6_1, 30) ^ __wasm_rotl_i32($6_1, 19) ^ __wasm_rotl_i32($6_1, 10)) | 0) + $21_1 | 0;
        $12_1 = $10_1 + $13_1 | 0;
        $11_1 = (($8_1 + ($12_1 & ($14_1 ^ $16_1) ^ $14_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) + 1249150122 | 0;
        $5_1 = ((($6_1 | $10_1) & $5_1 | $6_1 & $10_1) + (__wasm_rotl_i32($10_1, 30) ^ __wasm_rotl_i32($10_1, 19) ^ __wasm_rotl_i32($10_1, 10)) | 0) + $26_1 | 0;
        $15_1 = $5_1 + $11_1 | 0;
        $19_1 = ((($14_1 + $19_1 | 0) + ($15_1 & ($12_1 ^ $16_1) ^ $16_1) | 0) + (__wasm_rotl_i32($15_1, 26) ^ __wasm_rotl_i32($15_1, 21) ^ __wasm_rotl_i32($15_1, 7)) | 0) + 1555081692 | 0;
        $8_1 = $3_1 + $16_1 | 0;
        $3_1 = ((($5_1 | $10_1) & $6_1 | $5_1 & $10_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $27_1 | 0;
        $6_1 = $3_1 + $19_1 | 0;
        $16_1 = (($8_1 + ($6_1 & ($12_1 ^ $15_1) ^ $12_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1996064986 | 0;
        $8_1 = $4_1 + $12_1 | 0;
        $4_1 = ((($3_1 | $5_1) & $10_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $18_1 | 0;
        $10_1 = $4_1 + $16_1 | 0;
        $14_1 = (($8_1 + ($10_1 & ($6_1 ^ $15_1) ^ $15_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1740746414 | 0;
        $5_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $13_1 | 0;
        $12_1 = $5_1 + $14_1 | 0;
        $15_1 = ((($15_1 + $24_1 | 0) + ($12_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 1473132947 | 0;
        $8_1 = $6_1 + $33_1 | 0;
        $3_1 = ((($4_1 | $5_1) & $3_1 | $4_1 & $5_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $11_1 | 0;
        $6_1 = $3_1 + $15_1 | 0;
        $24_1 = (($8_1 + ($6_1 & ($10_1 ^ $12_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1341970488 | 0;
        $8_1 = $10_1 + $25_1 | 0;
        $4_1 = ((($3_1 | $5_1) & $4_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
        $10_1 = $4_1 + $24_1 | 0;
        $19_1 = (($8_1 + ($10_1 & ($6_1 ^ $12_1) ^ $12_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1084653625 | 0;
        $8_1 = $12_1 + $35_1 | 0;
        $5_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $16_1 | 0;
        $12_1 = $5_1 + $19_1 | 0;
        $16_1 = (($8_1 + ($12_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 958395405 | 0;
        $8_1 = $6_1 + $28_1 | 0;
        $3_1 = ((($4_1 | $5_1) & $3_1 | $4_1 & $5_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $14_1 | 0;
        $6_1 = $3_1 + $16_1 | 0;
        $25_1 = (($8_1 + ($6_1 & ($10_1 ^ $12_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 710438585 | 0;
        $8_1 = $10_1 + $34_1 | 0;
        $4_1 = ((($3_1 | $5_1) & $4_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $15_1 | 0;
        $10_1 = $4_1 + $25_1 | 0;
        $15_1 = (($8_1 + ($10_1 & ($6_1 ^ $12_1) ^ $12_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 113926993 | 0;
        $8_1 = $7_1 + $12_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
        $5_1 = $7_1 + $15_1 | 0;
        $12_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 338241895 | 0;
        $8_1 = $6_1 + $36_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
        $6_1 = $3_1 + $12_1 | 0;
        $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 666307205 | 0;
        $8_1 = $10_1 + $39_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $16_1 | 0;
        $10_1 = $4_1 + $19_1 | 0;
        $16_1 = (($8_1 + ($10_1 & ($5_1 ^ $6_1) ^ $5_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 773529912 | 0;
        $8_1 = $5_1 + $37_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $25_1 | 0;
        $5_1 = $7_1 + $16_1 | 0;
        $24_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1294757372 | 0;
        $8_1 = $6_1 + $30_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $15_1 | 0;
        $6_1 = $3_1 + $24_1 | 0;
        $15_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1396182291 | 0;
        $8_1 = $10_1 + $29_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $12_1 | 0;
        $10_1 = $4_1 + $15_1 | 0;
        $12_1 = (($8_1 + ($10_1 & ($5_1 ^ $6_1) ^ $5_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 1695183700 | 0;
        $8_1 = $5_1 + $31_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $19_1 | 0;
        $5_1 = $7_1 + $12_1 | 0;
        $19_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1986661051 | 0;
        $8_1 = $6_1 + $9_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $16_1 | 0;
        $9_1 = $3_1 + $19_1 | 0;
        $16_1 = (($8_1 + ($9_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 2117940946 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $24_1 | 0;
        $6_1 = $4_1 + $16_1 | 0;
        $10_1 = ((($10_1 + $40_1 | 0) + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1838011259 | 0;
        $8_1 = $5_1 + $49_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $15_1 | 0;
        $5_1 = $7_1 + $10_1 | 0;
        $15_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 1564481375 | 0;
        $8_1 = $9_1 + $47_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $12_1 | 0;
        $9_1 = $3_1 + $15_1 | 0;
        $12_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 1474664885 | 0;
        $8_1 = $6_1 + $41_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
        $6_1 = $4_1 + $12_1 | 0;
        $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1035236496 | 0;
        $8_1 = $5_1 + $48_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $16_1 | 0;
        $5_1 = $7_1 + $19_1 | 0;
        $16_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 949202525 | 0;
        $8_1 = $9_1 + $50_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $10_1 | 0;
        $9_1 = $3_1 + $16_1 | 0;
        $10_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 778901479 | 0;
        $8_1 = $6_1 + $23_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $15_1 | 0;
        $6_1 = $4_1 + $10_1 | 0;
        $15_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 694614492 | 0;
        $8_1 = $5_1 + $22_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $12_1 | 0;
        $5_1 = $7_1 + $15_1 | 0;
        $12_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 200395387 | 0;
        $8_1 = $9_1 + $51_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
        $9_1 = $3_1 + $12_1 | 0;
        $19_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 275423344 | 0;
        $8_1 = $6_1 + $42_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $16_1 | 0;
        $6_1 = $4_1 + $19_1 | 0;
        $16_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 430227734 | 0;
        $8_1 = $5_1 + $62_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $10_1 | 0;
        $5_1 = $7_1 + $16_1 | 0;
        $10_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 506948616 | 0;
        $8_1 = $9_1 + $58_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $15_1 | 0;
        $9_1 = $3_1 + $10_1 | 0;
        $24_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 659060556 | 0;
        $8_1 = $6_1 + $63_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $12_1 | 0;
        $6_1 = $4_1 + $24_1 | 0;
        $12_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 883997877 | 0;
        $8_1 = $5_1 + $57_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $19_1 | 0;
        $5_1 = $7_1 + $12_1 | 0;
        $19_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 958139571 | 0;
        $8_1 = $9_1 + $64_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $16_1 | 0;
        $9_1 = $3_1 + $19_1 | 0;
        $25_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 1322822218 | 0;
        $8_1 = $6_1 + $56_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $10_1 | 0;
        $6_1 = $4_1 + $25_1 | 0;
        $28_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1537002063 | 0;
        $15_1 = (((__wasm_rotl_i32($49_1, 25) ^ __wasm_rotl_i32($49_1, 14) ^ $49_1 >>> 3) + $40_1 | 0) + $42_1 | 0) + (__wasm_rotl_i32($64_1, 15) ^ __wasm_rotl_i32($64_1, 13) ^ $64_1 >>> 10) | 0;
        $8_1 = $15_1 + $5_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
        $5_1 = $7_1 + $28_1 | 0;
        $24_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1747873779 | 0;
        $8_1 = $9_1 + $55_1 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $12_1 | 0;
        $9_1 = $3_1 + $24_1 | 0;
        $12_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 1955562222 | 0;
        $16_1 = ((__wasm_rotl_i32($50_1, 25) ^ __wasm_rotl_i32($50_1, 14) ^ $50_1 >>> 3) + $48_1 | 0) + $57_1 | 0;
        $10_1 = (((__wasm_rotl_i32($41_1, 25) ^ __wasm_rotl_i32($41_1, 14) ^ $41_1 >>> 3) + $47_1 | 0) + $58_1 | 0) + (__wasm_rotl_i32($15_1, 15) ^ __wasm_rotl_i32($15_1, 13) ^ $15_1 >>> 10) | 0;
        $16_1 = $16_1 + (__wasm_rotl_i32($10_1, 15) ^ __wasm_rotl_i32($10_1, 13) ^ $10_1 >>> 10) | 0;
        $8_1 = $6_1 + $10_1 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
        $6_1 = $4_1 + $12_1 | 0;
        $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 2024104815 | 0;
        $8_1 = $5_1 + $70_1 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $25_1 | 0;
        $5_1 = $7_1 + $19_1 | 0;
        $25_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 2067236844 | 0;
        $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $28_1 | 0;
        $10_1 = $3_1 + $25_1 | 0;
        $28_1 = ((($9_1 + $16_1 | 0) + ($10_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1933114872 | 0;
        $8_1 = $6_1 + $71 | 0;
        $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $24_1 | 0;
        $6_1 = $4_1 + $28_1 | 0;
        $24_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1866530822 | 0;
        $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $12_1 | 0;
        $12_1 = $24_1 + $7_1 | 0;
        HEAP32[$0_1 + 28 >> 2] = $12_1 + $59_1;
        $9_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
        $3_1 = (($4_1 & ($9_1 | $7_1) | $7_1 & $9_1) + (__wasm_rotl_i32($9_1, 30) ^ __wasm_rotl_i32($9_1, 19) ^ __wasm_rotl_i32($9_1, 10)) | 0) + $25_1 | 0;
        $4_1 = ((($3_1 | $9_1) & $7_1 | $3_1 & $9_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $28_1 | 0;
        $7_1 = ((($4_1 | $3_1) & $9_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
        HEAP32[$0_1 + 12 >> 2] = $7_1 + $69_1;
        $53_1 = $9_1;
        $8_1 = $5_1;
        $5_1 = (((__wasm_rotl_i32($22_1, 25) ^ __wasm_rotl_i32($22_1, 14) ^ $22_1 >>> 3) + $23_1 | 0) + $56_1 | 0) + (__wasm_rotl_i32($16_1, 15) ^ __wasm_rotl_i32($16_1, 13) ^ $16_1 >>> 10) | 0;
        $9_1 = ((($8_1 + $5_1 | 0) + ($12_1 & ($6_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 1538233109 | 0;
        $23_1 = $53_1 + $9_1 | 0;
        HEAP32[$0_1 + 24 >> 2] = $23_1 + $72;
        $9_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $9_1 | 0;
        HEAP32[$0_1 + 8 >> 2] = $9_1 + $73;
        $8_1 = $3_1;
        $3_1 = (((((($22_1 + (__wasm_rotl_i32($51_1, 25) ^ __wasm_rotl_i32($51_1, 14) ^ $51_1 >>> 3) | 0) + $15_1 | 0) + (__wasm_rotl_i32($71, 15) ^ __wasm_rotl_i32($71, 13) ^ $71 >>> 10) | 0) + $10_1 | 0) + ($23_1 & ($6_1 ^ $12_1) ^ $6_1) | 0) + (__wasm_rotl_i32($23_1, 26) ^ __wasm_rotl_i32($23_1, 21) ^ __wasm_rotl_i32($23_1, 7)) | 0) - 1090935817 | 0;
        $22_1 = $8_1 + $3_1 | 0;
        HEAP32[$0_1 + 20 >> 2] = $22_1 + $65_1;
        $3_1 = ((($7_1 | $9_1) & $4_1 | $7_1 & $9_1) + (__wasm_rotl_i32($9_1, 30) ^ __wasm_rotl_i32($9_1, 19) ^ __wasm_rotl_i32($9_1, 10)) | 0) + $3_1 | 0;
        HEAP32[$0_1 + 4 >> 2] = $3_1 + $52_1;
        $8_1 = $4_1 + $32_1 | 0;
        $4_1 = (((((($51_1 + (__wasm_rotl_i32($42_1, 25) ^ __wasm_rotl_i32($42_1, 14) ^ $42_1 >>> 3) | 0) + $55_1 | 0) + (__wasm_rotl_i32($5_1, 15) ^ __wasm_rotl_i32($5_1, 13) ^ $5_1 >>> 10) | 0) + $6_1 | 0) + ($22_1 & ($12_1 ^ $23_1) ^ $12_1) | 0) + (__wasm_rotl_i32($22_1, 26) ^ __wasm_rotl_i32($22_1, 21) ^ __wasm_rotl_i32($22_1, 7)) | 0) - 965641998 | 0;
        HEAP32[$0_1 + 16 >> 2] = $8_1 + $4_1;
        wasm2js_i32$0 = $0_1, wasm2js_i32$1 = (($17_1 + (($3_1 | $9_1) & $7_1 | $3_1 & $9_1) | 0) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $4_1 | 0, HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        $1_1 = $1_1 + $61_1 | 0;
        $2_1 = $2_1 - $61_1 | 0;
        $61_1 = 64;
        $3_1 = 0;
        if ($2_1 >>> 0 > 63) {
          continue;
        }
        break;
      }
      ;
    }
    if ($2_1) {
      $70(($0_1 + $3_1 | 0) + 32 | 0, $1_1, $2_1);
    }
  }
  function $30($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0;
    $3_1 = global$0 - 16 | 0;
    global$0 = $3_1;
    $2_1 = HEAP32[$0_1 + 100 >> 2];
    $4_1 = HEAP32[$0_1 + 96 >> 2];
    HEAP8[$3_1 + 11 | 0] = ($2_1 & 536870911) << 3 | $4_1 >>> 29;
    HEAP8[$3_1 + 10 | 0] = $2_1 >>> 5;
    HEAP8[$3_1 + 9 | 0] = $2_1 >>> 13;
    HEAP8[$3_1 + 8 | 0] = $2_1 >>> 21;
    HEAP8[$3_1 + 15 | 0] = $4_1 << 3;
    HEAP8[$3_1 + 14 | 0] = $4_1 >>> 5;
    HEAP8[$3_1 + 13 | 0] = $4_1 >>> 13;
    HEAP8[$3_1 + 12 | 0] = $4_1 >>> 21;
    $29($0_1, 690512, (55 - $4_1 & 63) + 1 | 0);
    $29($0_1, $3_1 + 8 | 0, 8);
    $2_1 = HEAP32[$0_1 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 | 0] = $2_1;
    HEAP8[$1_1 + 1 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 4 | 0] = $2_1;
    HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 4 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 8 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 8 | 0] = $2_1;
    HEAP8[$1_1 + 9 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 10 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 11 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 8 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 12 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 12 | 0] = $2_1;
    HEAP8[$1_1 + 13 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 14 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 15 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 12 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 16 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 16 | 0] = $2_1;
    HEAP8[$1_1 + 17 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 18 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 19 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 16 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 20 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 20 | 0] = $2_1;
    HEAP8[$1_1 + 21 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 22 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 23 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 20 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 24 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 24 | 0] = $2_1;
    HEAP8[$1_1 + 25 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 26 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 27 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 24 >> 2] = 0;
    $2_1 = HEAP32[$0_1 + 28 >> 2];
    $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
    HEAP8[$1_1 + 28 | 0] = $2_1;
    HEAP8[$1_1 + 29 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 30 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 31 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 28 >> 2] = 0;
    global$0 = $3_1 + 16 | 0;
  }
  function $31($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0;
    $6_1 = global$0 - 880 | 0;
    global$0 = $6_1;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 56 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 48 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 40 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 32 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 24 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 16 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      $4_1 = $1_1 + 8 | 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      if (!$2_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689668, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      $0_1 = 0;
      label$4: {
        if (($3_1 | 0) != 65) {
          if (($3_1 | 0) != 33) {
            break label$1;
          }
          if ((HEAPU8[$2_1 | 0] & 254) != 2) {
            break label$1;
          }
          if (!$32($6_1 + 840 | 0, $2_1 + 1 | 0)) {
            $3_1 = 0;
            break label$4;
          }
          $3_1 = ($33($6_1 + 672 | 0, $6_1 + 840 | 0, HEAPU8[$2_1 | 0] == 3) | 0) != 0;
          break label$4;
        }
        $3_1 = HEAPU8[$2_1 | 0];
        if ($3_1 >>> 0 > 7) {
          break label$1;
        }
        if (!(1 << $3_1 & 208)) {
          break label$1;
        }
        $3_1 = 0;
        if (!$32($6_1 + 800 | 0, $2_1 + 1 | 0)) {
          break label$4;
        }
        if (!$32($6_1 + 760 | 0, $2_1 + 33 | 0)) {
          break label$4;
        }
        $7_1 = $6_1 + 800 | 0;
        $5_1 = $7_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $8_1 = $6_1 + 672 | 0;
        $3_1 = $8_1 + 8 | 0;
        HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $4_1;
        $5_1 = $7_1 + 16 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $3_1 = $8_1 + 16 | 0;
        HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $4_1;
        $5_1 = $7_1 + 24 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $3_1 = $8_1 + 24 | 0;
        HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $4_1;
        $5_1 = $7_1 + 32 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $3_1 = $8_1 + 32 | 0;
        HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $4_1;
        $5_1 = $6_1 + 760 | 0;
        $4_1 = $5_1 + 8 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $19_1 = $6_1 + 720 | 0;
        HEAP32[$19_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$19_1 + 4 >> 2] = $3_1;
        $4_1 = $5_1 + 16 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $14_1 = $6_1 + 728 | 0;
        HEAP32[$14_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$14_1 + 4 >> 2] = $3_1;
        $4_1 = $5_1 + 24 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $7_1 = $6_1 + 736 | 0;
        HEAP32[$7_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$7_1 + 4 >> 2] = $3_1;
        $4_1 = $5_1 + 32 | 0;
        $3_1 = HEAP32[$4_1 + 4 >> 2];
        $23_1 = $6_1 + 744 | 0;
        HEAP32[$23_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$23_1 + 4 >> 2] = $3_1;
        HEAP32[$6_1 + 752 >> 2] = 0;
        $3_1 = HEAP32[$6_1 + 804 >> 2];
        HEAP32[$6_1 + 672 >> 2] = HEAP32[$6_1 + 800 >> 2];
        HEAP32[$6_1 + 676 >> 2] = $3_1;
        $3_1 = HEAP32[$6_1 + 764 >> 2];
        HEAP32[$6_1 + 712 >> 2] = HEAP32[$6_1 + 760 >> 2];
        HEAP32[$6_1 + 716 >> 2] = $3_1;
        $2_1 = HEAPU8[$2_1 | 0];
        if (($2_1 & 254) == 6) {
          $3_1 = 0;
          if ((HEAP8[$6_1 + 760 | 0] & 1) == (($2_1 | 0) != 7 | 0)) {
            break label$4;
          }
        }
        $2_1 = HEAP32[$6_1 + 716 >> 2];
        $28_1 = $2_1;
        $9_1 = HEAP32[$6_1 + 712 >> 2];
        $3_1 = $9_1;
        $2_1 = $2_1 << 1 | $3_1 >>> 31;
        $15_1 = $6_1 + 96 | 0;
        $10_1 = HEAP32[$7_1 >> 2];
        $11_1 = HEAP32[$7_1 + 4 >> 2];
        $24_1 = $3_1 << 1;
        $30_1 = $2_1;
        $69($15_1, $10_1, $11_1, 0, 0, $24_1, $2_1, 0, 0);
        $2_1 = HEAP32[$19_1 + 4 >> 2];
        $25_1 = $2_1;
        $26_1 = HEAP32[$19_1 >> 2];
        $4_1 = $26_1;
        $2_1 = $2_1 << 1 | $4_1 >>> 31;
        $12_1 = $6_1 + 160 | 0;
        $13_1 = HEAP32[$14_1 >> 2];
        $14_1 = HEAP32[$14_1 + 4 >> 2];
        $4_1 = $4_1 << 1;
        $5_1 = $2_1;
        $69($12_1, $13_1, $14_1, 0, 0, $4_1, $2_1, 0, 0);
        $19_1 = $6_1 + 288 | 0;
        $3_1 = HEAP32[$23_1 >> 2];
        $2_1 = HEAP32[$23_1 + 4 >> 2];
        $69($19_1, $3_1, $2_1, 0, 0, $3_1, $2_1, 0, 0);
        $7_1 = $6_1 + 272 | 0;
        $69($7_1, HEAP32[$6_1 + 288 >> 2], HEAP32[$6_1 + 292 >> 2], 0, 0, 15632, 16, 0, 0);
        $2_1 = $2_1 << 1 | $3_1 >>> 31;
        $33_1 = $6_1 + 128 | 0;
        $17_1 = $3_1 << 1;
        $23_1 = $2_1;
        $69($33_1, $17_1, $2_1, 0, 0, $9_1, $28_1, 0, 0);
        $34_1 = $6_1 + 144 | 0;
        $69($34_1, $10_1, $11_1, 0, 0, $4_1, $5_1, 0, 0);
        $35_1 = $6_1 + 224 | 0;
        $69($35_1, $13_1, $14_1, 0, 0, $13_1, $14_1, 0, 0);
        $16_1 = $6_1 + 256 | 0;
        $2_1 = $19_1 + 8 | 0;
        $69($16_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $43_1 = $6_1 + 112 | 0;
        $69($43_1, $9_1, $28_1, 0, 0, $9_1, $28_1, 0, 0);
        $31_1 = $6_1 + 192 | 0;
        $69($31_1, $17_1, $23_1, 0, 0, $26_1, $25_1, 0, 0);
        $38_1 = $6_1 + 240 | 0;
        $69($38_1, $10_1, $11_1, 0, 0, $13_1 << 1, $14_1 << 1 | $13_1 >>> 31, 0, 0);
        $28_1 = HEAP32[$6_1 + 100 >> 2];
        $2_1 = $28_1 + HEAP32[$6_1 + 164 >> 2] | 0;
        $8_1 = HEAP32[$6_1 + 96 >> 2];
        $3_1 = HEAP32[$6_1 + 160 >> 2];
        $5_1 = $8_1 + $3_1 | 0;
        $4_1 = HEAP32[$6_1 + 272 >> 2];
        $39_1 = $5_1 + $4_1 | 0;
        $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + HEAP32[$6_1 + 276 >> 2] | 0;
        $4_1 = $4_1 >>> 0 > $39_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $9_1 = ($3_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 > $39_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
        $2_1 = $7_1 + 8 | 0;
        $19_1 = HEAP32[$2_1 >> 2];
        $7_1 = HEAP32[$2_1 + 4 >> 2];
        $8_1 = ($3_1 | 0) == ($28_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $28_1 >>> 0;
        $5_1 = $12_1 + 8 | 0;
        $3_1 = HEAP32[$5_1 >> 2];
        $2_1 = $15_1 + 8 | 0;
        $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $8_1 + $12_1 | 0;
        $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $7_1 | 0;
        $5_1 = $3_1;
        $3_1 = $3_1 + $19_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $9_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $40_1 = $4_1;
        $19_1 = $3_1 << 12 | $4_1 >>> 20;
        $5_1 = $2_1;
        $8_1 = $2_1 << 12 | $3_1 >>> 20;
        $21_1 = HEAP32[$6_1 + 144 >> 2];
        $3_1 = HEAP32[$6_1 + 224 >> 2];
        $12_1 = $21_1 + $3_1 | 0;
        $32_1 = HEAP32[$6_1 + 148 >> 2];
        $2_1 = $32_1 + HEAP32[$6_1 + 228 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = HEAP32[$6_1 + 128 >> 2];
        $9_1 = $3_1 + $12_1 | 0;
        $15_1 = $2_1;
        $2_1 = $2_1 + HEAP32[$6_1 + 132 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = HEAP32[$6_1 + 256 >> 2];
        $7_1 = $3_1 + $9_1 | 0;
        $4_1 = $2_1;
        $2_1 = $2_1 + HEAP32[$6_1 + 260 >> 2] | 0;
        $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $8_1 | 0;
        $44_1 = $6_1 + 32 | 0;
        $29_1 = $44_1;
        $19_1 = $7_1 + $19_1 | 0;
        $8_1 = $19_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $27_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $19_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $22_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
        $2_1 = $16_1 + 8 | 0;
        $18_1 = HEAP32[$2_1 >> 2];
        $20_1 = HEAP32[$2_1 + 4 >> 2];
        $28_1 = ($4_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
        $2_1 = $33_1 + 8 | 0;
        $16_1 = HEAP32[$2_1 >> 2];
        $9_1 = HEAP32[$2_1 + 4 >> 2];
        $7_1 = ($15_1 | 0) == ($32_1 | 0) & $12_1 >>> 0 < $21_1 >>> 0 | $15_1 >>> 0 < $32_1 >>> 0;
        $4_1 = $35_1 + 8 | 0;
        $3_1 = HEAP32[$4_1 >> 2];
        $2_1 = $34_1 + 8 | 0;
        $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $7_1 + $12_1 | 0;
        $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $9_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $16_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1;
        $3_1 = $3_1 + $28_1 | 0;
        $2_1 = ($4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $18_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1 + $22_1 | 0;
        $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $5_1 >>> 20 | 0;
        $3_1 = $4_1 + $5_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $27_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $8_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $5_1 = $2_1;
        $8_1 = $2_1 << 12 | $3_1 >>> 20;
        $18_1 = HEAP32[$6_1 + 192 >> 2];
        $3_1 = HEAP32[$6_1 + 240 >> 2];
        $9_1 = $18_1 + $3_1 | 0;
        $22_1 = HEAP32[$6_1 + 196 >> 2];
        $2_1 = $22_1 + HEAP32[$6_1 + 244 >> 2] | 0;
        $3_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $8_1 | 0;
        $7_1 = $7_1 + $9_1 | 0;
        $2_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $15_1 = $7_1 << 4 & -16;
        $8_1 = $2_1;
        $12_1 = ($2_1 << 4 | $7_1 >>> 28) & 16777215;
        $28_1 = $4_1;
        $69($29_1, $15_1 | $4_1 >>> 16 & 15, $12_1, 0, 0, 977, 1, 0, 0);
        $45_1 = $6_1 + 16 | 0;
        $69($45_1, $26_1, $25_1, 0, 0, $24_1, $30_1, 0, 0);
        $20_1 = $6_1 + 208 | 0;
        $69($20_1, $17_1, $23_1, 0, 0, $13_1, $14_1, 0, 0);
        $16_1 = $6_1 + 320 | 0;
        $69($16_1, $10_1, $11_1, 0, 0, $10_1, $11_1, 0, 0);
        $46_1 = $6_1 + 80 | 0;
        $15_1 = $46_1;
        $12_1 = ($3_1 | 0) == ($2_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $2_1 >>> 0;
        $7_1 = ($3_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $22_1 >>> 0;
        $4_1 = $38_1 + 8 | 0;
        $3_1 = HEAP32[$4_1 >> 2];
        $2_1 = $31_1 + 8 | 0;
        $9_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $7_1 + $9_1 | 0;
        $2_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $5_1 >>> 20 | 0;
        $3_1 = $4_1 + $5_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $12_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $8_1 = $3_1 << 12 | $8_1 >>> 20;
        $4_1 = $2_1;
        $9_1 = $2_1 << 12 | $3_1 >>> 20;
        $18_1 = HEAP32[$6_1 + 212 >> 2];
        $2_1 = $18_1 + HEAP32[$6_1 + 324 >> 2] | 0;
        $12_1 = HEAP32[$6_1 + 208 >> 2];
        $3_1 = HEAP32[$6_1 + 320 >> 2];
        $5_1 = $12_1 + $3_1 | 0;
        $7_1 = $5_1;
        $8_1 = $5_1 + $8_1 | 0;
        $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $9_1 | 0;
        $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $69($15_1, $8_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $69($6_1, $13_1, $14_1, 0, 0, $24_1, $30_1, 0, 0);
        $47_1 = $6_1 + 176 | 0;
        $69($47_1, $26_1, $25_1, 0, 0, $26_1, $25_1, 0, 0);
        $9_1 = $6_1 + 304 | 0;
        $69($9_1, $17_1, $23_1, 0, 0, $10_1, $11_1, 0, 0);
        $48_1 = $6_1 - -64 | 0;
        $11_1 = $48_1;
        $14_1 = ($3_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
        $7_1 = ($3_1 | 0) == ($18_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $18_1 >>> 0;
        $8_1 = $16_1 + 8 | 0;
        $3_1 = HEAP32[$8_1 >> 2];
        $2_1 = $20_1 + 8 | 0;
        $10_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $8_1 = $7_1 + $10_1 | 0;
        $2_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1 + $8_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1;
        $3_1 = $3_1 + $14_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $8_1 = $3_1 << 12 | $5_1 >>> 20;
        $5_1 = HEAP32[$6_1 + 304 >> 2];
        $14_1 = $8_1 + $5_1 | 0;
        $4_1 = $2_1;
        $3_1 = $2_1 << 12 | $3_1 >>> 20;
        $2_1 = $3_1 + HEAP32[$6_1 + 308 >> 2] | 0;
        $2_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $69($11_1, $14_1, $2_1, 0, 0, 15632, 16, 0, 0);
        $49_1 = $6_1 + 48 | 0;
        $7_1 = $49_1;
        $8_1 = ($2_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 < $3_1 >>> 0;
        $2_1 = $9_1 + 8 | 0;
        $5_1 = HEAP32[$2_1 >> 2];
        $2_1 = HEAP32[$2_1 + 4 >> 2];
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1 + $5_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $8_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $69($7_1, $3_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
        $2_1 = HEAP32[$6_1 + 676 >> 2];
        $13_1 = $2_1;
        $11_1 = HEAP32[$6_1 + 672 >> 2];
        $3_1 = $11_1;
        $2_1 = $2_1 << 1 | $3_1 >>> 31;
        $9_1 = $6_1 + 432 | 0;
        $16_1 = HEAP32[$6_1 + 696 >> 2];
        $15_1 = HEAP32[$6_1 + 700 >> 2];
        $27_1 = $3_1 << 1;
        $29_1 = $2_1;
        $69($9_1, $16_1, $15_1, 0, 0, $27_1, $2_1, 0, 0);
        $2_1 = HEAP32[$6_1 + 684 >> 2];
        $42_1 = $2_1;
        $41_1 = HEAP32[$6_1 + 680 >> 2];
        $4_1 = $41_1;
        $2_1 = $2_1 << 1 | $4_1 >>> 31;
        $10_1 = $6_1 + 496 | 0;
        $18_1 = HEAP32[$6_1 + 688 >> 2];
        $17_1 = HEAP32[$6_1 + 692 >> 2];
        $4_1 = $4_1 << 1;
        $5_1 = $2_1;
        $69($10_1, $18_1, $17_1, 0, 0, $4_1, $2_1, 0, 0);
        $14_1 = $6_1 + 624 | 0;
        $3_1 = HEAP32[$6_1 + 704 >> 2];
        $2_1 = HEAP32[$6_1 + 708 >> 2];
        $69($14_1, $3_1, $2_1, 0, 0, $3_1, $2_1, 0, 0);
        $7_1 = $6_1 + 608 | 0;
        $69($7_1, HEAP32[$6_1 + 624 >> 2], HEAP32[$6_1 + 628 >> 2], 0, 0, 15632, 16, 0, 0);
        $2_1 = $2_1 << 1 | $3_1 >>> 31;
        $26_1 = $6_1 + 464 | 0;
        $38_1 = $3_1 << 1;
        $22_1 = $2_1;
        $69($26_1, $38_1, $2_1, 0, 0, $11_1, $13_1, 0, 0);
        $32_1 = $6_1 + 480 | 0;
        $69($32_1, $16_1, $15_1, 0, 0, $4_1, $5_1, 0, 0);
        $33_1 = $6_1 + 560 | 0;
        $69($33_1, $18_1, $17_1, 0, 0, $18_1, $17_1, 0, 0);
        $12_1 = $6_1 + 592 | 0;
        $2_1 = $14_1 + 8 | 0;
        $69($12_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $50_1 = $6_1 + 448 | 0;
        $69($50_1, $11_1, $13_1, 0, 0, $11_1, $13_1, 0, 0);
        $36_1 = $6_1 + 528 | 0;
        $69($36_1, $38_1, $22_1, 0, 0, $41_1, $42_1, 0, 0);
        $37_1 = $6_1 + 576 | 0;
        $69($37_1, $16_1, $15_1, 0, 0, $18_1 << 1, $17_1 << 1 | $18_1 >>> 31, 0, 0);
        $13_1 = HEAP32[$6_1 + 436 >> 2];
        $2_1 = $13_1 + HEAP32[$6_1 + 500 >> 2] | 0;
        $8_1 = HEAP32[$6_1 + 432 >> 2];
        $3_1 = HEAP32[$6_1 + 496 >> 2];
        $4_1 = $8_1 + $3_1 | 0;
        $5_1 = HEAP32[$6_1 + 608 >> 2];
        $30_1 = $4_1 + $5_1 | 0;
        $3_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + HEAP32[$6_1 + 612 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $30_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $11_1 = ($3_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $30_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
        $2_1 = $7_1 + 8 | 0;
        $14_1 = HEAP32[$2_1 >> 2];
        $7_1 = HEAP32[$2_1 + 4 >> 2];
        $8_1 = ($3_1 | 0) == ($13_1 | 0) & $4_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0;
        $4_1 = $10_1 + 8 | 0;
        $3_1 = HEAP32[$4_1 >> 2];
        $2_1 = $9_1 + 8 | 0;
        $10_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $8_1 + $10_1 | 0;
        $2_1 = ($3_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $7_1 | 0;
        $4_1 = $3_1;
        $3_1 = $3_1 + $14_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1;
        $3_1 = $3_1 + $11_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $24_1 = $5_1;
        $14_1 = $3_1 << 12 | $5_1 >>> 20;
        $4_1 = $2_1;
        $8_1 = $2_1 << 12 | $3_1 >>> 20;
        $34_1 = HEAP32[$6_1 + 480 >> 2];
        $3_1 = HEAP32[$6_1 + 560 >> 2];
        $11_1 = $34_1 + $3_1 | 0;
        $25_1 = HEAP32[$6_1 + 484 >> 2];
        $2_1 = $25_1 + HEAP32[$6_1 + 564 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = HEAP32[$6_1 + 464 >> 2];
        $7_1 = $3_1 + $11_1 | 0;
        $9_1 = $2_1;
        $2_1 = $2_1 + HEAP32[$6_1 + 468 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = HEAP32[$6_1 + 592 >> 2];
        $5_1 = $3_1 + $7_1 | 0;
        $10_1 = $2_1;
        $2_1 = $2_1 + HEAP32[$6_1 + 596 >> 2] | 0;
        $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $8_1 | 0;
        $35_1 = $6_1 + 368 | 0;
        $14_1 = $5_1 + $14_1 | 0;
        $8_1 = $14_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $31_1 = ($3_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $14_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $21_1 = ($3_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $3_1 >>> 0 < $10_1 >>> 0;
        $2_1 = $12_1 + 8 | 0;
        $20_1 = HEAP32[$2_1 >> 2];
        $23_1 = HEAP32[$2_1 + 4 >> 2];
        $13_1 = ($9_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $9_1 >>> 0 > $10_1 >>> 0;
        $2_1 = $26_1 + 8 | 0;
        $12_1 = HEAP32[$2_1 >> 2];
        $10_1 = HEAP32[$2_1 + 4 >> 2];
        $7_1 = ($9_1 | 0) == ($25_1 | 0) & $11_1 >>> 0 < $34_1 >>> 0 | $9_1 >>> 0 < $25_1 >>> 0;
        $5_1 = $33_1 + 8 | 0;
        $3_1 = HEAP32[$5_1 >> 2];
        $2_1 = $32_1 + 8 | 0;
        $11_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $7_1 + $11_1 | 0;
        $2_1 = ($3_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
        $5_1 = $3_1;
        $3_1 = $3_1 + $12_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $13_1 | 0;
        $2_1 = ($5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $23_1 | 0;
        $5_1 = $3_1;
        $3_1 = $3_1 + $20_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1 + $21_1 | 0;
        $2_1 = $5_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1 + $5_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $31_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $8_1;
        $7_1 = $3_1 << 12 | $4_1 >>> 20;
        $5_1 = $2_1;
        $11_1 = $2_1 << 12 | $3_1 >>> 20;
        $21_1 = HEAP32[$6_1 + 532 >> 2];
        $2_1 = $21_1 + HEAP32[$6_1 + 580 >> 2] | 0;
        $13_1 = HEAP32[$6_1 + 528 >> 2];
        $3_1 = HEAP32[$6_1 + 576 >> 2];
        $8_1 = $13_1 + $3_1 | 0;
        $9_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $11_1 | 0;
        $10_1 = $7_1 << 4 & -16;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $11_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
        $23_1 = $4_1;
        $69($35_1, $10_1 | $4_1 >>> 16 & 15, $11_1, 0, 0, 977, 1, 0, 0);
        $11_1 = HEAP32[$6_1 + 372 >> 2];
        $2_1 = $11_1 + HEAP32[$6_1 + 452 >> 2] | 0;
        $31_1 = HEAP32[$6_1 + 368 >> 2];
        $4_1 = HEAP32[$6_1 + 448 >> 2];
        $10_1 = $31_1 + $4_1 | 0;
        HEAP32[$6_1 + 840 >> 2] = $10_1;
        $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        HEAP32[$6_1 + 844 >> 2] = $4_1 & 1048575;
        $25_1 = $6_1 + 352 | 0;
        $69($25_1, $41_1, $42_1, 0, 0, $27_1, $29_1, 0, 0);
        $26_1 = $6_1 + 544 | 0;
        $69($26_1, $38_1, $22_1, 0, 0, $18_1, $17_1, 0, 0);
        $32_1 = $6_1 + 656 | 0;
        $69($32_1, $16_1, $15_1, 0, 0, $16_1, $15_1, 0, 0);
        $33_1 = $6_1 + 416 | 0;
        $20_1 = $33_1;
        $12_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $9_1 = ($3_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $21_1 >>> 0;
        $7_1 = $37_1 + 8 | 0;
        $3_1 = HEAP32[$7_1 >> 2];
        $2_1 = $36_1 + 8 | 0;
        $13_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $9_1 + $13_1 | 0;
        $2_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $5_1 >>> 20 | 0;
        $3_1 = $5_1 + $7_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $12_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $9_1 = $3_1 << 12 | $8_1 >>> 20;
        $7_1 = $2_1;
        $8_1 = $2_1 << 12 | $3_1 >>> 20;
        $36_1 = HEAP32[$6_1 + 548 >> 2];
        $2_1 = $36_1 + HEAP32[$6_1 + 660 >> 2] | 0;
        $34_1 = HEAP32[$6_1 + 544 >> 2];
        $5_1 = HEAP32[$6_1 + 656 >> 2];
        $3_1 = $34_1 + $5_1 | 0;
        $21_1 = $3_1;
        $13_1 = $3_1 + $9_1 | 0;
        $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $5_1 + $8_1 | 0;
        $9_1 = $13_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $69($20_1, $13_1, $9_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $10_1 = ($4_1 | 0) == ($11_1 | 0) & $10_1 >>> 0 < $31_1 >>> 0 | $4_1 >>> 0 < $11_1 >>> 0;
        $8_1 = $50_1 + 8 | 0;
        $3_1 = HEAP32[$8_1 >> 2];
        $2_1 = $35_1 + 8 | 0;
        $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $10_1 + $12_1 | 0;
        $2_1 = $3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $12_1 = $3_1 << 12 | $4_1 >>> 20;
        $8_1 = $2_1;
        $10_1 = $2_1 << 12 | $3_1 >>> 20;
        $35_1 = HEAP32[$6_1 + 416 >> 2];
        $3_1 = HEAP32[$6_1 + 352 >> 2];
        $20_1 = $35_1 + $3_1 | 0;
        $37_1 = HEAP32[$6_1 + 420 >> 2];
        $2_1 = $37_1 + HEAP32[$6_1 + 356 >> 2] | 0;
        $4_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $4_1 + $10_1 | 0;
        $12_1 = $12_1 + $20_1 | 0;
        $2_1 = $12_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        HEAP32[$6_1 + 848 >> 2] = $12_1;
        $10_1 = $2_1;
        HEAP32[$6_1 + 852 >> 2] = $2_1 & 1048575;
        $31_1 = $6_1 + 336 | 0;
        $69($31_1, $18_1, $17_1, 0, 0, $27_1, $29_1, 0, 0);
        $29_1 = $6_1 + 512 | 0;
        $69($29_1, $41_1, $42_1, 0, 0, $41_1, $42_1, 0, 0);
        $27_1 = $6_1 + 640 | 0;
        $69($27_1, $38_1, $22_1, 0, 0, $16_1, $15_1, 0, 0);
        $18_1 = $6_1 + 400 | 0;
        $16_1 = $18_1;
        $17_1 = ($5_1 | 0) == ($9_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 > $9_1 >>> 0;
        $13_1 = ($5_1 | 0) == ($36_1 | 0) & $21_1 >>> 0 < $34_1 >>> 0 | $5_1 >>> 0 < $36_1 >>> 0;
        $5_1 = $32_1 + 8 | 0;
        $3_1 = HEAP32[$5_1 >> 2];
        $2_1 = $26_1 + 8 | 0;
        $15_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $13_1 + $15_1 | 0;
        $2_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $7_1 >>> 20 | 0;
        $3_1 = $5_1 + $7_1 | 0;
        $2_1 = $7_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $17_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $15_1 = $3_1 << 12 | $9_1 >>> 20;
        $7_1 = HEAP32[$6_1 + 640 >> 2];
        $9_1 = $15_1 + $7_1 | 0;
        $5_1 = $2_1;
        $21_1 = $2_1 << 12 | $3_1 >>> 20;
        $2_1 = $21_1 + HEAP32[$6_1 + 644 >> 2] | 0;
        $13_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $69($16_1, $9_1, $13_1, 0, 0, 15632, 16, 0, 0);
        $12_1 = ($4_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
        $11_1 = ($4_1 | 0) == ($37_1 | 0) & $20_1 >>> 0 < $35_1 >>> 0 | $4_1 >>> 0 < $37_1 >>> 0;
        $4_1 = $25_1 + 8 | 0;
        $3_1 = HEAP32[$4_1 >> 2];
        $2_1 = $33_1 + 8 | 0;
        $17_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $11_1 + $17_1 | 0;
        $2_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $8_1 = $8_1 >>> 20 | 0;
        $3_1 = $4_1 + $8_1 | 0;
        $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1;
        $3_1 = $3_1 + $12_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $11_1 = $3_1 << 12 | $10_1 >>> 20;
        $4_1 = $2_1;
        $8_1 = $2_1 << 12 | $3_1 >>> 20;
        $20_1 = HEAP32[$6_1 + 336 >> 2];
        $3_1 = HEAP32[$6_1 + 512 >> 2];
        $12_1 = $20_1 + $3_1 | 0;
        $22_1 = HEAP32[$6_1 + 340 >> 2];
        $2_1 = $22_1 + HEAP32[$6_1 + 516 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = HEAP32[$6_1 + 400 >> 2];
        $10_1 = $3_1 + $12_1 | 0;
        $17_1 = $2_1;
        $2_1 = $2_1 + HEAP32[$6_1 + 404 >> 2] | 0;
        $3_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $8_1 | 0;
        $11_1 = $11_1 + $10_1 | 0;
        $2_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        HEAP32[$6_1 + 856 >> 2] = $11_1;
        $8_1 = $2_1;
        HEAP32[$6_1 + 860 >> 2] = $2_1 & 1048575;
        $16_1 = $6_1 + 384 | 0;
        $15_1 = ($13_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $13_1 >>> 0 < $21_1 >>> 0;
        $2_1 = $27_1 + 8 | 0;
        $13_1 = HEAP32[$2_1 >> 2];
        $2_1 = HEAP32[$2_1 + 4 >> 2];
        $5_1 = $5_1 >>> 20 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $13_1 | 0;
        $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $15_1 | 0;
        $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $69($16_1, $5_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
        $15_1 = ($3_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $10_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $13_1 = ($3_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $17_1 >>> 0;
        $2_1 = $18_1 + 8 | 0;
        $9_1 = HEAP32[$2_1 >> 2];
        $10_1 = HEAP32[$2_1 + 4 >> 2];
        $11_1 = ($17_1 | 0) == ($22_1 | 0) & $12_1 >>> 0 < $20_1 >>> 0 | $17_1 >>> 0 < $22_1 >>> 0;
        $7_1 = $29_1 + 8 | 0;
        $3_1 = HEAP32[$7_1 >> 2];
        $2_1 = $31_1 + 8 | 0;
        $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $11_1 + $12_1 | 0;
        $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
        $5_1 = $3_1;
        $3_1 = $3_1 + $9_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $3_1 + $13_1 | 0;
        $2_1 = $7_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1 + $7_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $15_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $3_1 << 12 | $8_1 >>> 20;
        $4_1 = $2_1;
        $10_1 = $2_1 << 12 | $3_1 >>> 20;
        $12_1 = HEAP32[$6_1 + 384 >> 2];
        $8_1 = $30_1 & -2;
        $3_1 = $12_1 + $8_1 | 0;
        $13_1 = HEAP32[$6_1 + 388 >> 2];
        $2_1 = $13_1 + ($24_1 & 1048575) | 0;
        $11_1 = $3_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $11_1 + $10_1 | 0;
        $5_1 = $7_1;
        $7_1 = $3_1;
        $8_1 = $5_1 + $3_1 | 0;
        HEAP32[$6_1 + 864 >> 2] = $8_1;
        $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        HEAP32[$6_1 + 868 >> 2] = $3_1 & 1048575;
        $9_1 = $23_1 & 65535;
        $10_1 = ($3_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 < $11_1 >>> 0;
        $5_1 = ($11_1 | 0) == ($13_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $11_1 >>> 0 < $13_1 >>> 0;
        $2_1 = $16_1 + 8 | 0;
        $8_1 = $5_1 + HEAP32[$2_1 >> 2] | 0;
        $2_1 = HEAP32[$2_1 + 4 >> 2];
        $2_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $4_1 >>> 20 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + $8_1 | 0;
        $2_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $4_1;
        $4_1 = $4_1 + $10_1 | 0;
        $2_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $4_1 << 12 | $3_1 >>> 20;
        $5_1 = $3_1 + $14_1 | 0;
        $2_1 = $9_1 + ($2_1 << 12 | $4_1 >>> 20) | 0;
        HEAP32[$6_1 + 872 >> 2] = $5_1;
        HEAP32[$6_1 + 876 >> 2] = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $43_1 + 8 | 0;
        $7_1 = HEAP32[$2_1 >> 2];
        $8_1 = HEAP32[$2_1 + 4 >> 2];
        $2_1 = $44_1 + 8 | 0;
        $32_1 = HEAP32[$2_1 >> 2];
        $4_1 = HEAP32[$2_1 + 4 >> 2];
        $5_1 = HEAP32[$6_1 + 112 >> 2];
        $3_1 = HEAP32[$6_1 + 116 >> 2];
        $13_1 = HEAP32[$6_1 + 32 >> 2];
        $36_1 = HEAP32[$6_1 + 36 >> 2];
        $2_1 = $45_1 + 8 | 0;
        $20_1 = HEAP32[$2_1 >> 2];
        $16_1 = HEAP32[$2_1 + 4 >> 2];
        $2_1 = $46_1 + 8 | 0;
        $33_1 = HEAP32[$2_1 >> 2];
        $24_1 = HEAP32[$2_1 + 4 >> 2];
        $18_1 = HEAP32[$6_1 + 16 >> 2];
        $12_1 = HEAP32[$6_1 + 20 >> 2];
        $34_1 = HEAP32[$6_1 + 80 >> 2];
        $37_1 = HEAP32[$6_1 + 84 >> 2];
        $2_1 = $47_1 + 8 | 0;
        $15_1 = HEAP32[$2_1 >> 2];
        $17_1 = HEAP32[$2_1 + 4 >> 2];
        $2_1 = $6_1 + 8 | 0;
        $35_1 = HEAP32[$2_1 >> 2];
        $30_1 = HEAP32[$2_1 + 4 >> 2];
        $21_1 = HEAP32[$6_1 + 176 >> 2];
        $9_1 = HEAP32[$6_1 + 180 >> 2];
        $29_1 = HEAP32[$6_1 >> 2];
        $25_1 = HEAP32[$6_1 + 4 >> 2];
        $2_1 = $48_1 + 8 | 0;
        $11_1 = HEAP32[$2_1 >> 2];
        $14_1 = HEAP32[$2_1 + 4 >> 2];
        $27_1 = HEAP32[$6_1 + 64 >> 2];
        $10_1 = HEAP32[$6_1 + 68 >> 2];
        $31_1 = HEAP32[$6_1 + 48 >> 2];
        $26_1 = HEAP32[$6_1 + 52 >> 2];
        $2_1 = $49_1 + 8 | 0;
        $38_1 = HEAP32[$2_1 >> 2];
        $23_1 = HEAP32[$2_1 + 4 >> 2];
        $2_1 = $6_1 + 840 | 0;
        $34($2_1, $2_1, $6_1 + 672 | 0);
        $2_1 = $3_1 + $36_1 | 0;
        $3_1 = $5_1 + $13_1 | 0;
        $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $22_1 = $3_1;
        $3_1 = ($36_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $36_1 >>> 0;
        $2_1 = $4_1 + $8_1 | 0;
        $4_1 = $7_1 + $32_1 | 0;
        $2_1 = $4_1 >>> 0 < $32_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $3_1 = $3_1 + $4_1 | 0;
        $2_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $13_1 = $5_1;
        $7_1 = $3_1 << 12 | $5_1 >>> 20;
        $4_1 = $2_1;
        $8_1 = $2_1 << 12 | $3_1 >>> 20;
        $2_1 = $12_1 + $37_1 | 0;
        $5_1 = $18_1 + $34_1 | 0;
        $3_1 = $5_1 >>> 0 < $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $8_1 | 0;
        $18_1 = $5_1 + $7_1 | 0;
        $8_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = ($3_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $3_1 = ($3_1 | 0) == ($37_1 | 0) & $5_1 >>> 0 < $34_1 >>> 0 | $3_1 >>> 0 < $37_1 >>> 0;
        $2_1 = $16_1 + $24_1 | 0;
        $5_1 = $20_1 + $33_1 | 0;
        $2_1 = $5_1 >>> 0 < $33_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $20_1 = $5_1;
        $5_1 = $3_1 + $5_1 | 0;
        $2_1 = $20_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1 + $5_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $7_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $12_1 = $8_1;
        $24_1 = $3_1 << 12 | $8_1 >>> 20;
        $5_1 = $2_1;
        $7_1 = $2_1 << 12 | $3_1 >>> 20;
        $2_1 = $9_1 + $25_1 | 0;
        $3_1 = $21_1 + $29_1 | 0;
        $4_1 = $3_1 >>> 0 < $21_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $10_1 + $4_1 | 0;
        $10_1 = $3_1;
        $8_1 = $3_1 + $27_1 | 0;
        $3_1 = $8_1 >>> 0 < $27_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $7_1 | 0;
        $9_1 = $8_1;
        $7_1 = $8_1 + $24_1 | 0;
        $8_1 = $8_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $20_1 = $7_1;
        $24_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $2_1 = $4_1;
        $9_1 = ($2_1 | 0) == ($3_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
        $4_1 = $11_1;
        $3_1 = $14_1;
        $7_1 = ($2_1 | 0) == ($25_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $2_1 >>> 0 < $25_1 >>> 0;
        $2_1 = $17_1 + $30_1 | 0;
        $14_1 = $15_1 + $35_1 | 0;
        $2_1 = $14_1 >>> 0 < $35_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $7_1 = $7_1 + $14_1 | 0;
        $2_1 = ($7_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $3_1 | 0;
        $3_1 = $4_1 + $7_1 | 0;
        $2_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1 + $9_1 | 0;
        $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $5_1 >>> 20 | 0;
        $3_1 = $4_1 + $5_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $3_1;
        $3_1 = $3_1 + $24_1 | 0;
        $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $9_1 = $8_1;
        $8_1 = $3_1 << 12 | $8_1 >>> 20;
        $4_1 = $2_1;
        $5_1 = $2_1 << 12 | $3_1 >>> 20;
        $3_1 = $39_1 & -2;
        $16_1 = $3_1 + $31_1 | 0;
        $2_1 = $26_1 + ($40_1 & 1048575) | 0;
        $3_1 = $3_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $2_1 = $3_1 + $5_1 | 0;
        $5_1 = $8_1 + $16_1 | 0;
        $2_1 = $5_1 >>> 0 < $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $40_1 = $5_1;
        $8_1 = $2_1;
        $21_1 = HEAP32[$6_1 + 864 >> 2];
        $29_1 = HEAP32[$6_1 + 868 >> 2];
        $27_1 = HEAP32[$6_1 + 856 >> 2];
        $30_1 = HEAP32[$6_1 + 860 >> 2];
        $24_1 = HEAP32[$6_1 + 848 >> 2];
        $10_1 = HEAP32[$6_1 + 852 >> 2];
        $7_1 = HEAP32[$6_1 + 844 >> 2];
        $14_1 = HEAP32[$6_1 + 872 >> 2];
        $5_1 = HEAP32[$6_1 + 876 >> 2];
        $39_1 = $5_1;
        $2_1 = HEAP32[$6_1 + 840 >> 2];
        $5_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
        $11_1 = $2_1 + $5_1 | 0;
        $2_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
        $2_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $5_1 = $11_1 + 7 | 0;
        $2_1 = $5_1 >>> 0 < 7 ? $2_1 + 1 | 0 : $2_1;
        $15_1 = $5_1;
        $7_1 = $2_1;
        $2_1 = $10_1;
        $5_1 = $7_1 >>> 20 | 0;
        $10_1 = $5_1;
        $5_1 = $5_1 + $24_1 | 0;
        $2_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $17_1 = $5_1;
        $10_1 = $2_1;
        $2_1 = $30_1;
        $5_1 = $10_1 >>> 20 | 0;
        $11_1 = $5_1;
        $5_1 = $5_1 + $27_1 | 0;
        $2_1 = $11_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $30_1 = $5_1;
        $11_1 = $2_1;
        $2_1 = $29_1;
        $5_1 = $11_1 >>> 20 | 0;
        $29_1 = $5_1;
        $5_1 = $5_1 + $21_1 | 0;
        $2_1 = $29_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $24_1 = $5_1;
        $5_1 = $2_1;
        $27_1 = $15_1 - $22_1 | 0;
        $22_1 = ($7_1 & 1048575) - (($13_1 & 1048575) + ($15_1 >>> 0 < $22_1 >>> 0) | 0) | 0;
        $39_1 = $39_1 & 65535;
        $15_1 = $28_1 & 65535;
        $13_1 = ($3_1 | 0) == ($8_1 | 0) & $16_1 >>> 0 > $40_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $3_1 = ($3_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $31_1 >>> 0 | $3_1 >>> 0 < $26_1 >>> 0;
        $7_1 = $3_1 + $38_1 | 0;
        $2_1 = $23_1;
        $2_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $4_1 >>> 20 | 0;
        $3_1 = $4_1 + $7_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1;
        $3_1 = $3_1 + $13_1 | 0;
        $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $3_1 << 12 | $8_1 >>> 20;
        $7_1 = $4_1 + $19_1 | 0;
        $2_1 = $15_1 + ($2_1 << 12 | $3_1 >>> 20) | 0;
        $2_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = $14_1 - $7_1 | 0;
        $2_1 = $39_1 - (($7_1 >>> 0 > $14_1 >>> 0) + $2_1 | 0) | 0;
        $7_1 = $5_1 >>> 20 | 0;
        $3_1 = $4_1 + $7_1 | 0;
        $2_1 = ($7_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 262143 | 0;
        $3_1 = $3_1 - 4 | 0;
        $14_1 = $3_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
        $4_1 = __wasm_i64_mul($14_1 >>> 16 | 0, 0, 977, 1);
        $7_1 = $4_1 + $27_1 | 0;
        $2_1 = $22_1 + i64toi32_i32$HIGH_BITS | 0;
        $2_1 = ($4_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194299 | 0;
        $4_1 = $7_1 - 3908 | 0;
        $2_1 = $4_1 >>> 0 < 4294963388 ? $2_1 + 1 | 0 : $2_1;
        $28_1 = $4_1 ^ 976;
        $7_1 = $2_1 & 1048575;
        $16_1 = $7_1 ^ 1;
        if ((($28_1 | 0) != -1 | ($16_1 | 0) != 1048575) & ($4_1 | $7_1) != 0) {
          $3_1 = 0;
        } else {
          $15_1 = $24_1 - $40_1 | 0;
          $23_1 = ($5_1 & 1048575) - (($8_1 & 1048575) + ($24_1 >>> 0 < $40_1 >>> 0) | 0) | 0;
          $13_1 = $30_1 - $20_1 | 0;
          $19_1 = ($11_1 & 1048575) - (($9_1 & 1048575) + ($20_1 >>> 0 > $30_1 >>> 0) | 0) | 0;
          $4_1 = $2_1;
          $2_1 = ($10_1 & 1048575) - (($12_1 & 1048575) + ($17_1 >>> 0 < $18_1 >>> 0) | 0) | 0;
          $4_1 = $4_1 >>> 20 | 0;
          $5_1 = $4_1;
          $4_1 = $4_1 + ($17_1 - $18_1 | 0) | 0;
          $2_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
          $7_1 = $4_1 - 4 | 0;
          $8_1 = $7_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $19_1;
          $4_1 = $8_1 >>> 20 | 0;
          $5_1 = $4_1;
          $4_1 = $4_1 + $13_1 | 0;
          $2_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
          $5_1 = $4_1 - 4 | 0;
          $4_1 = $5_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $23_1;
          $19_1 = $4_1 >>> 20 | 0;
          $9_1 = $19_1;
          $19_1 = $15_1 + $19_1 | 0;
          $2_1 = ($9_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
          $19_1 = $19_1 - 4 | 0;
          $2_1 = $19_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = $19_1 & ($7_1 & $28_1 & $5_1);
          $8_1 = $2_1 & ($8_1 & $16_1 & $4_1);
          $4_1 = $3_1;
          $3_1 = $2_1;
          $2_1 = $14_1 & 65535;
          $3_1 = $3_1 >>> 20 | 0;
          $5_1 = $3_1;
          $3_1 = $3_1 + $4_1 | 0;
          $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $3_1 = ($3_1 & $7_1) == -1 & ($8_1 & ($2_1 ^ 983040)) == 1048575;
        }
      }
      if (!$3_1) {
        break label$1;
      }
      $35($1_1, $6_1 + 672 | 0);
      $0_1 = 1;
    }
    global$0 = $6_1 + 880 | 0;
    return $0_1;
  }
  function $32($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0;
    $4_1 = $0_1;
    $2_1 = HEAPU8[$1_1 + 30 | 0];
    $0_1 = $2_1 >>> 24 | 0;
    $3_1 = HEAPU8[$1_1 + 31 | 0] | $2_1 << 8;
    $2_1 = $0_1;
    $5_1 = HEAPU8[$1_1 + 29 | 0];
    $0_1 = $5_1 >>> 16 | 0;
    $5_1 = $5_1 << 16 | $3_1;
    $3_1 = $0_1 | $2_1;
    $2_1 = HEAPU8[$1_1 + 28 | 0];
    $0_1 = $2_1 >>> 8 | 0;
    $2_1 = $2_1 << 24 | $5_1;
    $0_1 = HEAPU8[$1_1 + 27 | 0] | ($0_1 | $3_1) | HEAPU8[$1_1 + 26 | 0] << 8 | (HEAPU8[$1_1 + 25 | 0] & 15) << 16;
    $5_1 = $0_1;
    $13_1 = $2_1;
    HEAP32[$4_1 >> 2] = $2_1;
    HEAP32[$4_1 + 4 >> 2] = $0_1;
    $2_1 = HEAPU8[$1_1 + 24 | 0];
    $0_1 = $2_1 >>> 28 | 0;
    $6_1 = $2_1 << 4 | HEAPU8[$1_1 + 25 | 0] >>> 4;
    $2_1 = $0_1;
    $3_1 = HEAPU8[$1_1 + 23 | 0];
    $0_1 = $3_1 >>> 20 | 0;
    $3_1 = $3_1 << 12 | $6_1;
    $6_1 = $0_1 | $2_1;
    $2_1 = HEAPU8[$1_1 + 22 | 0];
    $0_1 = $2_1 >>> 12 | 0;
    $3_1 = $2_1 << 20 | $3_1;
    $6_1 = $0_1 | $6_1;
    $2_1 = HEAPU8[$1_1 + 21 | 0];
    $0_1 = $2_1 >>> 4 | 0;
    $2_1 = $2_1 << 28 | $3_1;
    $3_1 = $0_1 | $6_1 | HEAPU8[$1_1 + 20 | 0] << 4;
    $0_1 = HEAPU8[$1_1 + 19 | 0] << 12;
    $6_1 = $2_1;
    HEAP32[$4_1 + 8 >> 2] = $2_1;
    $10_1 = $0_1 | $3_1;
    HEAP32[$4_1 + 12 >> 2] = $10_1;
    $2_1 = HEAPU8[$1_1 + 17 | 0];
    $0_1 = $2_1 >>> 24 | 0;
    $8_1 = HEAPU8[$1_1 + 18 | 0] | $2_1 << 8;
    $2_1 = $0_1;
    $3_1 = HEAPU8[$1_1 + 16 | 0];
    $0_1 = $3_1 >>> 16 | 0;
    $3_1 = $3_1 << 16 | $8_1;
    $8_1 = $0_1 | $2_1;
    $2_1 = HEAPU8[$1_1 + 15 | 0];
    $0_1 = $2_1 >>> 8 | 0;
    $2_1 = $2_1 << 24 | $3_1;
    $3_1 = HEAPU8[$1_1 + 14 | 0] | ($0_1 | $8_1) | HEAPU8[$1_1 + 13 | 0] << 8;
    $0_1 = (HEAPU8[$1_1 + 12 | 0] & 15) << 16;
    $8_1 = $2_1;
    HEAP32[$4_1 + 16 >> 2] = $2_1;
    $11_1 = $0_1 | $3_1;
    HEAP32[$4_1 + 20 >> 2] = $11_1;
    $2_1 = HEAPU8[$1_1 + 11 | 0];
    $0_1 = $2_1 >>> 28 | 0;
    $7_1 = $2_1 << 4 | HEAPU8[$1_1 + 12 | 0] >>> 4;
    $2_1 = $0_1;
    $3_1 = HEAPU8[$1_1 + 10 | 0];
    $0_1 = $3_1 >>> 20 | 0;
    $3_1 = $3_1 << 12 | $7_1;
    $7_1 = $0_1 | $2_1;
    $2_1 = HEAPU8[$1_1 + 9 | 0];
    $0_1 = $2_1 >>> 12 | 0;
    $3_1 = $2_1 << 20 | $3_1;
    $7_1 = $0_1 | $7_1;
    $2_1 = HEAPU8[$1_1 + 8 | 0];
    $0_1 = $2_1 >>> 4 | 0;
    $2_1 = $2_1 << 28 | $3_1;
    $3_1 = $0_1 | $7_1 | HEAPU8[$1_1 + 7 | 0] << 4;
    $0_1 = HEAPU8[$1_1 + 6 | 0] << 12;
    $7_1 = $2_1;
    HEAP32[$4_1 + 24 >> 2] = $2_1;
    $12_1 = $0_1 | $3_1;
    HEAP32[$4_1 + 28 >> 2] = $12_1;
    $2_1 = HEAPU8[$1_1 + 4 | 0];
    $0_1 = $2_1 >>> 24 | 0;
    $9_1 = HEAPU8[$1_1 + 5 | 0] | $2_1 << 8;
    $2_1 = $0_1;
    $3_1 = HEAPU8[$1_1 + 3 | 0];
    $0_1 = $3_1 >>> 16 | 0;
    $3_1 = $3_1 << 16 | $9_1;
    $9_1 = $0_1 | $2_1;
    $2_1 = HEAPU8[$1_1 + 2 | 0];
    $0_1 = $2_1 >>> 8 | 0;
    $2_1 = $2_1 << 24 | $3_1;
    $3_1 = HEAPU8[$1_1 + 1 | 0] | ($0_1 | $9_1);
    $0_1 = HEAPU8[$1_1 | 0] << 8;
    HEAP32[$4_1 + 32 >> 2] = $2_1;
    $0_1 = $0_1 | $3_1;
    HEAP32[$4_1 + 36 >> 2] = $0_1;
    return ($6_1 & $8_1 & $7_1) != -1 | ($10_1 & $11_1 & $12_1) != 1048575 | (($2_1 | 0) != -1 | ($0_1 | 0) != 65535) | (($5_1 | 0) == 1048574 & $13_1 >>> 0 < 4294966319 | $5_1 >>> 0 < 1048574);
  }
  function $33($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0;
    $6_1 = global$0 - 7616 | 0;
    global$0 = $6_1;
    $5_1 = $1_1 + 32 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $0_1 + 32 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $1_1 + 24 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $0_1 + 24 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $1_1 + 16 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $0_1 + 16 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $1_1 + 8 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $0_1 + 8 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$0_1 + 4 >> 2] = $3_1;
    $3_1 = $6_1 + 7096 | 0;
    $54($3_1, $1_1);
    $41_1 = $6_1 + 7056 | 0;
    $34($41_1, $1_1, $3_1);
    HEAP32[$0_1 + 80 >> 2] = 0;
    $3_1 = HEAP32[$6_1 + 7060 >> 2];
    $4_1 = HEAP32[$6_1 + 7056 >> 2] + 7 | 0;
    $1_1 = $4_1 >>> 0 < 7 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1;
    HEAP32[$6_1 + 7056 >> 2] = $3_1;
    HEAP32[$6_1 + 7060 >> 2] = $1_1;
    $13_1 = $6_1 + 6848 | 0;
    $21_1 = HEAP32[$6_1 + 7080 >> 2];
    $17_1 = HEAP32[$6_1 + 7084 >> 2];
    $28_1 = $3_1 << 1;
    $7_1 = $3_1;
    $22_1 = $1_1 << 1 | $3_1 >>> 31;
    $69($13_1, $21_1, $17_1, 0, 0, $28_1, $22_1, 0, 0);
    $3_1 = HEAP32[$6_1 + 7068 >> 2];
    $40_1 = $3_1;
    $33_1 = HEAP32[$6_1 + 7064 >> 2];
    $5_1 = $33_1;
    $3_1 = $3_1 << 1 | $5_1 >>> 31;
    $12_1 = $6_1 + 6880 | 0;
    $24_1 = HEAP32[$6_1 + 7072 >> 2];
    $18_1 = HEAP32[$6_1 + 7076 >> 2];
    $5_1 = $5_1 << 1;
    $8_1 = $3_1;
    $69($12_1, $24_1, $18_1, 0, 0, $5_1, $3_1, 0, 0);
    $9_1 = $6_1 + 7008 | 0;
    $4_1 = HEAP32[$6_1 + 7088 >> 2];
    $3_1 = HEAP32[$6_1 + 7092 >> 2];
    $69($9_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $10_1 = $6_1 + 6992 | 0;
    $69($10_1, HEAP32[$6_1 + 7008 >> 2], HEAP32[$6_1 + 7012 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $3_1 << 1 | $4_1 >>> 31;
    $31_1 = $6_1 + 6800 | 0;
    $23_1 = $4_1 << 1;
    $20_1 = $3_1;
    $69($31_1, $23_1, $3_1, 0, 0, $7_1, $1_1, 0, 0);
    $37_1 = $6_1 + 6864 | 0;
    $69($37_1, $21_1, $17_1, 0, 0, $5_1, $8_1, 0, 0);
    $30_1 = $6_1 + 6944 | 0;
    $69($30_1, $24_1, $18_1, 0, 0, $24_1, $18_1, 0, 0);
    $14_1 = $6_1 + 6976 | 0;
    $3_1 = $9_1 + 8 | 0;
    $69($14_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $39_1 = $6_1 + 6720 | 0;
    $69($39_1, $7_1, $1_1, 0, 0, $7_1, $1_1, 0, 0);
    $38_1 = $6_1 + 6912 | 0;
    $69($38_1, $23_1, $20_1, 0, 0, $33_1, $40_1, 0, 0);
    $35_1 = $6_1 + 6960 | 0;
    $69($35_1, $21_1, $17_1, 0, 0, $24_1 << 1, $18_1 << 1 | $24_1 >>> 31, 0, 0);
    $16_1 = HEAP32[$6_1 + 6852 >> 2];
    $3_1 = $16_1 + HEAP32[$6_1 + 6884 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 6848 >> 2];
    $4_1 = HEAP32[$6_1 + 6880 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 6992 >> 2];
    $15_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 6996 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $15_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $10_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($16_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
    $3_1 = $12_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $13_1 + 8 | 0;
    $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $10_1 | 0;
    $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $5_1;
    $11_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $32_1 = HEAP32[$6_1 + 6864 >> 2];
    $1_1 = HEAP32[$6_1 + 6944 >> 2];
    $9_1 = $32_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 6868 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 6948 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6800 >> 2];
    $7_1 = $1_1 + $9_1 | 0;
    $12_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6804 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6976 >> 2];
    $5_1 = $1_1 + $7_1 | 0;
    $10_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6980 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $36_1 = $6_1 + 6736 | 0;
    $29_1 = $36_1;
    $11_1 = $5_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $10_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $19_1 = HEAP32[$1_1 >> 2];
    $26_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($10_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $10_1 >>> 0 < $12_1 >>> 0;
    $1_1 = $31_1 + 8 | 0;
    $14_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($12_1 | 0) == ($34_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $30_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $37_1 + 8 | 0;
    $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $9_1 | 0;
    $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $19_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $25_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $14_1 = HEAP32[$6_1 + 6912 >> 2];
    $1_1 = HEAP32[$6_1 + 6960 >> 2];
    $10_1 = $14_1 + $1_1 | 0;
    $19_1 = HEAP32[$6_1 + 6916 >> 2];
    $3_1 = $19_1 + HEAP32[$6_1 + 6964 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $10_1 | 0;
    $3_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $9_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $13_1 = $4_1;
    $69($29_1, $12_1 | $4_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
    $27_1 = HEAP32[$6_1 + 6740 >> 2];
    $3_1 = $27_1 + HEAP32[$6_1 + 6724 >> 2] | 0;
    $25_1 = HEAP32[$6_1 + 6736 >> 2];
    $4_1 = HEAP32[$6_1 + 6720 >> 2];
    $9_1 = $25_1 + $4_1 | 0;
    HEAP32[$6_1 + 7576 >> 2] = $9_1;
    $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7580 >> 2] = $4_1 & 1048575;
    $31_1 = $6_1 + 6832 | 0;
    $69($31_1, $33_1, $40_1, 0, 0, $28_1, $22_1, 0, 0);
    $37_1 = $6_1 + 6928 | 0;
    $69($37_1, $23_1, $20_1, 0, 0, $24_1, $18_1, 0, 0);
    $30_1 = $6_1 + 7040 | 0;
    $69($30_1, $21_1, $17_1, 0, 0, $21_1, $17_1, 0, 0);
    $32_1 = $6_1 + 6784 | 0;
    $26_1 = $32_1;
    $12_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($19_1 | 0) & $10_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $19_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $10_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $5_1 + $7_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 << 12 | $8_1 >>> 20;
    $7_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $35_1 = HEAP32[$6_1 + 6932 >> 2];
    $3_1 = $35_1 + HEAP32[$6_1 + 7044 >> 2] | 0;
    $29_1 = HEAP32[$6_1 + 6928 >> 2];
    $5_1 = HEAP32[$6_1 + 7040 >> 2];
    $1_1 = $29_1 + $5_1 | 0;
    $19_1 = $1_1;
    $14_1 = $1_1 + $10_1 | 0;
    $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $5_1 + $8_1 | 0;
    $10_1 = $14_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($26_1, $14_1, $10_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $9_1 = ($4_1 | 0) == ($27_1 | 0) & $9_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
    $3_1 = $39_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $36_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $9_1 + $12_1 | 0;
    $3_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $1_1 << 12 | $4_1 >>> 20;
    $8_1 = $3_1;
    $9_1 = $3_1 << 12 | $1_1 >>> 20;
    $27_1 = HEAP32[$6_1 + 6784 >> 2];
    $1_1 = HEAP32[$6_1 + 6832 >> 2];
    $26_1 = $27_1 + $1_1 | 0;
    $36_1 = HEAP32[$6_1 + 6788 >> 2];
    $3_1 = $36_1 + HEAP32[$6_1 + 6836 >> 2] | 0;
    $4_1 = $1_1 >>> 0 > $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $9_1 | 0;
    $12_1 = $12_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7584 >> 2] = $12_1;
    $9_1 = $3_1;
    HEAP32[$6_1 + 7588 >> 2] = $3_1 & 1048575;
    $25_1 = $6_1 + 6816 | 0;
    $69($25_1, $24_1, $18_1, 0, 0, $28_1, $22_1, 0, 0);
    $22_1 = $6_1 + 6896 | 0;
    $69($22_1, $33_1, $40_1, 0, 0, $33_1, $40_1, 0, 0);
    $28_1 = $6_1 + 7024 | 0;
    $69($28_1, $23_1, $20_1, 0, 0, $21_1, $17_1, 0, 0);
    $24_1 = $6_1 + 6768 | 0;
    $21_1 = $24_1;
    $18_1 = ($5_1 | 0) == ($10_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
    $14_1 = ($5_1 | 0) == ($35_1 | 0) & $19_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $35_1 >>> 0;
    $3_1 = $30_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $37_1 + 8 | 0;
    $17_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $14_1 + $17_1 | 0;
    $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $7_1 >>> 20 | 0;
    $1_1 = $5_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $18_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $17_1 = $1_1 << 12 | $10_1 >>> 20;
    $7_1 = HEAP32[$6_1 + 7024 >> 2];
    $10_1 = $17_1 + $7_1 | 0;
    $5_1 = $3_1;
    $19_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $19_1 + HEAP32[$6_1 + 7028 >> 2] | 0;
    $14_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($21_1, $10_1, $14_1, 0, 0, 15632, 16, 0, 0);
    $12_1 = ($4_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $26_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
    $7_1 = ($4_1 | 0) == ($36_1 | 0) & $26_1 >>> 0 < $27_1 >>> 0 | $4_1 >>> 0 < $36_1 >>> 0;
    $3_1 = $31_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $18_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $18_1 | 0;
    $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $8_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $26_1 = HEAP32[$6_1 + 6816 >> 2];
    $1_1 = HEAP32[$6_1 + 6896 >> 2];
    $12_1 = $26_1 + $1_1 | 0;
    $20_1 = HEAP32[$6_1 + 6820 >> 2];
    $3_1 = $20_1 + HEAP32[$6_1 + 6900 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6768 >> 2];
    $9_1 = $1_1 + $12_1 | 0;
    $18_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6772 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $9_1 | 0;
    $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7592 >> 2] = $7_1;
    $8_1 = $3_1;
    HEAP32[$6_1 + 7596 >> 2] = $3_1 & 1048575;
    $21_1 = $6_1 + 6752 | 0;
    $17_1 = ($14_1 | 0) == ($19_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $14_1 >>> 0 < $19_1 >>> 0;
    $3_1 = $28_1 + 8 | 0;
    $14_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $5_1 >>> 20 | 0;
    $10_1 = $5_1;
    $5_1 = $5_1 + $14_1 | 0;
    $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $5_1;
    $5_1 = $5_1 + $17_1 | 0;
    $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($21_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $17_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($18_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $18_1 >>> 0;
    $1_1 = $24_1 + 8 | 0;
    $10_1 = HEAP32[$1_1 >> 2];
    $9_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($18_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 < $26_1 >>> 0 | $18_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $12_1 | 0;
    $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $9_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $12_1 = HEAP32[$6_1 + 6752 >> 2];
    $1_1 = $15_1 & -2;
    $8_1 = $12_1 + $1_1 | 0;
    $14_1 = HEAP32[$6_1 + 6756 >> 2];
    $3_1 = $14_1 + ($16_1 & 1048575) | 0;
    $7_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $7_1 + $5_1 | 0;
    $5_1 = $8_1 + $9_1 | 0;
    $3_1 = $5_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7600 >> 2] = $5_1;
    $1_1 = $3_1;
    HEAP32[$6_1 + 7604 >> 2] = $3_1 & 1048575;
    $10_1 = $13_1 & 65535;
    $9_1 = ($3_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $7_1 >>> 0;
    $5_1 = ($7_1 | 0) == ($14_1 | 0) & $8_1 >>> 0 < $12_1 >>> 0 | $7_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $21_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $9_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $11_1 | 0;
    $3_1 = $10_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$6_1 + 7608 >> 2] = $5_1;
    HEAP32[$6_1 + 7612 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $40_1 = $6_1 + 7576 | 0;
    $34($40_1, $40_1, $41_1);
    $1_1 = HEAP32[$6_1 + 7580 >> 2];
    $16_1 = $1_1;
    $13_1 = HEAP32[$6_1 + 7576 >> 2];
    $7_1 = $13_1;
    $3_1 = $1_1 << 1 | $7_1 >>> 31;
    $12_1 = $6_1 + 6448 | 0;
    $24_1 = HEAP32[$6_1 + 7600 >> 2];
    $26_1 = HEAP32[$6_1 + 7604 >> 2];
    $19_1 = $7_1 << 1;
    $23_1 = $3_1;
    $69($12_1, $24_1, $26_1, 0, 0, $19_1, $3_1, 0, 0);
    $1_1 = HEAP32[$6_1 + 7588 >> 2];
    $44_1 = $1_1;
    $43_1 = HEAP32[$6_1 + 7584 >> 2];
    $4_1 = $43_1;
    $3_1 = $1_1 << 1 | $4_1 >>> 31;
    $10_1 = $6_1 + 6656 | 0;
    $28_1 = HEAP32[$6_1 + 7592 >> 2];
    $21_1 = HEAP32[$6_1 + 7596 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $3_1;
    $69($10_1, $28_1, $21_1, 0, 0, $4_1, $3_1, 0, 0);
    $9_1 = $6_1 + 6608 | 0;
    $8_1 = HEAP32[$6_1 + 7608 >> 2];
    $1_1 = HEAP32[$6_1 + 7612 >> 2];
    $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $11_1 = $6_1 + 6592 | 0;
    $69($11_1, HEAP32[$6_1 + 6608 >> 2], HEAP32[$6_1 + 6612 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $1_1 << 1 | $8_1 >>> 31;
    $36_1 = $6_1 + 6560 | 0;
    $27_1 = $8_1 << 1;
    $22_1 = $3_1;
    $69($36_1, $27_1, $3_1, 0, 0, $7_1, $16_1, 0, 0);
    $31_1 = $6_1 + 6464 | 0;
    $69($31_1, $24_1, $26_1, 0, 0, $4_1, $5_1, 0, 0);
    $37_1 = $6_1 + 6640 | 0;
    $69($37_1, $28_1, $21_1, 0, 0, $28_1, $21_1, 0, 0);
    $14_1 = $6_1 + 6576 | 0;
    $1_1 = $9_1 + 8 | 0;
    $69($14_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $39_1 = $6_1 + 6704 | 0;
    $69($39_1, $7_1, $16_1, 0, 0, $7_1, $16_1, 0, 0);
    $38_1 = $6_1 + 6544 | 0;
    $69($38_1, $27_1, $3_1, 0, 0, $43_1, $44_1, 0, 0);
    $30_1 = $6_1 + 6480 | 0;
    $69($30_1, $24_1, $26_1, 0, 0, $28_1 << 1, $21_1 << 1 | $28_1 >>> 31, 0, 0);
    $13_1 = HEAP32[$6_1 + 6452 >> 2];
    $3_1 = $13_1 + HEAP32[$6_1 + 6660 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 6448 >> 2];
    $4_1 = HEAP32[$6_1 + 6656 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 6592 >> 2];
    $17_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 6596 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $17_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $10_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $12_1 + 8 | 0;
    $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $10_1 | 0;
    $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $18_1 = $5_1;
    $11_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $32_1 = HEAP32[$6_1 + 6464 >> 2];
    $1_1 = HEAP32[$6_1 + 6640 >> 2];
    $9_1 = $32_1 + $1_1 | 0;
    $35_1 = HEAP32[$6_1 + 6468 >> 2];
    $3_1 = $35_1 + HEAP32[$6_1 + 6644 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6560 >> 2];
    $7_1 = $1_1 + $9_1 | 0;
    $12_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6564 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6576 >> 2];
    $5_1 = $1_1 + $7_1 | 0;
    $10_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6580 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $29_1 = $6_1 + 6384 | 0;
    $11_1 = $5_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $25_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $20_1 = ($1_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $10_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $15_1 = HEAP32[$1_1 >> 2];
    $16_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($10_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $10_1 >>> 0 < $12_1 >>> 0;
    $1_1 = $36_1 + 8 | 0;
    $14_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($12_1 | 0) == ($35_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $35_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $9_1 | 0;
    $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $15_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $20_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $14_1 = HEAP32[$6_1 + 6544 >> 2];
    $1_1 = HEAP32[$6_1 + 6480 >> 2];
    $9_1 = $14_1 + $1_1 | 0;
    $13_1 = HEAP32[$6_1 + 6548 >> 2];
    $3_1 = $13_1 + HEAP32[$6_1 + 6484 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $9_1 | 0;
    $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $10_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $15_1 = $4_1;
    $69($29_1, $12_1 | $4_1 >>> 16 & 15, $10_1, 0, 0, 977, 1, 0, 0);
    $35_1 = $6_1 + 6688 | 0;
    $69($35_1, $43_1, $44_1, 0, 0, $19_1, $23_1, 0, 0);
    $36_1 = $6_1 + 6528 | 0;
    $69($36_1, $27_1, $22_1, 0, 0, $28_1, $21_1, 0, 0);
    $31_1 = $6_1 + 6496 | 0;
    $69($31_1, $24_1, $26_1, 0, 0, $24_1, $26_1, 0, 0);
    $37_1 = $6_1 + 6432 | 0;
    $12_1 = $37_1;
    $10_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($13_1 | 0) & $9_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $30_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $7_1 = $3_1;
    $4_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 6528 >> 2];
    $1_1 = HEAP32[$6_1 + 6496 >> 2];
    $20_1 = $30_1 + $1_1 | 0;
    $33_1 = HEAP32[$6_1 + 6532 >> 2];
    $3_1 = $33_1 + HEAP32[$6_1 + 6500 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $5_1 + $4_1 | 0;
    $16_1 = $8_1 + $20_1 | 0;
    $3_1 = $16_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $3_1;
    $69($12_1, $16_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $8_1 = HEAP32[$6_1 + 6384 >> 2];
    $1_1 = HEAP32[$6_1 + 6704 >> 2];
    $13_1 = $8_1 + $1_1 | 0;
    $9_1 = HEAP32[$6_1 + 6388 >> 2];
    $3_1 = $9_1 + HEAP32[$6_1 + 6708 >> 2] | 0;
    $42_1 = $6_1 + 7536 | 0;
    $34_1 = $42_1 + 8 | 0;
    $4_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = ($9_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 > $13_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
    $3_1 = $39_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $29_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $9_1 + $12_1 | 0;
    $3_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $4_1;
    $12_1 = $1_1 << 12 | $4_1 >>> 20;
    $8_1 = $3_1;
    $9_1 = $3_1 << 12 | $1_1 >>> 20;
    $38_1 = HEAP32[$6_1 + 6436 >> 2];
    $3_1 = $38_1 + HEAP32[$6_1 + 6692 >> 2] | 0;
    $32_1 = HEAP32[$6_1 + 6432 >> 2];
    $4_1 = HEAP32[$6_1 + 6688 >> 2];
    $1_1 = $32_1 + $4_1 | 0;
    $25_1 = $1_1;
    $12_1 = $1_1 + $12_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $9_1 | 0;
    HEAP32[$34_1 >> 2] = $12_1;
    $9_1 = $12_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$34_1 + 4 >> 2] = $9_1 & 1048575;
    $29_1 = $6_1 + 6624 | 0;
    $69($29_1, $28_1, $21_1, 0, 0, $19_1, $23_1, 0, 0);
    $23_1 = $6_1 + 6672 | 0;
    $69($23_1, $43_1, $44_1, 0, 0, $43_1, $44_1, 0, 0);
    $19_1 = $6_1 + 6512 | 0;
    $69($19_1, $27_1, $22_1, 0, 0, $24_1, $26_1, 0, 0);
    $22_1 = $6_1 + 6416 | 0;
    $21_1 = ($5_1 | 0) == ($10_1 | 0) & $16_1 >>> 0 < $20_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
    $16_1 = ($5_1 | 0) == ($33_1 | 0) & $20_1 >>> 0 < $30_1 >>> 0 | $5_1 >>> 0 < $33_1 >>> 0;
    $3_1 = $31_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $36_1 + 8 | 0;
    $24_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $16_1 + $24_1 | 0;
    $3_1 = $5_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $7_1 >>> 20 | 0;
    $1_1 = $5_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $21_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $28_1 = $1_1 << 12 | $10_1 >>> 20;
    $7_1 = HEAP32[$6_1 + 6512 >> 2];
    $10_1 = $28_1 + $7_1 | 0;
    $5_1 = $3_1;
    $30_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $30_1 + HEAP32[$6_1 + 6516 >> 2] | 0;
    $16_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($22_1, $10_1, $16_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $42_1 + 16 | 0;
    $24_1 = $27_1;
    $12_1 = ($4_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
    $7_1 = ($4_1 | 0) == ($38_1 | 0) & $25_1 >>> 0 < $32_1 >>> 0 | $4_1 >>> 0 < $38_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $37_1 + 8 | 0;
    $21_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $21_1 | 0;
    $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $8_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $26_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 6624 >> 2];
    $1_1 = HEAP32[$6_1 + 6672 >> 2];
    $9_1 = $20_1 + $1_1 | 0;
    $25_1 = HEAP32[$6_1 + 6628 >> 2];
    $3_1 = $25_1 + HEAP32[$6_1 + 6676 >> 2] | 0;
    $21_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $21_1 + HEAP32[$6_1 + 6420 >> 2] | 0;
    $1_1 = HEAP32[$6_1 + 6416 >> 2];
    $8_1 = $1_1 + $9_1 | 0;
    $12_1 = $8_1;
    $7_1 = $8_1 + $7_1 | 0;
    $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $26_1 | 0;
    HEAP32[$24_1 >> 2] = $7_1;
    $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$24_1 + 4 >> 2] = $8_1 & 1048575;
    $24_1 = $6_1 + 6400 | 0;
    $26_1 = ($16_1 | 0) == ($30_1 | 0) & $10_1 >>> 0 < $28_1 >>> 0 | $16_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $16_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $5_1 >>> 20 | 0;
    $10_1 = $5_1;
    $5_1 = $5_1 + $16_1 | 0;
    $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $5_1;
    $5_1 = $5_1 + $26_1 | 0;
    $3_1 = $16_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($24_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $28_1 = $42_1 + 24 | 0;
    $26_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $16_1 = ($1_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $12_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($21_1 | 0) == ($25_1 | 0) & $9_1 >>> 0 < $20_1 >>> 0 | $21_1 >>> 0 < $25_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $29_1 + 8 | 0;
    $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $9_1 | 0;
    $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $16_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $9_1 = $3_1 << 12 | $1_1 >>> 20;
    $12_1 = HEAP32[$6_1 + 6400 >> 2];
    $5_1 = $17_1 & -2;
    $1_1 = $12_1 + $5_1 | 0;
    $17_1 = HEAP32[$6_1 + 6404 >> 2];
    $3_1 = $17_1 + ($18_1 & 1048575) | 0;
    $7_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $7_1 + $9_1 | 0;
    $5_1 = $8_1;
    $8_1 = $1_1;
    $5_1 = $5_1 + $1_1 | 0;
    HEAP32[$28_1 >> 2] = $5_1;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
    $18_1 = $42_1 + 32 | 0;
    $16_1 = $18_1;
    $10_1 = $15_1 & 65535;
    $9_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
    $5_1 = ($7_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $12_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
    $3_1 = $24_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $9_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $11_1 | 0;
    $3_1 = $10_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$16_1 >> 2] = $5_1;
    HEAP32[$16_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7536 >> 2] = $13_1;
    HEAP32[$6_1 + 7540 >> 2] = $14_1 & 1048575;
    $34($42_1, $42_1, $41_1);
    $1_1 = HEAP32[$6_1 + 7540 >> 2];
    $22_1 = $1_1;
    $20_1 = HEAP32[$6_1 + 7536 >> 2];
    $7_1 = $20_1;
    $3_1 = $1_1 << 1 | $7_1 >>> 31;
    $15_1 = $6_1 + 6224 | 0;
    $12_1 = HEAP32[$28_1 >> 2];
    $10_1 = HEAP32[$28_1 + 4 >> 2];
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
    $1_1 = HEAP32[$34_1 + 4 >> 2];
    $41_1 = $1_1;
    $33_1 = HEAP32[$34_1 >> 2];
    $4_1 = $33_1;
    $3_1 = $1_1 << 1 | $4_1 >>> 31;
    $16_1 = $6_1 + 6320 | 0;
    $13_1 = HEAP32[$27_1 >> 2];
    $9_1 = HEAP32[$27_1 + 4 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $3_1;
    $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
    $14_1 = $6_1 + 6208 | 0;
    $8_1 = HEAP32[$18_1 >> 2];
    $1_1 = HEAP32[$18_1 + 4 >> 2];
    $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $11_1 = $6_1 + 6192 | 0;
    $69($11_1, HEAP32[$6_1 + 6208 >> 2], HEAP32[$6_1 + 6212 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $1_1 << 1 | $8_1 >>> 31;
    $39_1 = $6_1 + 6160 | 0;
    $24_1 = $8_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
    $38_1 = $6_1 + 6240 | 0;
    $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
    $35_1 = $6_1 + 6304 | 0;
    $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
    $28_1 = $6_1 + 6176 | 0;
    $1_1 = $14_1 + 8 | 0;
    $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 6368 | 0;
    $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
    $31_1 = $6_1 + 6144 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
    $37_1 = $6_1 + 6256 | 0;
    $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
    $20_1 = HEAP32[$6_1 + 6228 >> 2];
    $3_1 = $20_1 + HEAP32[$6_1 + 6324 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 6224 >> 2];
    $4_1 = HEAP32[$6_1 + 6320 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 6192 >> 2];
    $18_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 6196 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $16_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $15_1 + 8 | 0;
    $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $5_1;
    $11_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 6240 >> 2];
    $1_1 = HEAP32[$6_1 + 6304 >> 2];
    $14_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 6244 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 6308 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6160 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6164 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6176 >> 2];
    $5_1 = $1_1 + $7_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6180 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 6128 | 0;
    $29_1 = $32_1;
    $11_1 = $5_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $28_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $28_1 = HEAP32[$1_1 >> 2];
    $16_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $14_1 | 0;
    $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $28_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $25_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $16_1 = $3_1 << 12 | $1_1 >>> 20;
    $23_1 = HEAP32[$6_1 + 6148 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 6260 >> 2] | 0;
    $19_1 = HEAP32[$6_1 + 6144 >> 2];
    $1_1 = HEAP32[$6_1 + 6256 >> 2];
    $8_1 = $19_1 + $1_1 | 0;
    $14_1 = $8_1;
    $7_1 = $8_1 + $7_1 | 0;
    $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $16_1 | 0;
    $28_1 = $7_1 << 4 & -16;
    $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 6352 | 0;
    $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
    $25_1 = $6_1 + 6096 | 0;
    $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
    $22_1 = $6_1 + 6272 | 0;
    $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $28_1 = $6_1 + 6080 | 0;
    $20_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 6096 >> 2];
    $1_1 = HEAP32[$6_1 + 6272 >> 2];
    $7_1 = $20_1 + $1_1 | 0;
    $27_1 = HEAP32[$6_1 + 6100 >> 2];
    $3_1 = $27_1 + HEAP32[$6_1 + 6276 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $7_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 6288 | 0;
    $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $19_1 = $6_1 + 6336 | 0;
    $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
    $14_1 = $6_1 + 6032 | 0;
    $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
    $21_1 = $6_1 + 6016 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 6032 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 6036 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 5952 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 6128 >> 2];
    $1_1 = HEAP32[$6_1 + 6368 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 6132 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 6372 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $10_1 = HEAP32[$6_1 + 6080 >> 2];
    $1_1 = HEAP32[$6_1 + 6352 >> 2];
    $9_1 = $10_1 + $1_1 | 0;
    $14_1 = HEAP32[$6_1 + 6084 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 6356 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $8_1 + $9_1 | 0;
    $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $28_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 6288 >> 2];
    $1_1 = HEAP32[$6_1 + 6336 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 6292 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 6340 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 6016 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 6020 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 5936 | 0;
    $28_1 = $25_1;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $12_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $17_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 5956 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 5952 >> 2];
    $1_1 = $18_1 & -2;
    $9_1 = $22_1 + $1_1 | 0;
    $15_1 = $9_1;
    $12_1 = $9_1 + $12_1 | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $17_1 = $9_1 & 1048575;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $26_1 = $7_1 << 1;
    $24_1 = $3_1;
    $69($28_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 5968 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 5872 | 0;
    $20_1 = $19_1;
    $21_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($20_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 5856 | 0;
    $69($11_1, HEAP32[$6_1 + 5872 >> 2], HEAP32[$6_1 + 5876 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 5824 | 0;
    $20_1 = $1_1 << 1;
    $21_1 = $3_1;
    $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 5920 | 0;
    $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 5984 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 5840 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 6112 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 5808 | 0;
    $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 5888 | 0;
    $10_1 = $17_1;
    $9_1 = $18_1;
    $17_1 = $5_1;
    $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 5936 >> 2];
    $4_1 = HEAP32[$6_1 + 5968 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $13_1 = HEAP32[$6_1 + 5940 >> 2];
    $3_1 = $13_1 + HEAP32[$6_1 + 5972 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 5856 >> 2];
    $18_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5860 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $13_1 | 0;
    $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $4_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 5920 >> 2];
    $1_1 = HEAP32[$6_1 + 5984 >> 2];
    $13_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 5924 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 5988 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5824 >> 2];
    $14_1 = $1_1 + $13_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5828 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5840 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5844 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 5712 | 0;
    $29_1 = $32_1;
    $11_1 = $7_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $16_1 = HEAP32[$1_1 >> 2];
    $14_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $13_1 | 0;
    $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 5808 >> 2];
    $1_1 = HEAP32[$6_1 + 5888 >> 2];
    $14_1 = $19_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 5812 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 5892 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 6048 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
    $27_1 = $6_1 + 5792 | 0;
    $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
    $25_1 = $6_1 + 5904 | 0;
    $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $22_1 = $6_1 + 5776 | 0;
    $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $13_1 = HEAP32[$6_1 + 5792 >> 2];
    $1_1 = HEAP32[$6_1 + 5904 >> 2];
    $7_1 = $13_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 5796 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 5908 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $7_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 6e3 | 0;
    $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
    $19_1 = $6_1 + 6064 | 0;
    $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $14_1 = $6_1 + 5760 | 0;
    $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
    $21_1 = $6_1 + 5744 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 5760 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 5764 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 5728 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 5712 >> 2];
    $1_1 = HEAP32[$6_1 + 6112 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 5716 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 6116 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $10_1 = HEAP32[$6_1 + 5776 >> 2];
    $1_1 = HEAP32[$6_1 + 6048 >> 2];
    $9_1 = $10_1 + $1_1 | 0;
    $14_1 = HEAP32[$6_1 + 5780 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 6052 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $8_1 + $9_1 | 0;
    $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $22_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 6e3 >> 2];
    $1_1 = HEAP32[$6_1 + 6064 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 6004 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 6068 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5744 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5748 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 5632 | 0;
    $28_1 = $25_1;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $12_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $17_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 5732 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 5728 >> 2];
    $1_1 = $18_1 & -2;
    $9_1 = $22_1 + $1_1 | 0;
    $15_1 = $9_1;
    $12_1 = $9_1 + $12_1 | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = $9_1 & 1048575;
    $18_1 = $20_1;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 5584 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 5536 | 0;
    $17_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 5520 | 0;
    $69($11_1, HEAP32[$6_1 + 5536 >> 2], HEAP32[$6_1 + 5540 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 5488 | 0;
    $24_1 = $1_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 5568 | 0;
    $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 5680 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 5504 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 5648 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 5472 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 5552 | 0;
    $16_1 = $12_1;
    $13_1 = $20_1;
    $9_1 = $18_1;
    $18_1 = $5_1;
    $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 5632 >> 2];
    $4_1 = HEAP32[$6_1 + 5584 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $12_1 = HEAP32[$6_1 + 5636 >> 2];
    $3_1 = $12_1 + HEAP32[$6_1 + 5588 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 5520 >> 2];
    $14_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5524 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $12_1 | 0;
    $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 5568 >> 2];
    $1_1 = HEAP32[$6_1 + 5680 >> 2];
    $15_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 5572 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 5684 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5488 >> 2];
    $10_1 = $1_1 + $15_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5492 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5504 >> 2];
    $11_1 = $1_1 + $10_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5508 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 5376 | 0;
    $29_1 = $32_1;
    $8_1 = $7_1 + $11_1 | 0;
    $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $20_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $11_1 + $15_1 | 0;
    $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 5472 >> 2];
    $1_1 = HEAP32[$6_1 + 5552 >> 2];
    $15_1 = $19_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 5476 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 5556 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $7_1 | 0;
    $11_1 = $11_1 + $15_1 | 0;
    $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $11_1 << 4 & -16;
    $7_1 = $3_1;
    $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
    $10_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 5616 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
    $27_1 = $6_1 + 5456 | 0;
    $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
    $25_1 = $6_1 + 5696 | 0;
    $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
    $23_1 = $6_1 + 5440 | 0;
    $22_1 = $23_1;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $11_1 + $15_1 | 0;
    $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $7_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 5456 >> 2];
    $1_1 = HEAP32[$6_1 + 5696 >> 2];
    $11_1 = $20_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 5460 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 5700 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $11_1 | 0;
    $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $19_1 = $6_1 + 5600 | 0;
    $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $22_1 = $6_1 + 5664 | 0;
    $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $15_1 = $6_1 + 5424 | 0;
    $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
    $18_1 = $6_1 + 5408 | 0;
    $13_1 = $18_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $11_1 + $16_1 | 0;
    $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 5424 >> 2];
    $9_1 = $7_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 5428 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $20_1 = $6_1 + 5392 | 0;
    $11_1 = $20_1;
    $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $15_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 5376 >> 2];
    $1_1 = HEAP32[$6_1 + 5648 >> 2];
    $9_1 = $4_1 + $1_1 | 0;
    $7_1 = HEAP32[$6_1 + 5380 >> 2];
    $3_1 = $7_1 + HEAP32[$6_1 + 5652 >> 2] | 0;
    $30_1 = $6_1 + 7496 | 0;
    $27_1 = $30_1 + 8 | 0;
    $16_1 = $27_1;
    $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $11_1 | 0;
    $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $11_1 = $5_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $15_1 = HEAP32[$6_1 + 5440 >> 2];
    $1_1 = HEAP32[$6_1 + 5616 >> 2];
    $13_1 = $15_1 + $1_1 | 0;
    $21_1 = HEAP32[$6_1 + 5444 >> 2];
    $3_1 = $21_1 + HEAP32[$6_1 + 5620 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$16_1 >> 2] = $7_1;
    $5_1 = $3_1;
    HEAP32[$16_1 + 4 >> 2] = $3_1 & 1048575;
    $25_1 = $30_1 + 16 | 0;
    $17_1 = $25_1;
    $16_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $13_1 + $15_1 | 0;
    $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $24_1 = HEAP32[$6_1 + 5600 >> 2];
    $1_1 = HEAP32[$6_1 + 5664 >> 2];
    $16_1 = $24_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 5604 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 5668 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5408 >> 2];
    $13_1 = $1_1 + $16_1 | 0;
    $15_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5412 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$17_1 >> 2] = $7_1;
    $5_1 = $3_1;
    HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
    $28_1 = $30_1 + 24 | 0;
    $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
    $1_1 = $18_1 + 8 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $18_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $19_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $13_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $7_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 + $21_1 | 0;
    $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $16_1 = HEAP32[$6_1 + 5392 >> 2];
    $5_1 = $14_1 & -2;
    $1_1 = $16_1 + $5_1 | 0;
    $17_1 = HEAP32[$6_1 + 5396 >> 2];
    $3_1 = $17_1 + ($12_1 & 1048575) | 0;
    $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $14_1 + $7_1 | 0;
    $12_1 = $1_1;
    $5_1 = $1_1 + $13_1 | 0;
    HEAP32[$28_1 >> 2] = $5_1;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
    $18_1 = $30_1 + 32 | 0;
    $15_1 = $18_1;
    $7_1 = $8_1;
    $13_1 = $10_1 & 65535;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $5_1 = ($14_1 | 0) == ($17_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
    $3_1 = $20_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $7_1 | 0;
    $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$15_1 >> 2] = $5_1;
    HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7496 >> 2] = $9_1;
    HEAP32[$6_1 + 7500 >> 2] = $11_1 & 1048575;
    $34($30_1, $30_1, $42_1);
    $1_1 = HEAP32[$6_1 + 7500 >> 2];
    $22_1 = $1_1;
    $20_1 = HEAP32[$6_1 + 7496 >> 2];
    $7_1 = $20_1;
    $3_1 = $1_1 << 1 | $7_1 >>> 31;
    $15_1 = $6_1 + 5216 | 0;
    $12_1 = HEAP32[$28_1 >> 2];
    $10_1 = HEAP32[$28_1 + 4 >> 2];
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
    $1_1 = HEAP32[$27_1 + 4 >> 2];
    $41_1 = $1_1;
    $33_1 = HEAP32[$27_1 >> 2];
    $4_1 = $33_1;
    $3_1 = $1_1 << 1 | $4_1 >>> 31;
    $16_1 = $6_1 + 5312 | 0;
    $13_1 = HEAP32[$25_1 >> 2];
    $9_1 = HEAP32[$25_1 + 4 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $3_1;
    $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
    $14_1 = $6_1 + 5200 | 0;
    $8_1 = HEAP32[$18_1 >> 2];
    $1_1 = HEAP32[$18_1 + 4 >> 2];
    $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $11_1 = $6_1 + 5184 | 0;
    $69($11_1, HEAP32[$6_1 + 5200 >> 2], HEAP32[$6_1 + 5204 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $1_1 << 1 | $8_1 >>> 31;
    $39_1 = $6_1 + 5152 | 0;
    $24_1 = $8_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
    $38_1 = $6_1 + 5232 | 0;
    $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
    $35_1 = $6_1 + 5296 | 0;
    $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
    $28_1 = $6_1 + 5168 | 0;
    $1_1 = $14_1 + 8 | 0;
    $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 5360 | 0;
    $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
    $31_1 = $6_1 + 5136 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
    $37_1 = $6_1 + 5248 | 0;
    $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
    $20_1 = HEAP32[$6_1 + 5220 >> 2];
    $3_1 = $20_1 + HEAP32[$6_1 + 5316 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 5216 >> 2];
    $4_1 = HEAP32[$6_1 + 5312 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 5184 >> 2];
    $18_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 5188 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $16_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $15_1 + 8 | 0;
    $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $5_1;
    $11_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 5232 >> 2];
    $1_1 = HEAP32[$6_1 + 5296 >> 2];
    $14_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 5236 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 5300 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5152 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5156 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5168 >> 2];
    $5_1 = $1_1 + $7_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5172 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 5120 | 0;
    $29_1 = $32_1;
    $11_1 = $5_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $28_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $28_1 = HEAP32[$1_1 >> 2];
    $16_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $14_1 | 0;
    $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $28_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $25_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 5136 >> 2];
    $1_1 = HEAP32[$6_1 + 5248 >> 2];
    $14_1 = $19_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 5140 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 5252 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $28_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 5344 | 0;
    $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
    $25_1 = $6_1 + 5088 | 0;
    $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
    $22_1 = $6_1 + 5264 | 0;
    $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $28_1 = $6_1 + 5072 | 0;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 5088 >> 2];
    $1_1 = HEAP32[$6_1 + 5264 >> 2];
    $7_1 = $20_1 + $1_1 | 0;
    $27_1 = HEAP32[$6_1 + 5092 >> 2];
    $3_1 = $27_1 + HEAP32[$6_1 + 5268 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $7_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 5280 | 0;
    $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $19_1 = $6_1 + 5328 | 0;
    $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
    $14_1 = $6_1 + 5024 | 0;
    $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
    $21_1 = $6_1 + 5008 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 5024 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 5028 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 4944 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 5120 >> 2];
    $1_1 = HEAP32[$6_1 + 5360 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 5124 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 5364 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $10_1 = HEAP32[$6_1 + 5072 >> 2];
    $1_1 = HEAP32[$6_1 + 5344 >> 2];
    $9_1 = $10_1 + $1_1 | 0;
    $14_1 = HEAP32[$6_1 + 5076 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 5348 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $8_1 + $9_1 | 0;
    $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $28_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 5280 >> 2];
    $1_1 = HEAP32[$6_1 + 5328 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 5284 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 5332 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 5008 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 5012 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 4928 | 0;
    $28_1 = $25_1;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $12_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $17_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 4948 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 4944 >> 2];
    $1_1 = $18_1 & -2;
    $9_1 = $22_1 + $1_1 | 0;
    $15_1 = $9_1;
    $12_1 = $9_1 + $12_1 | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $17_1 = $9_1 & 1048575;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $26_1 = $7_1 << 1;
    $24_1 = $3_1;
    $69($28_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 4960 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 4864 | 0;
    $20_1 = $19_1;
    $21_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($20_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 4848 | 0;
    $69($11_1, HEAP32[$6_1 + 4864 >> 2], HEAP32[$6_1 + 4868 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 4816 | 0;
    $20_1 = $1_1 << 1;
    $21_1 = $3_1;
    $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 4912 | 0;
    $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 4976 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 4832 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 5104 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 4800 | 0;
    $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 4880 | 0;
    $10_1 = $17_1;
    $9_1 = $18_1;
    $17_1 = $5_1;
    $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 4928 >> 2];
    $4_1 = HEAP32[$6_1 + 4960 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $13_1 = HEAP32[$6_1 + 4932 >> 2];
    $3_1 = $13_1 + HEAP32[$6_1 + 4964 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 4848 >> 2];
    $18_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4852 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $13_1 | 0;
    $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $4_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 4912 >> 2];
    $1_1 = HEAP32[$6_1 + 4976 >> 2];
    $13_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 4916 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 4980 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4816 >> 2];
    $14_1 = $1_1 + $13_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4820 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4832 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4836 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 4704 | 0;
    $29_1 = $32_1;
    $11_1 = $7_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $16_1 = HEAP32[$1_1 >> 2];
    $14_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $13_1 | 0;
    $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 4800 >> 2];
    $1_1 = HEAP32[$6_1 + 4880 >> 2];
    $14_1 = $19_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 4804 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 4884 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 5040 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
    $27_1 = $6_1 + 4784 | 0;
    $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
    $25_1 = $6_1 + 4896 | 0;
    $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $22_1 = $6_1 + 4768 | 0;
    $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $13_1 = HEAP32[$6_1 + 4784 >> 2];
    $1_1 = HEAP32[$6_1 + 4896 >> 2];
    $7_1 = $13_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 4788 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 4900 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $7_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 4992 | 0;
    $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
    $19_1 = $6_1 + 5056 | 0;
    $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $14_1 = $6_1 + 4752 | 0;
    $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
    $21_1 = $6_1 + 4736 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 4752 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 4756 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 4720 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 4704 >> 2];
    $1_1 = HEAP32[$6_1 + 5104 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 4708 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 5108 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $12_1 = $3_1 << 12 | $1_1 >>> 20;
    $14_1 = HEAP32[$6_1 + 4772 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 5044 >> 2] | 0;
    $10_1 = HEAP32[$6_1 + 4768 >> 2];
    $1_1 = HEAP32[$6_1 + 5040 >> 2];
    $5_1 = $10_1 + $1_1 | 0;
    $9_1 = $5_1;
    $8_1 = $5_1 + $8_1 | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $12_1 | 0;
    $5_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $22_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 4992 >> 2];
    $1_1 = HEAP32[$6_1 + 5056 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 4996 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 5060 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4736 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4740 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 4624 | 0;
    $28_1 = $25_1;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $17_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $12_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 4724 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 4720 >> 2];
    $9_1 = $18_1 & -2;
    $1_1 = $22_1 + $9_1 | 0;
    $15_1 = $1_1;
    $1_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $12_1 | 0;
    $12_1 = $15_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = $9_1 & 1048575;
    $18_1 = $20_1;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 4576 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 4528 | 0;
    $17_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 4512 | 0;
    $69($11_1, HEAP32[$6_1 + 4528 >> 2], HEAP32[$6_1 + 4532 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 4480 | 0;
    $24_1 = $1_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 4560 | 0;
    $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 4672 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 4496 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 4640 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 4464 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 4544 | 0;
    $16_1 = $12_1;
    $13_1 = $20_1;
    $9_1 = $18_1;
    $18_1 = $5_1;
    $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 4624 >> 2];
    $4_1 = HEAP32[$6_1 + 4576 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $12_1 = HEAP32[$6_1 + 4628 >> 2];
    $3_1 = $12_1 + HEAP32[$6_1 + 4580 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 4512 >> 2];
    $14_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4516 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $12_1 | 0;
    $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 4560 >> 2];
    $1_1 = HEAP32[$6_1 + 4672 >> 2];
    $15_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 4564 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 4676 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4480 >> 2];
    $10_1 = $1_1 + $15_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4484 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4496 >> 2];
    $11_1 = $1_1 + $10_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4500 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 4368 | 0;
    $29_1 = $32_1;
    $8_1 = $7_1 + $11_1 | 0;
    $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $20_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $11_1 + $15_1 | 0;
    $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 4464 >> 2];
    $1_1 = HEAP32[$6_1 + 4544 >> 2];
    $15_1 = $19_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 4468 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 4548 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $7_1 | 0;
    $11_1 = $11_1 + $15_1 | 0;
    $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $11_1 << 4 & -16;
    $7_1 = $3_1;
    $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
    $10_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 4608 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
    $27_1 = $6_1 + 4448 | 0;
    $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
    $25_1 = $6_1 + 4688 | 0;
    $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
    $23_1 = $6_1 + 4432 | 0;
    $22_1 = $23_1;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $11_1 + $15_1 | 0;
    $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $7_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 4448 >> 2];
    $1_1 = HEAP32[$6_1 + 4688 >> 2];
    $11_1 = $20_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 4452 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 4692 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $11_1 | 0;
    $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $19_1 = $6_1 + 4592 | 0;
    $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $22_1 = $6_1 + 4656 | 0;
    $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $15_1 = $6_1 + 4416 | 0;
    $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
    $18_1 = $6_1 + 4400 | 0;
    $13_1 = $18_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $11_1 + $16_1 | 0;
    $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 4416 >> 2];
    $9_1 = $7_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 4420 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $20_1 = $6_1 + 4384 | 0;
    $11_1 = $20_1;
    $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $15_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 4368 >> 2];
    $1_1 = HEAP32[$6_1 + 4640 >> 2];
    $9_1 = $4_1 + $1_1 | 0;
    $7_1 = HEAP32[$6_1 + 4372 >> 2];
    $3_1 = $7_1 + HEAP32[$6_1 + 4644 >> 2] | 0;
    $30_1 = $6_1 + 7456 | 0;
    $27_1 = $30_1 + 8 | 0;
    $17_1 = $27_1;
    $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $11_1 | 0;
    $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $11_1 = $5_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $16_1 = $3_1 << 12 | $1_1 >>> 20;
    $21_1 = HEAP32[$6_1 + 4436 >> 2];
    $3_1 = $21_1 + HEAP32[$6_1 + 4612 >> 2] | 0;
    $15_1 = HEAP32[$6_1 + 4432 >> 2];
    $1_1 = HEAP32[$6_1 + 4608 >> 2];
    $5_1 = $15_1 + $1_1 | 0;
    $13_1 = $5_1;
    $7_1 = $5_1 + $7_1 | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $16_1 | 0;
    HEAP32[$17_1 >> 2] = $7_1;
    $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$17_1 + 4 >> 2] = $5_1 & 1048575;
    $25_1 = $30_1 + 16 | 0;
    $17_1 = $25_1;
    $16_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $13_1 + $15_1 | 0;
    $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $24_1 = HEAP32[$6_1 + 4592 >> 2];
    $1_1 = HEAP32[$6_1 + 4656 >> 2];
    $16_1 = $24_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 4596 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 4660 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4400 >> 2];
    $13_1 = $1_1 + $16_1 | 0;
    $15_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4404 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$17_1 >> 2] = $7_1;
    $5_1 = $3_1;
    HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
    $28_1 = $30_1 + 24 | 0;
    $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
    $1_1 = $18_1 + 8 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $18_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $19_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $13_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $7_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 + $21_1 | 0;
    $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $16_1 = HEAP32[$6_1 + 4384 >> 2];
    $5_1 = $14_1 & -2;
    $1_1 = $16_1 + $5_1 | 0;
    $17_1 = HEAP32[$6_1 + 4388 >> 2];
    $3_1 = $17_1 + ($12_1 & 1048575) | 0;
    $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $14_1 + $7_1 | 0;
    $12_1 = $1_1;
    $5_1 = $1_1 + $13_1 | 0;
    HEAP32[$28_1 >> 2] = $5_1;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
    $18_1 = $30_1 + 32 | 0;
    $15_1 = $18_1;
    $7_1 = $8_1;
    $13_1 = $10_1 & 65535;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $5_1 = ($14_1 | 0) == ($17_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
    $3_1 = $20_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $7_1 | 0;
    $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$15_1 >> 2] = $5_1;
    HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7456 >> 2] = $9_1;
    HEAP32[$6_1 + 7460 >> 2] = $11_1 & 1048575;
    $34($30_1, $30_1, $42_1);
    $1_1 = HEAP32[$6_1 + 7460 >> 2];
    $22_1 = $1_1;
    $20_1 = HEAP32[$6_1 + 7456 >> 2];
    $7_1 = $20_1;
    $3_1 = $1_1 << 1 | $7_1 >>> 31;
    $15_1 = $6_1 + 4208 | 0;
    $12_1 = HEAP32[$28_1 >> 2];
    $10_1 = HEAP32[$28_1 + 4 >> 2];
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
    $1_1 = HEAP32[$27_1 + 4 >> 2];
    $41_1 = $1_1;
    $33_1 = HEAP32[$27_1 >> 2];
    $4_1 = $33_1;
    $3_1 = $1_1 << 1 | $4_1 >>> 31;
    $16_1 = $6_1 + 4304 | 0;
    $13_1 = HEAP32[$25_1 >> 2];
    $9_1 = HEAP32[$25_1 + 4 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $3_1;
    $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
    $14_1 = $6_1 + 4192 | 0;
    $8_1 = HEAP32[$18_1 >> 2];
    $1_1 = HEAP32[$18_1 + 4 >> 2];
    $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $11_1 = $6_1 + 4176 | 0;
    $69($11_1, HEAP32[$6_1 + 4192 >> 2], HEAP32[$6_1 + 4196 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $1_1 << 1 | $8_1 >>> 31;
    $39_1 = $6_1 + 4144 | 0;
    $24_1 = $8_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
    $38_1 = $6_1 + 4224 | 0;
    $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
    $35_1 = $6_1 + 4288 | 0;
    $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
    $28_1 = $6_1 + 4160 | 0;
    $1_1 = $14_1 + 8 | 0;
    $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 4352 | 0;
    $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
    $31_1 = $6_1 + 4128 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
    $37_1 = $6_1 + 4240 | 0;
    $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
    $20_1 = HEAP32[$6_1 + 4212 >> 2];
    $3_1 = $20_1 + HEAP32[$6_1 + 4308 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 4208 >> 2];
    $4_1 = HEAP32[$6_1 + 4304 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 4176 >> 2];
    $18_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 4180 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $16_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $15_1 + 8 | 0;
    $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $5_1;
    $11_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 4224 >> 2];
    $1_1 = HEAP32[$6_1 + 4288 >> 2];
    $14_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 4228 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 4292 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4144 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4148 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4160 >> 2];
    $5_1 = $1_1 + $7_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4164 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 4112 | 0;
    $29_1 = $32_1;
    $11_1 = $5_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $28_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $28_1 = HEAP32[$1_1 >> 2];
    $16_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $14_1 | 0;
    $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $28_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $25_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 4128 >> 2];
    $1_1 = HEAP32[$6_1 + 4240 >> 2];
    $14_1 = $19_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 4132 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 4244 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $28_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 4336 | 0;
    $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
    $25_1 = $6_1 + 4080 | 0;
    $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
    $22_1 = $6_1 + 4256 | 0;
    $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $28_1 = $6_1 + 4064 | 0;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 4080 >> 2];
    $1_1 = HEAP32[$6_1 + 4256 >> 2];
    $7_1 = $20_1 + $1_1 | 0;
    $27_1 = HEAP32[$6_1 + 4084 >> 2];
    $3_1 = $27_1 + HEAP32[$6_1 + 4260 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $7_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 4272 | 0;
    $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $19_1 = $6_1 + 4320 | 0;
    $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
    $14_1 = $6_1 + 4016 | 0;
    $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
    $21_1 = $6_1 + 4e3 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 4016 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 4020 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 3936 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 4112 >> 2];
    $1_1 = HEAP32[$6_1 + 4352 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 4116 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 4356 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $10_1 = HEAP32[$6_1 + 4064 >> 2];
    $1_1 = HEAP32[$6_1 + 4336 >> 2];
    $9_1 = $10_1 + $1_1 | 0;
    $14_1 = HEAP32[$6_1 + 4068 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 4340 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $8_1 + $9_1 | 0;
    $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $28_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 4272 >> 2];
    $1_1 = HEAP32[$6_1 + 4320 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 4276 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 4324 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 4e3 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 4004 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 3920 | 0;
    $28_1 = $25_1;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $12_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $17_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 3940 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 3936 >> 2];
    $1_1 = $18_1 & -2;
    $9_1 = $22_1 + $1_1 | 0;
    $15_1 = $9_1;
    $12_1 = $9_1 + $12_1 | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = $9_1 & 1048575;
    $18_1 = $20_1;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 3952 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 3856 | 0;
    $17_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 3840 | 0;
    $69($11_1, HEAP32[$6_1 + 3856 >> 2], HEAP32[$6_1 + 3860 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 3808 | 0;
    $24_1 = $1_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 3904 | 0;
    $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 3968 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 3824 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 4096 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 3792 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 3872 | 0;
    $16_1 = $12_1;
    $13_1 = $20_1;
    $9_1 = $18_1;
    $18_1 = $5_1;
    $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 3920 >> 2];
    $4_1 = HEAP32[$6_1 + 3952 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $12_1 = HEAP32[$6_1 + 3924 >> 2];
    $3_1 = $12_1 + HEAP32[$6_1 + 3956 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 3840 >> 2];
    $14_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 3844 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $12_1 | 0;
    $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 3904 >> 2];
    $1_1 = HEAP32[$6_1 + 3968 >> 2];
    $15_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 3908 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 3972 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 3808 >> 2];
    $10_1 = $1_1 + $15_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 3812 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 3824 >> 2];
    $11_1 = $1_1 + $10_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 3828 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 3696 | 0;
    $29_1 = $32_1;
    $8_1 = $7_1 + $11_1 | 0;
    $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $20_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $11_1 + $15_1 | 0;
    $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 3792 >> 2];
    $1_1 = HEAP32[$6_1 + 3872 >> 2];
    $15_1 = $19_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 3796 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 3876 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $7_1 | 0;
    $11_1 = $11_1 + $15_1 | 0;
    $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $11_1 << 4 & -16;
    $7_1 = $3_1;
    $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
    $10_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 4032 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
    $27_1 = $6_1 + 3776 | 0;
    $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
    $25_1 = $6_1 + 3888 | 0;
    $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
    $23_1 = $6_1 + 3760 | 0;
    $22_1 = $23_1;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $11_1 + $15_1 | 0;
    $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $7_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 3776 >> 2];
    $1_1 = HEAP32[$6_1 + 3888 >> 2];
    $11_1 = $20_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 3780 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 3892 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $11_1 | 0;
    $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $19_1 = $6_1 + 3984 | 0;
    $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $22_1 = $6_1 + 4048 | 0;
    $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $15_1 = $6_1 + 3744 | 0;
    $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
    $18_1 = $6_1 + 3728 | 0;
    $13_1 = $18_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $11_1 + $16_1 | 0;
    $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 3744 >> 2];
    $9_1 = $7_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 3748 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $20_1 = $6_1 + 3712 | 0;
    $11_1 = $20_1;
    $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $15_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 3696 >> 2];
    $1_1 = HEAP32[$6_1 + 4096 >> 2];
    $9_1 = $4_1 + $1_1 | 0;
    $7_1 = HEAP32[$6_1 + 3700 >> 2];
    $3_1 = $7_1 + HEAP32[$6_1 + 4100 >> 2] | 0;
    $30_1 = $6_1 + 7416 | 0;
    $27_1 = $30_1 + 8 | 0;
    $17_1 = $27_1;
    $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $11_1 | 0;
    $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $11_1 = $5_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $16_1 = $3_1 << 12 | $1_1 >>> 20;
    $21_1 = HEAP32[$6_1 + 3764 >> 2];
    $3_1 = $21_1 + HEAP32[$6_1 + 4036 >> 2] | 0;
    $15_1 = HEAP32[$6_1 + 3760 >> 2];
    $1_1 = HEAP32[$6_1 + 4032 >> 2];
    $5_1 = $15_1 + $1_1 | 0;
    $13_1 = $5_1;
    $7_1 = $5_1 + $7_1 | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $16_1 | 0;
    HEAP32[$17_1 >> 2] = $7_1;
    $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$17_1 + 4 >> 2] = $5_1 & 1048575;
    $25_1 = $30_1 + 16 | 0;
    $17_1 = $25_1;
    $16_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $13_1 + $15_1 | 0;
    $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $24_1 = HEAP32[$6_1 + 3984 >> 2];
    $1_1 = HEAP32[$6_1 + 4048 >> 2];
    $16_1 = $24_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 3988 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 4052 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 3728 >> 2];
    $13_1 = $1_1 + $16_1 | 0;
    $15_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 3732 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$17_1 >> 2] = $7_1;
    $5_1 = $3_1;
    HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
    $28_1 = $30_1 + 24 | 0;
    $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
    $1_1 = $18_1 + 8 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $18_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $19_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $13_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $7_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 + $21_1 | 0;
    $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $16_1 = HEAP32[$6_1 + 3712 >> 2];
    $5_1 = $14_1 & -2;
    $1_1 = $16_1 + $5_1 | 0;
    $18_1 = HEAP32[$6_1 + 3716 >> 2];
    $3_1 = $18_1 + ($12_1 & 1048575) | 0;
    $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $14_1 + $7_1 | 0;
    $12_1 = $1_1;
    $5_1 = $1_1 + $13_1 | 0;
    HEAP32[$28_1 >> 2] = $5_1;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
    $15_1 = $30_1 + 32 | 0;
    $7_1 = $8_1;
    $13_1 = $10_1 & 65535;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $5_1 = ($14_1 | 0) == ($18_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $18_1 >>> 0;
    $3_1 = $20_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $7_1 | 0;
    $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$15_1 >> 2] = $5_1;
    HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7416 >> 2] = $9_1;
    HEAP32[$6_1 + 7420 >> 2] = $11_1 & 1048575;
    $34($30_1, $30_1, $40_1);
    $9_1 = HEAP32[$15_1 + 4 >> 2];
    $3_1 = $6_1 + 7376 | 0;
    $1_1 = $3_1 + 32 | 0;
    $4_1 = HEAP32[$15_1 >> 2];
    HEAP32[$1_1 >> 2] = $4_1;
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $10_1 = HEAP32[$28_1 + 4 >> 2];
    $1_1 = $3_1 + 24 | 0;
    $11_1 = HEAP32[$28_1 >> 2];
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $13_1 = HEAP32[$25_1 + 4 >> 2];
    $1_1 = $3_1 + 16 | 0;
    $7_1 = HEAP32[$25_1 >> 2];
    HEAP32[$1_1 >> 2] = $7_1;
    HEAP32[$1_1 + 4 >> 2] = $13_1;
    $14_1 = HEAP32[$27_1 + 4 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $8_1 = HEAP32[$27_1 >> 2];
    HEAP32[$1_1 >> 2] = $8_1;
    HEAP32[$1_1 + 4 >> 2] = $14_1;
    $12_1 = HEAP32[$6_1 + 7420 >> 2];
    $5_1 = HEAP32[$6_1 + 7416 >> 2];
    HEAP32[$6_1 + 7376 >> 2] = $5_1;
    HEAP32[$6_1 + 7380 >> 2] = $12_1;
    $1_1 = 11;
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 3664 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 3584 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 3520 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 3504 | 0;
      $69($18_1, HEAP32[$6_1 + 3520 >> 2], HEAP32[$6_1 + 3524 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 3472 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 3632 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 3568 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 3488 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 3680 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 3456 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 3536 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 3668 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 3588 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 3664 >> 2];
      $5_1 = HEAP32[$6_1 + 3584 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 3504 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 3508 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 3632 >> 2];
      $4_1 = HEAP32[$6_1 + 3568 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 3636 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 3572 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3472 >> 2];
      $11_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3476 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3488 >> 2];
      $8_1 = $4_1 + $11_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3492 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 3440 | 0;
      $9_1 = $8_1 + $9_1 | 0;
      $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $11_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $18_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 3460 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 3540 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 3456 >> 2];
      $4_1 = HEAP32[$6_1 + 3536 >> 2];
      $7_1 = $25_1 + $4_1 | 0;
      $15_1 = $7_1;
      $11_1 = $7_1 + $11_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $18_1 | 0;
      $23_1 = $11_1 << 4 & -16;
      $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 3616 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 3424 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 3648 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 3408 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $11_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 3428 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 3652 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 3424 >> 2];
      $4_1 = HEAP32[$6_1 + 3648 >> 2];
      $8_1 = $15_1 + $4_1 | 0;
      $11_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 3552 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 3600 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 3392 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 3376 | 0;
      $12_1 = $26_1;
      $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
      $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 3392 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 3396 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 3360 | 0;
      $11_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 3440 >> 2];
      $4_1 = HEAP32[$6_1 + 3680 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 3444 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 3684 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 3408 >> 2];
      $4_1 = HEAP32[$6_1 + 3616 >> 2];
      $11_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 3412 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 3620 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $8_1 | 0;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $11_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$11_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1 + $16_1 | 0;
      $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $11_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 3552 >> 2];
      $4_1 = HEAP32[$6_1 + 3600 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 3556 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 3604 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3376 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3380 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $10_1 + $11_1 | 0;
      $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $11_1;
      $21_1 = $4_1 << 12 | $11_1 >>> 20;
      $5_1 = $3_1;
      $10_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 3360 >> 2];
      $11_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 3364 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $11_1;
      $11_1 = $11_1 + $21_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $10_1 | 0;
      $14_1 = $9_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1 << 12 | $10_1 >>> 20;
      $5_1 = $9_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $5_1;
      $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $10_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    $1_1 = $6_1 + 7376 | 0;
    $17_1 = $1_1 + 32 | 0;
    HEAP32[$17_1 >> 2] = $4_1;
    HEAP32[$17_1 + 4 >> 2] = $9_1;
    $18_1 = $1_1 + 24 | 0;
    HEAP32[$18_1 >> 2] = $11_1;
    HEAP32[$18_1 + 4 >> 2] = $10_1;
    $15_1 = $1_1 + 16 | 0;
    HEAP32[$15_1 >> 2] = $7_1;
    HEAP32[$15_1 + 4 >> 2] = $13_1;
    $16_1 = $1_1 + 8 | 0;
    HEAP32[$16_1 >> 2] = $8_1;
    HEAP32[$16_1 + 4 >> 2] = $14_1;
    HEAP32[$6_1 + 7376 >> 2] = $5_1;
    HEAP32[$6_1 + 7380 >> 2] = $12_1;
    $34($1_1, $1_1, $6_1 + 7416 | 0);
    $9_1 = HEAP32[$17_1 + 4 >> 2];
    $3_1 = $6_1 + 7336 | 0;
    $1_1 = $3_1 + 32 | 0;
    $4_1 = HEAP32[$17_1 >> 2];
    HEAP32[$1_1 >> 2] = $4_1;
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $10_1 = HEAP32[$18_1 + 4 >> 2];
    $1_1 = $3_1 + 24 | 0;
    $11_1 = HEAP32[$18_1 >> 2];
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $13_1 = HEAP32[$15_1 + 4 >> 2];
    $1_1 = $3_1 + 16 | 0;
    $7_1 = HEAP32[$15_1 >> 2];
    HEAP32[$1_1 >> 2] = $7_1;
    HEAP32[$1_1 + 4 >> 2] = $13_1;
    $14_1 = HEAP32[$16_1 + 4 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $8_1 = HEAP32[$16_1 >> 2];
    HEAP32[$1_1 >> 2] = $8_1;
    HEAP32[$1_1 + 4 >> 2] = $14_1;
    $12_1 = HEAP32[$6_1 + 7380 >> 2];
    $5_1 = HEAP32[$6_1 + 7376 >> 2];
    HEAP32[$6_1 + 7336 >> 2] = $5_1;
    HEAP32[$6_1 + 7340 >> 2] = $12_1;
    $1_1 = 22;
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 3328 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 3248 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 3184 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 3168 | 0;
      $69($18_1, HEAP32[$6_1 + 3184 >> 2], HEAP32[$6_1 + 3188 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 3136 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 3296 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 3232 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 3152 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 3344 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 3120 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 3200 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 3332 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 3252 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 3328 >> 2];
      $5_1 = HEAP32[$6_1 + 3248 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 3168 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 3172 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $11_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 3296 >> 2];
      $4_1 = HEAP32[$6_1 + 3232 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 3300 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 3236 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3136 >> 2];
      $9_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3140 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3152 >> 2];
      $8_1 = $4_1 + $9_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3156 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 3104 | 0;
      $11_1 = $8_1 + $11_1 | 0;
      $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $9_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $18_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 3124 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 3204 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 3120 >> 2];
      $4_1 = HEAP32[$6_1 + 3200 >> 2];
      $7_1 = $25_1 + $4_1 | 0;
      $15_1 = $7_1;
      $9_1 = $7_1 + $9_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $18_1 | 0;
      $23_1 = $9_1 << 4 & -16;
      $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 3280 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 3088 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 3312 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 3072 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 3092 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 3316 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 3088 >> 2];
      $4_1 = HEAP32[$6_1 + 3312 >> 2];
      $8_1 = $15_1 + $4_1 | 0;
      $9_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 3216 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 3264 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 3056 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 3040 | 0;
      $12_1 = $26_1;
      $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $9_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 3056 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 3060 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 3024 | 0;
      $9_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 3104 >> 2];
      $4_1 = HEAP32[$6_1 + 3344 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 3108 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 3348 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 3072 >> 2];
      $4_1 = HEAP32[$6_1 + 3280 >> 2];
      $8_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 3076 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 3284 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1;
      $9_1 = $8_1;
      $8_1 = $4_1 + $8_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $7_1 | 0;
      $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $9_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$9_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $16_1 | 0;
      $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $9_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 3216 >> 2];
      $4_1 = HEAP32[$6_1 + 3264 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 3220 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 3268 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 3040 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 3044 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $9_1 + $10_1 | 0;
      $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $9_1;
      $10_1 = $4_1 << 12 | $9_1 >>> 20;
      $5_1 = $3_1;
      $9_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 3024 >> 2];
      $17_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 3028 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      $14_1 = $11_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $10_1 + $17_1 | 0;
      $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1;
      $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1;
      $10_1 = $4_1 << 12 | $5_1 >>> 20;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $9_1;
      $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $5_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    $1_1 = $6_1 + 7336 | 0;
    $17_1 = $1_1 + 32 | 0;
    HEAP32[$17_1 >> 2] = $4_1;
    HEAP32[$17_1 + 4 >> 2] = $9_1;
    $18_1 = $1_1 + 24 | 0;
    HEAP32[$18_1 >> 2] = $11_1;
    HEAP32[$18_1 + 4 >> 2] = $10_1;
    $15_1 = $1_1 + 16 | 0;
    HEAP32[$15_1 >> 2] = $7_1;
    HEAP32[$15_1 + 4 >> 2] = $13_1;
    $16_1 = $1_1 + 8 | 0;
    HEAP32[$16_1 >> 2] = $8_1;
    HEAP32[$16_1 + 4 >> 2] = $14_1;
    HEAP32[$6_1 + 7336 >> 2] = $5_1;
    HEAP32[$6_1 + 7340 >> 2] = $12_1;
    $34($1_1, $1_1, $6_1 + 7376 | 0);
    $9_1 = HEAP32[$17_1 + 4 >> 2];
    $3_1 = $6_1 + 7296 | 0;
    $1_1 = $3_1 + 32 | 0;
    $4_1 = HEAP32[$17_1 >> 2];
    HEAP32[$1_1 >> 2] = $4_1;
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $10_1 = HEAP32[$18_1 + 4 >> 2];
    $1_1 = $3_1 + 24 | 0;
    $11_1 = HEAP32[$18_1 >> 2];
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $13_1 = HEAP32[$15_1 + 4 >> 2];
    $1_1 = $3_1 + 16 | 0;
    $7_1 = HEAP32[$15_1 >> 2];
    HEAP32[$1_1 >> 2] = $7_1;
    HEAP32[$1_1 + 4 >> 2] = $13_1;
    $14_1 = HEAP32[$16_1 + 4 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $8_1 = HEAP32[$16_1 >> 2];
    HEAP32[$1_1 >> 2] = $8_1;
    HEAP32[$1_1 + 4 >> 2] = $14_1;
    $12_1 = HEAP32[$6_1 + 7340 >> 2];
    $5_1 = HEAP32[$6_1 + 7336 >> 2];
    HEAP32[$6_1 + 7296 >> 2] = $5_1;
    HEAP32[$6_1 + 7300 >> 2] = $12_1;
    $1_1 = 44;
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 2992 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 2912 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 2848 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 2832 | 0;
      $69($18_1, HEAP32[$6_1 + 2848 >> 2], HEAP32[$6_1 + 2852 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 2800 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 2960 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 2896 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 2816 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 3008 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 2784 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 2864 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 2996 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 2916 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 2992 >> 2];
      $5_1 = HEAP32[$6_1 + 2912 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 2832 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 2836 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2960 >> 2];
      $4_1 = HEAP32[$6_1 + 2896 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 2964 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 2900 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2800 >> 2];
      $11_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2804 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2816 >> 2];
      $8_1 = $4_1 + $11_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2820 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 2768 | 0;
      $9_1 = $8_1 + $9_1 | 0;
      $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $11_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $18_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2788 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 2868 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 2784 >> 2];
      $4_1 = HEAP32[$6_1 + 2864 >> 2];
      $7_1 = $25_1 + $4_1 | 0;
      $15_1 = $7_1;
      $11_1 = $7_1 + $11_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $18_1 | 0;
      $23_1 = $11_1 << 4 & -16;
      $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 2944 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 2752 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 2976 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 2736 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $11_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2756 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 2980 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 2752 >> 2];
      $4_1 = HEAP32[$6_1 + 2976 >> 2];
      $8_1 = $15_1 + $4_1 | 0;
      $11_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 2880 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 2928 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 2720 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 2704 | 0;
      $12_1 = $26_1;
      $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
      $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 2720 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 2724 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 2688 | 0;
      $11_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 2768 >> 2];
      $4_1 = HEAP32[$6_1 + 3008 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 2772 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 3012 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 2736 >> 2];
      $4_1 = HEAP32[$6_1 + 2944 >> 2];
      $11_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 2740 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 2948 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $8_1 | 0;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $11_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$11_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1 + $16_1 | 0;
      $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $11_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 2880 >> 2];
      $4_1 = HEAP32[$6_1 + 2928 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 2884 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 2932 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2704 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2708 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $10_1 + $11_1 | 0;
      $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $11_1;
      $21_1 = $4_1 << 12 | $11_1 >>> 20;
      $5_1 = $3_1;
      $10_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 2688 >> 2];
      $11_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 2692 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $11_1;
      $11_1 = $11_1 + $21_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $10_1 | 0;
      $14_1 = $9_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1 << 12 | $10_1 >>> 20;
      $5_1 = $9_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $5_1;
      $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $10_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    $1_1 = $6_1 + 7296 | 0;
    $17_1 = $1_1 + 32 | 0;
    HEAP32[$17_1 >> 2] = $4_1;
    HEAP32[$17_1 + 4 >> 2] = $9_1;
    $18_1 = $1_1 + 24 | 0;
    HEAP32[$18_1 >> 2] = $11_1;
    HEAP32[$18_1 + 4 >> 2] = $10_1;
    $15_1 = $1_1 + 16 | 0;
    HEAP32[$15_1 >> 2] = $7_1;
    HEAP32[$15_1 + 4 >> 2] = $13_1;
    $16_1 = $1_1 + 8 | 0;
    HEAP32[$16_1 >> 2] = $8_1;
    HEAP32[$16_1 + 4 >> 2] = $14_1;
    HEAP32[$6_1 + 7296 >> 2] = $5_1;
    HEAP32[$6_1 + 7300 >> 2] = $12_1;
    $34($1_1, $1_1, $6_1 + 7336 | 0);
    $9_1 = HEAP32[$17_1 + 4 >> 2];
    $3_1 = $6_1 + 7256 | 0;
    $1_1 = $3_1 + 32 | 0;
    $4_1 = HEAP32[$17_1 >> 2];
    HEAP32[$1_1 >> 2] = $4_1;
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $10_1 = HEAP32[$18_1 + 4 >> 2];
    $1_1 = $3_1 + 24 | 0;
    $11_1 = HEAP32[$18_1 >> 2];
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $13_1 = HEAP32[$15_1 + 4 >> 2];
    $1_1 = $3_1 + 16 | 0;
    $7_1 = HEAP32[$15_1 >> 2];
    HEAP32[$1_1 >> 2] = $7_1;
    HEAP32[$1_1 + 4 >> 2] = $13_1;
    $14_1 = HEAP32[$16_1 + 4 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $8_1 = HEAP32[$16_1 >> 2];
    HEAP32[$1_1 >> 2] = $8_1;
    HEAP32[$1_1 + 4 >> 2] = $14_1;
    $12_1 = HEAP32[$6_1 + 7300 >> 2];
    $5_1 = HEAP32[$6_1 + 7296 >> 2];
    HEAP32[$6_1 + 7256 >> 2] = $5_1;
    HEAP32[$6_1 + 7260 >> 2] = $12_1;
    $1_1 = 88;
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 2656 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 2576 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 2512 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 2496 | 0;
      $69($18_1, HEAP32[$6_1 + 2512 >> 2], HEAP32[$6_1 + 2516 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 2464 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 2624 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 2560 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 2480 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 2672 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 2448 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 2528 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 2660 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 2580 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 2656 >> 2];
      $5_1 = HEAP32[$6_1 + 2576 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 2496 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 2500 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $11_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2624 >> 2];
      $4_1 = HEAP32[$6_1 + 2560 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 2628 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 2564 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2464 >> 2];
      $9_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2468 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2480 >> 2];
      $8_1 = $4_1 + $9_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2484 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 2432 | 0;
      $11_1 = $8_1 + $11_1 | 0;
      $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $9_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $18_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2452 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 2532 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 2448 >> 2];
      $4_1 = HEAP32[$6_1 + 2528 >> 2];
      $7_1 = $25_1 + $4_1 | 0;
      $15_1 = $7_1;
      $9_1 = $7_1 + $9_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $18_1 | 0;
      $23_1 = $9_1 << 4 & -16;
      $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 2608 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 2416 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 2640 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 2400 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2420 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 2644 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 2416 >> 2];
      $4_1 = HEAP32[$6_1 + 2640 >> 2];
      $8_1 = $15_1 + $4_1 | 0;
      $9_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 2544 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 2592 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 2384 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 2368 | 0;
      $12_1 = $26_1;
      $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $9_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 2384 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 2388 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 2352 | 0;
      $9_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 2432 >> 2];
      $4_1 = HEAP32[$6_1 + 2672 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 2436 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 2676 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 2400 >> 2];
      $4_1 = HEAP32[$6_1 + 2608 >> 2];
      $8_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 2404 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 2612 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1;
      $9_1 = $8_1;
      $8_1 = $4_1 + $8_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $7_1 | 0;
      $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $9_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$9_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $16_1 | 0;
      $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $9_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 2544 >> 2];
      $4_1 = HEAP32[$6_1 + 2592 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 2548 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 2596 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2368 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2372 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $9_1 + $10_1 | 0;
      $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $9_1;
      $10_1 = $4_1 << 12 | $9_1 >>> 20;
      $5_1 = $3_1;
      $9_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 2352 >> 2];
      $17_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 2356 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      $14_1 = $11_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $10_1 + $17_1 | 0;
      $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1;
      $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1;
      $10_1 = $4_1 << 12 | $5_1 >>> 20;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $9_1;
      $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $5_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    $1_1 = $6_1 + 7256 | 0;
    $17_1 = $1_1 + 32 | 0;
    HEAP32[$17_1 >> 2] = $4_1;
    HEAP32[$17_1 + 4 >> 2] = $9_1;
    $18_1 = $1_1 + 24 | 0;
    HEAP32[$18_1 >> 2] = $11_1;
    HEAP32[$18_1 + 4 >> 2] = $10_1;
    $15_1 = $1_1 + 16 | 0;
    HEAP32[$15_1 >> 2] = $7_1;
    HEAP32[$15_1 + 4 >> 2] = $13_1;
    $16_1 = $1_1 + 8 | 0;
    HEAP32[$16_1 >> 2] = $8_1;
    HEAP32[$16_1 + 4 >> 2] = $14_1;
    HEAP32[$6_1 + 7256 >> 2] = $5_1;
    HEAP32[$6_1 + 7260 >> 2] = $12_1;
    $34($1_1, $1_1, $6_1 + 7296 | 0);
    $9_1 = HEAP32[$17_1 + 4 >> 2];
    $3_1 = $6_1 + 7216 | 0;
    $1_1 = $3_1 + 32 | 0;
    $4_1 = HEAP32[$17_1 >> 2];
    HEAP32[$1_1 >> 2] = $4_1;
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $10_1 = HEAP32[$18_1 + 4 >> 2];
    $1_1 = $3_1 + 24 | 0;
    $11_1 = HEAP32[$18_1 >> 2];
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $13_1 = HEAP32[$15_1 + 4 >> 2];
    $1_1 = $3_1 + 16 | 0;
    $7_1 = HEAP32[$15_1 >> 2];
    HEAP32[$1_1 >> 2] = $7_1;
    HEAP32[$1_1 + 4 >> 2] = $13_1;
    $14_1 = HEAP32[$16_1 + 4 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $8_1 = HEAP32[$16_1 >> 2];
    HEAP32[$1_1 >> 2] = $8_1;
    HEAP32[$1_1 + 4 >> 2] = $14_1;
    $12_1 = HEAP32[$6_1 + 7260 >> 2];
    $5_1 = HEAP32[$6_1 + 7256 >> 2];
    HEAP32[$6_1 + 7216 >> 2] = $5_1;
    HEAP32[$6_1 + 7220 >> 2] = $12_1;
    $1_1 = 44;
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 2320 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 2240 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 2176 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 2160 | 0;
      $69($18_1, HEAP32[$6_1 + 2176 >> 2], HEAP32[$6_1 + 2180 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 2128 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 2288 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 2224 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 2144 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 2336 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 2112 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 2192 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 2324 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 2244 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 2320 >> 2];
      $5_1 = HEAP32[$6_1 + 2240 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 2160 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 2164 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2288 >> 2];
      $4_1 = HEAP32[$6_1 + 2224 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 2292 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 2228 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2128 >> 2];
      $11_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2132 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2144 >> 2];
      $8_1 = $4_1 + $11_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2148 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 2096 | 0;
      $9_1 = $8_1 + $9_1 | 0;
      $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $11_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $11_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $18_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2116 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 2196 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 2112 >> 2];
      $4_1 = HEAP32[$6_1 + 2192 >> 2];
      $7_1 = $25_1 + $4_1 | 0;
      $15_1 = $7_1;
      $11_1 = $7_1 + $11_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $18_1 | 0;
      $23_1 = $11_1 << 4 & -16;
      $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 2272 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 2080 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 2304 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 2064 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $11_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 2084 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 2308 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 2080 >> 2];
      $4_1 = HEAP32[$6_1 + 2304 >> 2];
      $8_1 = $15_1 + $4_1 | 0;
      $11_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 2208 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 2256 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 2048 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 2032 | 0;
      $12_1 = $26_1;
      $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
      $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $11_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 2048 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 2052 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 2016 | 0;
      $11_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 2096 >> 2];
      $4_1 = HEAP32[$6_1 + 2336 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 2100 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 2340 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 2064 >> 2];
      $4_1 = HEAP32[$6_1 + 2272 >> 2];
      $11_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 2068 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 2276 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $8_1 | 0;
      $8_1 = $7_1 + $11_1 | 0;
      $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $11_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$11_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1 + $16_1 | 0;
      $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $11_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 2208 >> 2];
      $4_1 = HEAP32[$6_1 + 2256 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 2212 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 2260 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 2032 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 2036 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $10_1 + $11_1 | 0;
      $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $11_1;
      $21_1 = $4_1 << 12 | $11_1 >>> 20;
      $5_1 = $3_1;
      $10_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 2016 >> 2];
      $11_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 2020 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $11_1;
      $11_1 = $11_1 + $21_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $10_1 | 0;
      $14_1 = $9_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $4_1 << 12 | $10_1 >>> 20;
      $5_1 = $9_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $5_1;
      $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $10_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    $3_1 = $6_1 + 7216 | 0;
    $24_1 = $3_1 + 32 | 0;
    HEAP32[$24_1 >> 2] = $4_1;
    HEAP32[$24_1 + 4 >> 2] = $9_1;
    $1_1 = $3_1 + 24 | 0;
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $9_1 = $3_1 + 16 | 0;
    HEAP32[$9_1 >> 2] = $7_1;
    HEAP32[$9_1 + 4 >> 2] = $13_1;
    $17_1 = $3_1 + 8 | 0;
    HEAP32[$17_1 >> 2] = $8_1;
    HEAP32[$17_1 + 4 >> 2] = $14_1;
    HEAP32[$6_1 + 7216 >> 2] = $5_1;
    HEAP32[$6_1 + 7220 >> 2] = $12_1;
    $34($3_1, $3_1, $6_1 + 7336 | 0);
    $12_1 = HEAP32[$1_1 >> 2];
    $5_1 = $12_1;
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $10_1;
    $1_1 = HEAP32[$6_1 + 7220 >> 2];
    $20_1 = $1_1;
    $18_1 = HEAP32[$6_1 + 7216 >> 2];
    $7_1 = $18_1;
    $3_1 = $1_1 << 1 | $7_1 >>> 31;
    $15_1 = $6_1 + 1856 | 0;
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($15_1, $5_1, $4_1, 0, 0, $21_1, $3_1, 0, 0);
    $1_1 = HEAP32[$17_1 + 4 >> 2];
    $40_1 = $1_1;
    $33_1 = HEAP32[$17_1 >> 2];
    $4_1 = $33_1;
    $3_1 = $1_1 << 1 | $4_1 >>> 31;
    $16_1 = $6_1 + 1952 | 0;
    $13_1 = HEAP32[$9_1 >> 2];
    $9_1 = HEAP32[$9_1 + 4 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $3_1;
    $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
    $14_1 = $6_1 + 1840 | 0;
    $8_1 = HEAP32[$24_1 >> 2];
    $1_1 = HEAP32[$24_1 + 4 >> 2];
    $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $11_1 = $6_1 + 1824 | 0;
    $69($11_1, HEAP32[$6_1 + 1840 >> 2], HEAP32[$6_1 + 1844 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $1_1 << 1 | $8_1 >>> 31;
    $39_1 = $6_1 + 1792 | 0;
    $24_1 = $8_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $7_1, $20_1, 0, 0);
    $38_1 = $6_1 + 1872 | 0;
    $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
    $35_1 = $6_1 + 1936 | 0;
    $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
    $28_1 = $6_1 + 1808 | 0;
    $1_1 = $14_1 + 8 | 0;
    $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 2e3 | 0;
    $69($36_1, $7_1, $20_1, 0, 0, $7_1, $20_1, 0, 0);
    $31_1 = $6_1 + 1776 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $33_1, $40_1, 0, 0);
    $37_1 = $6_1 + 1888 | 0;
    $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
    $20_1 = HEAP32[$6_1 + 1860 >> 2];
    $3_1 = $20_1 + HEAP32[$6_1 + 1956 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 1856 >> 2];
    $4_1 = HEAP32[$6_1 + 1952 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 1824 >> 2];
    $18_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 1828 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $16_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $15_1 + 8 | 0;
    $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $5_1;
    $11_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 1872 >> 2];
    $1_1 = HEAP32[$6_1 + 1936 >> 2];
    $14_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 1876 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 1940 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1792 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1796 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1808 >> 2];
    $5_1 = $1_1 + $7_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1812 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 1760 | 0;
    $29_1 = $32_1;
    $11_1 = $5_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $28_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $28_1 = HEAP32[$1_1 >> 2];
    $16_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $14_1 | 0;
    $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $28_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $25_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 1776 >> 2];
    $1_1 = HEAP32[$6_1 + 1888 >> 2];
    $14_1 = $19_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 1780 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 1892 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $28_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 1984 | 0;
    $69($29_1, $33_1, $40_1, 0, 0, $21_1, $26_1, 0, 0);
    $25_1 = $6_1 + 1728 | 0;
    $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
    $22_1 = $6_1 + 1904 | 0;
    $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $28_1 = $6_1 + 1712 | 0;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $14_1 = $3_1 << 12 | $1_1 >>> 20;
    $27_1 = HEAP32[$6_1 + 1732 >> 2];
    $3_1 = $27_1 + HEAP32[$6_1 + 1908 >> 2] | 0;
    $20_1 = HEAP32[$6_1 + 1728 >> 2];
    $1_1 = HEAP32[$6_1 + 1904 >> 2];
    $5_1 = $20_1 + $1_1 | 0;
    $7_1 = $5_1;
    $8_1 = $5_1 + $8_1 | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $14_1 | 0;
    $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($28_1, $8_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 1920 | 0;
    $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $19_1 = $6_1 + 1968 | 0;
    $69($19_1, $33_1, $40_1, 0, 0, $33_1, $40_1, 0, 0);
    $14_1 = $6_1 + 1664 | 0;
    $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
    $21_1 = $6_1 + 1648 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 1664 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 1668 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 1584 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 1760 >> 2];
    $1_1 = HEAP32[$6_1 + 2e3 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 1764 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 2004 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $12_1 = $3_1 << 12 | $1_1 >>> 20;
    $14_1 = HEAP32[$6_1 + 1716 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 1988 >> 2] | 0;
    $10_1 = HEAP32[$6_1 + 1712 >> 2];
    $1_1 = HEAP32[$6_1 + 1984 >> 2];
    $5_1 = $10_1 + $1_1 | 0;
    $9_1 = $5_1;
    $8_1 = $5_1 + $8_1 | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $12_1 | 0;
    $5_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $28_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 1920 >> 2];
    $1_1 = HEAP32[$6_1 + 1968 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 1924 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 1972 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1648 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1652 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 1568 | 0;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $17_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $12_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 1588 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 1584 >> 2];
    $9_1 = $18_1 & -2;
    $1_1 = $22_1 + $9_1 | 0;
    $15_1 = $1_1;
    $1_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $12_1 | 0;
    $12_1 = $15_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $17_1 = $9_1 & 1048575;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $26_1 = $7_1 << 1;
    $24_1 = $3_1;
    $69($25_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 1600 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 1504 | 0;
    $21_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 1488 | 0;
    $69($11_1, HEAP32[$6_1 + 1504 >> 2], HEAP32[$6_1 + 1508 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 1456 | 0;
    $20_1 = $1_1 << 1;
    $21_1 = $3_1;
    $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 1552 | 0;
    $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 1616 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 1472 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 1744 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 1440 | 0;
    $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 1520 | 0;
    $10_1 = $17_1;
    $9_1 = $18_1;
    $17_1 = $5_1;
    $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 1568 >> 2];
    $4_1 = HEAP32[$6_1 + 1600 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $13_1 = HEAP32[$6_1 + 1572 >> 2];
    $3_1 = $13_1 + HEAP32[$6_1 + 1604 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 1488 >> 2];
    $18_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1492 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $13_1 | 0;
    $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $4_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 1552 >> 2];
    $1_1 = HEAP32[$6_1 + 1616 >> 2];
    $13_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 1556 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 1620 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1456 >> 2];
    $14_1 = $1_1 + $13_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1460 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1472 >> 2];
    $7_1 = $1_1 + $14_1 | 0;
    $16_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1476 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 1344 | 0;
    $29_1 = $32_1;
    $11_1 = $7_1 + $11_1 | 0;
    $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $16_1 = HEAP32[$1_1 >> 2];
    $14_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $13_1 | 0;
    $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $8_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 1440 >> 2];
    $1_1 = HEAP32[$6_1 + 1520 >> 2];
    $14_1 = $19_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 1444 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 1524 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $7_1 = $7_1 + $14_1 | 0;
    $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $7_1 << 4 & -16;
    $8_1 = $3_1;
    $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
    $16_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 1680 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
    $27_1 = $6_1 + 1424 | 0;
    $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
    $25_1 = $6_1 + 1536 | 0;
    $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
    $22_1 = $6_1 + 1408 | 0;
    $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $13_1 = HEAP32[$6_1 + 1424 >> 2];
    $1_1 = HEAP32[$6_1 + 1536 >> 2];
    $7_1 = $13_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 1428 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 1540 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $7_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $23_1 = $6_1 + 1632 | 0;
    $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
    $19_1 = $6_1 + 1696 | 0;
    $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $14_1 = $6_1 + 1392 | 0;
    $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
    $21_1 = $6_1 + 1376 | 0;
    $10_1 = $21_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 1392 >> 2];
    $9_1 = $8_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 1396 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $27_1 = $6_1 + 1360 | 0;
    $7_1 = $27_1;
    $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $14_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 1344 >> 2];
    $1_1 = HEAP32[$6_1 + 1744 >> 2];
    $7_1 = $4_1 + $1_1 | 0;
    $8_1 = HEAP32[$6_1 + 1348 >> 2];
    $3_1 = $8_1 + HEAP32[$6_1 + 1748 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $9_1 | 0;
    $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $5_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $10_1 = HEAP32[$6_1 + 1408 >> 2];
    $1_1 = HEAP32[$6_1 + 1680 >> 2];
    $9_1 = $10_1 + $1_1 | 0;
    $14_1 = HEAP32[$6_1 + 1412 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 1684 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $8_1 = $8_1 + $9_1 | 0;
    $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $1_1 = $22_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $10_1 + $14_1 | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $5_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$6_1 + 1632 >> 2];
    $1_1 = HEAP32[$6_1 + 1696 >> 2];
    $12_1 = $22_1 + $1_1 | 0;
    $29_1 = HEAP32[$6_1 + 1636 >> 2];
    $3_1 = $29_1 + HEAP32[$6_1 + 1700 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1376 >> 2];
    $10_1 = $1_1 + $12_1 | 0;
    $17_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1380 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $25_1 = $6_1 + 1264 | 0;
    $5_1 = $9_1 + $10_1 | 0;
    $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $21_1 + 8 | 0;
    $26_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
    $3_1 = $19_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $12_1 + $17_1 | 0;
    $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $1_1 + $24_1 | 0;
    $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $9_1;
    $12_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $3_1;
    $17_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 1364 >> 2];
    $3_1 = $29_1 + ($15_1 & 1048575) | 0;
    $22_1 = HEAP32[$6_1 + 1360 >> 2];
    $1_1 = $18_1 & -2;
    $9_1 = $22_1 + $1_1 | 0;
    $15_1 = $9_1;
    $12_1 = $9_1 + $12_1 | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $17_1 | 0;
    $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = $9_1 & 1048575;
    $18_1 = $20_1;
    $3_1 = $13_1 & 1048575;
    $32_1 = $3_1;
    $13_1 = $7_1;
    $3_1 = $3_1 << 1 | $7_1 >>> 31;
    $21_1 = $7_1 << 1;
    $26_1 = $3_1;
    $69($25_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
    $3_1 = $14_1 & 1048575;
    $33_1 = $3_1;
    $23_1 = $6_1 + 1216 | 0;
    $18_1 = $10_1 & 1048575;
    $7_1 = $8_1 << 1;
    $28_1 = $8_1;
    $10_1 = $3_1 << 1 | $8_1 >>> 31;
    $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
    $19_1 = $6_1 + 1168 | 0;
    $17_1 = $16_1 & 65535;
    $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $8_1 + $11_1 | 0;
    $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
    $11_1 = $6_1 + 1152 | 0;
    $69($11_1, HEAP32[$6_1 + 1168 >> 2], HEAP32[$6_1 + 1172 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $4_1;
    $3_1 = $3_1 << 1 | $1_1 >>> 31;
    $39_1 = $6_1 + 1120 | 0;
    $24_1 = $1_1 << 1;
    $17_1 = $3_1;
    $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
    $38_1 = $6_1 + 1200 | 0;
    $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
    $35_1 = $6_1 + 1312 | 0;
    $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
    $22_1 = $6_1 + 1136 | 0;
    $1_1 = $19_1 + 8 | 0;
    $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $36_1 = $6_1 + 1280 | 0;
    $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
    $31_1 = $6_1 + 1104 | 0;
    $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
    $37_1 = $6_1 + 1184 | 0;
    $16_1 = $12_1;
    $13_1 = $20_1;
    $9_1 = $18_1;
    $18_1 = $5_1;
    $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$6_1 + 1264 >> 2];
    $4_1 = HEAP32[$6_1 + 1216 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $12_1 = HEAP32[$6_1 + 1268 >> 2];
    $3_1 = $12_1 + HEAP32[$6_1 + 1220 >> 2] | 0;
    $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$6_1 + 1152 >> 2];
    $14_1 = $4_1 + $1_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1156 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $12_1 | 0;
    $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $30_1 = HEAP32[$6_1 + 1200 >> 2];
    $1_1 = HEAP32[$6_1 + 1312 >> 2];
    $15_1 = $30_1 + $1_1 | 0;
    $34_1 = HEAP32[$6_1 + 1204 >> 2];
    $3_1 = $34_1 + HEAP32[$6_1 + 1316 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1120 >> 2];
    $10_1 = $1_1 + $15_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1124 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1136 >> 2];
    $11_1 = $1_1 + $10_1 | 0;
    $20_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1140 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $32_1 = $6_1 + 1008 | 0;
    $29_1 = $32_1;
    $8_1 = $7_1 + $11_1 | 0;
    $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
    $1_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
    $1_1 = $39_1 + 8 | 0;
    $20_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $38_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $11_1 + $15_1 | 0;
    $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1 + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1;
    $11_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $19_1 = HEAP32[$6_1 + 1104 >> 2];
    $1_1 = HEAP32[$6_1 + 1184 >> 2];
    $15_1 = $19_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 1108 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 1188 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $7_1 | 0;
    $11_1 = $11_1 + $15_1 | 0;
    $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $11_1 << 4 & -16;
    $7_1 = $3_1;
    $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
    $10_1 = $4_1;
    $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
    $29_1 = $6_1 + 1248 | 0;
    $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
    $27_1 = $6_1 + 1088 | 0;
    $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
    $25_1 = $6_1 + 1328 | 0;
    $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
    $23_1 = $6_1 + 1072 | 0;
    $22_1 = $23_1;
    $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $31_1 + 8 | 0;
    $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $11_1 + $15_1 | 0;
    $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $20_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $7_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 1088 >> 2];
    $1_1 = HEAP32[$6_1 + 1328 >> 2];
    $11_1 = $20_1 + $1_1 | 0;
    $30_1 = HEAP32[$6_1 + 1092 >> 2];
    $3_1 = $30_1 + HEAP32[$6_1 + 1332 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $11_1 | 0;
    $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $3_1;
    $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $19_1 = $6_1 + 1232 | 0;
    $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
    $22_1 = $6_1 + 1296 | 0;
    $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $15_1 = $6_1 + 1056 | 0;
    $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
    $18_1 = $6_1 + 1040 | 0;
    $13_1 = $18_1;
    $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
    $3_1 = $25_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $27_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $11_1 + $16_1 | 0;
    $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 1056 >> 2];
    $9_1 = $7_1 + $5_1 | 0;
    $4_1 = $3_1;
    $1_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + HEAP32[$6_1 + 1060 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $20_1 = $6_1 + 1024 | 0;
    $11_1 = $20_1;
    $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $1_1 = $15_1 + 8 | 0;
    $5_1 = HEAP32[$1_1 >> 2];
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = HEAP32[$6_1 + 1008 >> 2];
    $1_1 = HEAP32[$6_1 + 1280 >> 2];
    $9_1 = $4_1 + $1_1 | 0;
    $7_1 = HEAP32[$6_1 + 1012 >> 2];
    $3_1 = $7_1 + HEAP32[$6_1 + 1284 >> 2] | 0;
    $30_1 = $6_1 + 7176 | 0;
    $27_1 = $30_1 + 8 | 0;
    $16_1 = $27_1;
    $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $7_1 + $11_1 | 0;
    $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $11_1 = $5_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $15_1 = HEAP32[$6_1 + 1072 >> 2];
    $1_1 = HEAP32[$6_1 + 1248 >> 2];
    $13_1 = $15_1 + $1_1 | 0;
    $21_1 = HEAP32[$6_1 + 1076 >> 2];
    $3_1 = $21_1 + HEAP32[$6_1 + 1252 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$16_1 >> 2] = $7_1;
    $5_1 = $3_1;
    HEAP32[$16_1 + 4 >> 2] = $3_1 & 1048575;
    $25_1 = $30_1 + 16 | 0;
    $17_1 = $25_1;
    $16_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
    $3_1 = $29_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $23_1 + 8 | 0;
    $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $13_1 + $15_1 | 0;
    $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $5_1 = $3_1 << 12 | $1_1 >>> 20;
    $24_1 = HEAP32[$6_1 + 1232 >> 2];
    $1_1 = HEAP32[$6_1 + 1296 >> 2];
    $16_1 = $24_1 + $1_1 | 0;
    $23_1 = HEAP32[$6_1 + 1236 >> 2];
    $3_1 = $23_1 + HEAP32[$6_1 + 1300 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 1040 >> 2];
    $13_1 = $1_1 + $16_1 | 0;
    $15_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 1044 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $5_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$17_1 >> 2] = $7_1;
    $5_1 = $3_1;
    HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
    $28_1 = $30_1 + 24 | 0;
    $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
    $1_1 = $18_1 + 8 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $18_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $19_1 + 8 | 0;
    $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $13_1 + $16_1 | 0;
    $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $7_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 + $21_1 | 0;
    $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $26_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $7_1 = $3_1 << 12 | $1_1 >>> 20;
    $16_1 = HEAP32[$6_1 + 1024 >> 2];
    $5_1 = $14_1 & -2;
    $1_1 = $16_1 + $5_1 | 0;
    $18_1 = HEAP32[$6_1 + 1028 >> 2];
    $3_1 = $18_1 + ($12_1 & 1048575) | 0;
    $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $14_1 + $7_1 | 0;
    $12_1 = $1_1;
    $5_1 = $1_1 + $13_1 | 0;
    $3_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$28_1 >> 2] = $5_1;
    $1_1 = $3_1;
    HEAP32[$28_1 + 4 >> 2] = $3_1 & 1048575;
    $15_1 = $30_1 + 32 | 0;
    $7_1 = $8_1;
    $13_1 = $10_1 & 65535;
    $10_1 = ($3_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $14_1 >>> 0;
    $5_1 = ($14_1 | 0) == ($18_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $18_1 >>> 0;
    $3_1 = $20_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $7_1 | 0;
    $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$15_1 >> 2] = $5_1;
    HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 + 7176 >> 2] = $9_1;
    HEAP32[$6_1 + 7180 >> 2] = $11_1 & 1048575;
    $34($30_1, $30_1, $6_1 + 7536 | 0);
    $9_1 = HEAP32[$15_1 + 4 >> 2];
    $3_1 = $6_1 + 7136 | 0;
    $1_1 = $3_1 + 32 | 0;
    $4_1 = HEAP32[$15_1 >> 2];
    HEAP32[$1_1 >> 2] = $4_1;
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $10_1 = HEAP32[$28_1 + 4 >> 2];
    $1_1 = $3_1 + 24 | 0;
    $11_1 = HEAP32[$28_1 >> 2];
    HEAP32[$1_1 >> 2] = $11_1;
    HEAP32[$1_1 + 4 >> 2] = $10_1;
    $13_1 = HEAP32[$25_1 + 4 >> 2];
    $1_1 = $3_1 + 16 | 0;
    $7_1 = HEAP32[$25_1 >> 2];
    HEAP32[$1_1 >> 2] = $7_1;
    HEAP32[$1_1 + 4 >> 2] = $13_1;
    $14_1 = HEAP32[$27_1 + 4 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $8_1 = HEAP32[$27_1 >> 2];
    HEAP32[$1_1 >> 2] = $8_1;
    HEAP32[$1_1 + 4 >> 2] = $14_1;
    $12_1 = HEAP32[$6_1 + 7180 >> 2];
    $5_1 = HEAP32[$6_1 + 7176 >> 2];
    HEAP32[$6_1 + 7136 >> 2] = $5_1;
    HEAP32[$6_1 + 7140 >> 2] = $12_1;
    $1_1 = 23;
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 976 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 896 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 832 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 816 | 0;
      $69($18_1, HEAP32[$6_1 + 832 >> 2], HEAP32[$6_1 + 836 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 784 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 944 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 880 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 800 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 992 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 768 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 848 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 980 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 900 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 976 >> 2];
      $5_1 = HEAP32[$6_1 + 896 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 816 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 820 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $11_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 944 >> 2];
      $4_1 = HEAP32[$6_1 + 880 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 948 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 884 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 784 >> 2];
      $9_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 788 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 800 >> 2];
      $8_1 = $4_1 + $9_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 804 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 752 | 0;
      $11_1 = $8_1 + $11_1 | 0;
      $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $9_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $18_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 772 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 852 >> 2] | 0;
      $25_1 = HEAP32[$6_1 + 768 >> 2];
      $4_1 = HEAP32[$6_1 + 848 >> 2];
      $7_1 = $25_1 + $4_1 | 0;
      $15_1 = $7_1;
      $9_1 = $7_1 + $9_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $18_1 | 0;
      $23_1 = $9_1 << 4 & -16;
      $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 928 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 736 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 960 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 720 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $8_1 = $3_1 << 12 | $4_1 >>> 20;
      $15_1 = HEAP32[$6_1 + 736 >> 2];
      $4_1 = HEAP32[$6_1 + 960 >> 2];
      $9_1 = $15_1 + $4_1 | 0;
      $19_1 = HEAP32[$6_1 + 740 >> 2];
      $3_1 = $19_1 + HEAP32[$6_1 + 964 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $8_1 | 0;
      $7_1 = $7_1 + $9_1 | 0;
      $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $3_1;
      $69($23_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 864 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 912 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 704 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 688 | 0;
      $12_1 = $26_1;
      $10_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $19_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $9_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 704 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 708 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 672 | 0;
      $9_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 752 >> 2];
      $4_1 = HEAP32[$6_1 + 992 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 756 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 996 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 720 >> 2];
      $4_1 = HEAP32[$6_1 + 928 >> 2];
      $8_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 724 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 932 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1;
      $9_1 = $8_1;
      $8_1 = $4_1 + $8_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $7_1 | 0;
      $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $9_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$9_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $16_1 | 0;
      $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $9_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 864 >> 2];
      $4_1 = HEAP32[$6_1 + 912 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 868 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 916 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 688 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 692 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $9_1 + $10_1 | 0;
      $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $9_1;
      $10_1 = $4_1 << 12 | $9_1 >>> 20;
      $5_1 = $3_1;
      $9_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 672 >> 2];
      $17_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 676 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      $14_1 = $11_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $10_1 + $17_1 | 0;
      $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1;
      $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1;
      $10_1 = $4_1 << 12 | $5_1 >>> 20;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $9_1;
      $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $5_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    HEAP32[$6_1 + 7168 >> 2] = $4_1;
    HEAP32[$6_1 + 7172 >> 2] = $9_1;
    HEAP32[$6_1 + 7160 >> 2] = $11_1;
    HEAP32[$6_1 + 7164 >> 2] = $10_1;
    HEAP32[$6_1 + 7152 >> 2] = $7_1;
    HEAP32[$6_1 + 7156 >> 2] = $13_1;
    HEAP32[$6_1 + 7144 >> 2] = $8_1;
    HEAP32[$6_1 + 7148 >> 2] = $14_1;
    HEAP32[$6_1 + 7136 >> 2] = $5_1;
    HEAP32[$6_1 + 7140 >> 2] = $12_1;
    $1_1 = $6_1 + 7136 | 0;
    $34($1_1, $1_1, $6_1 + 7376 | 0);
    $1_1 = 6;
    $4_1 = HEAP32[$6_1 + 7168 >> 2];
    $9_1 = HEAP32[$6_1 + 7172 >> 2];
    $11_1 = HEAP32[$6_1 + 7160 >> 2];
    $10_1 = HEAP32[$6_1 + 7164 >> 2];
    $7_1 = HEAP32[$6_1 + 7152 >> 2];
    $13_1 = HEAP32[$6_1 + 7156 >> 2];
    $8_1 = HEAP32[$6_1 + 7144 >> 2];
    $14_1 = HEAP32[$6_1 + 7148 >> 2];
    $5_1 = HEAP32[$6_1 + 7136 >> 2];
    $12_1 = HEAP32[$6_1 + 7140 >> 2];
    while (1) {
      $15_1 = $5_1;
      $3_1 = $12_1 << 1 | $5_1 >>> 31;
      $25_1 = $6_1 + 640 | 0;
      $20_1 = $5_1 << 1;
      $28_1 = $3_1;
      $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
      $19_1 = $6_1 + 560 | 0;
      $5_1 = $8_1 << 1;
      $16_1 = $14_1;
      $24_1 = $8_1;
      $8_1 = $14_1 << 1 | $8_1 >>> 31;
      $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
      $17_1 = $6_1 + 496 | 0;
      $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
      $18_1 = $6_1 + 480 | 0;
      $69($18_1, HEAP32[$6_1 + 496 >> 2], HEAP32[$6_1 + 500 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $9_1 << 1 | $4_1 >>> 31;
      $33_1 = $6_1 + 448 | 0;
      $22_1 = $4_1 << 1;
      $26_1 = $3_1;
      $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
      $34_1 = $6_1 + 608 | 0;
      $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
      $39_1 = $6_1 + 544 | 0;
      $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
      $23_1 = $6_1 + 464 | 0;
      $3_1 = $17_1 + 8 | 0;
      $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $38_1 = $6_1 + 656 | 0;
      $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
      $35_1 = $6_1 + 432 | 0;
      $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
      $36_1 = $6_1 + 512 | 0;
      $12_1 = $11_1;
      $21_1 = $7_1;
      $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 644 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 564 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 640 >> 2];
      $5_1 = HEAP32[$6_1 + 560 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 480 >> 2];
      $17_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 484 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $18_1 + 8 | 0;
      $9_1 = HEAP32[$3_1 >> 2];
      $11_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $19_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $8_1;
      $11_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 608 >> 2];
      $4_1 = HEAP32[$6_1 + 544 >> 2];
      $15_1 = $31_1 + $4_1 | 0;
      $40_1 = HEAP32[$6_1 + 612 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 548 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 448 >> 2];
      $9_1 = $4_1 + $15_1 | 0;
      $19_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 452 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 464 >> 2];
      $8_1 = $4_1 + $9_1 | 0;
      $18_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 468 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $37_1 = $6_1 + 416 | 0;
      $11_1 = $8_1 + $11_1 | 0;
      $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $23_1 + 8 | 0;
      $29_1 = HEAP32[$3_1 >> 2];
      $27_1 = HEAP32[$3_1 + 4 >> 2];
      $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
      $3_1 = $33_1 + 8 | 0;
      $23_1 = HEAP32[$3_1 >> 2];
      $18_1 = HEAP32[$3_1 + 4 >> 2];
      $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
      $8_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $15_1 | 0;
      $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $25_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $29_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $32_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $30_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $9_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $25_1 = HEAP32[$6_1 + 432 >> 2];
      $4_1 = HEAP32[$6_1 + 512 >> 2];
      $15_1 = $25_1 + $4_1 | 0;
      $31_1 = HEAP32[$6_1 + 436 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 516 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $9_1 = $9_1 + $15_1 | 0;
      $3_1 = $9_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $23_1 = $9_1 << 4 & -16;
      $7_1 = $3_1;
      $19_1 = ($3_1 << 4 | $9_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
      $30_1 = $6_1 + 592 | 0;
      $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
      $32_1 = $6_1 + 400 | 0;
      $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
      $29_1 = $6_1 + 624 | 0;
      $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
      $27_1 = $6_1 + 384 | 0;
      $23_1 = $27_1;
      $19_1 = ($4_1 | 0) == ($3_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $3_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $5_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $35_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1 + $15_1 | 0;
      $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $31_1 = HEAP32[$6_1 + 404 >> 2];
      $3_1 = $31_1 + HEAP32[$6_1 + 628 >> 2] | 0;
      $15_1 = HEAP32[$6_1 + 400 >> 2];
      $4_1 = HEAP32[$6_1 + 624 >> 2];
      $8_1 = $15_1 + $4_1 | 0;
      $9_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $25_1 = $6_1 + 528 | 0;
      $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
      $23_1 = $6_1 + 576 | 0;
      $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
      $13_1 = $6_1 + 368 | 0;
      $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
      $26_1 = $6_1 + 352 | 0;
      $12_1 = $26_1;
      $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
      $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
      $7_1 = $29_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $9_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $4_1 << 12 | $8_1 >>> 20;
      $8_1 = HEAP32[$6_1 + 368 >> 2];
      $10_1 = $7_1 + $8_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $4_1 + HEAP32[$6_1 + 372 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 336 | 0;
      $9_1 = $19_1;
      $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $3_1 = $13_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $5_1 = HEAP32[$6_1 + 416 >> 2];
      $4_1 = HEAP32[$6_1 + 656 >> 2];
      $12_1 = $5_1 + $4_1 | 0;
      $7_1 = HEAP32[$6_1 + 420 >> 2];
      $3_1 = $7_1 + HEAP32[$6_1 + 660 >> 2] | 0;
      $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $5_1 = $38_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $9_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $8_1;
      $9_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 384 >> 2];
      $4_1 = HEAP32[$6_1 + 592 >> 2];
      $8_1 = $10_1 + $4_1 | 0;
      $16_1 = HEAP32[$6_1 + 388 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 596 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1;
      $9_1 = $8_1;
      $8_1 = $4_1 + $8_1 | 0;
      $4_1 = $3_1;
      $3_1 = $3_1 + $7_1 | 0;
      $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
      $9_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$9_1 >> 2];
      $3_1 = $27_1 + 8 | 0;
      $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 + $16_1 | 0;
      $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $9_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $13_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $7_1;
      $9_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 528 >> 2];
      $4_1 = HEAP32[$6_1 + 576 >> 2];
      $13_1 = $22_1 + $4_1 | 0;
      $27_1 = HEAP32[$6_1 + 532 >> 2];
      $3_1 = $27_1 + HEAP32[$6_1 + 580 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 352 >> 2];
      $10_1 = $4_1 + $13_1 | 0;
      $21_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 356 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $7_1 = $9_1 + $10_1 | 0;
      $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
      $3_1 = $26_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $26_1 = HEAP32[$3_1 + 4 >> 2];
      $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
      $10_1 = $23_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $25_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
      $13_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $20_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $28_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $9_1;
      $10_1 = $4_1 << 12 | $9_1 >>> 20;
      $5_1 = $3_1;
      $9_1 = $3_1 << 12 | $4_1 >>> 20;
      $24_1 = HEAP32[$6_1 + 336 >> 2];
      $17_1 = $24_1 + ($17_1 & -2) | 0;
      $26_1 = HEAP32[$6_1 + 340 >> 2];
      $3_1 = $26_1 + ($14_1 & 1048575) | 0;
      $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $9_1 | 0;
      $14_1 = $11_1;
      $21_1 = $18_1 & 65535;
      $10_1 = $10_1 + $17_1 | 0;
      $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $10_1;
      $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
      $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $18_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $9_1;
      $10_1 = $4_1 << 12 | $5_1 >>> 20;
      $9_1 = $10_1 + $14_1 | 0;
      $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
      $4_1 = $9_1;
      $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $5_1 & 1048575;
      $13_1 = $13_1 & 1048575;
      $14_1 = $16_1 & 1048575;
      $5_1 = $12_1;
      $12_1 = $15_1 & 1048575;
      $1_1 = $1_1 - 1 | 0;
      if ($1_1) {
        continue;
      }
      break;
    }
    ;
    HEAP32[$6_1 + 7168 >> 2] = $4_1;
    HEAP32[$6_1 + 7172 >> 2] = $9_1;
    HEAP32[$6_1 + 7160 >> 2] = $11_1;
    HEAP32[$6_1 + 7164 >> 2] = $10_1;
    HEAP32[$6_1 + 7152 >> 2] = $7_1;
    HEAP32[$6_1 + 7156 >> 2] = $13_1;
    HEAP32[$6_1 + 7144 >> 2] = $8_1;
    HEAP32[$6_1 + 7148 >> 2] = $14_1;
    HEAP32[$6_1 + 7136 >> 2] = $5_1;
    HEAP32[$6_1 + 7140 >> 2] = $12_1;
    $39_1 = $6_1 + 7136 | 0;
    $34($39_1, $39_1, $6_1 + 7576 | 0);
    $1_1 = HEAP32[$6_1 + 7140 >> 2];
    $16_1 = $1_1;
    $14_1 = HEAP32[$6_1 + 7136 >> 2];
    $7_1 = $14_1;
    $3_1 = $1_1 << 1 | $7_1 >>> 31;
    $12_1 = $6_1 - -64 | 0;
    $21_1 = HEAP32[$6_1 + 7160 >> 2];
    $17_1 = HEAP32[$6_1 + 7164 >> 2];
    $28_1 = $7_1 << 1;
    $22_1 = $3_1;
    $69($12_1, $21_1, $17_1, 0, 0, $28_1, $3_1, 0, 0);
    $1_1 = HEAP32[$6_1 + 7148 >> 2];
    $33_1 = $1_1;
    $34_1 = HEAP32[$6_1 + 7144 >> 2];
    $4_1 = $34_1;
    $3_1 = $1_1 << 1 | $4_1 >>> 31;
    $10_1 = $6_1 + 272 | 0;
    $24_1 = HEAP32[$6_1 + 7152 >> 2];
    $18_1 = HEAP32[$6_1 + 7156 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $3_1;
    $69($10_1, $24_1, $18_1, 0, 0, $4_1, $3_1, 0, 0);
    $9_1 = $6_1 + 224 | 0;
    $8_1 = HEAP32[$6_1 + 7168 >> 2];
    $1_1 = HEAP32[$6_1 + 7172 >> 2];
    $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $11_1 = $6_1 + 208 | 0;
    $69($11_1, HEAP32[$6_1 + 224 >> 2], HEAP32[$6_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $1_1 << 1 | $8_1 >>> 31;
    $37_1 = $6_1 + 176 | 0;
    $23_1 = $8_1 << 1;
    $20_1 = $3_1;
    $69($37_1, $23_1, $3_1, 0, 0, $7_1, $16_1, 0, 0);
    $30_1 = $6_1 + 80 | 0;
    $69($30_1, $21_1, $17_1, 0, 0, $4_1, $5_1, 0, 0);
    $32_1 = $6_1 + 256 | 0;
    $69($32_1, $24_1, $18_1, 0, 0, $24_1, $18_1, 0, 0);
    $13_1 = $6_1 + 192 | 0;
    $1_1 = $9_1 + 8 | 0;
    $69($13_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $38_1 = $6_1 + 320 | 0;
    $69($38_1, $7_1, $16_1, 0, 0, $7_1, $16_1, 0, 0);
    $35_1 = $6_1 + 160 | 0;
    $69($35_1, $23_1, $3_1, 0, 0, $34_1, $33_1, 0, 0);
    $36_1 = $6_1 + 96 | 0;
    $69($36_1, $21_1, $17_1, 0, 0, $24_1 << 1, $18_1 << 1 | $24_1 >>> 31, 0, 0);
    $14_1 = HEAP32[$6_1 + 68 >> 2];
    $3_1 = $14_1 + HEAP32[$6_1 + 276 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 64 >> 2];
    $4_1 = HEAP32[$6_1 + 272 >> 2];
    $1_1 = $8_1 + $4_1 | 0;
    $5_1 = HEAP32[$6_1 + 208 >> 2];
    $15_1 = $1_1 + $5_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$6_1 + 212 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $15_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $3_1 = $11_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $7_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($4_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $10_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $12_1 + 8 | 0;
    $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $8_1 + $10_1 | 0;
    $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $5_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$6_1 + 80 >> 2];
    $1_1 = HEAP32[$6_1 + 256 >> 2];
    $10_1 = $29_1 + $1_1 | 0;
    $31_1 = HEAP32[$6_1 + 84 >> 2];
    $3_1 = $31_1 + HEAP32[$6_1 + 260 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 176 >> 2];
    $9_1 = $1_1 + $10_1 | 0;
    $14_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 180 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$6_1 + 192 >> 2];
    $5_1 = $1_1 + $9_1 | 0;
    $12_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$6_1 + 196 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $8_1 = $6_1;
    $11_1 = $5_1 + $7_1 | 0;
    $7_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $25_1 = ($1_1 | 0) == ($12_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 < $12_1 >>> 0;
    $1_1 = $13_1 + 8 | 0;
    $19_1 = HEAP32[$1_1 >> 2];
    $26_1 = HEAP32[$1_1 + 4 >> 2];
    $6_1 = ($12_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $12_1 >>> 0 < $14_1 >>> 0;
    $1_1 = $37_1 + 8 | 0;
    $13_1 = HEAP32[$1_1 >> 2];
    $12_1 = HEAP32[$1_1 + 4 >> 2];
    $9_1 = ($14_1 | 0) == ($31_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $14_1 >>> 0 < $31_1 >>> 0;
    $3_1 = $32_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $30_1 + 8 | 0;
    $10_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $9_1 + $10_1 | 0;
    $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $12_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $6_1 | 0;
    $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $19_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1 + $25_1 | 0;
    $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $7_1;
    $10_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $3_1;
    $9_1 = $3_1 << 12 | $1_1 >>> 20;
    $13_1 = HEAP32[$8_1 + 160 >> 2];
    $1_1 = HEAP32[$8_1 + 96 >> 2];
    $7_1 = $13_1 + $1_1 | 0;
    $19_1 = HEAP32[$8_1 + 164 >> 2];
    $3_1 = $19_1 + HEAP32[$8_1 + 100 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $9_1 | 0;
    $12_1 = $7_1;
    $7_1 = $7_1 + $10_1 | 0;
    $14_1 = $7_1 << 4 & -16;
    $9_1 = $7_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = ($9_1 << 4 | $7_1 >>> 28) & 16777215;
    $6_1 = $4_1;
    $69($8_1, $14_1 | $4_1 >>> 16 & 15, $10_1, 0, 0, 977, 1, 0, 0);
    $27_1 = HEAP32[$8_1 + 4 >> 2];
    $3_1 = $27_1 + HEAP32[$8_1 + 324 >> 2] | 0;
    $25_1 = HEAP32[$8_1 >> 2];
    $4_1 = HEAP32[$8_1 + 320 >> 2];
    $10_1 = $25_1 + $4_1 | 0;
    HEAP32[$8_1 + 7136 >> 2] = $10_1;
    $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$8_1 + 7140 >> 2] = $4_1 & 1048575;
    $31_1 = $8_1 + 304 | 0;
    $69($31_1, $34_1, $33_1, 0, 0, $28_1, $22_1, 0, 0);
    $37_1 = $8_1 + 144 | 0;
    $69($37_1, $23_1, $20_1, 0, 0, $24_1, $18_1, 0, 0);
    $30_1 = $8_1 + 112 | 0;
    $69($30_1, $21_1, $17_1, 0, 0, $21_1, $17_1, 0, 0);
    $32_1 = $8_1 + 48 | 0;
    $26_1 = $32_1;
    $14_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $12_1 = ($1_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $19_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $35_1 + 8 | 0;
    $13_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $12_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $5_1 + $7_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $1_1 << 12 | $9_1 >>> 20;
    $7_1 = $3_1;
    $9_1 = $3_1 << 12 | $1_1 >>> 20;
    $35_1 = HEAP32[$8_1 + 148 >> 2];
    $3_1 = $35_1 + HEAP32[$8_1 + 116 >> 2] | 0;
    $29_1 = HEAP32[$8_1 + 144 >> 2];
    $5_1 = HEAP32[$8_1 + 112 >> 2];
    $1_1 = $29_1 + $5_1 | 0;
    $19_1 = $1_1;
    $13_1 = $1_1 + $12_1 | 0;
    $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $5_1 + $9_1 | 0;
    $12_1 = $13_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($26_1, $13_1, $12_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $9_1 = $8_1;
    $10_1 = ($4_1 | 0) == ($27_1 | 0) & $10_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
    $3_1 = $38_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $1_1 = $9_1 + 8 | 0;
    $14_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $10_1 + $14_1 | 0;
    $3_1 = $1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $1_1 << 12 | $4_1 >>> 20;
    $8_1 = $3_1;
    $10_1 = $3_1 << 12 | $1_1 >>> 20;
    $27_1 = HEAP32[$9_1 + 48 >> 2];
    $1_1 = HEAP32[$9_1 + 304 >> 2];
    $26_1 = $27_1 + $1_1 | 0;
    $36_1 = HEAP32[$9_1 + 52 >> 2];
    $3_1 = $36_1 + HEAP32[$9_1 + 308 >> 2] | 0;
    $4_1 = $1_1 >>> 0 > $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $10_1 | 0;
    $14_1 = $14_1 + $26_1 | 0;
    $3_1 = $14_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$9_1 + 7144 >> 2] = $14_1;
    $10_1 = $3_1;
    HEAP32[$9_1 + 7148 >> 2] = $3_1 & 1048575;
    $25_1 = $9_1 + 240 | 0;
    $69($25_1, $24_1, $18_1, 0, 0, $28_1, $22_1, 0, 0);
    $22_1 = $9_1 + 288 | 0;
    $69($22_1, $34_1, $33_1, 0, 0, $34_1, $33_1, 0, 0);
    $28_1 = $9_1 + 128 | 0;
    $69($28_1, $23_1, $20_1, 0, 0, $21_1, $17_1, 0, 0);
    $24_1 = $9_1 + 32 | 0;
    $21_1 = $24_1;
    $18_1 = ($5_1 | 0) == ($12_1 | 0) & $13_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 > $12_1 >>> 0;
    $13_1 = ($5_1 | 0) == ($35_1 | 0) & $19_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $35_1 >>> 0;
    $3_1 = $30_1 + 8 | 0;
    $5_1 = HEAP32[$3_1 >> 2];
    $1_1 = $37_1 + 8 | 0;
    $17_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $13_1 + $17_1 | 0;
    $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $7_1 >>> 20 | 0;
    $1_1 = $5_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $18_1 | 0;
    $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $17_1 = $1_1 << 12 | $12_1 >>> 20;
    $7_1 = HEAP32[$9_1 + 128 >> 2];
    $12_1 = $17_1 + $7_1 | 0;
    $5_1 = $3_1;
    $19_1 = $3_1 << 12 | $1_1 >>> 20;
    $3_1 = $19_1 + HEAP32[$9_1 + 132 >> 2] | 0;
    $13_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($21_1, $12_1, $13_1, 0, 0, 15632, 16, 0, 0);
    $7_1 = $9_1;
    $14_1 = ($4_1 | 0) == ($10_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
    $9_1 = ($4_1 | 0) == ($36_1 | 0) & $26_1 >>> 0 < $27_1 >>> 0 | $4_1 >>> 0 < $36_1 >>> 0;
    $3_1 = $31_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $32_1 + 8 | 0;
    $18_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $9_1 + $18_1 | 0;
    $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $8_1 >>> 20 | 0;
    $1_1 = $4_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $1_1 << 12 | $10_1 >>> 20;
    $4_1 = $3_1;
    $8_1 = $3_1 << 12 | $1_1 >>> 20;
    $26_1 = HEAP32[$7_1 + 240 >> 2];
    $1_1 = HEAP32[$7_1 + 288 >> 2];
    $14_1 = $26_1 + $1_1 | 0;
    $20_1 = HEAP32[$7_1 + 244 >> 2];
    $3_1 = $20_1 + HEAP32[$7_1 + 292 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = HEAP32[$7_1 + 32 >> 2];
    $10_1 = $1_1 + $14_1 | 0;
    $18_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$7_1 + 36 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $1_1 + $8_1 | 0;
    $9_1 = $9_1 + $10_1 | 0;
    $3_1 = $9_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$7_1 + 7152 >> 2] = $9_1;
    $8_1 = $3_1;
    HEAP32[$7_1 + 7156 >> 2] = $3_1 & 1048575;
    $21_1 = $7_1 + 16 | 0;
    $17_1 = ($13_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $17_1 >>> 0 | $13_1 >>> 0 < $19_1 >>> 0;
    $3_1 = $28_1 + 8 | 0;
    $13_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $5_1 >>> 20 | 0;
    $12_1 = $5_1;
    $5_1 = $5_1 + $13_1 | 0;
    $3_1 = $12_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $5_1;
    $5_1 = $5_1 + $17_1 | 0;
    $3_1 = $12_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($21_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $5_1 = $7_1;
    $17_1 = ($1_1 | 0) == ($8_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $13_1 = ($1_1 | 0) == ($18_1 | 0) & $10_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $18_1 >>> 0;
    $1_1 = $24_1 + 8 | 0;
    $12_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $9_1 = ($18_1 | 0) == ($20_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $18_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $22_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $9_1 + $14_1 | 0;
    $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
    $7_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 + $13_1 | 0;
    $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $4_1 + $7_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $1_1 << 12 | $8_1 >>> 20;
    $4_1 = $3_1;
    $10_1 = $3_1 << 12 | $1_1 >>> 20;
    $14_1 = HEAP32[$5_1 + 16 >> 2];
    $8_1 = $15_1 & -2;
    $1_1 = $14_1 + $8_1 | 0;
    $13_1 = HEAP32[$5_1 + 20 >> 2];
    $3_1 = $13_1 + ($16_1 & 1048575) | 0;
    $9_1 = $1_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1 + $10_1 | 0;
    $8_1 = $7_1;
    $7_1 = $1_1;
    $8_1 = $8_1 + $1_1 | 0;
    HEAP32[$5_1 + 7160 >> 2] = $8_1;
    $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 7164 >> 2] = $1_1 & 1048575;
    $16_1 = $5_1;
    $12_1 = $6_1 & 65535;
    $10_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
    $5_1 = ($9_1 | 0) == ($13_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $9_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $21_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $5_1 = $1_1 + $11_1 | 0;
    $3_1 = $12_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$16_1 + 7168 >> 2] = $5_1;
    HEAP32[$16_1 + 7172 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $1_1 = $0_1 + 40 | 0;
    $54($1_1, $39_1);
    $54($39_1, $1_1);
    $3_1 = HEAP32[$16_1 + 7080 >> 2];
    $1_1 = HEAP32[$16_1 + 7160 >> 2];
    $18_1 = $3_1 - $1_1 | 0;
    $15_1 = HEAP32[$16_1 + 7084 >> 2] - (HEAP32[$16_1 + 7164 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
    $3_1 = HEAP32[$16_1 + 7072 >> 2];
    $1_1 = HEAP32[$16_1 + 7152 >> 2];
    $6_1 = $3_1 - $1_1 | 0;
    $13_1 = HEAP32[$16_1 + 7076 >> 2] - (HEAP32[$16_1 + 7156 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
    $3_1 = HEAP32[$16_1 + 7064 >> 2];
    $1_1 = HEAP32[$16_1 + 7144 >> 2];
    $9_1 = $3_1 - $1_1 | 0;
    $11_1 = HEAP32[$16_1 + 7068 >> 2] - (HEAP32[$16_1 + 7148 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
    $3_1 = HEAP32[$16_1 + 7056 >> 2];
    $1_1 = HEAP32[$16_1 + 7136 >> 2];
    $7_1 = $3_1 - $1_1 | 0;
    $5_1 = HEAP32[$16_1 + 7060 >> 2] - (HEAP32[$16_1 + 7140 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
    $4_1 = HEAP32[$16_1 + 7088 >> 2];
    $3_1 = HEAP32[$16_1 + 7168 >> 2];
    $1_1 = ($4_1 - $3_1 | 0) - 4 | 0;
    $3_1 = (HEAP32[$16_1 + 7092 >> 2] - (HEAP32[$16_1 + 7172 >> 2] + ($3_1 >>> 0 > $4_1 >>> 0) | 0) | 0) + 262143 | 0;
    $8_1 = $1_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
    $7_1 = $4_1 + $7_1 | 0;
    $3_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
    $3_1 = ($4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194299 | 0;
    $4_1 = $7_1 - 3908 | 0;
    $3_1 = $4_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $4_1;
    $12_1 = $3_1;
    $3_1 = $11_1;
    $4_1 = $12_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $9_1 | 0;
    $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
    $4_1 = $4_1 - 4 | 0;
    $3_1 = $4_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $4_1;
    $9_1 = $3_1;
    $3_1 = $13_1;
    $4_1 = $9_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $6_1 | 0;
    $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
    $4_1 = $4_1 - 4 | 0;
    $3_1 = $4_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
    $11_1 = $4_1;
    $7_1 = $3_1;
    $3_1 = $15_1;
    $4_1 = $7_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $18_1 | 0;
    $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
    $5_1 = $4_1 - 4 | 0;
    $4_1 = $5_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $8_1 & 65535;
    $8_1 = $5_1;
    $3_1 = $13_1;
    $5_1 = $4_1 >>> 20 | 0;
    $15_1 = $5_1;
    $5_1 = $1_1 + $5_1 | 0;
    $3_1 = $15_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    label$8: {
      if ($5_1 | ($8_1 | ($10_1 | $14_1 | $11_1)) | ($3_1 | ($9_1 | $12_1 | $7_1 | $4_1) & 1048575)) {
        $1_1 = 0;
        if (($10_1 & ($14_1 ^ 976) & $11_1 & $8_1 & $5_1) != -1) {
          $3_1 = 1;
        } else {
          $3_1 = ($9_1 & ($12_1 ^ 1) & $7_1 & $4_1 & ($3_1 ^ 983040)) != 1048575;
        }
        if ($3_1) {
          break label$8;
        }
      }
      $1_1 = $0_1 + 48 | 0;
      $11_1 = HEAP32[$1_1 >> 2];
      $8_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = HEAP32[$0_1 + 44 >> 2];
      $1_1 = $0_1 + 72 | 0;
      $10_1 = HEAP32[$1_1 >> 2];
      $1_1 = HEAP32[$1_1 + 4 >> 2];
      $15_1 = $1_1;
      $3_1 = HEAP32[$0_1 + 40 >> 2];
      $1_1 = __wasm_i64_mul($1_1 >>> 16 | 0, 0, 977, 1);
      $7_1 = $3_1 + $1_1 | 0;
      $3_1 = $4_1 + i64toi32_i32$HIGH_BITS | 0;
      $13_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1;
      $1_1 = $13_1 >>> 20 | 0;
      $8_1 = $1_1 + $11_1 | 0;
      $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $1_1 & 1048575;
      $3_1 = $0_1 - -64 | 0;
      $12_1 = HEAP32[$3_1 >> 2];
      $9_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $0_1 + 56 | 0;
      $5_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $11_1 = $1_1 >>> 20 | 0;
      $4_1 = $5_1 + $11_1 | 0;
      $11_1 = $11_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1;
      $5_1 = $11_1 >>> 20 | 0;
      $9_1 = $5_1;
      $5_1 = $5_1 + $12_1 | 0;
      $3_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $3_1 & 1048575;
      $9_1 = $11_1 & 1048575;
      $6_1 = ($4_1 & $8_1 & $5_1) == -1 & ($1_1 & $9_1 & $3_1) == 1048575;
      $1_1 = $3_1;
      $3_1 = $15_1 & 65535;
      $1_1 = $1_1 >>> 20 | 0;
      $11_1 = $1_1 + $10_1 | 0;
      $3_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $3_1;
      $13_1 = $13_1 & 1048575;
      if ($6_1 & (($11_1 | 0) == -1 & ($3_1 | 0) == 65535) & (($13_1 | 0) == 1048574 & $7_1 >>> 0 > 4294966318 | $13_1 >>> 0 > 1048574) | $3_1 >>> 16) {
        $3_1 = $13_1 + 1 | 0;
        $7_1 = $7_1 + 977 | 0;
        $3_1 = $7_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $3_1 & 1048575;
        $1_1 = $3_1;
        $3_1 = $14_1;
        $1_1 = $1_1 >>> 20 | 0;
        $8_1 = $1_1 + $8_1 | 0;
        $3_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $3_1 & 1048575;
        $1_1 = $3_1;
        $3_1 = $9_1;
        $1_1 = $1_1 >>> 20 | 0;
        $4_1 = $1_1 + $4_1 | 0;
        $3_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $9_1 = $3_1 & 1048575;
        $1_1 = $3_1;
        $3_1 = $12_1;
        $1_1 = $1_1 >>> 20 | 0;
        $5_1 = $1_1 + $5_1 | 0;
        $3_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $12_1 = $3_1 & 1048575;
        $1_1 = $3_1;
        $3_1 = $10_1;
        $15_1 = $11_1;
        $11_1 = ($1_1 >>> 20 | 0) + $11_1 | 0;
        $10_1 = ($15_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) & 65535;
      }
      HEAP32[$0_1 + 72 >> 2] = $11_1;
      HEAP32[$0_1 + 76 >> 2] = $10_1;
      HEAP32[$0_1 + 64 >> 2] = $5_1;
      HEAP32[$0_1 + 68 >> 2] = $12_1;
      HEAP32[$0_1 + 56 >> 2] = $4_1;
      HEAP32[$0_1 + 60 >> 2] = $9_1;
      HEAP32[$0_1 + 48 >> 2] = $8_1;
      HEAP32[$0_1 + 52 >> 2] = $14_1;
      HEAP32[$0_1 + 40 >> 2] = $7_1;
      HEAP32[$0_1 + 44 >> 2] = $13_1;
      $1_1 = 1;
      if (($7_1 & 1) == ($2_1 | 0)) {
        break label$8;
      }
      HEAP32[$0_1 + 72 >> 2] = -4 - $11_1;
      HEAP32[$0_1 + 76 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $10_1 | 0);
      HEAP32[$0_1 + 64 >> 2] = -4 - $5_1;
      HEAP32[$0_1 + 68 >> 2] = 4194303 - (($5_1 >>> 0 > 4294967292) + $12_1 | 0);
      HEAP32[$0_1 + 56 >> 2] = -4 - $4_1;
      HEAP32[$0_1 + 60 >> 2] = 4194303 - (($4_1 >>> 0 > 4294967292) + $9_1 | 0);
      HEAP32[$0_1 + 48 >> 2] = -4 - $8_1;
      HEAP32[$0_1 + 52 >> 2] = 4194303 - (($8_1 >>> 0 > 4294967292) + $14_1 | 0);
      HEAP32[$0_1 + 40 >> 2] = -3908 - $7_1;
      HEAP32[$0_1 + 44 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $13_1 | 0);
    }
    global$0 = $16_1 + 7616 | 0;
    return $1_1;
  }
  function $34($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0;
    $3_1 = global$0 - 496 | 0;
    global$0 = $3_1;
    $19_1 = $3_1 - -64 | 0;
    $31_1 = HEAP32[$2_1 + 24 >> 2];
    $32_1 = HEAP32[$2_1 + 28 >> 2];
    $33_1 = HEAP32[$1_1 >> 2];
    $34_1 = HEAP32[$1_1 + 4 >> 2];
    $69($19_1, $31_1, $32_1, 0, 0, $33_1, $34_1, 0, 0);
    $21_1 = $3_1 + 208 | 0;
    $35_1 = HEAP32[$2_1 + 16 >> 2];
    $36_1 = HEAP32[$2_1 + 20 >> 2];
    $37_1 = HEAP32[$1_1 + 8 >> 2];
    $38_1 = HEAP32[$1_1 + 12 >> 2];
    $69($21_1, $35_1, $36_1, 0, 0, $37_1, $38_1, 0, 0);
    $16_1 = $3_1 + 320 | 0;
    $39_1 = HEAP32[$2_1 + 8 >> 2];
    $40_1 = HEAP32[$2_1 + 12 >> 2];
    $41_1 = HEAP32[$1_1 + 16 >> 2];
    $42_1 = HEAP32[$1_1 + 20 >> 2];
    $69($16_1, $39_1, $40_1, 0, 0, $41_1, $42_1, 0, 0);
    $10_1 = $3_1 + 400 | 0;
    $43_1 = HEAP32[$2_1 >> 2];
    $44_1 = HEAP32[$2_1 + 4 >> 2];
    $45_1 = HEAP32[$1_1 + 24 >> 2];
    $46_1 = HEAP32[$1_1 + 28 >> 2];
    $69($10_1, $43_1, $44_1, 0, 0, $45_1, $46_1, 0, 0);
    $4_1 = $3_1 + 480 | 0;
    $47_1 = HEAP32[$2_1 + 32 >> 2];
    $48_1 = HEAP32[$2_1 + 36 >> 2];
    $49_1 = HEAP32[$1_1 + 32 >> 2];
    $24_1 = HEAP32[$1_1 + 36 >> 2];
    $69($4_1, $47_1, $48_1, 0, 0, $49_1, $24_1, 0, 0);
    $9_1 = $3_1 + 464 | 0;
    $69($9_1, HEAP32[$3_1 + 480 >> 2], HEAP32[$3_1 + 484 >> 2], 0, 0, 15632, 16, 0, 0);
    $20_1 = $3_1 + 80 | 0;
    $69($20_1, $47_1, $48_1, 0, 0, $33_1, $34_1, 0, 0);
    $50_1 = $3_1 + 144 | 0;
    $69($50_1, $31_1, $32_1, 0, 0, $37_1, $38_1, 0, 0);
    $51_1 = $3_1 + 272 | 0;
    $69($51_1, $35_1, $36_1, 0, 0, $41_1, $42_1, 0, 0);
    $52_1 = $3_1 + 368 | 0;
    $69($52_1, $39_1, $40_1, 0, 0, $45_1, $46_1, 0, 0);
    $26_1 = $3_1 + 432 | 0;
    $69($26_1, $43_1, $44_1, 0, 0, $49_1, $24_1, 0, 0);
    $15_1 = $3_1 + 448 | 0;
    $1_1 = $4_1 + 8 | 0;
    $69($15_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $53_1 = $3_1 + 96 | 0;
    $69($53_1, $43_1, $44_1, 0, 0, $33_1, $34_1, 0, 0);
    $54_1 = $3_1 + 224 | 0;
    $69($54_1, $47_1, $48_1, 0, 0, $37_1, $38_1, 0, 0);
    $55_1 = $3_1 + 160 | 0;
    $69($55_1, $31_1, $32_1, 0, 0, $41_1, $42_1, 0, 0);
    $56_1 = $3_1 + 288 | 0;
    $69($56_1, $35_1, $36_1, 0, 0, $45_1, $46_1, 0, 0);
    $28_1 = $3_1 + 384 | 0;
    $69($28_1, $39_1, $40_1, 0, 0, $49_1, $24_1, 0, 0);
    $14_1 = HEAP32[$3_1 + 208 >> 2];
    $2_1 = HEAP32[$3_1 + 64 >> 2];
    $18_1 = $14_1 + $2_1 | 0;
    $17_1 = HEAP32[$3_1 + 212 >> 2];
    $1_1 = $17_1 + HEAP32[$3_1 + 68 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 320 >> 2];
    $8_1 = $2_1 + $18_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 324 >> 2] | 0;
    $7_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $7_1 + HEAP32[$3_1 + 404 >> 2] | 0;
    $2_1 = HEAP32[$3_1 + 400 >> 2];
    $6_1 = $2_1 + $8_1 | 0;
    $5_1 = HEAP32[$3_1 + 464 >> 2];
    $57_1 = $6_1 + $5_1 | 0;
    $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + HEAP32[$3_1 + 468 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $57_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $12_1 = ($2_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 > $57_1 >>> 0 | $2_1 >>> 0 > $5_1 >>> 0;
    $1_1 = $9_1 + 8 | 0;
    $58_1 = HEAP32[$1_1 >> 2];
    $27_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = ($2_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
    $1_1 = $10_1 + 8 | 0;
    $13_1 = HEAP32[$1_1 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $9_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
    $1_1 = $16_1 + 8 | 0;
    $7_1 = HEAP32[$1_1 >> 2];
    $8_1 = HEAP32[$1_1 + 4 >> 2];
    $6_1 = ($4_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
    $4_1 = $19_1 + 8 | 0;
    $2_1 = HEAP32[$4_1 >> 2];
    $1_1 = $21_1 + 8 | 0;
    $18_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $6_1 + $18_1 | 0;
    $1_1 = ($2_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $8_1 | 0;
    $4_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $9_1 | 0;
    $1_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $10_1 | 0;
    $4_1 = $2_1;
    $2_1 = $2_1 + $13_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $11_1 | 0;
    $1_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $27_1 | 0;
    $4_1 = $2_1;
    $2_1 = $2_1 + $58_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $12_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $58_1 = $5_1;
    $18_1 = $2_1 << 12 | $5_1 >>> 20;
    $4_1 = $1_1;
    $6_1 = $1_1 << 12 | $2_1 >>> 20;
    $22_1 = HEAP32[$3_1 + 272 >> 2];
    $2_1 = HEAP32[$3_1 + 144 >> 2];
    $10_1 = $22_1 + $2_1 | 0;
    $29_1 = HEAP32[$3_1 + 276 >> 2];
    $1_1 = $29_1 + HEAP32[$3_1 + 148 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 368 >> 2];
    $9_1 = $2_1 + $10_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 372 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 432 >> 2];
    $7_1 = $2_1 + $9_1 | 0;
    $27_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 436 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 80 >> 2];
    $8_1 = $2_1 + $7_1 | 0;
    $11_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 84 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 448 >> 2];
    $5_1 = $2_1 + $8_1 | 0;
    $13_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 452 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + $6_1 | 0;
    $18_1 = $5_1 + $18_1 | 0;
    $6_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $25_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 > $18_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
    $23_1 = ($2_1 | 0) == ($13_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $13_1 >>> 0;
    $1_1 = $15_1 + 8 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $19_1 = HEAP32[$1_1 + 4 >> 2];
    $21_1 = ($11_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 < $7_1 >>> 0 | $11_1 >>> 0 > $13_1 >>> 0;
    $1_1 = $20_1 + 8 | 0;
    $16_1 = HEAP32[$1_1 >> 2];
    $20_1 = HEAP32[$1_1 + 4 >> 2];
    $15_1 = ($11_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $11_1 >>> 0 < $27_1 >>> 0;
    $1_1 = $26_1 + 8 | 0;
    $14_1 = HEAP32[$1_1 >> 2];
    $11_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($12_1 | 0) == ($27_1 | 0) & $10_1 >>> 0 > $9_1 >>> 0 | $12_1 >>> 0 > $27_1 >>> 0;
    $1_1 = $52_1 + 8 | 0;
    $9_1 = HEAP32[$1_1 >> 2];
    $7_1 = HEAP32[$1_1 + 4 >> 2];
    $8_1 = ($12_1 | 0) == ($29_1 | 0) & $10_1 >>> 0 < $22_1 >>> 0 | $12_1 >>> 0 < $29_1 >>> 0;
    $5_1 = $50_1 + 8 | 0;
    $2_1 = HEAP32[$5_1 >> 2];
    $1_1 = $51_1 + 8 | 0;
    $10_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $8_1 + $10_1 | 0;
    $1_1 = ($2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $7_1 | 0;
    $5_1 = $2_1;
    $2_1 = $2_1 + $9_1 | 0;
    $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $2_1;
    $2_1 = $2_1 + $13_1 | 0;
    $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $11_1 | 0;
    $5_1 = $2_1;
    $2_1 = $2_1 + $14_1 | 0;
    $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $2_1;
    $2_1 = $2_1 + $15_1 | 0;
    $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $20_1 | 0;
    $5_1 = $2_1;
    $2_1 = $2_1 + $16_1 | 0;
    $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $2_1;
    $2_1 = $2_1 + $21_1 | 0;
    $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $19_1 | 0;
    $5_1 = $2_1;
    $2_1 = $2_1 + $17_1 | 0;
    $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $2_1 + $23_1 | 0;
    $1_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $4_1 >>> 20 | 0;
    $2_1 = $4_1 + $5_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $25_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $6_1;
    $8_1 = $2_1 << 12 | $4_1 >>> 20;
    $5_1 = $1_1;
    $6_1 = $1_1 << 12 | $2_1 >>> 20;
    $23_1 = HEAP32[$3_1 + 288 >> 2];
    $2_1 = HEAP32[$3_1 + 160 >> 2];
    $11_1 = $23_1 + $2_1 | 0;
    $22_1 = HEAP32[$3_1 + 292 >> 2];
    $1_1 = $22_1 + HEAP32[$3_1 + 164 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 384 >> 2];
    $13_1 = $2_1 + $11_1 | 0;
    $14_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 388 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$3_1 + 224 >> 2];
    $10_1 = $2_1 + $13_1 | 0;
    $12_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 228 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + $6_1 | 0;
    $8_1 = $8_1 + $10_1 | 0;
    $1_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $9_1 = $8_1 << 4 & -16;
    $6_1 = $1_1;
    $7_1 = ($1_1 << 4 | $8_1 >>> 28) & 16777215;
    $27_1 = $4_1;
    $69($3_1, $9_1 | $4_1 >>> 16 & 15, $7_1, 0, 0, 977, 1, 0, 0);
    $25_1 = HEAP32[$3_1 + 4 >> 2];
    $1_1 = $25_1 + HEAP32[$3_1 + 100 >> 2] | 0;
    $7_1 = $0_1;
    $17_1 = HEAP32[$3_1 >> 2];
    $0_1 = HEAP32[$3_1 + 96 >> 2];
    $9_1 = $17_1 + $0_1 | 0;
    HEAP32[$7_1 >> 2] = $9_1;
    $4_1 = $0_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$7_1 + 4 >> 2] = $4_1 & 1048575;
    $61_1 = $3_1 + 112 | 0;
    $69($61_1, $39_1, $40_1, 0, 0, $33_1, $34_1, 0, 0);
    $62_1 = $3_1 + 240 | 0;
    $69($62_1, $43_1, $44_1, 0, 0, $37_1, $38_1, 0, 0);
    $63_1 = $3_1 + 336 | 0;
    $69($63_1, $47_1, $48_1, 0, 0, $41_1, $42_1, 0, 0);
    $30_1 = $3_1 + 176 | 0;
    $69($30_1, $31_1, $32_1, 0, 0, $45_1, $46_1, 0, 0);
    $26_1 = $3_1 + 304 | 0;
    $69($26_1, $35_1, $36_1, 0, 0, $49_1, $24_1, 0, 0);
    $64_1 = $3_1 + 48 | 0;
    $19_1 = $64_1;
    $21_1 = ($2_1 | 0) == ($6_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
    $16_1 = ($2_1 | 0) == ($12_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 < $12_1 >>> 0;
    $0_1 = $54_1 + 8 | 0;
    $20_1 = HEAP32[$0_1 >> 2];
    $15_1 = HEAP32[$0_1 + 4 >> 2];
    $12_1 = ($12_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 > $13_1 >>> 0 | $12_1 >>> 0 < $14_1 >>> 0;
    $0_1 = $28_1 + 8 | 0;
    $13_1 = HEAP32[$0_1 >> 2];
    $10_1 = HEAP32[$0_1 + 4 >> 2];
    $8_1 = ($14_1 | 0) == ($22_1 | 0) & $11_1 >>> 0 < $23_1 >>> 0 | $14_1 >>> 0 < $22_1 >>> 0;
    $1_1 = $55_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $0_1 = $56_1 + 8 | 0;
    $11_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
    $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $8_1 + $11_1 | 0;
    $1_1 = ($0_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $10_1 | 0;
    $2_1 = $0_1;
    $0_1 = $0_1 + $13_1 | 0;
    $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $12_1 | 0;
    $1_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $15_1 | 0;
    $2_1 = $0_1;
    $0_1 = $0_1 + $20_1 | 0;
    $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $0_1 + $16_1 | 0;
    $1_1 = $2_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $5_1 >>> 20 | 0;
    $0_1 = $2_1 + $5_1 | 0;
    $1_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $21_1 | 0;
    $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $0_1 << 12 | $6_1 >>> 20;
    $8_1 = $1_1;
    $2_1 = $1_1 << 12 | $0_1 >>> 20;
    $28_1 = HEAP32[$3_1 + 304 >> 2];
    $0_1 = HEAP32[$3_1 + 176 >> 2];
    $14_1 = $28_1 + $0_1 | 0;
    $59_1 = HEAP32[$3_1 + 308 >> 2];
    $1_1 = $59_1 + HEAP32[$3_1 + 180 >> 2] | 0;
    $1_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = HEAP32[$3_1 + 336 >> 2];
    $12_1 = $0_1 + $14_1 | 0;
    $15_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 340 >> 2] | 0;
    $6_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $6_1 + $2_1 | 0;
    $11_1 = $5_1 + $12_1 | 0;
    $1_1 = $11_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $10_1 = $1_1;
    $69($19_1, $11_1, $1_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $5_1 = ($4_1 | 0) == ($25_1 | 0) & $9_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 < $25_1 >>> 0;
    $1_1 = $53_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $0_1 = $3_1 + 8 | 0;
    $9_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
    $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $5_1 + $9_1 | 0;
    $1_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $13_1 = $0_1 << 12 | $4_1 >>> 20;
    $5_1 = $1_1;
    $9_1 = $1_1 << 12 | $0_1 >>> 20;
    $29_1 = HEAP32[$3_1 + 240 >> 2];
    $0_1 = HEAP32[$3_1 + 112 >> 2];
    $16_1 = $29_1 + $0_1 | 0;
    $60_1 = HEAP32[$3_1 + 244 >> 2];
    $1_1 = $60_1 + HEAP32[$3_1 + 116 >> 2] | 0;
    $23_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $23_1 + HEAP32[$3_1 + 52 >> 2] | 0;
    $2_1 = HEAP32[$3_1 + 48 >> 2];
    $0_1 = $2_1 + $16_1 | 0;
    $21_1 = $0_1;
    $13_1 = $0_1 + $13_1 | 0;
    $4_1 = $0_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $4_1 + $9_1 | 0;
    HEAP32[$7_1 + 8 >> 2] = $13_1;
    $9_1 = $13_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$7_1 + 12 >> 2] = $9_1 & 1048575;
    $50_1 = $3_1 + 128 | 0;
    $69($50_1, $35_1, $36_1, 0, 0, $33_1, $34_1, 0, 0);
    $51_1 = $3_1 + 256 | 0;
    $69($51_1, $39_1, $40_1, 0, 0, $37_1, $38_1, 0, 0);
    $52_1 = $3_1 + 352 | 0;
    $69($52_1, $43_1, $44_1, 0, 0, $41_1, $42_1, 0, 0);
    $53_1 = $3_1 + 416 | 0;
    $69($53_1, $47_1, $48_1, 0, 0, $45_1, $46_1, 0, 0);
    $54_1 = $3_1 + 192 | 0;
    $69($54_1, $31_1, $32_1, 0, 0, $49_1, $24_1, 0, 0);
    $55_1 = $3_1 + 32 | 0;
    $22_1 = $55_1;
    $56_1 = HEAP32[$3_1 + 416 >> 2];
    $0_1 = HEAP32[$3_1 + 192 >> 2];
    $20_1 = $56_1 + $0_1 | 0;
    $24_1 = HEAP32[$3_1 + 420 >> 2];
    $1_1 = $24_1 + HEAP32[$3_1 + 196 >> 2] | 0;
    $2_1 = $0_1 >>> 0 > $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $25_1 = ($6_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $12_1 >>> 0 | $6_1 >>> 0 > $10_1 >>> 0;
    $17_1 = ($6_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $6_1 >>> 0 < $15_1 >>> 0;
    $0_1 = $63_1 + 8 | 0;
    $19_1 = HEAP32[$0_1 >> 2];
    $12_1 = HEAP32[$0_1 + 4 >> 2];
    $11_1 = ($15_1 | 0) == ($59_1 | 0) & $14_1 >>> 0 < $28_1 >>> 0 | $15_1 >>> 0 < $59_1 >>> 0;
    $1_1 = $30_1 + 8 | 0;
    $6_1 = HEAP32[$1_1 >> 2];
    $0_1 = $26_1 + 8 | 0;
    $14_1 = $6_1 + HEAP32[$0_1 >> 2] | 0;
    $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $11_1 + $14_1 | 0;
    $1_1 = ($0_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $12_1 | 0;
    $6_1 = $0_1;
    $0_1 = $0_1 + $19_1 | 0;
    $1_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $6_1 = $0_1 + $17_1 | 0;
    $1_1 = $6_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $8_1 = $8_1 >>> 20 | 0;
    $0_1 = $8_1 + $6_1 | 0;
    $1_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $6_1 = $0_1;
    $0_1 = $0_1 + $25_1 | 0;
    $1_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $8_1 = $0_1 << 12 | $10_1 >>> 20;
    $10_1 = $8_1 + $20_1 | 0;
    $6_1 = $1_1;
    $1_1 = $2_1 + ($1_1 << 12 | $0_1 >>> 20) | 0;
    $15_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $69($22_1, $10_1, $15_1, 0, 0, 15632, 16, 0, 0);
    $8_1 = $7_1;
    $26_1 = HEAP32[$3_1 + 256 >> 2];
    $0_1 = HEAP32[$3_1 + 128 >> 2];
    $14_1 = $26_1 + $0_1 | 0;
    $30_1 = HEAP32[$3_1 + 260 >> 2];
    $1_1 = $30_1 + HEAP32[$3_1 + 132 >> 2] | 0;
    $1_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = HEAP32[$3_1 + 352 >> 2];
    $12_1 = $0_1 + $14_1 | 0;
    $17_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 356 >> 2] | 0;
    $1_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = HEAP32[$3_1 + 32 >> 2];
    $11_1 = $0_1 + $12_1 | 0;
    $19_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$3_1 + 36 >> 2] | 0;
    $0_1 = $0_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $28_1 = ($4_1 | 0) == ($9_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
    $22_1 = ($4_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 > $21_1 >>> 0 | $4_1 >>> 0 < $23_1 >>> 0;
    $1_1 = $64_1 + 8 | 0;
    $25_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $13_1 = ($23_1 | 0) == ($60_1 | 0) & $16_1 >>> 0 < $29_1 >>> 0 | $23_1 >>> 0 < $60_1 >>> 0;
    $7_1 = $61_1 + 8 | 0;
    $4_1 = HEAP32[$7_1 >> 2];
    $1_1 = $62_1 + 8 | 0;
    $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
    $1_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $13_1 + $16_1 | 0;
    $1_1 = ($4_1 >>> 0 < $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $21_1 | 0;
    $7_1 = $4_1;
    $4_1 = $4_1 + $25_1 | 0;
    $1_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $7_1 = $4_1 + $22_1 | 0;
    $1_1 = $7_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $5_1 >>> 20 | 0;
    $4_1 = $5_1 + $7_1 | 0;
    $1_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $28_1 | 0;
    $1_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $7_1 = $4_1 << 12 | $9_1 >>> 20;
    $9_1 = $7_1 + $11_1 | 0;
    $5_1 = $1_1;
    $1_1 = $0_1 + ($1_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$8_1 + 16 >> 2] = $9_1;
    $7_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$8_1 + 20 >> 2] = $7_1 & 1048575;
    $16_1 = $3_1 + 16 | 0;
    $13_1 = ($2_1 | 0) == ($15_1 | 0) & $10_1 >>> 0 < $20_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
    $10_1 = ($2_1 | 0) == ($24_1 | 0) & $20_1 >>> 0 < $56_1 >>> 0 | $2_1 >>> 0 < $24_1 >>> 0;
    $4_1 = $54_1 + 8 | 0;
    $2_1 = HEAP32[$4_1 >> 2];
    $1_1 = $53_1 + 8 | 0;
    $15_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $15_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $10_1 + $15_1 | 0;
    $1_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $6_1 = $6_1 >>> 20 | 0;
    $2_1 = $4_1 + $6_1 | 0;
    $1_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $13_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $69($16_1, $2_1, $1_1, 0, 0, 64028672, 65536, 0, 0);
    $4_1 = $8_1;
    $20_1 = ($0_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
    $15_1 = ($0_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 < $19_1 >>> 0;
    $0_1 = $55_1 + 8 | 0;
    $11_1 = HEAP32[$0_1 >> 2];
    $13_1 = HEAP32[$0_1 + 4 >> 2];
    $10_1 = ($17_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $17_1 >>> 0 > $19_1 >>> 0;
    $0_1 = $52_1 + 8 | 0;
    $9_1 = HEAP32[$0_1 >> 2];
    $8_1 = HEAP32[$0_1 + 4 >> 2];
    $6_1 = ($17_1 | 0) == ($30_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $17_1 >>> 0 < $30_1 >>> 0;
    $1_1 = $50_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $0_1 = $51_1 + 8 | 0;
    $12_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
    $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $6_1 + $12_1 | 0;
    $1_1 = ($0_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $8_1 | 0;
    $2_1 = $0_1;
    $0_1 = $0_1 + $9_1 | 0;
    $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $10_1 | 0;
    $1_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $13_1 | 0;
    $2_1 = $0_1;
    $0_1 = $0_1 + $11_1 | 0;
    $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $0_1 + $15_1 | 0;
    $1_1 = $2_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $5_1 >>> 20 | 0;
    $0_1 = $2_1 + $5_1 | 0;
    $1_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $20_1 | 0;
    $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $5_1 = $0_1 << 12 | $7_1 >>> 20;
    $2_1 = $1_1;
    $6_1 = $1_1 << 12 | $0_1 >>> 20;
    $11_1 = HEAP32[$3_1 + 20 >> 2];
    $1_1 = $11_1 + ($58_1 & 1048575) | 0;
    $13_1 = HEAP32[$3_1 + 16 >> 2];
    $0_1 = $57_1 + $13_1 | 0;
    $7_1 = $0_1 >>> 0 < $57_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $7_1 + $6_1 | 0;
    $8_1 = $0_1;
    $5_1 = $0_1 + $5_1 | 0;
    HEAP32[$4_1 + 24 >> 2] = $5_1;
    $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$4_1 + 28 >> 2] = $0_1 & 1048575;
    $6_1 = $4_1;
    $10_1 = $27_1 & 65535;
    $9_1 = ($0_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $0_1 >>> 0 < $7_1 >>> 0;
    $4_1 = ($7_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $7_1 >>> 0 < $11_1 >>> 0;
    $1_1 = $16_1 + 8 | 0;
    $5_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2];
    $1_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $2_1 >>> 20 | 0;
    $4_1 = $2_1;
    $2_1 = $2_1 + $5_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $9_1 | 0;
    $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $2_1 << 12 | $0_1 >>> 20;
    $4_1 = $0_1 + $18_1 | 0;
    $1_1 = $10_1 + ($1_1 << 12 | $2_1 >>> 20) | 0;
    HEAP32[$6_1 + 32 >> 2] = $4_1;
    HEAP32[$6_1 + 36 >> 2] = $0_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    global$0 = $3_1 + 496 | 0;
  }
  function $35($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0;
    $3_1 = $1_1 - -64 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $8_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $1_1 + 56 | 0;
    $6_1 = HEAP32[$3_1 >> 2];
    $17_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $1_1 + 48 | 0;
    $18_1 = HEAP32[$3_1 >> 2];
    $12_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $1_1 + 72 | 0;
    $14_1 = HEAP32[$3_1 >> 2];
    $5_1 = HEAP32[$3_1 + 4 >> 2];
    $20_1 = HEAP32[$1_1 + 40 >> 2];
    $22_1 = HEAP32[$1_1 + 44 >> 2];
    $19_1 = HEAP32[$1_1 + 24 >> 2];
    $13_1 = HEAP32[$1_1 + 28 >> 2];
    $7_1 = HEAP32[$1_1 + 16 >> 2];
    $16_1 = HEAP32[$1_1 + 20 >> 2];
    $2_1 = HEAP32[$1_1 + 8 >> 2];
    $9_1 = HEAP32[$1_1 + 12 >> 2];
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $21_1 = HEAP32[$1_1 + 32 >> 2];
    $4_1 = HEAP32[$1_1 + 36 >> 2];
    $24_1 = $4_1;
    $1_1 = HEAP32[$1_1 >> 2];
    $3_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
    $4_1 = $1_1 + $3_1 | 0;
    $1_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
    $10_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $9_1;
    $3_1 = $10_1 >>> 20 | 0;
    $9_1 = $3_1;
    $3_1 = $2_1 + $3_1 | 0;
    $9_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $16_1;
    $2_1 = $9_1 >>> 20 | 0;
    $15_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $16_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $13_1;
    $7_1 = $16_1 >>> 20 | 0;
    $13_1 = $7_1;
    $7_1 = $7_1 + $19_1 | 0;
    $19_1 = $13_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $25_1 = $9_1 & 1048575;
    $1_1 = $10_1 & 1048575;
    $15_1 = $1_1;
    $13_1 = $3_1;
    $10_1 = $2_1;
    $23_1 = $16_1 & 1048575;
    $2_1 = ($3_1 & $2_1 & $7_1) == -1 & ($23_1 & $9_1 & $19_1) == 1048575;
    $1_1 = $24_1 & 65535;
    $3_1 = $19_1 >>> 20 | 0;
    $9_1 = $3_1;
    $3_1 = $3_1 + $21_1 | 0;
    $1_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $21_1 = $3_1;
    $9_1 = $1_1;
    $3_1 = __wasm_i64_mul($2_1 & (($3_1 | 0) == -1 & ($1_1 | 0) == 65535) & (($15_1 | 0) == 1048574 & $4_1 >>> 0 > 4294966318 | $15_1 >>> 0 > 1048574) | $1_1 >>> 16, 0, 977, 1);
    $4_1 = $3_1 + $4_1 | 0;
    $1_1 = $15_1 + i64toi32_i32$HIGH_BITS | 0;
    $2_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $25_1;
    $3_1 = $2_1 >>> 20 | 0;
    $16_1 = $3_1 + $13_1 | 0;
    $3_1 = $3_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP8[$0_1 | 0] = $4_1;
    HEAP8[$0_1 + 1 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $4_1 >>> 24;
    $1_1 = $2_1 & 1048575 | $16_1 << 20;
    HEAP8[$0_1 + 4 | 0] = $1_1;
    HEAP8[$0_1 + 5 | 0] = $1_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $1_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $1_1 >>> 24;
    $13_1 = $14_1;
    $15_1 = $5_1 & 65535;
    $14_1 = $11_1;
    $11_1 = $6_1;
    $2_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
    $4_1 = $2_1 + $20_1 | 0;
    $1_1 = $22_1 + i64toi32_i32$HIGH_BITS | 0;
    $20_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $12_1;
    $2_1 = $20_1 >>> 20 | 0;
    $5_1 = $2_1;
    $2_1 = $2_1 + $18_1 | 0;
    $6_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $17_1;
    $5_1 = $6_1 >>> 20 | 0;
    $11_1 = $5_1 + $11_1 | 0;
    $12_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $8_1;
    $5_1 = $12_1 >>> 20 | 0;
    $8_1 = $5_1;
    $5_1 = $5_1 + $14_1 | 0;
    $17_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $15_1;
    $8_1 = $17_1 >>> 20 | 0;
    $14_1 = $8_1;
    $8_1 = $8_1 + $13_1 | 0;
    $1_1 = $14_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $18_1 = $8_1;
    $8_1 = $1_1;
    $22_1 = $6_1 & 1048575;
    $1_1 = $20_1 & 1048575;
    $15_1 = $4_1;
    $14_1 = $2_1;
    $13_1 = $12_1 & 1048575;
    $4_1 = __wasm_i64_mul(($11_1 & $2_1 & $5_1) == -1 & ($13_1 & $6_1 & $17_1) == 1048575 & (($18_1 | 0) == -1 & ($8_1 | 0) == 65535) & (($1_1 | 0) == 1048574 & $4_1 >>> 0 > 4294966318 | $1_1 >>> 0 > 1048574) | $8_1 >>> 16, 0, 977, 1);
    $2_1 = $15_1 + $4_1 | 0;
    $1_1 = $1_1 + i64toi32_i32$HIGH_BITS | 0;
    $6_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $22_1;
    $4_1 = $6_1 >>> 20 | 0;
    $12_1 = $4_1 + $14_1 | 0;
    $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP8[$0_1 + 32 | 0] = $2_1;
    HEAP8[$0_1 + 33 | 0] = $2_1 >>> 8;
    HEAP8[$0_1 + 34 | 0] = $2_1 >>> 16;
    HEAP8[$0_1 + 35 | 0] = $2_1 >>> 24;
    $1_1 = $6_1 & 1048575 | $12_1 << 20;
    HEAP8[$0_1 + 36 | 0] = $1_1;
    HEAP8[$0_1 + 37 | 0] = $1_1 >>> 8;
    HEAP8[$0_1 + 38 | 0] = $1_1 >>> 16;
    HEAP8[$0_1 + 39 | 0] = $1_1 >>> 24;
    $6_1 = ($3_1 & 4095) << 20 | $16_1 >>> 12;
    $14_1 = $3_1 >>> 12 & 255;
    $1_1 = $23_1;
    $2_1 = ($3_1 >>> 20 | 0) + $10_1 | 0;
    $3_1 = $2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $10_1 = $2_1;
    $1_1 = $2_1 << 8;
    $2_1 = $0_1;
    HEAP8[$2_1 + 8 | 0] = $6_1;
    HEAP8[$2_1 + 9 | 0] = $6_1 >>> 8;
    HEAP8[$2_1 + 10 | 0] = $6_1 >>> 16;
    HEAP8[$2_1 + 11 | 0] = $6_1 >>> 24;
    $1_1 = $1_1 | $14_1;
    HEAP8[$2_1 + 12 | 0] = $1_1;
    HEAP8[$2_1 + 13 | 0] = $1_1 >>> 8;
    HEAP8[$2_1 + 14 | 0] = $1_1 >>> 16;
    HEAP8[$2_1 + 15 | 0] = $1_1 >>> 24;
    $6_1 = ($4_1 & 4095) << 20 | $12_1 >>> 12;
    $12_1 = $4_1 >>> 12 & 255;
    $1_1 = $13_1;
    $2_1 = ($4_1 >>> 20 | 0) + $11_1 | 0;
    $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $11_1 = $2_1;
    $1_1 = $2_1 << 8;
    $2_1 = $0_1;
    HEAP8[$2_1 + 40 | 0] = $6_1;
    HEAP8[$2_1 + 41 | 0] = $6_1 >>> 8;
    HEAP8[$2_1 + 42 | 0] = $6_1 >>> 16;
    HEAP8[$2_1 + 43 | 0] = $6_1 >>> 24;
    $1_1 = $1_1 | $12_1;
    HEAP8[$2_1 + 44 | 0] = $1_1;
    HEAP8[$2_1 + 45 | 0] = $1_1 >>> 8;
    HEAP8[$2_1 + 46 | 0] = $1_1 >>> 16;
    HEAP8[$2_1 + 47 | 0] = $1_1 >>> 24;
    $10_1 = (($3_1 & 16777215) << 8 | $10_1 >>> 24) & 268435455;
    $1_1 = $19_1 & 1048575;
    $3_1 = $3_1 >>> 20 | 0;
    $2_1 = $3_1 + $7_1 | 0;
    $3_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $3_1 << 28 | $2_1 >>> 4;
    $7_1 = $2_1 << 28;
    $2_1 = $0_1;
    $7_1 = $7_1 | $10_1;
    HEAP8[$2_1 + 16 | 0] = $7_1;
    HEAP8[$2_1 + 17 | 0] = $7_1 >>> 8;
    HEAP8[$2_1 + 18 | 0] = $7_1 >>> 16;
    HEAP8[$2_1 + 19 | 0] = $7_1 >>> 24;
    HEAP8[$2_1 + 20 | 0] = $1_1;
    HEAP8[$2_1 + 21 | 0] = $1_1 >>> 8;
    HEAP8[$2_1 + 22 | 0] = $1_1 >>> 16;
    HEAP8[$2_1 + 23 | 0] = $1_1 >>> 24;
    $7_1 = (($4_1 & 16777215) << 8 | $11_1 >>> 24) & 268435455;
    $1_1 = $17_1 & 1048575;
    $4_1 = $4_1 >>> 20 | 0;
    $2_1 = $4_1 + $5_1 | 0;
    $4_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $4_1 << 28 | $2_1 >>> 4;
    $5_1 = $2_1 << 28;
    $2_1 = $0_1;
    $5_1 = $5_1 | $7_1;
    HEAP8[$2_1 + 48 | 0] = $5_1;
    HEAP8[$2_1 + 49 | 0] = $5_1 >>> 8;
    HEAP8[$2_1 + 50 | 0] = $5_1 >>> 16;
    HEAP8[$2_1 + 51 | 0] = $5_1 >>> 24;
    HEAP8[$2_1 + 52 | 0] = $1_1;
    HEAP8[$2_1 + 53 | 0] = $1_1 >>> 8;
    HEAP8[$2_1 + 54 | 0] = $1_1 >>> 16;
    HEAP8[$2_1 + 55 | 0] = $1_1 >>> 24;
    $2_1 = $3_1 >>> 4 & 65535;
    $1_1 = $9_1;
    $3_1 = ($3_1 >>> 20 | 0) + $21_1 | 0;
    $1_1 = ($3_1 >>> 0 < $21_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) << 16 | $3_1 >>> 16;
    $5_1 = $3_1 << 16;
    $3_1 = $0_1;
    $2_1 = $2_1 | $5_1;
    HEAP8[$3_1 + 24 | 0] = $2_1;
    HEAP8[$3_1 + 25 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 26 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 27 | 0] = $2_1 >>> 24;
    HEAP8[$3_1 + 28 | 0] = $1_1;
    HEAP8[$3_1 + 29 | 0] = $1_1 >>> 8;
    HEAP8[$3_1 + 30 | 0] = $1_1 >>> 16;
    HEAP8[$3_1 + 31 | 0] = $1_1 >>> 24;
    $2_1 = $4_1 >>> 4 & 65535;
    $1_1 = $8_1;
    $3_1 = ($4_1 >>> 20 | 0) + $18_1 | 0;
    $1_1 = ($3_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) << 16 | $3_1 >>> 16;
    $3_1 = $3_1 << 16 | $2_1;
    HEAP8[$0_1 + 56 | 0] = $3_1;
    HEAP8[$0_1 + 57 | 0] = $3_1 >>> 8;
    HEAP8[$0_1 + 58 | 0] = $3_1 >>> 16;
    HEAP8[$0_1 + 59 | 0] = $3_1 >>> 24;
    HEAP8[$0_1 + 60 | 0] = $1_1;
    HEAP8[$0_1 + 61 | 0] = $1_1 >>> 8;
    HEAP8[$0_1 + 62 | 0] = $1_1 >>> 16;
    HEAP8[$0_1 + 63 | 0] = $1_1 >>> 24;
  }
  function $36($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0;
    $8_1 = global$0 - 96 | 0;
    global$0 = $8_1;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689730, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      $5_1 = HEAP32[$1_1 >> 2];
      $26_1 = $3_1 & 256;
      if ($5_1 >>> 0 < ($26_1 ? 33 : 65) >>> 0) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690157, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      HEAP32[$1_1 >> 2] = 0;
      $22_1 = $68(690820, $5_1);
      if (!$2_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      if (($3_1 & 255) != 2) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689499, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      HEAP32[$8_1 + 88 >> 2] = 0;
      $3_1 = HEAPU8[$2_1 + 12 | 0] | HEAPU8[$2_1 + 13 | 0] << 8 | (HEAPU8[$2_1 + 14 | 0] << 16 | HEAPU8[$2_1 + 15 | 0] << 24);
      $6_1 = $3_1;
      $5_1 = HEAPU8[$2_1 + 8 | 0] | HEAPU8[$2_1 + 9 | 0] << 8 | (HEAPU8[$2_1 + 10 | 0] << 16 | HEAPU8[$2_1 + 11 | 0] << 24);
      $7_1 = ($3_1 << 12 | $5_1 >>> 20) & 1048575;
      $9_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $4_1 = $9_1;
      $5_1 = $5_1 << 12 & -4096 | $4_1 >>> 20;
      $20_1 = $7_1;
      $7_1 = HEAPU8[$2_1 + 16 | 0] | HEAPU8[$2_1 + 17 | 0] << 8 | (HEAPU8[$2_1 + 18 | 0] << 16 | HEAPU8[$2_1 + 19 | 0] << 24);
      $11_1 = $7_1;
      $3_1 = HEAPU8[$2_1 + 20 | 0] | HEAPU8[$2_1 + 21 | 0] << 8 | (HEAPU8[$2_1 + 22 | 0] << 16 | HEAPU8[$2_1 + 23 | 0] << 24);
      $9_1 = $3_1;
      $12_1 = ($3_1 << 24 | $7_1 >>> 8) & 1048575;
      $16_1 = $7_1 << 24 & -16777216 | $6_1 >>> 8;
      $23_1 = $12_1;
      $10_1 = $12_1;
      $7_1 = HEAPU8[$2_1 + 28 | 0] | HEAPU8[$2_1 + 29 | 0] << 8 | (HEAPU8[$2_1 + 30 | 0] << 16 | HEAPU8[$2_1 + 31 | 0] << 24);
      $3_1 = $7_1 >>> 16 | 0;
      $6_1 = HEAPU8[$2_1 + 24 | 0] | HEAPU8[$2_1 + 25 | 0] << 8 | (HEAPU8[$2_1 + 26 | 0] << 16 | HEAPU8[$2_1 + 27 | 0] << 24);
      $7_1 = ($7_1 & 65535) << 16 | $6_1 >>> 16;
      $17_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      $15_1 = $16_1 | ($7_1 | ($17_1 | $5_1));
      $24_1 = $3_1;
      $18_1 = $4_1 & 1048575;
      $4_1 = $10_1 | ($3_1 | ($18_1 | $20_1));
      $10_1 = $6_1 << 4 & 1048560;
      $6_1 = $9_1;
      $3_1 = $6_1 >>> 28 | 0;
      $12_1 = ($6_1 & 268435455) << 4 | $11_1 >>> 28;
      $9_1 = $15_1 | $12_1;
      $15_1 = $3_1 | $10_1;
      if (!($9_1 | ($4_1 | $15_1))) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      $6_1 = HEAPU8[$2_1 + 52 | 0] | HEAPU8[$2_1 + 53 | 0] << 8 | (HEAPU8[$2_1 + 54 | 0] << 16 | HEAPU8[$2_1 + 55 | 0] << 24);
      $3_1 = $6_1 >>> 28 | 0;
      $0_1 = HEAPU8[$2_1 + 48 | 0] | HEAPU8[$2_1 + 49 | 0] << 8 | (HEAPU8[$2_1 + 50 | 0] << 16 | HEAPU8[$2_1 + 51 | 0] << 24);
      $9_1 = ($6_1 & 268435455) << 4 | $0_1 >>> 28;
      $11_1 = $3_1;
      $3_1 = HEAPU8[$2_1 + 56 | 0] | HEAPU8[$2_1 + 57 | 0] << 8 | (HEAPU8[$2_1 + 58 | 0] << 16 | HEAPU8[$2_1 + 59 | 0] << 24);
      $27_1 = $3_1;
      $13_1 = HEAPU8[$2_1 + 60 | 0] | HEAPU8[$2_1 + 61 | 0] << 8 | (HEAPU8[$2_1 + 62 | 0] << 16 | HEAPU8[$2_1 + 63 | 0] << 24);
      $28_1 = $3_1 << 4 & 1048560;
      $4_1 = HEAPU8[$2_1 + 40 | 0] | HEAPU8[$2_1 + 41 | 0] << 8 | (HEAPU8[$2_1 + 42 | 0] << 16 | HEAPU8[$2_1 + 43 | 0] << 24);
      $10_1 = HEAPU8[$2_1 + 44 | 0] | HEAPU8[$2_1 + 45 | 0] << 8 | (HEAPU8[$2_1 + 46 | 0] << 16 | HEAPU8[$2_1 + 47 | 0] << 24);
      $19_1 = $10_1 >>> 8 | 0;
      $3_1 = $6_1 << 24 | $0_1 >>> 8;
      $29_1 = $0_1 << 24 & -16777216;
      $30_1 = $3_1 & 1048575;
      $6_1 = HEAPU8[$2_1 + 32 | 0] | HEAPU8[$2_1 + 33 | 0] << 8 | (HEAPU8[$2_1 + 34 | 0] << 16 | HEAPU8[$2_1 + 35 | 0] << 24);
      $0_1 = HEAPU8[$2_1 + 36 | 0] | HEAPU8[$2_1 + 37 | 0] << 8 | (HEAPU8[$2_1 + 38 | 0] << 16 | HEAPU8[$2_1 + 39 | 0] << 24);
      $14_1 = $0_1;
      $2_1 = $0_1 >>> 20 | 0;
      $0_1 = $4_1;
      $3_1 = $10_1 << 12 | $0_1 >>> 20;
      $10_1 = $0_1 << 12 & -4096;
      $25_1 = $3_1 & 1048575;
      $21_1 = $14_1 & 1048575;
      label$7: {
        if (($18_1 | 0) == 1048574 & $17_1 >>> 0 < 4294966319 | $18_1 >>> 0 < 1048574) {
          break label$7;
        }
        if (($5_1 & $16_1 & $12_1) != -1 | ($20_1 & $23_1 & $15_1) != 1048575) {
          break label$7;
        }
        if (($7_1 | 0) != -1 | ($24_1 | 0) != 65535) {
          break label$7;
        }
        $0_1 = $18_1 + 1 | 0;
        $17_1 = $17_1 + 977 | 0;
        $0_1 = $17_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
        $18_1 = $0_1 & 1048575;
        $4_1 = $0_1 >>> 20 | 0;
        $0_1 = $20_1;
        $5_1 = $4_1 + $5_1 | 0;
        $0_1 = $5_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $20_1 = $0_1 & 1048575;
        $3_1 = $23_1;
        $0_1 = $0_1 >>> 20 | 0;
        $16_1 = $0_1 + $16_1 | 0;
        $3_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $23_1 = $3_1 & 1048575;
        $4_1 = $3_1 >>> 20 | 0;
        $0_1 = $15_1;
        $12_1 = $4_1 + $12_1 | 0;
        $0_1 = $12_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $15_1 = $0_1 & 1048575;
        $4_1 = $0_1 >>> 20 | 0;
        $0_1 = $24_1;
        $3_1 = $7_1;
        $7_1 = $4_1 + $7_1 | 0;
        $24_1 = ($3_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
      }
      $4_1 = $9_1;
      $14_1 = $11_1 | $28_1;
      $11_1 = $19_1 | $29_1;
      $19_1 = $30_1;
      $10_1 = $2_1 | $10_1;
      $0_1 = $13_1;
      $3_1 = $0_1 >>> 16 | 0;
      $9_1 = ($0_1 & 65535) << 16 | $27_1 >>> 16;
      $13_1 = $3_1;
      $2_1 = $8_1;
      HEAP32[$2_1 + 40 >> 2] = $7_1;
      HEAP32[$2_1 + 44 >> 2] = $24_1;
      HEAP32[$2_1 + 32 >> 2] = $12_1;
      HEAP32[$2_1 + 36 >> 2] = $15_1;
      HEAP32[$2_1 + 24 >> 2] = $16_1;
      HEAP32[$2_1 + 28 >> 2] = $23_1;
      HEAP32[$2_1 + 16 >> 2] = $5_1;
      HEAP32[$2_1 + 20 >> 2] = $20_1;
      HEAP32[$2_1 + 8 >> 2] = $17_1;
      HEAP32[$2_1 + 12 >> 2] = $18_1;
      label$8: {
        if (($21_1 | 0) == 1048574 & $6_1 >>> 0 < 4294966319 | $21_1 >>> 0 < 1048574) {
          break label$8;
        }
        if (($10_1 & $11_1 & $4_1) != -1 | ($25_1 & $19_1 & $14_1) != 1048575) {
          break label$8;
        }
        if (($9_1 | 0) != -1 | ($13_1 | 0) != 65535) {
          break label$8;
        }
        $3_1 = $21_1 + 1 | 0;
        $6_1 = $6_1 + 977 | 0;
        $3_1 = $6_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
        $21_1 = $3_1 & 1048575;
        $0_1 = $25_1;
        $3_1 = $3_1 >>> 20 | 0;
        $10_1 = $3_1 + $10_1 | 0;
        $0_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $25_1 = $0_1 & 1048575;
        $5_1 = $0_1 >>> 20 | 0;
        $3_1 = $19_1;
        $11_1 = $5_1 + $11_1 | 0;
        $3_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $19_1 = $3_1 & 1048575;
        $5_1 = $3_1 >>> 20 | 0;
        $3_1 = $14_1;
        $4_1 = $4_1 + $5_1 | 0;
        $3_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $3_1 & 1048575;
        $0_1 = $13_1;
        $13_1 = $9_1;
        $9_1 = ($3_1 >>> 20 | 0) + $9_1 | 0;
        $13_1 = ($13_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
      }
      HEAP32[$2_1 + 80 >> 2] = $9_1;
      HEAP32[$8_1 + 84 >> 2] = $13_1;
      HEAP32[$8_1 + 72 >> 2] = $4_1;
      HEAP32[$8_1 + 76 >> 2] = $14_1;
      HEAP32[$8_1 + 64 >> 2] = $11_1;
      HEAP32[$8_1 + 68 >> 2] = $19_1;
      HEAP32[$8_1 + 56 >> 2] = $10_1;
      HEAP32[$8_1 + 60 >> 2] = $25_1;
      HEAP32[$8_1 + 48 >> 2] = $6_1;
      HEAP32[$8_1 + 52 >> 2] = $21_1;
      $37($22_1 + 1 | 0, $8_1 + 8 | 0);
      label$9: {
        if ($26_1) {
          HEAP8[$22_1 | 0] = $6_1 & 1 ? 3 : 2;
          $0_1 = 33;
          break label$9;
        }
        HEAP8[$22_1 | 0] = 4;
        $37($22_1 + 33 | 0, $8_1 + 48 | 0);
        $0_1 = 65;
      }
      HEAP32[$1_1 >> 2] = $0_1;
      $14_1 = 1;
    }
    global$0 = $8_1 + 96 | 0;
    return $14_1;
  }
  function $37($0_1, $1_1) {
    HEAP8[$0_1 | 0] = HEAP32[$1_1 + 36 >> 2] >>> 8;
    HEAP8[$0_1 + 1 | 0] = HEAP32[$1_1 + 36 >> 2];
    HEAP8[$0_1 + 2 | 0] = (HEAP32[$1_1 + 36 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 32 >> 2] >>> 24;
    HEAP8[$0_1 + 3 | 0] = (HEAP32[$1_1 + 36 >> 2] & 65535) << 16 | HEAP32[$1_1 + 32 >> 2] >>> 16;
    HEAP8[$0_1 + 4 | 0] = (HEAP32[$1_1 + 36 >> 2] & 255) << 24 | HEAP32[$1_1 + 32 >> 2] >>> 8;
    HEAP8[$0_1 + 5 | 0] = HEAP32[$1_1 + 32 >> 2];
    HEAP8[$0_1 + 6 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 12;
    HEAP8[$0_1 + 7 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 4;
    HEAP8[$0_1 + 8 | 0] = (HEAP32[$1_1 + 28 >> 2] & 268435455) << 4 | HEAP32[$1_1 + 24 >> 2] >>> 28;
    HEAP8[$0_1 + 9 | 0] = (HEAP32[$1_1 + 28 >> 2] & 1048575) << 12 | HEAP32[$1_1 + 24 >> 2] >>> 20;
    HEAP8[$0_1 + 10 | 0] = (HEAP32[$1_1 + 28 >> 2] & 4095) << 20 | HEAP32[$1_1 + 24 >> 2] >>> 12;
    HEAP8[$0_1 + 11 | 0] = (HEAP32[$1_1 + 28 >> 2] & 15) << 28 | HEAP32[$1_1 + 24 >> 2] >>> 4;
    HEAP8[$0_1 + 12 | 0] = HEAPU16[$1_1 + 22 >> 1] & 15 | HEAP32[$1_1 + 24 >> 2] << 4;
    HEAP8[$0_1 + 13 | 0] = HEAP32[$1_1 + 20 >> 2] >>> 8;
    HEAP8[$0_1 + 14 | 0] = HEAP32[$1_1 + 20 >> 2];
    HEAP8[$0_1 + 15 | 0] = (HEAP32[$1_1 + 20 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 16 >> 2] >>> 24;
    HEAP8[$0_1 + 16 | 0] = (HEAP32[$1_1 + 20 >> 2] & 65535) << 16 | HEAP32[$1_1 + 16 >> 2] >>> 16;
    HEAP8[$0_1 + 17 | 0] = (HEAP32[$1_1 + 20 >> 2] & 255) << 24 | HEAP32[$1_1 + 16 >> 2] >>> 8;
    HEAP8[$0_1 + 18 | 0] = HEAP32[$1_1 + 16 >> 2];
    HEAP8[$0_1 + 19 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 12;
    HEAP8[$0_1 + 20 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 4;
    HEAP8[$0_1 + 21 | 0] = (HEAP32[$1_1 + 12 >> 2] & 268435455) << 4 | HEAP32[$1_1 + 8 >> 2] >>> 28;
    HEAP8[$0_1 + 22 | 0] = (HEAP32[$1_1 + 12 >> 2] & 1048575) << 12 | HEAP32[$1_1 + 8 >> 2] >>> 20;
    HEAP8[$0_1 + 23 | 0] = (HEAP32[$1_1 + 12 >> 2] & 4095) << 20 | HEAP32[$1_1 + 8 >> 2] >>> 12;
    HEAP8[$0_1 + 24 | 0] = (HEAP32[$1_1 + 12 >> 2] & 15) << 28 | HEAP32[$1_1 + 8 >> 2] >>> 4;
    HEAP8[$0_1 + 25 | 0] = HEAPU16[$1_1 + 6 >> 1] & 15 | HEAP32[$1_1 + 8 >> 2] << 4;
    HEAP8[$0_1 + 26 | 0] = HEAP32[$1_1 + 4 >> 2] >>> 8;
    HEAP8[$0_1 + 27 | 0] = HEAP32[$1_1 + 4 >> 2];
    HEAP8[$0_1 + 28 | 0] = (HEAP32[$1_1 + 4 >> 2] & 16777215) << 8 | HEAP32[$1_1 >> 2] >>> 24;
    HEAP8[$0_1 + 29 | 0] = (HEAP32[$1_1 + 4 >> 2] & 65535) << 16 | HEAP32[$1_1 >> 2] >>> 16;
    HEAP8[$0_1 + 30 | 0] = (HEAP32[$1_1 + 4 >> 2] & 255) << 24 | HEAP32[$1_1 >> 2] >>> 8;
    HEAP8[$0_1 + 31 | 0] = HEAP32[$1_1 >> 2];
  }
  function $38($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
    $6_1 = $0_1;
    $3_1 = $1_1;
    $1_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
    $5_1 = $1_1 << 8 & 16711680;
    $12_1 = $1_1 << 24 | $5_1;
    $4_1 = $1_1 >>> 8 | 0;
    $0_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
    $5_1 = ($4_1 | $0_1 << 24) & 65280;
    $1_1 = $1_1 >>> 24 | 0;
    $5_1 = $12_1 | ($5_1 | ($1_1 | $0_1 << 8) & 255);
    $4_1 = ($1_1 | ($0_1 & 16777215) << 8) & 16711680 | ($4_1 | ($0_1 & 255) << 24) & -16777216;
    $8_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $4_1;
    HEAP32[$6_1 >> 2] = $8_1;
    HEAP32[$6_1 + 4 >> 2] = $5_1;
    $1_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
    $7_1 = $1_1 << 8 & 16711680 | $1_1 << 24;
    $0_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
    $4_1 = ($0_1 << 24 | $1_1 >>> 8) & 65280;
    $12_1 = $7_1 | ($4_1 | ($0_1 << 8 | $1_1 >>> 24) & 255);
    $4_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
    $7_1 = $4_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
    $15_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $7_1;
    HEAP32[$6_1 + 8 >> 2] = $15_1;
    $9_1 = $12_1;
    HEAP32[$6_1 + 12 >> 2] = $9_1;
    $1_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
    $7_1 = $1_1 << 8 & 16711680;
    $13_1 = $1_1 << 24 | $7_1;
    $0_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
    $7_1 = ($0_1 << 24 | $1_1 >>> 8) & 65280;
    $7_1 = $13_1 | ($7_1 | ($0_1 << 8 | $1_1 >>> 24) & 255);
    $4_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
    $4_1 = $4_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
    $14_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $4_1;
    HEAP32[$6_1 + 16 >> 2] = $14_1;
    $13_1 = $7_1;
    HEAP32[$6_1 + 20 >> 2] = $7_1;
    $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
    $1_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
    $7_1 = $1_1 << 8 & 16711680 | $1_1 << 24;
    $12_1 = $7_1 | (($0_1 << 8 | $1_1 >>> 24) & 255 | ($0_1 << 24 | $1_1 >>> 8) & 65280);
    $3_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
    $10_1 = $3_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
    $7_1 = $0_1 >>> 8 & 65280;
    $1_1 = $0_1 >>> 24 | 0;
    $0_1 = $12_1;
    $3_1 = ($13_1 | 0) == -1;
    $7_1 = $1_1 | $7_1 | $10_1;
    $1_1 = $3_1 & $14_1 >>> 0 < 4294967294 | ($13_1 | 0) != -1 | ($0_1 & $7_1) != -1;
    $4_1 = ($9_1 | 0) == -1162945306;
    $0_1 = ($1_1 | ($4_1 & $15_1 >>> 0 < 2940772411 | $9_1 >>> 0 < 3132021990)) ^ -1;
    $10_1 = $0_1 & (($5_1 | 0) == -1076732276 & $8_1 >>> 0 > 3493216576 | $5_1 >>> 0 > 3218235020) | ($0_1 & ($4_1 & $15_1 >>> 0 > 2940772411 | $9_1 >>> 0 > 3132021990) | ($14_1 | 0) == -1 & $3_1 & ($1_1 ^ -1));
    $11_1 = __wasm_i64_mul($10_1, 0, 801750719, 1076732275);
    $4_1 = i64toi32_i32$HIGH_BITS;
    $3_1 = $4_1 + $5_1 | 0;
    $0_1 = $8_1 + $11_1 | 0;
    $3_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 >> 2] = $0_1;
    HEAP32[$6_1 + 4 >> 2] = $3_1;
    $1_1 = $6_1;
    $3_1 = ($3_1 | 0) == ($4_1 | 0) & $0_1 >>> 0 < $11_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $11_1 = __wasm_i64_mul($10_1, 0, 1354194884, 1162945305);
    $5_1 = i64toi32_i32$HIGH_BITS;
    $8_1 = $5_1 + $9_1 | 0;
    $6_1 = $11_1 + $15_1 | 0;
    $0_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $8_1 + 1 | 0 : $8_1;
    $3_1 = $3_1 + $6_1 | 0;
    $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$1_1 + 8 >> 2] = $3_1;
    HEAP32[$1_1 + 12 >> 2] = $4_1;
    $9_1 = ($0_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
    $0_1 = ($0_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $4_1 >>> 0;
    $5_1 = $9_1 + $0_1 | 0;
    $4_1 = $13_1;
    $3_1 = $0_1 >>> 0 > $5_1 >>> 0;
    $6_1 = $10_1 + $14_1 | 0;
    $0_1 = $6_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $3_1 + $0_1 | 0;
    $4_1 = $6_1;
    $5_1 = $4_1 + $5_1 | 0;
    $8_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $8_1 + 1 | 0 : $8_1;
    HEAP32[$1_1 + 16 >> 2] = $5_1;
    HEAP32[$1_1 + 20 >> 2] = $8_1;
    $3_1 = $1_1;
    $6_1 = $7_1;
    $1_1 = !$0_1 & $4_1 >>> 0 < $10_1 >>> 0;
    $0_1 = ($0_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
    $5_1 = $1_1 + $0_1 | 0;
    $1_1 = ($0_1 >>> 0 > $5_1 >>> 0) + $12_1 | 0;
    $0_1 = $5_1 + $6_1 | 0;
    $1_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$3_1 + 24 >> 2] = $0_1;
    HEAP32[$3_1 + 28 >> 2] = $1_1;
    if ($2_1) {
      HEAP32[$2_1 >> 2] = $10_1;
    }
  }
  function $39($0_1, $1_1) {
    HEAP8[$0_1 | 0] = HEAPU8[$1_1 + 31 | 0];
    HEAP8[$0_1 + 1 | 0] = HEAPU16[$1_1 + 30 >> 1];
    HEAP8[$0_1 + 2 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 8;
    HEAP8[$0_1 + 3 | 0] = HEAP32[$1_1 + 28 >> 2];
    HEAP8[$0_1 + 4 | 0] = (HEAP32[$1_1 + 28 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 24 >> 2] >>> 24;
    HEAP8[$0_1 + 5 | 0] = (HEAP32[$1_1 + 28 >> 2] & 65535) << 16 | HEAP32[$1_1 + 24 >> 2] >>> 16;
    HEAP8[$0_1 + 6 | 0] = (HEAP32[$1_1 + 28 >> 2] & 255) << 24 | HEAP32[$1_1 + 24 >> 2] >>> 8;
    HEAP8[$0_1 + 7 | 0] = HEAP32[$1_1 + 24 >> 2];
    HEAP8[$0_1 + 8 | 0] = HEAPU8[$1_1 + 23 | 0];
    HEAP8[$0_1 + 9 | 0] = HEAPU16[$1_1 + 22 >> 1];
    HEAP8[$0_1 + 10 | 0] = HEAP32[$1_1 + 20 >> 2] >>> 8;
    HEAP8[$0_1 + 11 | 0] = HEAP32[$1_1 + 20 >> 2];
    HEAP8[$0_1 + 12 | 0] = (HEAP32[$1_1 + 20 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 16 >> 2] >>> 24;
    HEAP8[$0_1 + 13 | 0] = (HEAP32[$1_1 + 20 >> 2] & 65535) << 16 | HEAP32[$1_1 + 16 >> 2] >>> 16;
    HEAP8[$0_1 + 14 | 0] = (HEAP32[$1_1 + 20 >> 2] & 255) << 24 | HEAP32[$1_1 + 16 >> 2] >>> 8;
    HEAP8[$0_1 + 15 | 0] = HEAP32[$1_1 + 16 >> 2];
    HEAP8[$0_1 + 16 | 0] = HEAPU8[$1_1 + 15 | 0];
    HEAP8[$0_1 + 17 | 0] = HEAPU16[$1_1 + 14 >> 1];
    HEAP8[$0_1 + 18 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 8;
    HEAP8[$0_1 + 19 | 0] = HEAP32[$1_1 + 12 >> 2];
    HEAP8[$0_1 + 20 | 0] = (HEAP32[$1_1 + 12 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 8 >> 2] >>> 24;
    HEAP8[$0_1 + 21 | 0] = (HEAP32[$1_1 + 12 >> 2] & 65535) << 16 | HEAP32[$1_1 + 8 >> 2] >>> 16;
    HEAP8[$0_1 + 22 | 0] = (HEAP32[$1_1 + 12 >> 2] & 255) << 24 | HEAP32[$1_1 + 8 >> 2] >>> 8;
    HEAP8[$0_1 + 23 | 0] = HEAP32[$1_1 + 8 >> 2];
    HEAP8[$0_1 + 24 | 0] = HEAPU8[$1_1 + 7 | 0];
    HEAP8[$0_1 + 25 | 0] = HEAPU16[$1_1 + 6 >> 1];
    HEAP8[$0_1 + 26 | 0] = HEAP32[$1_1 + 4 >> 2] >>> 8;
    HEAP8[$0_1 + 27 | 0] = HEAP32[$1_1 + 4 >> 2];
    HEAP8[$0_1 + 28 | 0] = (HEAP32[$1_1 + 4 >> 2] & 16777215) << 8 | HEAP32[$1_1 >> 2] >>> 24;
    HEAP8[$0_1 + 29 | 0] = (HEAP32[$1_1 + 4 >> 2] & 65535) << 16 | HEAP32[$1_1 >> 2] >>> 16;
    HEAP8[$0_1 + 30 | 0] = (HEAP32[$1_1 + 4 >> 2] & 255) << 24 | HEAP32[$1_1 >> 2] >>> 8;
    HEAP8[$0_1 + 31 | 0] = HEAP32[$1_1 >> 2];
  }
  function $40($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0;
    $6_1 = global$0 - 320 | 0;
    global$0 = $6_1;
    $2_1 = $6_1 + 280 | 0;
    $3_1 = $2_1 + 32 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 24 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 16 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $2_1 = $2_1 + 8 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    HEAP32[$6_1 + 280 >> 2] = 0;
    HEAP32[$6_1 + 284 >> 2] = 0;
    $2_1 = $6_1 + 240 | 0;
    $3_1 = $2_1 + 32 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 24 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $2_1 = $2_1 + 16 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    HEAP32[$6_1 + 248 >> 2] = 0;
    HEAP32[$6_1 + 252 >> 2] = 0;
    HEAP32[$6_1 + 240 >> 2] = 1;
    HEAP32[$6_1 + 244 >> 2] = 0;
    $3_1 = $1_1 + 32 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $2_1 = $6_1 + 200 | 0;
    $5_1 = $2_1 + 32 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $4_1;
    $3_1 = $1_1 + 24 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $2_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $4_1;
    $3_1 = $1_1 + 16 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $2_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $4_1;
    $3_1 = $1_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $2_1 = $2_1 + 8 | 0;
    HEAP32[$2_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$2_1 + 4 >> 2] = $4_1;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    HEAP32[$6_1 + 200 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$6_1 + 204 >> 2] = $2_1;
    $3_1 = $0_1 + 32 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $2_1 = $6_1 + 160 | 0;
    $30_1 = $2_1 + 32 | 0;
    HEAP32[$30_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$30_1 + 4 >> 2] = $4_1;
    $3_1 = $0_1 + 24 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $2_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $4_1;
    $3_1 = $0_1 + 16 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $5_1 = $2_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $4_1;
    $3_1 = $0_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    $2_1 = $2_1 + 8 | 0;
    HEAP32[$2_1 >> 2] = HEAP32[$3_1 >> 2];
    HEAP32[$2_1 + 4 >> 2] = $4_1;
    $2_1 = HEAP32[$0_1 + 4 >> 2];
    HEAP32[$6_1 + 160 >> 2] = HEAP32[$0_1 >> 2];
    HEAP32[$6_1 + 164 >> 2] = $2_1;
    $24_1 = 5;
    $22_1 = -1;
    $25_1 = -1;
    while (1) {
      $2_1 = $22_1;
      $20_1 = HEAP32[$6_1 + 160 >> 2];
      $16_1 = HEAP32[$6_1 + 164 >> 2];
      $3_1 = __wasm_ctz_i64($20_1, $16_1 | -1073741824);
      $22_1 = $2_1 - $3_1 | 0;
      $25_1 = $25_1 - (i64toi32_i32$HIGH_BITS + ($2_1 >>> 0 < $3_1 >>> 0) | 0) | 0;
      $2_1 = $3_1 & 31;
      if (($3_1 & 63) >>> 0 >= 32) {
        $8_1 = 0;
        $14_1 = 1 << $2_1;
      } else {
        $8_1 = 1 << $2_1;
        $14_1 = $8_1 - 1 & 1 >>> 32 - $2_1;
      }
      $28_1 = HEAP32[$6_1 + 200 >> 2];
      $26_1 = HEAP32[$6_1 + 204 >> 2];
      $5_1 = $3_1;
      label$2: {
        if (($3_1 | 0) == 62) {
          $7_1 = 0;
          $5_1 = 0;
          $13_1 = 1;
          $11_1 = 0;
          $21_1 = 0;
          $18_1 = 0;
          break label$2;
        }
        $3_1 = $5_1 & 31;
        if (($5_1 & 63) >>> 0 >= 32) {
          $4_1 = $16_1 >>> $3_1 | 0;
          $3_1 = 0;
        } else {
          $4_1 = ((1 << $3_1) - 1 & $16_1) << 32 - $3_1 | $20_1 >>> $3_1;
          $3_1 = $16_1 >>> $3_1 | 0;
        }
        $12_1 = 62 - $5_1 | 0;
        $13_1 = 1;
        $11_1 = 0;
        $21_1 = 0;
        $18_1 = 0;
        $10_1 = $28_1;
        $9_1 = $26_1;
        $7_1 = 0;
        $5_1 = 0;
        while (1) {
          label$5: {
            if (($25_1 | 0) < 0) {
              $2_1 = __wasm_i64_mul($4_1, $3_1, $4_1, $3_1);
              $17_1 = $2_1 - 2 | 0;
              $23_1 = i64toi32_i32$HIGH_BITS - ($2_1 >>> 0 < 2) | 0;
              $19_1 = 0 - $10_1 | 0;
              $2_1 = 0 - ((($10_1 | 0) != 0) + $9_1 | 0) | 0;
              $10_1 = __wasm_i64_mul($17_1, $23_1, __wasm_i64_mul($19_1, $2_1, $4_1, $3_1), i64toi32_i32$HIGH_BITS);
              $25_1 = 0 - ((($22_1 | 0) != 0) + $25_1 | 0) | 0;
              $22_1 = 0 - $22_1 | 0;
              $9_1 = $22_1 + 1 | 0;
              $15_1 = 64 - (($9_1 | 0) > ($12_1 | 0) ? $12_1 : $9_1) | 0;
              $9_1 = $15_1 & 31;
              if (($15_1 & 63) >>> 0 >= 32) {
                $9_1 = -1 >>> $9_1 | 0;
              } else {
                $9_1 = (1 << $9_1) - 1 << 32 - $9_1 | -1 >>> $9_1;
              }
              $31_1 = $9_1 & $10_1 & 63;
              $15_1 = 0 - $21_1 | 0;
              $17_1 = 0 - ((($21_1 | 0) != 0) + $18_1 | 0) | 0;
              $23_1 = 0 - $8_1 | 0;
              $33_1 = 0 - ((($8_1 | 0) != 0) + $14_1 | 0) | 0;
              $10_1 = $4_1;
              $9_1 = $3_1;
              break label$5;
            }
            $15_1 = ($10_1 << 1) + 2 | 0;
            $2_1 = $9_1;
            $17_1 = $15_1 & 8;
            $15_1 = $17_1 + $10_1 | 0;
            $15_1 = 0 - __wasm_i64_mul($15_1, $15_1 >>> 0 < $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1, $4_1, $3_1) | 0;
            $2_1 = $22_1 + 1 | 0;
            $17_1 = 64 - (($2_1 | 0) > ($12_1 | 0) ? $12_1 : $2_1) | 0;
            $2_1 = $17_1 & 31;
            if (($17_1 & 63) >>> 0 >= 32) {
              $2_1 = -1 >>> $2_1 | 0;
            } else {
              $2_1 = (1 << $2_1) - 1 << 32 - $2_1 | -1 >>> $2_1;
            }
            $31_1 = $2_1 & $15_1 & 15;
            $23_1 = $7_1;
            $33_1 = $5_1;
            $15_1 = $13_1;
            $17_1 = $11_1;
            $19_1 = $4_1;
            $2_1 = $3_1;
            $7_1 = $8_1;
            $5_1 = $14_1;
            $13_1 = $21_1;
            $11_1 = $18_1;
          }
          $8_1 = $22_1;
          $3_1 = __wasm_i64_mul($10_1, $9_1, $31_1, 0) + $19_1 | 0;
          $2_1 = i64toi32_i32$HIGH_BITS + $2_1 | 0;
          $4_1 = $3_1 >>> 0 < $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $12_1 & 31;
          if (($12_1 & 63) >>> 0 >= 32) {
            $14_1 = 0;
            $2_1 = -1 << $2_1;
          } else {
            $14_1 = -1 << $2_1;
            $2_1 = $14_1 | (1 << $2_1) - 1 & -1 >>> 32 - $2_1;
          }
          $19_1 = __wasm_ctz_i64($3_1 | $14_1, $2_1 | $4_1);
          $22_1 = $8_1 - $19_1 | 0;
          $25_1 = $25_1 - (i64toi32_i32$HIGH_BITS + ($8_1 >>> 0 < $19_1 >>> 0) | 0) | 0;
          $8_1 = $19_1 & 31;
          if (($19_1 & 63) >>> 0 >= 32) {
            $21_1 = 0;
            $18_1 = $13_1 << $8_1;
          } else {
            $21_1 = $13_1 << $8_1;
            $18_1 = (1 << $8_1) - 1 & $13_1 >>> 32 - $8_1 | $11_1 << $8_1;
          }
          $8_1 = $19_1 & 31;
          if (($19_1 & 63) >>> 0 >= 32) {
            $2_1 = $7_1 << $8_1;
            $8_1 = 0;
          } else {
            $2_1 = (1 << $8_1) - 1 & $7_1 >>> 32 - $8_1 | $5_1 << $8_1;
            $8_1 = $7_1 << $8_1;
          }
          $14_1 = $2_1;
          $29_1 = $19_1 & 31;
          if (($19_1 & 63) >>> 0 >= 32) {
            $2_1 = 0;
            $4_1 = $4_1 >>> $29_1 | 0;
          } else {
            $2_1 = $4_1 >>> $29_1 | 0;
            $4_1 = ((1 << $29_1) - 1 & $4_1) << 32 - $29_1 | $3_1 >>> $29_1;
          }
          $3_1 = $2_1;
          $13_1 = __wasm_i64_mul($13_1, $11_1, $31_1, 0) + $15_1 | 0;
          $2_1 = i64toi32_i32$HIGH_BITS + $17_1 | 0;
          $11_1 = $13_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $7_1 = __wasm_i64_mul($7_1, $5_1, $31_1, 0) + $23_1 | 0;
          $2_1 = i64toi32_i32$HIGH_BITS + $33_1 | 0;
          $5_1 = $7_1 >>> 0 < $23_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $12_1 = $12_1 - $19_1 | 0;
          if ($12_1) {
            continue;
          }
          break;
        }
        ;
      }
      HEAP32[$6_1 + 152 >> 2] = $13_1;
      HEAP32[$6_1 + 156 >> 2] = $11_1;
      HEAP32[$6_1 + 144 >> 2] = $7_1;
      HEAP32[$6_1 + 148 >> 2] = $5_1;
      HEAP32[$6_1 + 136 >> 2] = $21_1;
      HEAP32[$6_1 + 140 >> 2] = $18_1;
      HEAP32[$6_1 + 128 >> 2] = $8_1;
      HEAP32[$6_1 + 132 >> 2] = $14_1;
      $67($6_1 + 280 | 0, $6_1 + 240 | 0, $6_1 + 128 | 0, $1_1);
      $23_1 = $14_1;
      $2_1 = $14_1 >> 31;
      $14_1 = $2_1;
      $10_1 = $2_1;
      $2_1 = $26_1 >> 31;
      $9_1 = $6_1 + 112 | 0;
      $19_1 = $8_1;
      $3_1 = $2_1;
      $69($9_1, $8_1, $23_1, $10_1, $10_1, $28_1, $26_1, $2_1, $2_1);
      $33_1 = $21_1;
      $2_1 = $18_1 >> 31;
      $21_1 = $2_1;
      $8_1 = $2_1;
      $2_1 = $16_1 >> 31;
      $10_1 = $6_1 + 80 | 0;
      $29_1 = $18_1;
      $4_1 = $2_1;
      $69($10_1, $33_1, $18_1, $8_1, $8_1, $20_1, $16_1, $2_1, $2_1);
      $2_1 = $5_1 >> 31;
      $8_1 = $6_1 + 96 | 0;
      $31_1 = $7_1;
      $42_1 = $5_1;
      $36_1 = $2_1;
      $69($8_1, $7_1, $5_1, $2_1, $2_1, $28_1, $26_1, $3_1, $3_1);
      $2_1 = $11_1 >> 31;
      $12_1 = $6_1 - -64 | 0;
      $28_1 = $13_1;
      $26_1 = $11_1;
      $37_1 = $2_1;
      $69($12_1, $13_1, $11_1, $2_1, $2_1, $20_1, $16_1, $4_1, $4_1);
      $7_1 = HEAP32[$6_1 + 80 >> 2];
      $4_1 = HEAP32[$6_1 + 112 >> 2];
      $3_1 = $7_1 + $4_1 | 0;
      $5_1 = HEAP32[$6_1 + 84 >> 2];
      $2_1 = $5_1 + HEAP32[$6_1 + 116 >> 2] | 0;
      $2_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $4_1 = $3_1;
      $3_1 = $2_1;
      $5_1 = ($5_1 | 0) == ($2_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $5_1 >>> 0;
      $2_1 = $9_1 + 8 | 0;
      $7_1 = HEAP32[$2_1 >> 2];
      $9_1 = $10_1 + 8 | 0;
      $4_1 = $7_1 + HEAP32[$9_1 >> 2] | 0;
      $2_1 = HEAP32[$9_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $7_1 = $4_1;
      $4_1 = $4_1 + $5_1 | 0;
      $5_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $7_1 = $5_1 << 2 | $4_1 >>> 30;
      $4_1 = $4_1 << 2 | $3_1 >>> 30;
      $3_1 = $7_1;
      $11_1 = HEAP32[$6_1 + 64 >> 2];
      $9_1 = HEAP32[$6_1 + 96 >> 2];
      $7_1 = $11_1 + $9_1 | 0;
      $10_1 = HEAP32[$6_1 + 68 >> 2];
      $2_1 = $10_1 + HEAP32[$6_1 + 100 >> 2] | 0;
      $2_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $9_1 = $7_1;
      $7_1 = $2_1;
      $10_1 = ($10_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
      $2_1 = $8_1 + 8 | 0;
      $11_1 = HEAP32[$2_1 >> 2];
      $8_1 = $12_1 + 8 | 0;
      $9_1 = $11_1 + HEAP32[$8_1 >> 2] | 0;
      $2_1 = HEAP32[$8_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
      $2_1 = $9_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $8_1 = $9_1;
      $9_1 = $10_1 + $9_1 | 0;
      $11_1 = $8_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $8_1 = $11_1 << 2 | $9_1 >>> 30;
      $10_1 = $9_1 << 2 | $7_1 >>> 30;
      $9_1 = $8_1;
      $38_1 = ($24_1 | 0) < 2;
      if (!$38_1) {
        $2_1 = $5_1 >> 31;
        $5_1 = $5_1 >> 30;
        $8_1 = $2_1;
        $15_1 = $11_1 >> 30;
        $17_1 = $11_1 >> 31;
        $27_1 = $24_1 - 1 | 0;
        $12_1 = $6_1 + 160 | 0;
        $11_1 = $6_1 + 200 | 0;
        while (1) {
          $13_1 = $11_1 + 8 | 0;
          $16_1 = HEAP32[$13_1 >> 2];
          $2_1 = HEAP32[$13_1 + 4 >> 2];
          $20_1 = $2_1;
          $2_1 = $2_1 >> 31;
          $7_1 = $2_1;
          $69($6_1, $16_1, $20_1, $2_1, $2_1, $19_1, $23_1, $14_1, $14_1);
          $39_1 = $6_1 + 32 | 0;
          $18_1 = $12_1 + 8 | 0;
          $34_1 = HEAP32[$18_1 >> 2];
          $2_1 = HEAP32[$18_1 + 4 >> 2];
          $32_1 = $2_1;
          $2_1 = $2_1 >> 31;
          $69($39_1, $34_1, $32_1, $2_1, $2_1, $33_1, $29_1, $21_1, $21_1);
          $40_1 = $6_1 + 16 | 0;
          $69($40_1, $16_1, $20_1, $7_1, $7_1, $31_1, $42_1, $36_1, $36_1);
          $41_1 = $6_1 + 48 | 0;
          $69($41_1, $34_1, $32_1, $2_1, $2_1, $28_1, $26_1, $37_1, $37_1);
          $7_1 = HEAP32[$6_1 >> 2];
          $43_1 = $7_1;
          $32_1 = HEAP32[$6_1 + 4 >> 2];
          $2_1 = $32_1 + $3_1 | 0;
          $16_1 = $4_1 + $7_1 | 0;
          $4_1 = $16_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $4_1 + HEAP32[$6_1 + 36 >> 2] | 0;
          $3_1 = HEAP32[$6_1 + 32 >> 2];
          $7_1 = $3_1 + $16_1 | 0;
          $20_1 = $7_1;
          HEAP32[$11_1 >> 2] = $7_1;
          $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          HEAP32[$11_1 + 4 >> 2] = $3_1 & 1073741823;
          $7_1 = HEAP32[$6_1 + 16 >> 2];
          $44_1 = $7_1;
          $35_1 = HEAP32[$6_1 + 20 >> 2];
          $2_1 = $35_1 + $9_1 | 0;
          $11_1 = $7_1 + $10_1 | 0;
          $10_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $10_1 + HEAP32[$6_1 + 52 >> 2] | 0;
          $7_1 = HEAP32[$6_1 + 48 >> 2];
          $9_1 = $7_1 + $11_1 | 0;
          $34_1 = $9_1;
          HEAP32[$12_1 >> 2] = $9_1;
          $7_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          HEAP32[$12_1 + 4 >> 2] = $7_1 & 1073741823;
          $9_1 = ($3_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
          $2_1 = $39_1 + 8 | 0;
          $12_1 = HEAP32[$2_1 >> 2];
          $20_1 = HEAP32[$2_1 + 4 >> 2];
          $16_1 = ($4_1 | 0) == ($32_1 | 0) & $16_1 >>> 0 < $43_1 >>> 0 | $4_1 >>> 0 < $32_1 >>> 0;
          $2_1 = $6_1 + 8 | 0;
          $4_1 = HEAP32[$2_1 >> 2] + $5_1 | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + $8_1 | 0;
          $2_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $8_1 = $4_1;
          $4_1 = $4_1 + $16_1 | 0;
          $2_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
          $8_1 = $4_1;
          $4_1 = $4_1 + $12_1 | 0;
          $2_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $8_1 = $4_1;
          $4_1 = $4_1 + $9_1 | 0;
          $9_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $9_1 >> 31;
          $5_1 = $9_1 >> 30;
          $8_1 = $2_1;
          $12_1 = ($7_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 > $34_1 >>> 0 | $7_1 >>> 0 < $10_1 >>> 0;
          $2_1 = $41_1 + 8 | 0;
          $16_1 = HEAP32[$2_1 >> 2];
          $20_1 = HEAP32[$2_1 + 4 >> 2];
          $11_1 = ($10_1 | 0) == ($35_1 | 0) & $11_1 >>> 0 < $44_1 >>> 0 | $10_1 >>> 0 < $35_1 >>> 0;
          $2_1 = $40_1 + 8 | 0;
          $10_1 = HEAP32[$2_1 >> 2] + $15_1 | 0;
          $2_1 = HEAP32[$2_1 + 4 >> 2] + $17_1 | 0;
          $2_1 = $10_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $17_1 = $10_1;
          $10_1 = $10_1 + $11_1 | 0;
          $2_1 = ($17_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
          $11_1 = $10_1;
          $10_1 = $10_1 + $16_1 | 0;
          $2_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $11_1 = $10_1;
          $10_1 = $10_1 + $12_1 | 0;
          $11_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
          $2_1 = $11_1 >> 31;
          $15_1 = $11_1 >> 30;
          $17_1 = $2_1;
          $9_1 = $9_1 << 2 | $4_1 >>> 30;
          $4_1 = $4_1 << 2 | $3_1 >>> 30;
          $3_1 = $9_1;
          $11_1 = $11_1 << 2 | $10_1 >>> 30;
          $10_1 = $10_1 << 2 | $7_1 >>> 30;
          $9_1 = $11_1;
          $11_1 = $13_1;
          $12_1 = $18_1;
          $27_1 = $27_1 - 1 | 0;
          if ($27_1) {
            continue;
          }
          break;
        }
        ;
      }
      $8_1 = $24_1 - 1 | 0;
      $2_1 = $8_1 << 3;
      $5_1 = $2_1 + ($6_1 + 160 | 0) | 0;
      HEAP32[$5_1 >> 2] = $10_1;
      HEAP32[$5_1 + 4 >> 2] = $9_1;
      $2_1 = ($6_1 + 200 | 0) + $2_1 | 0;
      HEAP32[$2_1 >> 2] = $4_1;
      HEAP32[$2_1 + 4 >> 2] = $3_1;
      label$9: {
        if (!(HEAP32[$6_1 + 164 >> 2] | HEAP32[$6_1 + 160 >> 2])) {
          if ($38_1) {
            break label$9;
          }
          $11_1 = $8_1 & 3;
          label$11: {
            if ($24_1 - 2 >>> 0 < 3) {
              $7_1 = 0;
              $5_1 = 0;
              $2_1 = 1;
              break label$11;
            }
            $2_1 = $8_1 & -4;
            $27_1 = 0;
            $7_1 = 0;
            $5_1 = 0;
            $12_1 = $30_1;
            while (1) {
              $14_1 = $12_1 - 8 | 0;
              $13_1 = $12_1 - 16 | 0;
              $21_1 = $12_1 - 24 | 0;
              $7_1 = HEAP32[$12_1 >> 2] | (HEAP32[$14_1 >> 2] | (HEAP32[$13_1 >> 2] | (HEAP32[$21_1 >> 2] | $7_1)));
              $5_1 = HEAP32[$12_1 + 4 >> 2] | (HEAP32[$14_1 + 4 >> 2] | (HEAP32[$13_1 + 4 >> 2] | (HEAP32[$21_1 + 4 >> 2] | $5_1)));
              $12_1 = $12_1 + 32 | 0;
              $27_1 = $27_1 + 4 | 0;
              if (($2_1 | 0) != ($27_1 | 0)) {
                continue;
              }
              break;
            }
            ;
            $2_1 = $27_1 + 1 | 0;
          }
          if ($11_1) {
            $12_1 = ($6_1 + 160 | 0) + ($2_1 << 3) | 0;
            while (1) {
              $7_1 = HEAP32[$12_1 >> 2] | $7_1;
              $5_1 = HEAP32[$12_1 + 4 >> 2] | $5_1;
              $12_1 = $12_1 + 8 | 0;
              $11_1 = $11_1 - 1 | 0;
              if ($11_1) {
                continue;
              }
              break;
            }
            ;
          }
          if (!($5_1 | $7_1)) {
            break label$9;
          }
        }
        $2_1 = $9_1 >> 31;
        $5_1 = $2_1 ^ $10_1;
        $7_1 = $2_1 ^ $9_1;
        $2_1 = ($24_1 >> 31) - ($24_1 >>> 0 < 2) >> 31;
        $5_1 = $2_1 | $5_1;
        $7_1 = $2_1 | $7_1;
        $2_1 = $3_1 >> 31;
        if ($5_1 | $2_1 ^ $4_1 | ($7_1 | $2_1 ^ $3_1)) {
          continue;
        }
        $7_1 = ($24_1 << 3) - 16 | 0;
        $2_1 = $7_1 + ($6_1 + 200 | 0) | 0;
        $14_1 = HEAP32[$2_1 + 4 >> 2];
        HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$2_1 + 4 >> 2] = $4_1 << 30 | $14_1;
        $2_1 = ($6_1 + 160 | 0) + $7_1 | 0;
        $5_1 = HEAP32[$2_1 + 4 >> 2];
        HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$2_1 + 4 >> 2] = $10_1 << 30 | $5_1;
        $24_1 = $8_1;
        continue;
      }
      break;
    }
    ;
    $2_1 = $3_1 >> 31;
    $3_1 = $2_1;
    $11_1 = $6_1 + 280 | 0;
    $2_1 = $11_1 + 32 | 0;
    $8_1 = HEAP32[$2_1 >> 2];
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $14_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $4_1 = $2_1;
    $9_1 = HEAP32[$1_1 >> 2];
    $13_1 = $2_1 & $9_1;
    $5_1 = $13_1 + HEAP32[$6_1 + 280 >> 2] | 0;
    $10_1 = HEAP32[$1_1 + 4 >> 2];
    $2_1 = HEAP32[$6_1 + 284 >> 2] + ($10_1 & $2_1) | 0;
    $2_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1 ^ $5_1;
    $25_1 = $5_1 - $3_1 | 0;
    $5_1 = ($2_1 ^ $3_1) - (($3_1 >>> 0 > $5_1 >>> 0) + $3_1 | 0) | 0;
    $7_1 = $0_1;
    $12_1 = $9_1;
    $21_1 = $10_1;
    $0_1 = HEAP32[$1_1 + 32 >> 2];
    $16_1 = $0_1;
    $9_1 = $0_1 & $4_1;
    $0_1 = $9_1 + $8_1 | 0;
    $20_1 = HEAP32[$1_1 + 36 >> 2];
    $2_1 = $14_1 + ($20_1 & $4_1) | 0;
    $2_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $0_1 ^ $3_1;
    $13_1 = $0_1 - $3_1 | 0;
    $22_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
    $0_1 = HEAP32[$1_1 + 24 >> 2];
    $28_1 = $0_1;
    $10_1 = $0_1 & $4_1;
    $9_1 = $11_1 + 24 | 0;
    $0_1 = $10_1 + HEAP32[$9_1 >> 2] | 0;
    $26_1 = HEAP32[$1_1 + 28 >> 2];
    $2_1 = HEAP32[$9_1 + 4 >> 2] + ($26_1 & $4_1) | 0;
    $2_1 = $0_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $0_1 ^ $3_1;
    $14_1 = $0_1 - $3_1 | 0;
    $17_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
    $0_1 = HEAP32[$1_1 + 16 >> 2];
    $24_1 = $0_1;
    $8_1 = $0_1 & $4_1;
    $10_1 = $11_1 + 16 | 0;
    $0_1 = $8_1 + HEAP32[$10_1 >> 2] | 0;
    $19_1 = HEAP32[$1_1 + 20 >> 2];
    $2_1 = HEAP32[$10_1 + 4 >> 2] + ($19_1 & $4_1) | 0;
    $2_1 = $0_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $0_1 ^ $3_1;
    $8_1 = $0_1 - $3_1 | 0;
    $15_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
    $23_1 = HEAP32[$1_1 + 8 >> 2];
    $18_1 = $23_1 & $4_1;
    $11_1 = $11_1 + 8 | 0;
    $0_1 = $18_1 + HEAP32[$11_1 >> 2] | 0;
    $30_1 = HEAP32[$1_1 + 12 >> 2];
    $2_1 = HEAP32[$11_1 + 4 >> 2] + ($30_1 & $4_1) | 0;
    $2_1 = $0_1 >>> 0 < $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $0_1 ^ $3_1;
    $1_1 = $0_1 - $3_1 | 0;
    $2_1 = (($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0) + ($5_1 >> 31) | 0;
    $0_1 = $5_1 >> 30;
    $4_1 = $0_1 + $1_1 | 0;
    $18_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = ($18_1 >> 31) + $15_1 | 0;
    $0_1 = $18_1 >> 30;
    $8_1 = $0_1 + $8_1 | 0;
    $15_1 = $0_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = ($15_1 >> 31) + $17_1 | 0;
    $0_1 = $15_1 >> 30;
    $14_1 = $0_1 + $14_1 | 0;
    $17_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = ($17_1 >> 31) + $22_1 | 0;
    $0_1 = $17_1 >> 30;
    $13_1 = $0_1 + $13_1 | 0;
    $22_1 = $0_1 >>> 0 > $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $22_1 >> 31;
    $2_1 = ($0_1 & $21_1) + ($5_1 & 1073741823) | 0;
    $3_1 = $0_1;
    $1_1 = ($3_1 & $12_1) + $25_1 | 0;
    $0_1 = $1_1 >>> 0 < $25_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 & 1073741823;
    $12_1 = $2_1;
    HEAP32[$7_1 >> 2] = $1_1;
    HEAP32[$7_1 + 4 >> 2] = $2_1;
    $2_1 = ($3_1 & $30_1) + ($18_1 & 1073741823) | 0;
    $5_1 = $4_1;
    $4_1 = ($3_1 & $23_1) + $4_1 | 0;
    $2_1 = ($0_1 >> 31) + ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
    $0_1 = $0_1 >> 30;
    $5_1 = $0_1;
    $0_1 = $0_1 + $4_1 | 0;
    $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $0_1;
    HEAP32[$11_1 >> 2] = $4_1;
    $0_1 = $2_1;
    $2_1 = $2_1 & 1073741823;
    HEAP32[$11_1 + 4 >> 2] = $2_1;
    $5_1 = $7_1 + 8 | 0;
    HEAP32[$5_1 >> 2] = $4_1;
    HEAP32[$5_1 + 4 >> 2] = $2_1;
    $2_1 = ($3_1 & $19_1) + ($15_1 & 1073741823) | 0;
    $4_1 = ($3_1 & $24_1) + $8_1 | 0;
    $2_1 = ($0_1 >> 31) + ($4_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
    $0_1 = $0_1 >> 30;
    $8_1 = $0_1;
    $0_1 = $0_1 + $4_1 | 0;
    $2_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $0_1;
    HEAP32[$10_1 >> 2] = $4_1;
    $0_1 = $2_1;
    $2_1 = $2_1 & 1073741823;
    HEAP32[$10_1 + 4 >> 2] = $2_1;
    $5_1 = $7_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = $4_1;
    HEAP32[$5_1 + 4 >> 2] = $2_1;
    $2_1 = ($3_1 & $26_1) + ($17_1 & 1073741823) | 0;
    $4_1 = ($3_1 & $28_1) + $14_1 | 0;
    $2_1 = ($0_1 >> 31) + ($4_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
    $0_1 = $0_1 >> 30;
    $8_1 = $0_1;
    $0_1 = $0_1 + $4_1 | 0;
    $2_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $0_1;
    HEAP32[$9_1 >> 2] = $4_1;
    $0_1 = $2_1;
    $2_1 = $2_1 & 1073741823;
    HEAP32[$9_1 + 4 >> 2] = $2_1;
    $5_1 = $7_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = $4_1;
    HEAP32[$5_1 + 4 >> 2] = $2_1;
    $5_1 = $7_1 + 32 | 0;
    $2_1 = ($3_1 & $20_1) + $22_1 | 0;
    $3_1 = ($3_1 & $16_1) + $13_1 | 0;
    $2_1 = ($0_1 >> 31) + ($3_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
    $0_1 = $0_1 >> 30;
    $4_1 = $0_1;
    $0_1 = $0_1 + $3_1 | 0;
    $2_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$5_1 >> 2] = $0_1;
    HEAP32[$5_1 + 4 >> 2] = $2_1;
    HEAP32[$6_1 + 280 >> 2] = $1_1;
    HEAP32[$6_1 + 284 >> 2] = $12_1;
    global$0 = $6_1 + 320 | 0;
  }
  function $41($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0;
    $5_1 = global$0 - 288 | 0;
    global$0 = $5_1;
    $66($5_1 + 224 | 0, $1_1, $2_1);
    $3_1 = $5_1 + 208 | 0;
    $22_1 = HEAP32[$5_1 + 256 >> 2];
    $17_1 = HEAP32[$5_1 + 260 >> 2];
    $69($3_1, $22_1, $17_1, 0, 0, 801750719, 1076732275, 0, 0);
    $18_1 = $5_1 + 176 | 0;
    $29_1 = HEAP32[$5_1 + 264 >> 2];
    $24_1 = HEAP32[$5_1 + 268 >> 2];
    $69($18_1, $29_1, $24_1, 0, 0, 801750719, 1076732275, 0, 0);
    $11_1 = $5_1 + 192 | 0;
    $69($11_1, $22_1, $17_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $21_1 = $5_1 + 144 | 0;
    $30_1 = HEAP32[$5_1 + 272 >> 2];
    $26_1 = HEAP32[$5_1 + 276 >> 2];
    $69($21_1, $30_1, $26_1, 0, 0, 801750719, 1076732275, 0, 0);
    $16_1 = $5_1 + 160 | 0;
    $69($16_1, $29_1, $24_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $27_1 = $5_1 + 112 | 0;
    $23_1 = HEAP32[$5_1 + 280 >> 2];
    $28_1 = HEAP32[$5_1 + 284 >> 2];
    $69($27_1, $23_1, $28_1, 0, 0, 801750719, 1076732275, 0, 0);
    $25_1 = $5_1 + 128 | 0;
    $69($25_1, $30_1, $26_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $31_1 = $5_1 + 96 | 0;
    $69($31_1, $23_1, $28_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $4_1 = HEAP32[$5_1 + 224 >> 2];
    $2_1 = HEAP32[$5_1 + 208 >> 2];
    $13_1 = $4_1 + $2_1 | 0;
    $8_1 = HEAP32[$5_1 + 228 >> 2];
    $1_1 = $8_1 + HEAP32[$5_1 + 212 >> 2] | 0;
    $19_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = ($8_1 | 0) == ($19_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $8_1 >>> 0 > $19_1 >>> 0;
    $10_1 = HEAP32[$5_1 + 232 >> 2];
    $1_1 = $3_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $3_1 = $10_1 + $2_1 | 0;
    $12_1 = HEAP32[$5_1 + 236 >> 2];
    $1_1 = $12_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $3_1 + $4_1 | 0;
    $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $4_1 + HEAP32[$5_1 + 180 >> 2] | 0;
    $8_1 = $2_1;
    $2_1 = HEAP32[$5_1 + 176 >> 2];
    $3_1 = $8_1 + $2_1 | 0;
    $6_1 = HEAP32[$5_1 + 192 >> 2];
    $14_1 = $3_1 + $6_1 | 0;
    $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + HEAP32[$5_1 + 196 >> 2] | 0;
    $15_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $9_1 = ($2_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
    $7_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $6_1 = ($4_1 | 0) == ($12_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
    $2_1 = HEAP32[$5_1 + 240 >> 2];
    $12_1 = $2_1;
    $3_1 = $11_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $18_1 + 8 | 0;
    $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $20_1 = HEAP32[$5_1 + 244 >> 2];
    $1_1 = $20_1 + ($4_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) | 0;
    $2_1 = $2_1 + $10_1 | 0;
    $1_1 = $2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $6_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $9_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $9_1 = $2_1;
    $2_1 = HEAP32[$5_1 + 144 >> 2];
    $7_1 = $9_1 + $2_1 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$5_1 + 148 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$5_1 + 160 >> 2];
    $6_1 = $2_1 + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$5_1 + 164 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $17_1 + $2_1 | 0;
    $8_1 = $6_1 + $22_1 | 0;
    $17_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $18_1 = $8_1;
    $11_1 = ($2_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $17_1 >>> 0;
    $10_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
    $6_1 = ($3_1 | 0) == ($20_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $20_1 >>> 0;
    $2_1 = HEAP32[$5_1 + 248 >> 2];
    $20_1 = $2_1;
    $3_1 = $16_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $1_1 = $21_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $22_1 = HEAP32[$5_1 + 252 >> 2];
    $1_1 = $22_1 + ($4_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) | 0;
    $2_1 = $2_1 + $9_1 | 0;
    $1_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $6_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $10_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $11_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $9_1 = $2_1;
    $2_1 = HEAP32[$5_1 + 112 >> 2];
    $7_1 = $9_1 + $2_1 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$5_1 + 116 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$5_1 + 128 >> 2];
    $6_1 = $2_1 + $7_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$5_1 + 132 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $24_1 + $2_1 | 0;
    $24_1 = $5_1 + 80 | 0;
    $16_1 = $24_1;
    $8_1 = $6_1 + $29_1 | 0;
    $21_1 = $8_1 >>> 0 < $29_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $11_1 = $8_1;
    $12_1 = ($2_1 | 0) == ($21_1 | 0) & $8_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $21_1 >>> 0;
    $10_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $6_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
    $8_1 = ($3_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 < $22_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $3_1 = HEAP32[$1_1 >> 2];
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = HEAP32[$5_1 + 96 >> 2];
    $1_1 = $25_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $20_1 = $7_1 + $2_1 | 0;
    $9_1 = HEAP32[$5_1 + 100 >> 2];
    $1_1 = $9_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = ($2_1 >>> 0 > $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $4_1 | 0;
    $2_1 = $3_1 + $20_1 | 0;
    $1_1 = $2_1 >>> 0 < $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $8_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $6_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $10_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = $2_1 + $12_1 | 0;
    $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $26_1 + $2_1 | 0;
    $3_1 = $4_1;
    $4_1 = $3_1 + $30_1 | 0;
    $1_1 = $4_1 >>> 0 < $30_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $25_1 = $4_1;
    $10_1 = $1_1;
    $69($16_1, $4_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
    $26_1 = $5_1 + 48 | 0;
    $6_1 = $26_1;
    $8_1 = ($1_1 | 0) == ($2_1 | 0) & $3_1 >>> 0 > $4_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
    $4_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $9_1 >>> 0;
    $1_1 = $31_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $3_1 = $2_1 + $23_1 | 0;
    $1_1 = $28_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $3_1 + $4_1 | 0;
    $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $8_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $20_1 = $2_1;
    $16_1 = $1_1;
    $69($6_1, $2_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
    $22_1 = $5_1 - -64 | 0;
    $69($22_1, $25_1, $10_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $27_1 = $5_1 + 32 | 0;
    $69($27_1, $2_1, $1_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $2_1 = HEAP32[$5_1 + 80 >> 2];
    $12_1 = $2_1 + $13_1 | 0;
    $1_1 = $19_1 + HEAP32[$5_1 + 84 >> 2] | 0;
    $8_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $4_1 = ($19_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $8_1 >>> 0 < $19_1 >>> 0;
    $1_1 = $24_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $3_1 = $2_1 + $14_1 | 0;
    $1_1 = $15_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $3_1 + $4_1 | 0;
    $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $4_1 + HEAP32[$5_1 + 52 >> 2] | 0;
    $7_1 = $2_1;
    $2_1 = HEAP32[$5_1 + 48 >> 2];
    $3_1 = $7_1 + $2_1 | 0;
    $6_1 = HEAP32[$5_1 + 64 >> 2];
    $13_1 = $3_1 + $6_1 | 0;
    $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + HEAP32[$5_1 + 68 >> 2] | 0;
    $23_1 = ($16_1 | 0) == ($28_1 | 0) & $20_1 >>> 0 < $23_1 >>> 0 | $16_1 >>> 0 < $28_1 >>> 0;
    $31_1 = $23_1 ? 801750719 : 0;
    $24_1 = $23_1 ? 1076732275 : 0;
    $6_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $19_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
    $9_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $7_1 = ($4_1 | 0) == ($15_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
    $1_1 = $26_1 + 8 | 0;
    $3_1 = HEAP32[$1_1 >> 2];
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $1_1 = $22_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $14_1 = $2_1 + $18_1 | 0;
    $1_1 = $17_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = ($2_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $4_1 | 0;
    $2_1 = $3_1 + $14_1 | 0;
    $1_1 = $2_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $9_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $19_1 | 0;
    $3_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $3_1 + $24_1 | 0;
    $15_1 = $2_1;
    $2_1 = $2_1 + $31_1 | 0;
    $1_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $9_1 = $2_1;
    $2_1 = HEAP32[$5_1 + 32 >> 2];
    $7_1 = $9_1 + $2_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$5_1 + 36 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $10_1 + $2_1 | 0;
    $14_1 = $7_1 + $25_1 | 0;
    $10_1 = $14_1 >>> 0 < $25_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $25_1 = ($2_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 > $10_1 >>> 0;
    $19_1 = ($2_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $7_1 = ($3_1 | 0) == ($4_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
    $4_1 = ($3_1 | 0) == ($17_1 | 0) & $15_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $17_1 >>> 0;
    $1_1 = $27_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 >> 2];
    $3_1 = $2_1 + $11_1 | 0;
    $1_1 = $21_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = $3_1 + $4_1 | 0;
    $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $19_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = $2_1;
    $2_1 = $2_1 + $25_1 | 0;
    $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $7_1 = $2_1;
    $2_1 = $23_1 ? 1354194884 : 0;
    $3_1 = $7_1 + $2_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + ($23_1 ? 1162945305 : 0) | 0;
    $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $16_1 + $2_1 | 0;
    $17_1 = $5_1 + 16 | 0;
    $18_1 = $3_1 + $20_1 | 0;
    $9_1 = $18_1 >>> 0 < $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $15_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 > $18_1 >>> 0 | $2_1 >>> 0 > $9_1 >>> 0;
    $2_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $4_1 = $23_1 + (($4_1 | 0) == ($21_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0) | 0;
    $1_1 = $23_1 >>> 0 > $4_1 >>> 0;
    $2_1 = $2_1 + $4_1 | 0;
    $1_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $11_1 = $2_1 + $15_1 | 0;
    $1_1 = $11_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $15_1 = $1_1;
    $69($17_1, $11_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
    $69($5_1, $11_1, $1_1, 0, 0, 1354194884, 1162945305, 0, 0);
    $2_1 = HEAP32[$5_1 + 16 >> 2];
    $16_1 = $2_1;
    $19_1 = HEAP32[$5_1 + 20 >> 2];
    $1_1 = $19_1 + $8_1 | 0;
    $4_1 = $2_1 + $12_1 | 0;
    $8_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $2_1 = HEAP32[$5_1 >> 2];
    $7_1 = $2_1;
    $21_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $21_1 + $6_1 | 0;
    $3_1 = $2_1 + $13_1 | 0;
    $2_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $6_1 = $3_1;
    $3_1 = ($8_1 | 0) == ($19_1 | 0) & $4_1 >>> 0 < $16_1 >>> 0 | $8_1 >>> 0 < $19_1 >>> 0;
    $1_1 = $17_1 + 8 | 0;
    $13_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2];
    $1_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $2_1 | 0;
    $3_1 = $6_1 + $13_1 | 0;
    $12_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $13_1 = $3_1;
    $3_1 = ($2_1 | 0) == ($12_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $12_1 >>> 0;
    $2_1 = ($2_1 | 0) == ($21_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $21_1 >>> 0;
    $1_1 = $5_1 + 8 | 0;
    $6_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
    $1_1 = HEAP32[$1_1 + 4 >> 2];
    $1_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $7_1 = $3_1 + $6_1 | 0;
    $6_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $10_1 + $15_1 | 0;
    $3_1 = $11_1 + $14_1 | 0;
    $2_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + $6_1 | 0;
    $16_1 = ($2_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $15_1 >>> 0;
    $10_1 = $3_1;
    $7_1 = $3_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $10_1;
    $10_1 = $7_1;
    $6_1 = ($2_1 | 0) == ($3_1 | 0) & $1_1 >>> 0 > $7_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
    $2_1 = $16_1 + $6_1 | 0;
    $6_1 = $2_1 >>> 0 < $6_1 >>> 0;
    $1_1 = $9_1 + $6_1 | 0;
    $9_1 = $2_1 + $18_1 | 0;
    $1_1 = $9_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $18_1 = ($3_1 | 0) == -1;
    $7_1 = $1_1;
    $11_1 = $18_1 & $10_1 >>> 0 < 4294967294 | ($3_1 | 0) != -1 | ($1_1 & $9_1) != -1;
    $14_1 = ($12_1 | 0) == -1162945306;
    $1_1 = ($11_1 | ($14_1 & $13_1 >>> 0 < 2940772411 | $12_1 >>> 0 < 3132021990)) ^ -1;
    $11_1 = ($1_1 & (($8_1 | 0) == -1076732276 & $4_1 >>> 0 > 3493216576 | $8_1 >>> 0 > 3218235020) | ($1_1 & ($14_1 & $13_1 >>> 0 > 2940772411 | $12_1 >>> 0 > 3132021990) | ($10_1 | 0) == -1 & $18_1 & ($11_1 ^ -1))) + (($6_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 > $9_1 >>> 0 | $6_1 >>> 0 > $7_1 >>> 0) | 0;
    $2_1 = __wasm_i64_mul($11_1, 0, 801750719, 1076732275);
    $6_1 = $2_1 + $4_1 | 0;
    $1_1 = $8_1 + i64toi32_i32$HIGH_BITS | 0;
    HEAP32[$0_1 >> 2] = $6_1;
    $1_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$0_1 + 4 >> 2] = $1_1;
    $2_1 = $0_1;
    $8_1 = ($1_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
    $0_1 = __wasm_i64_mul($11_1, 0, 1354194884, 1162945305);
    $4_1 = $0_1 + $13_1 | 0;
    $1_1 = $12_1 + i64toi32_i32$HIGH_BITS | 0;
    $1_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $1_1;
    $8_1 = $4_1 + $8_1 | 0;
    $1_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$2_1 + 8 >> 2] = $8_1;
    HEAP32[$2_1 + 12 >> 2] = $1_1;
    $16_1 = ($0_1 | 0) == ($12_1 | 0) & $4_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
    $0_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
    $6_1 = $16_1 + $0_1 | 0;
    $8_1 = $0_1 >>> 0 > $6_1 >>> 0;
    $1_1 = $3_1;
    $4_1 = $10_1 + $11_1 | 0;
    $0_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $0_1 + $8_1 | 0;
    $8_1 = $4_1 + $6_1 | 0;
    $1_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$2_1 + 16 >> 2] = $8_1;
    HEAP32[$2_1 + 20 >> 2] = $1_1;
    $3_1 = ($0_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $3_1 >>> 0;
    $0_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
    $4_1 = $3_1 + $0_1 | 0;
    $1_1 = $7_1 + ($0_1 >>> 0 > $4_1 >>> 0) | 0;
    $0_1 = $4_1 + $9_1 | 0;
    $1_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$2_1 + 24 >> 2] = $0_1;
    HEAP32[$2_1 + 28 >> 2] = $1_1;
    global$0 = $5_1 + 288 | 0;
  }
  function $42($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
    $10_1 = global$0 - 3808 | 0;
    global$0 = $10_1;
    $4_1 = $10_1 + 3696 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $10_1 + 3704 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $10_1 + 3712 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    HEAP32[$10_1 + 3688 >> 2] = 0;
    HEAP32[$10_1 + 3692 >> 2] = 0;
    HEAP32[$10_1 + 3680 >> 2] = 1;
    HEAP32[$10_1 + 3684 >> 2] = 0;
    label$1: {
      if (!(HEAP32[$1_1 + 120 >> 2] ? 0 : HEAP32[$2_1 + 24 >> 2] | (HEAP32[$2_1 + 16 >> 2] | (HEAP32[$2_1 + 8 >> 2] | HEAP32[$2_1 >> 2])) | (HEAP32[$2_1 + 28 >> 2] | (HEAP32[$2_1 + 20 >> 2] | (HEAP32[$2_1 + 12 >> 2] | HEAP32[$2_1 + 4 >> 2]))))) {
        $2_1 = 0;
        $1_1 = 0;
        break label$1;
      }
      $5_1 = global$0 - 128 | 0;
      global$0 = $5_1;
      $7_1 = $5_1 - -64 | 0;
      $66($7_1, $2_1, 690640);
      HEAP32[$5_1 + 56 >> 2] = 0;
      HEAP32[$5_1 + 60 >> 2] = 0;
      $8_1 = ((HEAP32[$5_1 + 108 >> 2] >>> 31 | 0) - 1 >>> 8 ^ -1) & 1;
      $6_1 = HEAP32[$5_1 + 112 >> 2];
      $13_1 = $8_1 + $6_1 | 0;
      $4_1 = HEAP32[$5_1 + 116 >> 2];
      HEAP32[$5_1 + 32 >> 2] = $13_1;
      $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$5_1 + 36 >> 2] = $4_1;
      $8_1 = !$4_1 & $8_1 >>> 0 > $13_1 >>> 0;
      $6_1 = HEAP32[$5_1 + 120 >> 2];
      $13_1 = $8_1 + $6_1 | 0;
      $4_1 = HEAP32[$5_1 + 124 >> 2];
      HEAP32[$5_1 + 40 >> 2] = $13_1;
      $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$5_1 + 44 >> 2] = $4_1;
      HEAP32[$5_1 + 48 >> 2] = !$4_1 & $8_1 >>> 0 > $13_1 >>> 0;
      HEAP32[$5_1 + 52 >> 2] = 0;
      $66($7_1, $2_1, 690672);
      HEAP32[$5_1 + 24 >> 2] = 0;
      HEAP32[$5_1 + 28 >> 2] = 0;
      $8_1 = ((HEAP32[$5_1 + 108 >> 2] >>> 31 | 0) - 1 >>> 8 ^ -1) & 1;
      $6_1 = HEAP32[$5_1 + 112 >> 2];
      $7_1 = $8_1 + $6_1 | 0;
      $4_1 = HEAP32[$5_1 + 116 >> 2];
      HEAP32[$5_1 >> 2] = $7_1;
      $4_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$5_1 + 4 >> 2] = $4_1;
      $6_1 = !$4_1 & $7_1 >>> 0 < $8_1 >>> 0;
      $18_1 = $5_1;
      $5_1 = HEAP32[$5_1 + 120 >> 2];
      $8_1 = $6_1 + $5_1 | 0;
      $4_1 = HEAP32[$18_1 + 124 >> 2];
      HEAP32[$18_1 + 8 >> 2] = $8_1;
      $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$18_1 + 12 >> 2] = $4_1;
      HEAP32[$18_1 + 16 >> 2] = !$4_1 & $6_1 >>> 0 > $8_1 >>> 0;
      HEAP32[$18_1 + 20 >> 2] = 0;
      $4_1 = $18_1 + 32 | 0;
      $41($4_1, $4_1, 690576);
      $41($18_1, $18_1, 690608);
      $8_1 = HEAP32[$18_1 >> 2];
      $6_1 = HEAP32[$18_1 + 32 >> 2];
      $5_1 = $8_1 + $6_1 | 0;
      $7_1 = HEAP32[$18_1 + 4 >> 2];
      $4_1 = $7_1 + HEAP32[$18_1 + 36 >> 2] | 0;
      $19_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $5_1;
      $13_1 = ($7_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $7_1 >>> 0 > $19_1 >>> 0;
      $5_1 = HEAP32[$18_1 + 40 >> 2];
      $8_1 = $13_1 + $5_1 | 0;
      $4_1 = HEAP32[$18_1 + 44 >> 2];
      $7_1 = HEAP32[$18_1 + 8 >> 2];
      $6_1 = $7_1 + $8_1 | 0;
      $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $5_1 + HEAP32[$18_1 + 12 >> 2] | 0;
      $9_1 = !$5_1 & $8_1 >>> 0 < $13_1 >>> 0;
      $17_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = $6_1;
      $5_1 = ($5_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 > $6_1 >>> 0 | $5_1 >>> 0 > $17_1 >>> 0;
      $6_1 = $9_1 + $5_1 | 0;
      $9_1 = $5_1 >>> 0 > $6_1 >>> 0;
      $4_1 = $9_1 + HEAP32[$18_1 + 52 >> 2] | 0;
      $5_1 = HEAP32[$18_1 + 48 >> 2];
      $13_1 = $5_1 + $6_1 | 0;
      $7_1 = HEAP32[$18_1 + 16 >> 2];
      $8_1 = $13_1 + $7_1 | 0;
      $5_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $5_1 + HEAP32[$18_1 + 20 >> 2] | 0;
      $6_1 = ($5_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 > $13_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
      $7_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $20_1 = $8_1;
      $5_1 = ($5_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 > $8_1 >>> 0 | $5_1 >>> 0 > $7_1 >>> 0;
      $6_1 = $6_1 + $5_1 | 0;
      $13_1 = $5_1 >>> 0 > $6_1 >>> 0;
      $4_1 = $13_1 + HEAP32[$18_1 + 60 >> 2] | 0;
      $5_1 = HEAP32[$18_1 + 56 >> 2];
      $8_1 = $5_1 + $6_1 | 0;
      $9_1 = HEAP32[$18_1 + 24 >> 2];
      $14_1 = $8_1 + $9_1 | 0;
      $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $5_1 + HEAP32[$18_1 + 28 >> 2] | 0;
      $15_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = (($5_1 | 0) == ($13_1 | 0) & $6_1 >>> 0 > $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0) + (($5_1 | 0) == ($15_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0) | 0;
      $6_1 = ($7_1 | 0) == -1;
      $5_1 = $6_1 & $20_1 >>> 0 < 4294967294 | ($7_1 | 0) != -1 | ($14_1 & $15_1) != -1;
      $8_1 = ($17_1 | 0) == -1162945306;
      $4_1 = ($5_1 | ($8_1 & $16_1 >>> 0 < 2940772411 | $17_1 >>> 0 < 3132021990)) ^ -1;
      $23_1 = $9_1 + ($4_1 & (($19_1 | 0) == -1076732276 & $12_1 >>> 0 > 3493216576 | $19_1 >>> 0 > 3218235020) | ($4_1 & ($8_1 & $16_1 >>> 0 > 2940772411 | $17_1 >>> 0 > 3132021990) | ($20_1 | 0) == -1 & $6_1 & ($5_1 ^ -1))) | 0;
      $6_1 = __wasm_i64_mul($23_1, 0, 801750719, 1076732275);
      $5_1 = $6_1 + $12_1 | 0;
      $4_1 = $19_1 + i64toi32_i32$HIGH_BITS | 0;
      $9_1 = $10_1 + 3720 | 0;
      HEAP32[$9_1 >> 2] = $5_1;
      $13_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 4 >> 2] = $13_1;
      $8_1 = $9_1;
      $6_1 = __wasm_i64_mul($23_1, 0, 1354194884, 1162945305);
      $11_1 = $6_1 + $16_1 | 0;
      $4_1 = $17_1 + i64toi32_i32$HIGH_BITS | 0;
      $5_1 = ($13_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $13_1 >>> 0 < $19_1 >>> 0;
      $9_1 = $11_1 + $5_1 | 0;
      $4_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $4_1;
      HEAP32[$8_1 + 8 >> 2] = $9_1;
      $12_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 12 >> 2] = $12_1;
      $4_1 = $7_1;
      $13_1 = $20_1 + $23_1 | 0;
      $5_1 = $13_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = ($6_1 | 0) == ($17_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $6_1 >>> 0 < $17_1 >>> 0;
      $6_1 = ($6_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $6_1 >>> 0 > $12_1 >>> 0;
      $9_1 = $4_1 + $6_1 | 0;
      $4_1 = ($6_1 >>> 0 > $9_1 >>> 0) + $5_1 | 0;
      $6_1 = $9_1 + $13_1 | 0;
      $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 16 >> 2] = $6_1;
      HEAP32[$8_1 + 20 >> 2] = $4_1;
      $16_1 = $8_1;
      $7_1 = ($5_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $20_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
      $5_1 = ($4_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $6_1 = $7_1 + $5_1 | 0;
      $4_1 = $15_1 + ($5_1 >>> 0 > $6_1 >>> 0) | 0;
      $5_1 = $6_1 + $14_1 | 0;
      $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 24 >> 2] = $5_1;
      HEAP32[$8_1 + 28 >> 2] = $4_1;
      $8_1 = $10_1 + 2560 | 0;
      $41($8_1, $16_1, 690704);
      $24_1 = HEAP32[$8_1 + 24 >> 2];
      $14_1 = HEAP32[$8_1 + 16 >> 2];
      $13_1 = HEAP32[$8_1 + 8 >> 2];
      $5_1 = HEAP32[$8_1 >> 2];
      $12_1 = HEAP32[$8_1 + 28 >> 2];
      $9_1 = HEAP32[$8_1 + 20 >> 2];
      $11_1 = HEAP32[$8_1 + 12 >> 2];
      $7_1 = HEAP32[$8_1 + 4 >> 2];
      $4_1 = $24_1 | ($14_1 | ($13_1 | $5_1)) | ($12_1 | ($9_1 | ($11_1 | $7_1))) ? -1 : 0;
      $20_1 = $5_1 ^ -1;
      $6_1 = $20_1 - 801750718 | 0;
      $23_1 = $4_1 & $6_1;
      HEAP32[$8_1 >> 2] = $23_1;
      $5_1 = $4_1;
      $7_1 = $7_1 ^ -1;
      $4_1 = $7_1 - (($20_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
      $15_1 = $5_1 & $4_1;
      HEAP32[$8_1 + 4 >> 2] = $15_1;
      $6_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
      $13_1 = $13_1 ^ -1;
      $19_1 = $6_1 + $13_1 | 0;
      $20_1 = $11_1 ^ -1;
      $4_1 = $20_1;
      $7_1 = $19_1 - 1354194885 | 0;
      $17_1 = $7_1 & $5_1;
      HEAP32[$8_1 + 8 >> 2] = $17_1;
      $4_1 = $6_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $4_1 - (($19_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
      $6_1 = $11_1 & $5_1;
      HEAP32[$8_1 + 12 >> 2] = $6_1;
      $7_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $13_1 = $7_1 + (($4_1 | 0) == ($20_1 | 0) & $13_1 >>> 0 > $19_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0) | 0;
      $20_1 = $14_1 ^ -1;
      $30_1 = $20_1 + $13_1 | 0;
      $14_1 = $9_1 ^ -1;
      $4_1 = $14_1 + ($7_1 >>> 0 > $13_1 >>> 0) | 0;
      $4_1 = $20_1 >>> 0 > $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $4_1 - ($30_1 >>> 0 < 2) | 0;
      $13_1 = $11_1 & $5_1;
      $19_1 = $13_1;
      $7_1 = $30_1 - 2 | 0;
      $9_1 = $7_1 & $5_1;
      HEAP32[$8_1 + 16 >> 2] = $9_1;
      HEAP32[$8_1 + 20 >> 2] = $13_1;
      $7_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
      $13_1 = $7_1 + (($4_1 | 0) == ($14_1 | 0) & $20_1 >>> 0 > $30_1 >>> 0 | $4_1 >>> 0 < $14_1 >>> 0) | 0;
      $4_1 = $7_1 >>> 0 > $13_1 >>> 0;
      $7_1 = $13_1 - $24_1 | 0;
      $30_1 = $7_1 - 2 & $5_1;
      HEAP32[$8_1 + 24 >> 2] = $30_1;
      $11_1 = ($4_1 - (($13_1 >>> 0 < $24_1 >>> 0) + $12_1 | 0) | 0) - ($7_1 >>> 0 < 2) & $5_1;
      HEAP32[$8_1 + 28 >> 2] = $11_1;
      $5_1 = HEAP32[$2_1 >> 2];
      $7_1 = $5_1;
      $13_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $13_1 + $15_1 | 0;
      $5_1 = $5_1 + $23_1 | 0;
      $4_1 = $5_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $15_1 = $5_1;
      HEAP32[$8_1 >> 2] = $5_1;
      $20_1 = $4_1;
      HEAP32[$8_1 + 4 >> 2] = $4_1;
      $4_1 = $6_1;
      $12_1 = ($13_1 | 0) == ($20_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $13_1 >>> 0 > $20_1 >>> 0;
      $5_1 = $12_1 + $17_1 | 0;
      $6_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + HEAP32[$2_1 + 12 >> 2] | 0;
      $7_1 = $5_1;
      $13_1 = HEAP32[$2_1 + 8 >> 2];
      $5_1 = $5_1 + $13_1 | 0;
      $14_1 = $5_1;
      HEAP32[$8_1 + 8 >> 2] = $5_1;
      $17_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 12 >> 2] = $17_1;
      $25_1 = HEAP32[$2_1 + 16 >> 2];
      $9_1 = $25_1 + $9_1 | 0;
      $24_1 = HEAP32[$2_1 + 20 >> 2];
      $4_1 = $24_1 + $19_1 | 0;
      $5_1 = $9_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = !$6_1 & $7_1 >>> 0 < $12_1 >>> 0;
      $6_1 = ($6_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 > $14_1 >>> 0 | $6_1 >>> 0 > $17_1 >>> 0;
      $7_1 = $4_1 + $6_1 | 0;
      $4_1 = ($6_1 >>> 0 > $7_1 >>> 0) + $5_1 | 0;
      $6_1 = $7_1 + $9_1 | 0;
      $4_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $19_1 = $6_1;
      HEAP32[$8_1 + 16 >> 2] = $6_1;
      $7_1 = $4_1;
      HEAP32[$8_1 + 20 >> 2] = $4_1;
      $6_1 = HEAP32[$2_1 + 24 >> 2];
      $12_1 = $6_1;
      $23_1 = HEAP32[$2_1 + 28 >> 2];
      $4_1 = $23_1 + $11_1 | 0;
      $6_1 = $6_1 + $30_1 | 0;
      $2_1 = $6_1 >>> 0 < $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $6_1;
      $4_1 = ($5_1 | 0) == ($24_1 | 0) & $9_1 >>> 0 < $25_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
      $5_1 = ($5_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 > $7_1 >>> 0;
      $9_1 = $4_1 + $5_1 | 0;
      $4_1 = ($5_1 >>> 0 > $9_1 >>> 0) + $2_1 | 0;
      $11_1 = $6_1 + $9_1 | 0;
      $4_1 = $11_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $8_1;
      $9_1 = $4_1;
      $13_1 = (($2_1 | 0) == ($23_1 | 0) & $12_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 < $23_1 >>> 0) + (($2_1 | 0) == ($4_1 | 0) & $11_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0) | 0;
      $5_1 = ($7_1 | 0) == -1;
      $4_1 = $5_1 & $19_1 >>> 0 < 4294967294 | ($7_1 | 0) != -1 | ($4_1 & $11_1) != -1;
      $8_1 = ($17_1 | 0) == -1162945306;
      $2_1 = ($4_1 | ($8_1 & $14_1 >>> 0 < 2940772411 | $17_1 >>> 0 < 3132021990)) ^ -1;
      $23_1 = $13_1 + ($2_1 & (($20_1 | 0) == -1076732276 & $15_1 >>> 0 > 3493216576 | $20_1 >>> 0 > 3218235020) | ($2_1 & ($8_1 & $14_1 >>> 0 > 2940772411 | $17_1 >>> 0 > 3132021990) | ($19_1 | 0) == -1 & $5_1 & ($4_1 ^ -1))) | 0;
      $5_1 = __wasm_i64_mul($23_1, 0, 801750719, 1076732275);
      $2_1 = $5_1 + $15_1 | 0;
      $4_1 = $20_1 + i64toi32_i32$HIGH_BITS | 0;
      HEAP32[$6_1 >> 2] = $2_1;
      $8_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$6_1 + 4 >> 2] = $8_1;
      $5_1 = __wasm_i64_mul($23_1, 0, 1354194884, 1162945305);
      $12_1 = $5_1 + $14_1 | 0;
      $4_1 = $17_1 + i64toi32_i32$HIGH_BITS | 0;
      $2_1 = ($8_1 | 0) == ($20_1 | 0) & $2_1 >>> 0 < $15_1 >>> 0 | $8_1 >>> 0 < $20_1 >>> 0;
      $13_1 = $12_1 + $2_1 | 0;
      $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $4_1;
      HEAP32[$6_1 + 8 >> 2] = $13_1;
      $15_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$6_1 + 12 >> 2] = $15_1;
      $4_1 = $7_1;
      $8_1 = $19_1 + $23_1 | 0;
      $2_1 = $8_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = ($5_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $5_1 >>> 0 < $17_1 >>> 0;
      $5_1 = ($5_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 > $13_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
      $13_1 = $4_1 + $5_1 | 0;
      $4_1 = ($5_1 >>> 0 > $13_1 >>> 0) + $2_1 | 0;
      $5_1 = $8_1 + $13_1 | 0;
      $4_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$6_1 + 16 >> 2] = $5_1;
      HEAP32[$6_1 + 20 >> 2] = $4_1;
      $7_1 = ($2_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
      $2_1 = ($2_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
      $5_1 = $7_1 + $2_1 | 0;
      $4_1 = $9_1 + ($2_1 >>> 0 > $5_1 >>> 0) | 0;
      $2_1 = $5_1 + $11_1 | 0;
      $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$6_1 + 24 >> 2] = $2_1;
      HEAP32[$6_1 + 28 >> 2] = $4_1;
      global$0 = $18_1 + 128 | 0;
      wasm2js_i32$0 = $10_1, wasm2js_i32$1 = $62($10_1 + 496 | 0, $6_1, 5), HEAP32[wasm2js_i32$0 + 1528 >> 2] = wasm2js_i32$1;
      $62_1 = $62($10_1 + 1012 | 0, $16_1, 5);
      HEAP32[$10_1 + 1532 >> 2] = $62_1;
      $52_1 = HEAP32[$10_1 + 1528 >> 2];
      $39_1 = $10_1 + 3088 | 0;
      $70($39_1, $1_1, 128);
      $2_1 = $10_1 + 1536 | 0;
      $46_1 = $10_1 + 2240 | 0;
      $51_1 = $10_1 + 3680 | 0;
      $12_1 = 0;
      $15_1 = 0;
      $11_1 = 0;
      $7_1 = 0;
      $17_1 = global$0 - 720 | 0;
      global$0 = $17_1;
      label$4: {
        if (HEAP32[$39_1 + 120 >> 2]) {
          HEAP32[$17_1 + 672 >> 2] = 1;
          $68($17_1 + 552 | 0, 120);
          $8_1 = 0;
          $6_1 = 0;
          break label$4;
        }
        $55($17_1 + 552 | 0, $39_1);
        $1_1 = $17_1 + 664 | 0;
        $11_1 = HEAP32[$1_1 >> 2];
        $7_1 = HEAP32[$1_1 + 4 >> 2];
        $1_1 = $17_1 + 648 | 0;
        $22_1 = HEAP32[$1_1 >> 2];
        $21_1 = HEAP32[$1_1 + 4 >> 2];
        $1_1 = $17_1 + 640 | 0;
        $27_1 = HEAP32[$1_1 >> 2];
        $26_1 = HEAP32[$1_1 + 4 >> 2];
        $12_1 = HEAP32[$17_1 + 632 >> 2];
        $15_1 = HEAP32[$17_1 + 636 >> 2];
        $1_1 = $17_1 + 656 | 0;
        $8_1 = HEAP32[$1_1 >> 2];
        $6_1 = HEAP32[$1_1 + 4 >> 2];
      }
      $32_1 = $17_1 + 552 | 0;
      $5_1 = $32_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $45_1 = $17_1 + 336 | 0;
      $1_1 = $45_1 + 8 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 16 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 + 16 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 24 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 32 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 + 32 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 48 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 + 48 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 56 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 + 56 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 - -64 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 - -64 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 72 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $45_1 + 72 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      HEAP32[$17_1 + 416 >> 2] = 0;
      $1_1 = HEAP32[$17_1 + 556 >> 2];
      HEAP32[$17_1 + 336 >> 2] = HEAP32[$17_1 + 552 >> 2];
      HEAP32[$17_1 + 340 >> 2] = $1_1;
      $1_1 = HEAP32[$17_1 + 596 >> 2];
      HEAP32[$17_1 + 376 >> 2] = HEAP32[$17_1 + 592 >> 2];
      HEAP32[$17_1 + 380 >> 2] = $1_1;
      $29_1 = $17_1 + 304 | 0;
      $31_1 = $12_1 << 1;
      $35_1 = $15_1 << 1 | $12_1 >>> 31;
      $69($29_1, $8_1, $6_1, 0, 0, $31_1, $35_1, 0, 0);
      $28_1 = $17_1 + 224 | 0;
      $5_1 = $22_1;
      $1_1 = $21_1;
      $13_1 = $27_1 << 1;
      $9_1 = $26_1 << 1 | $27_1 >>> 31;
      $69($28_1, $5_1, $1_1, 0, 0, $13_1, $9_1, 0, 0);
      $14_1 = $17_1 + 160 | 0;
      $4_1 = $7_1;
      $69($14_1, $11_1, $4_1, 0, 0, $11_1, $4_1, 0, 0);
      $20_1 = $17_1 + 144 | 0;
      $69($20_1, HEAP32[$17_1 + 160 >> 2], HEAP32[$17_1 + 164 >> 2], 0, 0, 15632, 16, 0, 0);
      $7_1 = $11_1;
      $4_1 = $4_1 << 1 | $7_1 >>> 31;
      $42_1 = $17_1 + 112 | 0;
      $43_1 = $7_1 << 1;
      $30_1 = $4_1;
      $69($42_1, $43_1, $4_1, 0, 0, $12_1, $15_1, 0, 0);
      $44_1 = $17_1 + 272 | 0;
      $69($44_1, $8_1, $6_1, 0, 0, $13_1, $9_1, 0, 0);
      $36_1 = $17_1 + 208 | 0;
      $69($36_1, $5_1, $1_1, 0, 0, $5_1, $1_1, 0, 0);
      $23_1 = $17_1 + 128 | 0;
      $4_1 = $14_1 + 8 | 0;
      $69($23_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $50_1 = $17_1 + 320 | 0;
      $69($50_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
      $47_1 = $17_1 + 96 | 0;
      $69($47_1, $43_1, $30_1, 0, 0, $27_1, $26_1, 0, 0);
      $19_1 = $1_1;
      $25_1 = $5_1;
      $4_1 = $1_1 << 1 | $5_1 >>> 31;
      $48_1 = $17_1 + 176 | 0;
      $22_1 = $8_1;
      $21_1 = $6_1;
      $69($48_1, $8_1, $6_1, 0, 0, $5_1 << 1, $4_1, 0, 0);
      $9_1 = HEAP32[$17_1 + 304 >> 2];
      $5_1 = HEAP32[$17_1 + 224 >> 2];
      $1_1 = $9_1 + $5_1 | 0;
      $33_1 = HEAP32[$17_1 + 308 >> 2];
      $4_1 = $33_1 + HEAP32[$17_1 + 228 >> 2] | 0;
      $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = HEAP32[$17_1 + 144 >> 2];
      $24_1 = $5_1 + $1_1 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$17_1 + 148 >> 2] | 0;
      $13_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $40_1 = HEAP32[$17_1 + 272 >> 2];
      $5_1 = HEAP32[$17_1 + 208 >> 2];
      $14_1 = $40_1 + $5_1 | 0;
      $41_1 = HEAP32[$17_1 + 276 >> 2];
      $4_1 = $41_1 + HEAP32[$17_1 + 212 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = HEAP32[$17_1 + 112 >> 2];
      $16_1 = $5_1 + $14_1 | 0;
      $7_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$17_1 + 116 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = HEAP32[$17_1 + 128 >> 2];
      $12_1 = $5_1 + $16_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$17_1 + 132 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $18_1 = ($6_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 > $24_1 >>> 0 | $6_1 >>> 0 > $13_1 >>> 0;
      $4_1 = $20_1 + 8 | 0;
      $11_1 = HEAP32[$4_1 >> 2];
      $15_1 = HEAP32[$4_1 + 4 >> 2];
      $9_1 = ($6_1 | 0) == ($33_1 | 0) & $1_1 >>> 0 < $9_1 >>> 0 | $6_1 >>> 0 < $33_1 >>> 0;
      $4_1 = $28_1 + 8 | 0;
      $6_1 = HEAP32[$4_1 >> 2];
      $1_1 = $29_1 + 8 | 0;
      $20_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $9_1 + $20_1 | 0;
      $4_1 = ($1_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
      $6_1 = $1_1;
      $1_1 = $1_1 + $11_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $1_1 + $18_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $20_1 = $13_1;
      $13_1 = $1_1 << 12 | $13_1 >>> 20;
      $15_1 = $13_1 + $12_1 | 0;
      $6_1 = $4_1;
      $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
      $13_1 = $15_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $49_1 = $17_1 + 80 | 0;
      $33_1 = $49_1;
      $37_1 = HEAP32[$17_1 + 96 >> 2];
      $1_1 = HEAP32[$17_1 + 176 >> 2];
      $11_1 = $37_1 + $1_1 | 0;
      $34_1 = HEAP32[$17_1 + 100 >> 2];
      $4_1 = $34_1 + HEAP32[$17_1 + 180 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $29_1 = ($5_1 | 0) == ($13_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
      $28_1 = ($5_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $4_1 = $23_1 + 8 | 0;
      $23_1 = HEAP32[$4_1 >> 2];
      $18_1 = HEAP32[$4_1 + 4 >> 2];
      $16_1 = ($7_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
      $4_1 = $42_1 + 8 | 0;
      $12_1 = HEAP32[$4_1 >> 2];
      $9_1 = HEAP32[$4_1 + 4 >> 2];
      $7_1 = ($7_1 | 0) == ($41_1 | 0) & $14_1 >>> 0 < $40_1 >>> 0 | $7_1 >>> 0 < $41_1 >>> 0;
      $8_1 = $36_1 + 8 | 0;
      $5_1 = HEAP32[$8_1 >> 2];
      $4_1 = $44_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $7_1 + $14_1 | 0;
      $4_1 = ($5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
      $7_1 = $5_1;
      $5_1 = $5_1 + $12_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $5_1;
      $5_1 = $5_1 + $16_1 | 0;
      $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $18_1 | 0;
      $7_1 = $5_1;
      $5_1 = $5_1 + $23_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $5_1 + $28_1 | 0;
      $4_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $5_1 = $6_1 + $8_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $5_1;
      $5_1 = $5_1 + $29_1 | 0;
      $6_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $6_1 << 12 | $5_1 >>> 20;
      $4_1 = $5_1 << 12;
      $5_1 = $13_1;
      $13_1 = $4_1 | $5_1 >>> 20;
      $7_1 = $13_1 + $11_1 | 0;
      $4_1 = $1_1 + $8_1 | 0;
      $13_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $7_1;
      $4_1 = $13_1 << 4 | $8_1 >>> 28;
      $9_1 = $8_1 << 4 & -16;
      $7_1 = $4_1 & 16777215;
      $18_1 = $5_1;
      $69($33_1, $9_1 | $5_1 >>> 16 & 15, $7_1, 0, 0, 977, 1, 0, 0);
      $9_1 = $17_1;
      $28_1 = HEAP32[$9_1 + 80 >> 2];
      $5_1 = HEAP32[$9_1 + 320 >> 2];
      $12_1 = $28_1 + $5_1 | 0;
      $38_1 = HEAP32[$9_1 + 84 >> 2];
      $4_1 = $38_1 + HEAP32[$9_1 + 324 >> 2] | 0;
      HEAP32[$9_1 + 424 >> 2] = $12_1;
      $7_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 428 >> 2] = $7_1 & 1048575;
      $42_1 = $9_1 + 256 | 0;
      $69($42_1, $27_1, $26_1, 0, 0, $31_1, $35_1, 0, 0);
      $44_1 = $9_1 - -64 | 0;
      $69($44_1, $43_1, $30_1, 0, 0, $25_1, $19_1, 0, 0);
      $36_1 = $9_1 + 288 | 0;
      $69($36_1, $22_1, $21_1, 0, 0, $22_1, $21_1, 0, 0);
      $40_1 = $9_1 + 48 | 0;
      $17_1 = $40_1;
      $33_1 = HEAP32[$9_1 + 64 >> 2];
      $5_1 = HEAP32[$9_1 + 288 >> 2];
      $23_1 = $33_1 + $5_1 | 0;
      $41_1 = HEAP32[$9_1 + 68 >> 2];
      $4_1 = $41_1 + HEAP32[$9_1 + 292 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = $23_1;
      $16_1 = ($1_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $13_1 >>> 0;
      $11_1 = ($1_1 | 0) == ($34_1 | 0) & $11_1 >>> 0 < $37_1 >>> 0 | $1_1 >>> 0 < $34_1 >>> 0;
      $4_1 = $48_1 + 8 | 0;
      $8_1 = HEAP32[$4_1 >> 2];
      $1_1 = $47_1 + 8 | 0;
      $29_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $8_1 >>> 0 > $29_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $11_1 + $29_1 | 0;
      $4_1 = $8_1 >>> 0 < $29_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $1_1 = $6_1 + $8_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1 << 12 | $13_1 >>> 20;
      $14_1 = $6_1 + $14_1 | 0;
      $8_1 = $4_1;
      $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
      $11_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($17_1, $14_1, $11_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $29_1 = HEAP32[$9_1 + 48 >> 2];
      $1_1 = HEAP32[$9_1 + 256 >> 2];
      $17_1 = $29_1 + $1_1 | 0;
      $37_1 = HEAP32[$9_1 + 52 >> 2];
      $4_1 = $37_1 + HEAP32[$9_1 + 260 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = $17_1;
      $12_1 = ($7_1 | 0) == ($38_1 | 0) & $12_1 >>> 0 < $28_1 >>> 0 | $7_1 >>> 0 < $38_1 >>> 0;
      $13_1 = $50_1 + 8 | 0;
      $6_1 = HEAP32[$13_1 >> 2];
      $4_1 = $49_1 + 8 | 0;
      $28_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$13_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 > $28_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $12_1 + $28_1 | 0;
      $4_1 = $6_1 >>> 0 < $28_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $6_1 << 12 | $7_1 >>> 20;
      $16_1 = $7_1 + $16_1 | 0;
      $13_1 = $4_1;
      $4_1 = $1_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
      HEAP32[$9_1 + 432 >> 2] = $16_1;
      $12_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 436 >> 2] = $12_1 & 1048575;
      $28_1 = $9_1 + 192 | 0;
      $69($28_1, $25_1, $19_1, 0, 0, $31_1, $35_1, 0, 0);
      $31_1 = $9_1 + 240 | 0;
      $69($31_1, $27_1, $26_1, 0, 0, $27_1, $26_1, 0, 0);
      $27_1 = $9_1 + 32 | 0;
      $69($27_1, $43_1, $30_1, 0, 0, $22_1, $21_1, 0, 0);
      $25_1 = $9_1 + 16 | 0;
      $19_1 = $25_1;
      $14_1 = ($5_1 | 0) == ($11_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
      $7_1 = ($5_1 | 0) == ($41_1 | 0) & $23_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $41_1 >>> 0;
      $6_1 = $36_1 + 8 | 0;
      $5_1 = HEAP32[$6_1 >> 2];
      $4_1 = $44_1 + 8 | 0;
      $21_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $7_1 + $21_1 | 0;
      $4_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $8_1 >>> 20 | 0;
      $5_1 = $6_1 + $8_1 | 0;
      $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $5_1;
      $5_1 = $5_1 + $14_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $23_1 = $5_1 << 12 | $11_1 >>> 20;
      $6_1 = HEAP32[$9_1 + 32 >> 2];
      $11_1 = $23_1 + $6_1 | 0;
      $7_1 = $4_1;
      $35_1 = $4_1 << 12 | $5_1 >>> 20;
      $4_1 = $35_1 + HEAP32[$9_1 + 36 >> 2] | 0;
      $21_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($19_1, $11_1, $21_1, 0, 0, 15632, 16, 0, 0);
      $26_1 = HEAP32[$9_1 + 192 >> 2];
      $5_1 = HEAP32[$9_1 + 240 >> 2];
      $19_1 = $26_1 + $5_1 | 0;
      $30_1 = HEAP32[$9_1 + 196 >> 2];
      $4_1 = $30_1 + HEAP32[$9_1 + 244 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = HEAP32[$9_1 + 16 >> 2];
      $14_1 = $5_1 + $19_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$9_1 + 20 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $22_1 = ($1_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 > $12_1 >>> 0;
      $16_1 = ($1_1 | 0) == ($37_1 | 0) & $17_1 >>> 0 < $29_1 >>> 0 | $1_1 >>> 0 < $37_1 >>> 0;
      $4_1 = $42_1 + 8 | 0;
      $6_1 = HEAP32[$4_1 >> 2];
      $1_1 = $40_1 + 8 | 0;
      $17_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $16_1 + $17_1 | 0;
      $4_1 = $6_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $13_1 >>> 20 | 0;
      $1_1 = $6_1 + $13_1 | 0;
      $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $1_1 << 12 | $12_1 >>> 20;
      $12_1 = $13_1 + $14_1 | 0;
      $6_1 = $4_1;
      $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
      HEAP32[$9_1 + 440 >> 2] = $12_1;
      $13_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 444 >> 2] = $13_1 & 1048575;
      $1_1 = $9_1;
      $16_1 = ($21_1 | 0) == ($35_1 | 0) & $11_1 >>> 0 < $23_1 >>> 0 | $21_1 >>> 0 < $35_1 >>> 0;
      $4_1 = $27_1 + 8 | 0;
      $11_1 = HEAP32[$4_1 >> 2];
      $4_1 = HEAP32[$4_1 + 4 >> 2];
      $7_1 = $7_1 >>> 20 | 0;
      $9_1 = $7_1;
      $7_1 = $7_1 + $11_1 | 0;
      $4_1 = $9_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = $7_1;
      $7_1 = $7_1 + $16_1 | 0;
      $4_1 = $9_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($1_1, $7_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
      $7_1 = $1_1;
      $21_1 = HEAP32[$1_1 >> 2];
      $1_1 = $24_1 & -2;
      $9_1 = $21_1 + $1_1 | 0;
      $22_1 = HEAP32[$7_1 + 4 >> 2];
      $4_1 = $22_1 + ($20_1 & 1048575) | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $20_1 = ($5_1 | 0) == ($13_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
      $14_1 = ($5_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
      $4_1 = $25_1 + 8 | 0;
      $16_1 = HEAP32[$4_1 >> 2];
      $11_1 = HEAP32[$4_1 + 4 >> 2];
      $12_1 = ($8_1 | 0) == ($30_1 | 0) & $19_1 >>> 0 < $26_1 >>> 0 | $8_1 >>> 0 < $30_1 >>> 0;
      $8_1 = $31_1 + 8 | 0;
      $5_1 = HEAP32[$8_1 >> 2];
      $4_1 = $28_1 + 8 | 0;
      $19_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $12_1 + $19_1 | 0;
      $4_1 = ($5_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $11_1 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $16_1 | 0;
      $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $5_1 + $14_1 | 0;
      $4_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $5_1 = $6_1 + $8_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $5_1;
      $5_1 = $5_1 + $20_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = $5_1 << 12 | $13_1 >>> 20;
      $8_1 = $13_1 + $9_1 | 0;
      $6_1 = $4_1;
      $4_1 = $1_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
      HEAP32[$7_1 + 448 >> 2] = $8_1;
      $5_1 = $8_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$7_1 + 452 >> 2] = $5_1 & 1048575;
      $11_1 = $18_1 & 65535;
      $12_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
      $13_1 = ($1_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $21_1 >>> 0 | $1_1 >>> 0 < $22_1 >>> 0;
      $1_1 = $7_1 + 8 | 0;
      $8_1 = $13_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $8_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $1_1 = $6_1 + $8_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1 << 12 | $5_1 >>> 20;
      $6_1 = $5_1 + $15_1 | 0;
      $4_1 = $11_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
      HEAP32[$7_1 + 456 >> 2] = $6_1;
      HEAP32[$7_1 + 460 >> 2] = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $7_1 + 680 | 0;
      $19_1 = $7_1 + 424 | 0;
      $13_1 = $32_1 + 80 | 0;
      $34($1_1, $19_1, $13_1);
      $34($2_1, $39_1, $19_1);
      $34($2_1 + 40 | 0, $39_1 + 40 | 0, $1_1);
      $5_1 = HEAP32[$39_1 + 120 >> 2];
      HEAP32[$2_1 + 80 >> 2] = $5_1;
      $4_1 = $2_1 + 8 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $20_1 = $19_1 + 8 | 0;
      HEAP32[$20_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$20_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 + 16 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $18_1 = $19_1 + 16 | 0;
      HEAP32[$18_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$18_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 + 24 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $14_1 = $19_1 + 24 | 0;
      HEAP32[$14_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$14_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 + 32 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $16_1 = $19_1 + 32 | 0;
      HEAP32[$16_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$16_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 + 48 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $11_1 = $19_1 + 48 | 0;
      HEAP32[$11_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$11_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 + 56 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $12_1 = $19_1 + 56 | 0;
      HEAP32[$12_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$12_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 - -64 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $15_1 = $19_1 - -64 | 0;
      HEAP32[$15_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$15_1 + 4 >> 2] = $1_1;
      $4_1 = $2_1 + 72 | 0;
      $1_1 = HEAP32[$4_1 + 4 >> 2];
      $9_1 = $19_1 + 72 | 0;
      HEAP32[$9_1 >> 2] = HEAP32[$4_1 >> 2];
      HEAP32[$9_1 + 4 >> 2] = $1_1;
      HEAP32[$7_1 + 544 >> 2] = $5_1;
      $1_1 = HEAP32[$2_1 + 4 >> 2];
      HEAP32[$7_1 + 424 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$7_1 + 428 >> 2] = $1_1;
      $1_1 = HEAP32[$2_1 + 44 >> 2];
      HEAP32[$7_1 + 464 >> 2] = HEAP32[$2_1 + 40 >> 2];
      HEAP32[$7_1 + 468 >> 2] = $1_1;
      $5_1 = $39_1 + 112 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $19_1 + 112 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $39_1 + 104 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $19_1 + 104 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $39_1 + 96 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $19_1 + 96 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $39_1 + 88 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $19_1 + 88 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $8_1 = HEAP32[$39_1 + 80 >> 2];
      $6_1 = HEAP32[$39_1 + 84 >> 2];
      $1_1 = HEAP32[$7_1 + 636 >> 2];
      HEAP32[$46_1 >> 2] = HEAP32[$7_1 + 632 >> 2];
      HEAP32[$46_1 + 4 >> 2] = $1_1;
      $5_1 = $32_1 + 88 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $46_1 + 8 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 96 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $46_1 + 16 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 104 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $46_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $32_1 + 112 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $46_1 + 32 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      HEAP32[$7_1 + 504 >> 2] = $8_1;
      HEAP32[$7_1 + 508 >> 2] = $6_1;
      $65($19_1, $19_1, $45_1, $46_1 + 40 | 0);
      HEAP32[$2_1 + 168 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 88 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 92 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 96 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 104 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 112 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 120 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 128 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 136 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 144 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 152 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 160 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $65($19_1, $19_1, $45_1, $46_1 + 80 | 0);
      HEAP32[$2_1 + 256 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 176 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 180 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 184 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 192 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 200 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 208 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 216 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 224 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 232 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 240 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 248 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $65($19_1, $19_1, $45_1, $46_1 + 120 | 0);
      HEAP32[$2_1 + 344 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 264 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 268 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 272 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 280 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 288 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 296 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 304 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 312 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 320 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 328 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 336 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $65($19_1, $19_1, $45_1, $46_1 + 160 | 0);
      HEAP32[$2_1 + 432 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 352 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 356 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 360 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 368 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 376 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 384 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 392 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 400 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 408 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 416 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 424 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $65($19_1, $19_1, $45_1, $46_1 + 200 | 0);
      HEAP32[$2_1 + 520 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 440 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 444 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 448 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 456 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 464 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 472 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 480 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 488 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 496 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 504 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 512 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $23_1 = $46_1 + 240 | 0;
      $65($19_1, $19_1, $45_1, $23_1);
      HEAP32[$2_1 + 608 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 528 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 532 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 536 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 544 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 552 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 560 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 568 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 576 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 584 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 592 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 600 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $6_1 = $46_1 + 280 | 0;
      $65($19_1, $19_1, $45_1, $6_1);
      HEAP32[$2_1 + 696 >> 2] = 0;
      $1_1 = HEAP32[$7_1 + 428 >> 2];
      HEAP32[$2_1 + 616 >> 2] = HEAP32[$7_1 + 424 >> 2];
      HEAP32[$2_1 + 620 >> 2] = $1_1;
      $4_1 = HEAP32[$20_1 + 4 >> 2];
      $1_1 = $2_1 + 624 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$18_1 + 4 >> 2];
      $1_1 = $2_1 + 632 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$14_1 + 4 >> 2];
      $1_1 = $2_1 + 640 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$16_1 + 4 >> 2];
      $1_1 = $2_1 + 648 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$7_1 + 468 >> 2];
      $1_1 = $2_1 + 656 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$11_1 + 4 >> 2];
      $1_1 = $2_1 + 664 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $2_1 + 672 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$15_1 + 4 >> 2];
      $1_1 = $2_1 + 680 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $2_1 + 688 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $34($51_1, $19_1 + 80 | 0, $13_1);
      global$0 = $7_1 + 720 | 0;
      $11_1 = global$0 - 928 | 0;
      global$0 = $11_1;
      $8_1 = $2_1 + 616 | 0;
      $7_1 = $8_1 + 72 | 0;
      $5_1 = HEAP32[$7_1 >> 2];
      $13_1 = HEAP32[$8_1 + 44 >> 2];
      $4_1 = HEAP32[$8_1 + 40 >> 2];
      $15_1 = HEAP32[$7_1 + 4 >> 2];
      $1_1 = __wasm_i64_mul($15_1 >>> 16 | 0, 0, 977, 1);
      $9_1 = $4_1 + $1_1 | 0;
      $4_1 = $13_1 + i64toi32_i32$HIGH_BITS | 0;
      HEAP32[$8_1 + 40 >> 2] = $9_1;
      $4_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 44 >> 2] = $4_1 & 1048575;
      $12_1 = $8_1 + 48 | 0;
      $9_1 = HEAP32[$12_1 >> 2];
      $1_1 = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $1_1 >>> 20 | 0;
      $13_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$12_1 >> 2] = $1_1;
      HEAP32[$12_1 + 4 >> 2] = $4_1 & 1048575;
      $12_1 = $8_1 + 56 | 0;
      $9_1 = HEAP32[$12_1 >> 2];
      $1_1 = $4_1;
      $4_1 = HEAP32[$12_1 + 4 >> 2];
      $1_1 = $1_1 >>> 20 | 0;
      $13_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$12_1 >> 2] = $1_1;
      HEAP32[$12_1 + 4 >> 2] = $4_1 & 1048575;
      $9_1 = $8_1 - -64 | 0;
      $13_1 = HEAP32[$9_1 >> 2];
      $1_1 = $4_1;
      $4_1 = HEAP32[$9_1 + 4 >> 2];
      $1_1 = $1_1 >>> 20 | 0;
      $8_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $4_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 >> 2] = $1_1;
      HEAP32[$9_1 + 4 >> 2] = $4_1 & 1048575;
      $8_1 = $7_1;
      $1_1 = $4_1;
      $4_1 = $15_1 & 65535;
      $1_1 = $1_1 >>> 20 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $5_1 | 0;
      $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 >> 2] = $1_1;
      HEAP32[$8_1 + 4 >> 2] = $4_1;
      $5_1 = $6_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $41_1 = $11_1 + 808 | 0;
      $1_1 = $41_1 + 8 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $6_1 + 16 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $41_1 + 16 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $6_1 + 24 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $41_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $6_1 + 32 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $41_1 + 32 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $1_1 = HEAP32[$6_1 + 4 >> 2];
      HEAP32[$11_1 + 808 >> 2] = HEAP32[$6_1 >> 2];
      HEAP32[$11_1 + 812 >> 2] = $1_1;
      $51_1 = 6;
      $34_1 = $2_1 + 528 | 0;
      $5_1 = $34_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $38_1 = $11_1 + 680 | 0;
      $1_1 = $38_1 + 8 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 + 16 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 + 16 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 + 24 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 + 24 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 + 32 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 + 32 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 + 48 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 + 48 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 + 56 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 + 56 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 - -64 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 - -64 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $5_1 = $34_1 + 72 | 0;
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $38_1 + 72 | 0;
      HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$1_1 + 4 >> 2] = $4_1;
      $1_1 = HEAP32[$34_1 + 4 >> 2];
      HEAP32[$11_1 + 680 >> 2] = HEAP32[$34_1 >> 2];
      HEAP32[$11_1 + 684 >> 2] = $1_1;
      $1_1 = HEAP32[$34_1 + 44 >> 2];
      HEAP32[$11_1 + 720 >> 2] = HEAP32[$34_1 + 40 >> 2];
      HEAP32[$11_1 + 724 >> 2] = $1_1;
      $16_1 = HEAP32[$11_1 + 840 >> 2];
      $7_1 = HEAP32[$11_1 + 844 >> 2];
      $5_1 = HEAP32[$11_1 + 824 >> 2];
      $13_1 = HEAP32[$11_1 + 828 >> 2];
      $31_1 = HEAP32[$11_1 + 816 >> 2];
      $17_1 = HEAP32[$11_1 + 820 >> 2];
      $8_1 = HEAP32[$11_1 + 832 >> 2];
      $6_1 = HEAP32[$11_1 + 836 >> 2];
      $12_1 = HEAP32[$11_1 + 808 >> 2];
      $15_1 = HEAP32[$11_1 + 812 >> 2];
      HEAP32[$11_1 + 800 >> 2] = 0;
      $25_1 = $11_1 + 440 | 0;
      $35_1 = $12_1 << 1;
      $43_1 = $15_1 << 1 | $12_1 >>> 31;
      $69($25_1, $8_1, $6_1, 0, 0, $35_1, $43_1, 0, 0);
      $24_1 = $11_1 + 504 | 0;
      $1_1 = $13_1;
      $13_1 = $31_1 << 1;
      $9_1 = $17_1 << 1 | $31_1 >>> 31;
      $69($24_1, $5_1, $1_1, 0, 0, $13_1, $9_1, 0, 0);
      $20_1 = $11_1 + 632 | 0;
      $4_1 = $7_1;
      $69($20_1, $16_1, $4_1, 0, 0, $16_1, $4_1, 0, 0);
      $18_1 = $11_1 + 616 | 0;
      $69($18_1, HEAP32[$11_1 + 632 >> 2], HEAP32[$11_1 + 636 >> 2], 0, 0, 15632, 16, 0, 0);
      $7_1 = $16_1;
      $4_1 = $4_1 << 1 | $7_1 >>> 31;
      $42_1 = $11_1 + 472 | 0;
      $28_1 = $7_1 << 1;
      $27_1 = $4_1;
      $69($42_1, $28_1, $4_1, 0, 0, $12_1, $15_1, 0, 0);
      $44_1 = $11_1 + 488 | 0;
      $69($44_1, $8_1, $6_1, 0, 0, $13_1, $9_1, 0, 0);
      $36_1 = $11_1 + 568 | 0;
      $69($36_1, $5_1, $1_1, 0, 0, $5_1, $1_1, 0, 0);
      $16_1 = $11_1 + 600 | 0;
      $4_1 = $20_1 + 8 | 0;
      $69($16_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $47_1 = $11_1 + 456 | 0;
      $69($47_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
      $48_1 = $11_1 + 536 | 0;
      $69($48_1, $28_1, $27_1, 0, 0, $31_1, $17_1, 0, 0);
      $21_1 = $1_1;
      $30_1 = $5_1;
      $4_1 = $1_1 << 1 | $5_1 >>> 31;
      $49_1 = $11_1 + 584 | 0;
      $26_1 = $8_1;
      $22_1 = $6_1;
      $69($49_1, $8_1, $6_1, 0, 0, $5_1 << 1, $4_1, 0, 0);
      $8_1 = HEAP32[$11_1 + 440 >> 2];
      $5_1 = HEAP32[$11_1 + 504 >> 2];
      $1_1 = $8_1 + $5_1 | 0;
      $15_1 = HEAP32[$11_1 + 444 >> 2];
      $4_1 = $15_1 + HEAP32[$11_1 + 508 >> 2] | 0;
      $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = HEAP32[$11_1 + 616 >> 2];
      $19_1 = $5_1 + $1_1 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$11_1 + 620 >> 2] | 0;
      $5_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = ($6_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
      $4_1 = $18_1 + 8 | 0;
      $13_1 = HEAP32[$4_1 >> 2];
      $7_1 = HEAP32[$4_1 + 4 >> 2];
      $8_1 = ($6_1 | 0) == ($15_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $6_1 >>> 0 < $15_1 >>> 0;
      $4_1 = $24_1 + 8 | 0;
      $6_1 = HEAP32[$4_1 >> 2];
      $1_1 = $25_1 + 8 | 0;
      $15_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $8_1 + $15_1 | 0;
      $4_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $7_1 | 0;
      $6_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $20_1 = $5_1;
      $13_1 = $1_1 << 12 | $5_1 >>> 20;
      $8_1 = $4_1;
      $7_1 = $4_1 << 12 | $1_1 >>> 20;
      $40_1 = HEAP32[$11_1 + 488 >> 2];
      $1_1 = HEAP32[$11_1 + 568 >> 2];
      $12_1 = $40_1 + $1_1 | 0;
      $37_1 = HEAP32[$11_1 + 492 >> 2];
      $4_1 = $37_1 + HEAP32[$11_1 + 572 >> 2] | 0;
      $4_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = HEAP32[$11_1 + 472 >> 2];
      $15_1 = $1_1 + $12_1 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$11_1 + 476 >> 2] | 0;
      $4_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = HEAP32[$11_1 + 600 >> 2];
      $9_1 = $1_1 + $15_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$11_1 + 604 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $1_1 + $7_1 | 0;
      $33_1 = $11_1 + 376 | 0;
      $29_1 = $33_1;
      $13_1 = $9_1 + $13_1 | 0;
      $7_1 = $13_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $25_1 = ($1_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
      $24_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
      $1_1 = $16_1 + 8 | 0;
      $18_1 = HEAP32[$1_1 >> 2];
      $14_1 = HEAP32[$1_1 + 4 >> 2];
      $16_1 = ($5_1 | 0) == ($6_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
      $1_1 = $42_1 + 8 | 0;
      $15_1 = HEAP32[$1_1 >> 2];
      $9_1 = HEAP32[$1_1 + 4 >> 2];
      $6_1 = ($6_1 | 0) == ($37_1 | 0) & $12_1 >>> 0 < $40_1 >>> 0 | $6_1 >>> 0 < $37_1 >>> 0;
      $4_1 = $36_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 >> 2];
      $1_1 = $44_1 + 8 | 0;
      $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $6_1 + $12_1 | 0;
      $4_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $15_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $4_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $18_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1 + $24_1 | 0;
      $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $8_1 >>> 20 | 0;
      $1_1 = $5_1 + $6_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $25_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $7_1;
      $7_1 = $1_1 << 12 | $5_1 >>> 20;
      $6_1 = $4_1;
      $9_1 = $4_1 << 12 | $1_1 >>> 20;
      $25_1 = HEAP32[$11_1 + 540 >> 2];
      $4_1 = $25_1 + HEAP32[$11_1 + 588 >> 2] | 0;
      $14_1 = HEAP32[$11_1 + 536 >> 2];
      $1_1 = HEAP32[$11_1 + 584 >> 2];
      $8_1 = $14_1 + $1_1 | 0;
      $12_1 = $8_1;
      $7_1 = $8_1 + $7_1 | 0;
      $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $1_1 + $9_1 | 0;
      $15_1 = $7_1 << 4 & -16;
      $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
      $18_1 = $5_1;
      $69($29_1, $15_1 | $5_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
      $9_1 = $11_1;
      $29_1 = HEAP32[$9_1 + 376 >> 2];
      $5_1 = HEAP32[$9_1 + 456 >> 2];
      $15_1 = $29_1 + $5_1 | 0;
      $50_1 = HEAP32[$9_1 + 380 >> 2];
      $4_1 = $50_1 + HEAP32[$9_1 + 460 >> 2] | 0;
      HEAP32[$9_1 + 888 >> 2] = $15_1;
      $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 892 >> 2] = $5_1 & 1048575;
      $37_1 = $9_1 + 360 | 0;
      $69($37_1, $31_1, $17_1, 0, 0, $35_1, $43_1, 0, 0);
      $42_1 = $9_1 + 552 | 0;
      $69($42_1, $28_1, $27_1, 0, 0, $30_1, $21_1, 0, 0);
      $44_1 = $9_1 + 664 | 0;
      $69($44_1, $26_1, $22_1, 0, 0, $26_1, $22_1, 0, 0);
      $36_1 = $9_1 + 424 | 0;
      $24_1 = $36_1;
      $16_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $12_1 = ($1_1 | 0) == ($25_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $25_1 >>> 0;
      $4_1 = $49_1 + 8 | 0;
      $7_1 = HEAP32[$4_1 >> 2];
      $1_1 = $48_1 + 8 | 0;
      $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $14_1 + $12_1 | 0;
      $4_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $1_1 = $6_1 + $7_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $1_1 << 12 | $8_1 >>> 20;
      $7_1 = $4_1;
      $6_1 = $4_1 << 12 | $1_1 >>> 20;
      $40_1 = HEAP32[$9_1 + 552 >> 2];
      $1_1 = HEAP32[$9_1 + 664 >> 2];
      $25_1 = $40_1 + $1_1 | 0;
      $48_1 = HEAP32[$9_1 + 556 >> 2];
      $4_1 = $48_1 + HEAP32[$9_1 + 668 >> 2] | 0;
      $8_1 = $1_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $8_1 + $6_1 | 0;
      $14_1 = $12_1 + $25_1 | 0;
      $4_1 = $14_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $4_1;
      $69($24_1, $14_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $15_1 = ($5_1 | 0) == ($50_1 | 0) & $15_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $50_1 >>> 0;
      $4_1 = $47_1 + 8 | 0;
      $6_1 = HEAP32[$4_1 >> 2];
      $1_1 = $33_1 + 8 | 0;
      $16_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $15_1 + $16_1 | 0;
      $4_1 = $1_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $16_1 = $1_1 << 12 | $5_1 >>> 20;
      $6_1 = $4_1;
      $15_1 = $4_1 << 12 | $1_1 >>> 20;
      $33_1 = HEAP32[$9_1 + 424 >> 2];
      $1_1 = HEAP32[$9_1 + 360 >> 2];
      $24_1 = $33_1 + $1_1 | 0;
      $49_1 = HEAP32[$9_1 + 428 >> 2];
      $4_1 = $49_1 + HEAP32[$9_1 + 364 >> 2] | 0;
      $5_1 = $1_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $5_1 + $15_1 | 0;
      $16_1 = $16_1 + $24_1 | 0;
      $4_1 = $16_1 >>> 0 < $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 + 896 >> 2] = $16_1;
      $15_1 = $4_1;
      HEAP32[$9_1 + 900 >> 2] = $4_1 & 1048575;
      $29_1 = $9_1 + 344 | 0;
      $69($29_1, $30_1, $21_1, 0, 0, $35_1, $43_1, 0, 0);
      $35_1 = $9_1 + 520 | 0;
      $69($35_1, $31_1, $17_1, 0, 0, $31_1, $17_1, 0, 0);
      $31_1 = $9_1 + 648 | 0;
      $69($31_1, $28_1, $27_1, 0, 0, $26_1, $22_1, 0, 0);
      $30_1 = $9_1 + 408 | 0;
      $26_1 = $30_1;
      $21_1 = ($8_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $25_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
      $14_1 = ($8_1 | 0) == ($48_1 | 0) & $25_1 >>> 0 < $40_1 >>> 0 | $8_1 >>> 0 < $48_1 >>> 0;
      $4_1 = $44_1 + 8 | 0;
      $8_1 = HEAP32[$4_1 >> 2];
      $1_1 = $42_1 + 8 | 0;
      $22_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $8_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $8_1 = $14_1 + $22_1 | 0;
      $4_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $7_1 >>> 20 | 0;
      $1_1 = $7_1 + $8_1 | 0;
      $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $1_1;
      $1_1 = $1_1 + $21_1 | 0;
      $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $22_1 = $1_1 << 12 | $12_1 >>> 20;
      $7_1 = HEAP32[$9_1 + 648 >> 2];
      $12_1 = $22_1 + $7_1 | 0;
      $8_1 = $4_1;
      $25_1 = $4_1 << 12 | $1_1 >>> 20;
      $4_1 = $25_1 + HEAP32[$9_1 + 652 >> 2] | 0;
      $21_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($26_1, $12_1, $21_1, 0, 0, 15632, 16, 0, 0);
      $7_1 = $9_1;
      $16_1 = ($5_1 | 0) == ($15_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
      $9_1 = ($5_1 | 0) == ($49_1 | 0) & $24_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $49_1 >>> 0;
      $4_1 = $37_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 >> 2];
      $1_1 = $36_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $9_1 + $14_1 | 0;
      $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $1_1 = $5_1 + $6_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $15_1 = $1_1 << 12 | $15_1 >>> 20;
      $6_1 = $4_1;
      $9_1 = $4_1 << 12 | $1_1 >>> 20;
      $17_1 = HEAP32[$7_1 + 344 >> 2];
      $1_1 = HEAP32[$7_1 + 520 >> 2];
      $14_1 = $17_1 + $1_1 | 0;
      $24_1 = HEAP32[$7_1 + 348 >> 2];
      $4_1 = $24_1 + HEAP32[$7_1 + 524 >> 2] | 0;
      $4_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = HEAP32[$7_1 + 408 >> 2];
      $16_1 = $1_1 + $14_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$7_1 + 412 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $1_1 + $9_1 | 0;
      $15_1 = $15_1 + $16_1 | 0;
      $4_1 = $15_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$7_1 + 904 >> 2] = $15_1;
      $9_1 = $4_1;
      HEAP32[$7_1 + 908 >> 2] = $4_1 & 1048575;
      $26_1 = $7_1 + 392 | 0;
      $22_1 = ($21_1 | 0) == ($25_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $25_1 >>> 0;
      $4_1 = $31_1 + 8 | 0;
      $21_1 = HEAP32[$4_1 >> 2];
      $4_1 = HEAP32[$4_1 + 4 >> 2];
      $8_1 = $8_1 >>> 20 | 0;
      $12_1 = $8_1;
      $8_1 = $8_1 + $21_1 | 0;
      $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $8_1;
      $8_1 = $8_1 + $22_1 | 0;
      $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($26_1, $8_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
      $8_1 = $7_1;
      $21_1 = ($1_1 | 0) == ($9_1 | 0) & $15_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
      $16_1 = ($1_1 | 0) == ($5_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
      $1_1 = $30_1 + 8 | 0;
      $12_1 = HEAP32[$1_1 >> 2];
      $15_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($24_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
      $4_1 = $35_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 >> 2];
      $1_1 = $29_1 + 8 | 0;
      $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $7_1 + $14_1 | 0;
      $4_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
      $5_1 = $1_1;
      $1_1 = $1_1 + $12_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1 + $16_1 | 0;
      $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $1_1 = $5_1 + $6_1 | 0;
      $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $21_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $1_1 << 12 | $9_1 >>> 20;
      $6_1 = $4_1;
      $15_1 = $4_1 << 12 | $1_1 >>> 20;
      $16_1 = HEAP32[$8_1 + 396 >> 2];
      $4_1 = $16_1 + ($20_1 & 1048575) | 0;
      $12_1 = HEAP32[$8_1 + 392 >> 2];
      $5_1 = $19_1 & -2;
      $1_1 = $12_1 + $5_1 | 0;
      $9_1 = $1_1;
      $7_1 = $1_1 + $7_1 | 0;
      $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $5_1 + $15_1 | 0;
      HEAP32[$8_1 + 912 >> 2] = $7_1;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 916 >> 2] = $1_1 & 1048575;
      $15_1 = $18_1 & 65535;
      $7_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
      $5_1 = ($5_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $5_1 >>> 0 < $16_1 >>> 0;
      $4_1 = $26_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2];
      $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $6_1 >>> 20 | 0;
      $5_1 = $6_1 + $8_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $5_1;
      $5_1 = $5_1 + $7_1 | 0;
      $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $1_1 = $5_1 << 12 | $1_1 >>> 20;
      $6_1 = $1_1 + $13_1 | 0;
      $4_1 = $15_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
      HEAP32[$11_1 + 920 >> 2] = $6_1;
      HEAP32[$11_1 + 924 >> 2] = $1_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $11_1 + 848 | 0;
      $1_1 = $11_1 + 888 | 0;
      $34($4_1, $1_1, $41_1);
      $34($34_1, $38_1, $1_1);
      $39_1 = $38_1 + 40 | 0;
      $34($34_1 + 40 | 0, $39_1, $4_1);
      HEAP32[$34_1 + 80 >> 2] = 0;
      $35_1 = $23_1;
      $32_1 = $2_1 + 440 | 0;
      while (1) {
        $50_1 = $11_1 + 808 | 0;
        $34($50_1, $50_1, $35_1);
        $5_1 = $32_1 + 32 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $34_1 = $11_1 + 680 | 0;
        $1_1 = $34_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 24 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $34_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 16 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $34_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $34_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $47_1 = $32_1 + 40 | 0;
        $1_1 = HEAP32[$47_1 + 4 >> 2];
        HEAP32[$39_1 >> 2] = HEAP32[$47_1 >> 2];
        HEAP32[$39_1 + 4 >> 2] = $1_1;
        $5_1 = $32_1 + 48 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $39_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 56 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $39_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 - -64 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $39_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $32_1 + 72 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $39_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $1_1 = HEAP32[$32_1 + 4 >> 2];
        HEAP32[$11_1 + 680 >> 2] = HEAP32[$32_1 >> 2];
        HEAP32[$11_1 + 684 >> 2] = $1_1;
        HEAP32[$11_1 + 800 >> 2] = 0;
        $1_1 = HEAP32[$11_1 + 812 >> 2];
        $18_1 = $1_1;
        $14_1 = HEAP32[$11_1 + 808 >> 2];
        $7_1 = $14_1;
        $4_1 = $1_1 << 1 | $7_1 >>> 31;
        $12_1 = $11_1 + 72 | 0;
        $26_1 = HEAP32[$11_1 + 832 >> 2];
        $22_1 = HEAP32[$11_1 + 836 >> 2];
        $25_1 = $7_1 << 1;
        $30_1 = $4_1;
        $69($12_1, $26_1, $22_1, 0, 0, $25_1, $4_1, 0, 0);
        $1_1 = HEAP32[$11_1 + 820 >> 2];
        $38_1 = $1_1;
        $41_1 = HEAP32[$11_1 + 816 >> 2];
        $5_1 = $41_1;
        $4_1 = $1_1 << 1 | $5_1 >>> 31;
        $15_1 = $11_1 + 280 | 0;
        $23_1 = HEAP32[$11_1 + 824 >> 2];
        $21_1 = HEAP32[$11_1 + 828 >> 2];
        $5_1 = $5_1 << 1;
        $6_1 = $4_1;
        $69($15_1, $23_1, $21_1, 0, 0, $5_1, $4_1, 0, 0);
        $9_1 = $11_1 + 232 | 0;
        $8_1 = HEAP32[$11_1 + 840 >> 2];
        $1_1 = HEAP32[$11_1 + 844 >> 2];
        $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
        $13_1 = $11_1 + 216 | 0;
        $69($13_1, HEAP32[$11_1 + 232 >> 2], HEAP32[$11_1 + 236 >> 2], 0, 0, 15632, 16, 0, 0);
        $4_1 = $1_1 << 1 | $8_1 >>> 31;
        $36_1 = $11_1 + 184 | 0;
        $31_1 = $8_1 << 1;
        $24_1 = $4_1;
        $69($36_1, $31_1, $4_1, 0, 0, $7_1, $18_1, 0, 0);
        $40_1 = $11_1 + 88 | 0;
        $69($40_1, $26_1, $22_1, 0, 0, $5_1, $6_1, 0, 0);
        $33_1 = $11_1 + 264 | 0;
        $69($33_1, $23_1, $21_1, 0, 0, $23_1, $21_1, 0, 0);
        $16_1 = $11_1 + 200 | 0;
        $1_1 = $9_1 + 8 | 0;
        $69($16_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $49_1 = $11_1 + 328 | 0;
        $69($49_1, $7_1, $18_1, 0, 0, $7_1, $18_1, 0, 0);
        $37_1 = $11_1 + 168 | 0;
        $69($37_1, $31_1, $4_1, 0, 0, $41_1, $38_1, 0, 0);
        $42_1 = $11_1 + 104 | 0;
        $69($42_1, $26_1, $22_1, 0, 0, $23_1 << 1, $21_1 << 1 | $23_1 >>> 31, 0, 0);
        $8_1 = HEAP32[$11_1 + 72 >> 2];
        $5_1 = HEAP32[$11_1 + 280 >> 2];
        $1_1 = $8_1 + $5_1 | 0;
        $14_1 = HEAP32[$11_1 + 76 >> 2];
        $4_1 = $14_1 + HEAP32[$11_1 + 284 >> 2] | 0;
        $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$11_1 + 216 >> 2];
        $19_1 = $5_1 + $1_1 | 0;
        $6_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$11_1 + 220 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = ($6_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $4_1 = $13_1 + 8 | 0;
        $13_1 = HEAP32[$4_1 >> 2];
        $7_1 = HEAP32[$4_1 + 4 >> 2];
        $8_1 = ($6_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $6_1 >>> 0 < $14_1 >>> 0;
        $4_1 = $15_1 + 8 | 0;
        $6_1 = HEAP32[$4_1 >> 2];
        $1_1 = $12_1 + 8 | 0;
        $15_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $8_1 + $15_1 | 0;
        $4_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $7_1 | 0;
        $6_1 = $1_1;
        $1_1 = $1_1 + $13_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $9_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $20_1 = $5_1;
        $13_1 = $1_1 << 12 | $5_1 >>> 20;
        $8_1 = $4_1;
        $7_1 = $4_1 << 12 | $1_1 >>> 20;
        $29_1 = HEAP32[$11_1 + 88 >> 2];
        $1_1 = HEAP32[$11_1 + 264 >> 2];
        $12_1 = $29_1 + $1_1 | 0;
        $44_1 = HEAP32[$11_1 + 92 >> 2];
        $4_1 = $44_1 + HEAP32[$11_1 + 268 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = HEAP32[$11_1 + 184 >> 2];
        $15_1 = $1_1 + $12_1 | 0;
        $6_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$11_1 + 188 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = HEAP32[$11_1 + 200 >> 2];
        $9_1 = $1_1 + $15_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$11_1 + 204 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $1_1 + $7_1 | 0;
        $28_1 = $11_1 + 8 | 0;
        $13_1 = $9_1 + $13_1 | 0;
        $7_1 = $13_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $27_1 = ($1_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
        $17_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
        $1_1 = $16_1 + 8 | 0;
        $18_1 = HEAP32[$1_1 >> 2];
        $14_1 = HEAP32[$1_1 + 4 >> 2];
        $16_1 = ($5_1 | 0) == ($6_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
        $1_1 = $36_1 + 8 | 0;
        $15_1 = HEAP32[$1_1 >> 2];
        $9_1 = HEAP32[$1_1 + 4 >> 2];
        $6_1 = ($6_1 | 0) == ($44_1 | 0) & $12_1 >>> 0 < $29_1 >>> 0 | $6_1 >>> 0 < $44_1 >>> 0;
        $4_1 = $33_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $1_1 = $40_1 + 8 | 0;
        $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $6_1 + $12_1 | 0;
        $4_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
        $5_1 = $1_1;
        $1_1 = $1_1 + $15_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
        $5_1 = $1_1;
        $1_1 = $1_1 + $18_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1 + $17_1 | 0;
        $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $8_1 >>> 20 | 0;
        $1_1 = $5_1 + $6_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $27_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $7_1;
        $7_1 = $1_1 << 12 | $5_1 >>> 20;
        $6_1 = $4_1;
        $9_1 = $4_1 << 12 | $1_1 >>> 20;
        $27_1 = HEAP32[$11_1 + 172 >> 2];
        $4_1 = $27_1 + HEAP32[$11_1 + 108 >> 2] | 0;
        $14_1 = HEAP32[$11_1 + 168 >> 2];
        $1_1 = HEAP32[$11_1 + 104 >> 2];
        $8_1 = $14_1 + $1_1 | 0;
        $12_1 = $8_1;
        $7_1 = $8_1 + $7_1 | 0;
        $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $1_1 + $9_1 | 0;
        $15_1 = $7_1 << 4 & -16;
        $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
        $18_1 = $5_1;
        $69($28_1, $15_1 | $5_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
        $9_1 = $11_1;
        $43_1 = HEAP32[$9_1 + 8 >> 2];
        $5_1 = HEAP32[$9_1 + 328 >> 2];
        $15_1 = $43_1 + $5_1 | 0;
        $48_1 = HEAP32[$9_1 + 12 >> 2];
        $4_1 = $48_1 + HEAP32[$9_1 + 332 >> 2] | 0;
        HEAP32[$9_1 + 888 >> 2] = $15_1;
        $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 892 >> 2] = $5_1 & 1048575;
        $44_1 = $9_1 + 312 | 0;
        $69($44_1, $41_1, $38_1, 0, 0, $25_1, $30_1, 0, 0);
        $36_1 = $9_1 + 152 | 0;
        $69($36_1, $31_1, $24_1, 0, 0, $23_1, $21_1, 0, 0);
        $40_1 = $9_1 + 120 | 0;
        $69($40_1, $26_1, $22_1, 0, 0, $26_1, $22_1, 0, 0);
        $33_1 = $9_1 + 56 | 0;
        $17_1 = $33_1;
        $16_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
        $12_1 = ($1_1 | 0) == ($27_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
        $4_1 = $42_1 + 8 | 0;
        $7_1 = HEAP32[$4_1 >> 2];
        $1_1 = $37_1 + 8 | 0;
        $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $14_1 + $12_1 | 0;
        $4_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $6_1 + $7_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $16_1 = $1_1 << 12 | $8_1 >>> 20;
        $7_1 = $4_1;
        $12_1 = $4_1 << 12 | $1_1 >>> 20;
        $37_1 = HEAP32[$9_1 + 156 >> 2];
        $4_1 = $37_1 + HEAP32[$9_1 + 124 >> 2] | 0;
        $29_1 = HEAP32[$9_1 + 152 >> 2];
        $6_1 = HEAP32[$9_1 + 120 >> 2];
        $1_1 = $29_1 + $6_1 | 0;
        $27_1 = $1_1;
        $14_1 = $1_1 + $16_1 | 0;
        $8_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $8_1 + $12_1 | 0;
        $12_1 = $14_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($17_1, $14_1, $12_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $15_1 = ($5_1 | 0) == ($48_1 | 0) & $15_1 >>> 0 < $43_1 >>> 0 | $5_1 >>> 0 < $48_1 >>> 0;
        $4_1 = $49_1 + 8 | 0;
        $6_1 = HEAP32[$4_1 >> 2];
        $1_1 = $28_1 + 8 | 0;
        $16_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $15_1 + $16_1 | 0;
        $4_1 = $1_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $16_1 = $1_1 << 12 | $5_1 >>> 20;
        $6_1 = $4_1;
        $15_1 = $4_1 << 12 | $1_1 >>> 20;
        $28_1 = HEAP32[$9_1 + 56 >> 2];
        $1_1 = HEAP32[$9_1 + 312 >> 2];
        $17_1 = $28_1 + $1_1 | 0;
        $42_1 = HEAP32[$9_1 + 60 >> 2];
        $4_1 = $42_1 + HEAP32[$9_1 + 316 >> 2] | 0;
        $5_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + $15_1 | 0;
        $16_1 = $16_1 + $17_1 | 0;
        $4_1 = $16_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 896 >> 2] = $16_1;
        $15_1 = $4_1;
        HEAP32[$9_1 + 900 >> 2] = $4_1 & 1048575;
        $43_1 = $9_1 + 248 | 0;
        $69($43_1, $23_1, $21_1, 0, 0, $25_1, $30_1, 0, 0);
        $30_1 = $9_1 + 296 | 0;
        $69($30_1, $41_1, $38_1, 0, 0, $41_1, $38_1, 0, 0);
        $25_1 = $9_1 + 136 | 0;
        $69($25_1, $31_1, $24_1, 0, 0, $26_1, $22_1, 0, 0);
        $23_1 = $9_1 + 40 | 0;
        $21_1 = ($8_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $27_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
        $14_1 = ($8_1 | 0) == ($37_1 | 0) & $27_1 >>> 0 < $29_1 >>> 0 | $8_1 >>> 0 < $37_1 >>> 0;
        $4_1 = $40_1 + 8 | 0;
        $8_1 = HEAP32[$4_1 >> 2];
        $1_1 = $36_1 + 8 | 0;
        $22_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $8_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $14_1 + $22_1 | 0;
        $4_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $7_1 >>> 20 | 0;
        $1_1 = $7_1 + $8_1 | 0;
        $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $1_1;
        $1_1 = $1_1 + $21_1 | 0;
        $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $22_1 = $1_1 << 12 | $12_1 >>> 20;
        $7_1 = HEAP32[$9_1 + 136 >> 2];
        $12_1 = $22_1 + $7_1 | 0;
        $8_1 = $4_1;
        $27_1 = $4_1 << 12 | $1_1 >>> 20;
        $4_1 = $27_1 + HEAP32[$9_1 + 140 >> 2] | 0;
        $21_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($23_1, $12_1, $21_1, 0, 0, 15632, 16, 0, 0);
        $7_1 = $9_1;
        $16_1 = ($5_1 | 0) == ($15_1 | 0) & $16_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
        $9_1 = ($5_1 | 0) == ($42_1 | 0) & $17_1 >>> 0 < $28_1 >>> 0 | $5_1 >>> 0 < $42_1 >>> 0;
        $4_1 = $44_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $1_1 = $33_1 + 8 | 0;
        $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $9_1 + $14_1 | 0;
        $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $5_1 + $6_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $16_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $1_1 << 12 | $15_1 >>> 20;
        $6_1 = $4_1;
        $9_1 = $4_1 << 12 | $1_1 >>> 20;
        $17_1 = HEAP32[$7_1 + 248 >> 2];
        $1_1 = HEAP32[$7_1 + 296 >> 2];
        $14_1 = $17_1 + $1_1 | 0;
        $24_1 = HEAP32[$7_1 + 252 >> 2];
        $4_1 = $24_1 + HEAP32[$7_1 + 300 >> 2] | 0;
        $4_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = HEAP32[$7_1 + 40 >> 2];
        $16_1 = $1_1 + $14_1 | 0;
        $5_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$7_1 + 44 >> 2] | 0;
        $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $1_1 + $9_1 | 0;
        $15_1 = $15_1 + $16_1 | 0;
        $4_1 = $15_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$7_1 + 904 >> 2] = $15_1;
        $9_1 = $4_1;
        HEAP32[$7_1 + 908 >> 2] = $4_1 & 1048575;
        $26_1 = $7_1 + 24 | 0;
        $22_1 = ($21_1 | 0) == ($27_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
        $4_1 = $25_1 + 8 | 0;
        $21_1 = HEAP32[$4_1 >> 2];
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $8_1 = $8_1 >>> 20 | 0;
        $12_1 = $8_1;
        $8_1 = $8_1 + $21_1 | 0;
        $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $8_1;
        $8_1 = $8_1 + $22_1 | 0;
        $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($26_1, $8_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
        $8_1 = $7_1;
        $21_1 = ($1_1 | 0) == ($9_1 | 0) & $15_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
        $16_1 = ($1_1 | 0) == ($5_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
        $1_1 = $23_1 + 8 | 0;
        $12_1 = HEAP32[$1_1 >> 2];
        $15_1 = HEAP32[$1_1 + 4 >> 2];
        $7_1 = ($5_1 | 0) == ($24_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
        $4_1 = $30_1 + 8 | 0;
        $5_1 = HEAP32[$4_1 >> 2];
        $1_1 = $43_1 + 8 | 0;
        $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $7_1 + $14_1 | 0;
        $4_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
        $5_1 = $1_1;
        $1_1 = $1_1 + $12_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1 + $16_1 | 0;
        $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $1_1 = $5_1 + $6_1 | 0;
        $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $1_1;
        $1_1 = $1_1 + $21_1 | 0;
        $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $1_1 << 12 | $9_1 >>> 20;
        $6_1 = $4_1;
        $7_1 = $4_1 << 12 | $1_1 >>> 20;
        $12_1 = HEAP32[$8_1 + 24 >> 2];
        $1_1 = $19_1 & -2;
        $9_1 = $12_1 + $1_1 | 0;
        $16_1 = HEAP32[$8_1 + 28 >> 2];
        $4_1 = $16_1 + ($20_1 & 1048575) | 0;
        $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + $7_1 | 0;
        $7_1 = $9_1 + $15_1 | 0;
        $4_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$8_1 + 912 >> 2] = $7_1;
        $1_1 = $4_1;
        HEAP32[$8_1 + 916 >> 2] = $4_1 & 1048575;
        $15_1 = $18_1 & 65535;
        $7_1 = ($4_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $7_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
        $5_1 = ($5_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $5_1 >>> 0 < $16_1 >>> 0;
        $4_1 = $26_1 + 8 | 0;
        $8_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $6_1 >>> 20 | 0;
        $5_1 = $6_1 + $8_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1;
        $5_1 = $5_1 + $7_1 | 0;
        $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $1_1 = $5_1 << 12 | $1_1 >>> 20;
        $6_1 = $1_1 + $13_1 | 0;
        $4_1 = $15_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        HEAP32[$11_1 + 920 >> 2] = $6_1;
        HEAP32[$11_1 + 924 >> 2] = $1_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $11_1 + 848 | 0;
        $1_1 = $11_1 + 888 | 0;
        $34($4_1, $1_1, $50_1);
        $34($32_1, $34_1, $1_1);
        $34($47_1, $39_1, $4_1);
        HEAP32[$32_1 + 80 >> 2] = 0;
        $32_1 = $32_1 - 88 | 0;
        $35_1 = $35_1 - 40 | 0;
        $51_1 = $51_1 - 1 | 0;
        if ($51_1) {
          continue;
        }
        break;
      }
      ;
      global$0 = $11_1 + 928 | 0;
      $1_1 = 0;
      $32_1 = ($52_1 | 0) > 0 ? $52_1 : 0;
      while (1) {
        $40_1 = $10_1 - -64 | 0;
        $53_1 = HEAP32[$2_1 >> 2];
        $54_1 = HEAP32[$2_1 + 4 >> 2];
        $69($40_1, $53_1, $54_1, 0, 0, -431719958, 28934, 0, 0);
        $33_1 = $10_1 + 416 | 0;
        $4_1 = $2_1 + 8 | 0;
        $55_1 = HEAP32[$4_1 >> 2];
        $56_1 = HEAP32[$4_1 + 4 >> 2];
        $69($33_1, $55_1, $56_1, 0, 0, -375590839, 799796, 0, 0);
        $29_1 = $10_1 + 336 | 0;
        $4_1 = $2_1 + 16 | 0;
        $57_1 = HEAP32[$4_1 >> 2];
        $58_1 = HEAP32[$4_1 + 4 >> 2];
        $69($29_1, $57_1, $58_1, 0, 0, 1486445587, 479535, 0, 0);
        $26_1 = $10_1 + 256 | 0;
        $4_1 = $2_1 + 24 | 0;
        $59_1 = HEAP32[$4_1 >> 2];
        $60_1 = HEAP32[$4_1 + 4 >> 2];
        $69($26_1, $59_1, $60_1, 0, 0, 1905590766, 617512, 0, 0);
        $5_1 = $10_1 + 176 | 0;
        $4_1 = $2_1 + 32 | 0;
        $61_1 = HEAP32[$4_1 >> 2];
        $45_1 = HEAP32[$4_1 + 4 >> 2];
        $69($5_1, $61_1, $45_1, 0, 0, 1781228924, 31465, 0, 0);
        $19_1 = $10_1 + 160 | 0;
        $69($19_1, HEAP32[$10_1 + 176 >> 2] & -4, HEAP32[$10_1 + 180 >> 2], 0, 0, 15632, 16, 0, 0);
        $34_1 = $10_1 + 80 | 0;
        $69($34_1, $53_1, $54_1, 0, 0, 1781228924, 31465, 0, 0);
        $51_1 = $10_1 + 432 | 0;
        $69($51_1, $55_1, $56_1, 0, 0, -431719958, 28934, 0, 0);
        $50_1 = $10_1 + 352 | 0;
        $69($50_1, $57_1, $58_1, 0, 0, -375590839, 799796, 0, 0);
        $47_1 = $10_1 + 272 | 0;
        $69($47_1, $59_1, $60_1, 0, 0, 1486445587, 479535, 0, 0);
        $48_1 = $10_1 + 192 | 0;
        $69($48_1, $61_1, $45_1, 0, 0, 1905590766, 617512, 0, 0);
        $28_1 = $10_1 + 144 | 0;
        $4_1 = $5_1 + 8 | 0;
        $69($28_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
        $38_1 = $10_1 + 96 | 0;
        $69($38_1, $53_1, $54_1, 0, 0, 1905590766, 617512, 0, 0);
        $41_1 = $10_1 + 448 | 0;
        $69($41_1, $55_1, $56_1, 0, 0, 1781228924, 31465, 0, 0);
        $49_1 = $10_1 + 368 | 0;
        $69($49_1, $57_1, $58_1, 0, 0, -431719958, 28934, 0, 0);
        $37_1 = $10_1 + 288 | 0;
        $69($37_1, $59_1, $60_1, 0, 0, -375590839, 799796, 0, 0);
        $42_1 = $10_1 + 208 | 0;
        $69($42_1, $61_1, $45_1, 0, 0, 1486445587, 479535, 0, 0);
        $44_1 = HEAP32[$10_1 + 432 >> 2];
        $5_1 = HEAP32[$10_1 + 80 >> 2];
        $23_1 = $44_1 + $5_1 | 0;
        $52_1 = HEAP32[$10_1 + 436 >> 2];
        $4_1 = $52_1 + HEAP32[$10_1 + 84 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 352 >> 2];
        $22_1 = $5_1 + $23_1 | 0;
        $24_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 356 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 272 >> 2];
        $21_1 = $5_1 + $22_1 | 0;
        $12_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 276 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 192 >> 2];
        $20_1 = $5_1 + $21_1 | 0;
        $15_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 196 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 144 >> 2];
        $18_1 = $5_1 + $20_1 | 0;
        $9_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 148 >> 2] | 0;
        $6_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $43_1 = HEAP32[$10_1 + 416 >> 2];
        $5_1 = HEAP32[$10_1 + 64 >> 2];
        $14_1 = $43_1 + $5_1 | 0;
        $36_1 = HEAP32[$10_1 + 420 >> 2];
        $4_1 = $36_1 + HEAP32[$10_1 + 68 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 336 >> 2];
        $16_1 = $5_1 + $14_1 | 0;
        $7_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 340 >> 2] | 0;
        $8_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $8_1 + HEAP32[$10_1 + 260 >> 2] | 0;
        $5_1 = HEAP32[$10_1 + 256 >> 2];
        $11_1 = $5_1 + $16_1 | 0;
        $13_1 = HEAP32[$10_1 + 160 >> 2];
        $30_1 = $11_1 + $13_1 | 0;
        $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $5_1 + HEAP32[$10_1 + 164 >> 2] | 0;
        $13_1 = $13_1 >>> 0 > $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $35_1 = ($5_1 | 0) == ($13_1 | 0) & $11_1 >>> 0 > $30_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
        $4_1 = $19_1 + 8 | 0;
        $31_1 = HEAP32[$4_1 >> 2];
        $27_1 = HEAP32[$4_1 + 4 >> 2];
        $25_1 = ($5_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
        $4_1 = $26_1 + 8 | 0;
        $17_1 = HEAP32[$4_1 >> 2];
        $26_1 = HEAP32[$4_1 + 4 >> 2];
        $19_1 = ($7_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
        $4_1 = $29_1 + 8 | 0;
        $16_1 = HEAP32[$4_1 >> 2];
        $11_1 = HEAP32[$4_1 + 4 >> 2];
        $7_1 = ($7_1 | 0) == ($36_1 | 0) & $14_1 >>> 0 < $43_1 >>> 0 | $7_1 >>> 0 < $36_1 >>> 0;
        $8_1 = $40_1 + 8 | 0;
        $5_1 = HEAP32[$8_1 >> 2];
        $4_1 = $33_1 + 8 | 0;
        $14_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $7_1 + $14_1 | 0;
        $4_1 = ($5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $11_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $16_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $19_1 | 0;
        $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $26_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $17_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $25_1 | 0;
        $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $27_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $31_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $35_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $19_1 = $13_1;
        $7_1 = $5_1 << 12 | $13_1 >>> 20;
        $11_1 = $7_1 + $18_1 | 0;
        $8_1 = $4_1;
        $4_1 = $6_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        $16_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $36_1 = HEAP32[$10_1 + 368 >> 2];
        $5_1 = HEAP32[$10_1 + 448 >> 2];
        $17_1 = $36_1 + $5_1 | 0;
        $39_1 = HEAP32[$10_1 + 372 >> 2];
        $4_1 = $39_1 + HEAP32[$10_1 + 452 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 288 >> 2];
        $26_1 = $5_1 + $17_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 292 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 208 >> 2];
        $14_1 = $5_1 + $26_1 | 0;
        $7_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 212 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $40_1 = ($6_1 | 0) == ($16_1 | 0) & $11_1 >>> 0 < $18_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
        $33_1 = ($6_1 | 0) == ($9_1 | 0) & $18_1 >>> 0 < $20_1 >>> 0 | $6_1 >>> 0 < $9_1 >>> 0;
        $4_1 = $28_1 + 8 | 0;
        $29_1 = HEAP32[$4_1 >> 2];
        $28_1 = HEAP32[$4_1 + 4 >> 2];
        $43_1 = ($9_1 | 0) == ($15_1 | 0) & $20_1 >>> 0 < $21_1 >>> 0 | $9_1 >>> 0 < $15_1 >>> 0;
        $4_1 = $48_1 + 8 | 0;
        $35_1 = HEAP32[$4_1 >> 2];
        $31_1 = HEAP32[$4_1 + 4 >> 2];
        $27_1 = ($12_1 | 0) == ($15_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $12_1 >>> 0 > $15_1 >>> 0;
        $4_1 = $47_1 + 8 | 0;
        $25_1 = HEAP32[$4_1 >> 2];
        $21_1 = HEAP32[$4_1 + 4 >> 2];
        $20_1 = ($12_1 | 0) == ($24_1 | 0) & $22_1 >>> 0 < $23_1 >>> 0 | $12_1 >>> 0 < $24_1 >>> 0;
        $4_1 = $50_1 + 8 | 0;
        $18_1 = HEAP32[$4_1 >> 2];
        $12_1 = HEAP32[$4_1 + 4 >> 2];
        $15_1 = ($24_1 | 0) == ($52_1 | 0) & $23_1 >>> 0 < $44_1 >>> 0 | $24_1 >>> 0 < $52_1 >>> 0;
        $9_1 = $34_1 + 8 | 0;
        $6_1 = HEAP32[$9_1 >> 2];
        $4_1 = $51_1 + 8 | 0;
        $22_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $15_1 + $22_1 | 0;
        $4_1 = ($6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $12_1 | 0;
        $9_1 = $6_1;
        $6_1 = $6_1 + $18_1 | 0;
        $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $6_1;
        $6_1 = $6_1 + $20_1 | 0;
        $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $21_1 | 0;
        $9_1 = $6_1;
        $6_1 = $6_1 + $25_1 | 0;
        $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $6_1;
        $6_1 = $6_1 + $27_1 | 0;
        $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $31_1 | 0;
        $9_1 = $6_1;
        $6_1 = $6_1 + $35_1 | 0;
        $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $6_1;
        $6_1 = $6_1 + $43_1 | 0;
        $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $28_1 | 0;
        $9_1 = $6_1;
        $6_1 = $6_1 + $29_1 | 0;
        $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $6_1 + $33_1 | 0;
        $4_1 = $9_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $8_1 >>> 20 | 0;
        $6_1 = $9_1 + $8_1 | 0;
        $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $6_1;
        $6_1 = $6_1 + $40_1 | 0;
        $8_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $8_1 << 12 | $6_1 >>> 20;
        $4_1 = $6_1 << 12;
        $6_1 = $16_1;
        $15_1 = $4_1 | $6_1 >>> 20;
        $16_1 = $15_1 + $14_1 | 0;
        $4_1 = $5_1 + $9_1 | 0;
        $12_1 = $15_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $16_1;
        $4_1 = $12_1 << 4 | $9_1 >>> 28;
        $15_1 = $9_1 << 4 & -16;
        $9_1 = $4_1 & 16777215;
        $20_1 = $6_1;
        $69($10_1, $15_1 | $6_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
        $33_1 = HEAP32[$10_1 + 4 >> 2];
        $4_1 = $33_1 + HEAP32[$10_1 + 100 >> 2] | 0;
        $46_1 = ($10_1 + 2240 | 0) + $1_1 | 0;
        $9_1 = $46_1;
        $29_1 = HEAP32[$10_1 >> 2];
        $6_1 = HEAP32[$10_1 + 96 >> 2];
        $18_1 = $29_1 + $6_1 | 0;
        HEAP32[$9_1 >> 2] = $18_1;
        $15_1 = $6_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$9_1 + 4 >> 2] = $15_1 & 1048575;
        $51_1 = $10_1 + 112 | 0;
        $69($51_1, $53_1, $54_1, 0, 0, 1486445587, 479535, 0, 0);
        $50_1 = $10_1 + 464 | 0;
        $69($50_1, $55_1, $56_1, 0, 0, 1905590766, 617512, 0, 0);
        $47_1 = $10_1 + 384 | 0;
        $69($47_1, $57_1, $58_1, 0, 0, 1781228924, 31465, 0, 0);
        $28_1 = $10_1 + 304 | 0;
        $69($28_1, $59_1, $60_1, 0, 0, -431719958, 28934, 0, 0);
        $43_1 = $10_1 + 224 | 0;
        $69($43_1, $61_1, $45_1, 0, 0, -375590839, 799796, 0, 0);
        $48_1 = $10_1 + 48 | 0;
        $31_1 = $48_1;
        $35_1 = HEAP32[$10_1 + 304 >> 2];
        $6_1 = HEAP32[$10_1 + 384 >> 2];
        $22_1 = $35_1 + $6_1 | 0;
        $52_1 = HEAP32[$10_1 + 308 >> 2];
        $4_1 = $52_1 + HEAP32[$10_1 + 388 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = HEAP32[$10_1 + 224 >> 2];
        $21_1 = $6_1 + $22_1 | 0;
        $9_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 228 >> 2] | 0;
        $6_1 = $6_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $27_1 = ($5_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $5_1 >>> 0 > $12_1 >>> 0;
        $25_1 = ($5_1 | 0) == ($7_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
        $4_1 = $42_1 + 8 | 0;
        $24_1 = HEAP32[$4_1 >> 2];
        $23_1 = HEAP32[$4_1 + 4 >> 2];
        $26_1 = ($7_1 | 0) == ($13_1 | 0) & $17_1 >>> 0 > $26_1 >>> 0 | $7_1 >>> 0 < $13_1 >>> 0;
        $4_1 = $37_1 + 8 | 0;
        $14_1 = HEAP32[$4_1 >> 2];
        $16_1 = HEAP32[$4_1 + 4 >> 2];
        $13_1 = ($13_1 | 0) == ($39_1 | 0) & $17_1 >>> 0 < $36_1 >>> 0 | $13_1 >>> 0 < $39_1 >>> 0;
        $7_1 = $41_1 + 8 | 0;
        $5_1 = HEAP32[$7_1 >> 2];
        $4_1 = $49_1 + 8 | 0;
        $17_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $13_1 + $17_1 | 0;
        $4_1 = ($5_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $16_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $14_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $26_1 | 0;
        $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $23_1 | 0;
        $7_1 = $5_1;
        $5_1 = $5_1 + $24_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1 + $25_1 | 0;
        $4_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $8_1 >>> 20 | 0;
        $5_1 = $7_1 + $8_1 | 0;
        $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $27_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $5_1 << 12 | $12_1 >>> 20;
        $14_1 = $8_1 + $21_1 | 0;
        $13_1 = $4_1;
        $4_1 = $6_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        $16_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($31_1, $14_1, $16_1 & 1048575, 0, 0, 15632, 16, 0, 0);
        $17_1 = $46_1 + 8 | 0;
        $49_1 = HEAP32[$10_1 + 464 >> 2];
        $5_1 = HEAP32[$10_1 + 112 >> 2];
        $25_1 = $49_1 + $5_1 | 0;
        $34_1 = HEAP32[$10_1 + 468 >> 2];
        $4_1 = $34_1 + HEAP32[$10_1 + 116 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = HEAP32[$10_1 + 48 >> 2];
        $24_1 = $5_1 + $25_1 | 0;
        $27_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 52 >> 2] | 0;
        $8_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = ($15_1 | 0) == ($33_1 | 0) & $18_1 >>> 0 < $29_1 >>> 0 | $15_1 >>> 0 < $33_1 >>> 0;
        $7_1 = $38_1 + 8 | 0;
        $5_1 = HEAP32[$7_1 >> 2];
        $4_1 = $10_1 + 8 | 0;
        $18_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $12_1 + $18_1 | 0;
        $4_1 = $5_1 >>> 0 < $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $5_1 << 12 | $15_1 >>> 20;
        $18_1 = $15_1 + $24_1 | 0;
        $7_1 = $4_1;
        $4_1 = $8_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        HEAP32[$17_1 >> 2] = $18_1;
        $12_1 = $15_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$17_1 + 4 >> 2] = $12_1 & 1048575;
        $37_1 = $10_1 + 128 | 0;
        $69($37_1, $53_1, $54_1, 0, 0, -375590839, 799796, 0, 0);
        $42_1 = $10_1 + 480 | 0;
        $69($42_1, $55_1, $56_1, 0, 0, 1486445587, 479535, 0, 0);
        $44_1 = $10_1 + 400 | 0;
        $69($44_1, $57_1, $58_1, 0, 0, 1905590766, 617512, 0, 0);
        $36_1 = $10_1 + 320 | 0;
        $69($36_1, $59_1, $60_1, 0, 0, 1781228924, 31465, 0, 0);
        $40_1 = $10_1 + 240 | 0;
        $69($40_1, $61_1, $45_1, 0, 0, -431719958, 28934, 0, 0);
        $33_1 = $10_1 + 32 | 0;
        $31_1 = $33_1;
        $29_1 = HEAP32[$10_1 + 240 >> 2];
        $5_1 = HEAP32[$10_1 + 320 >> 2];
        $23_1 = $29_1 + $5_1 | 0;
        $38_1 = HEAP32[$10_1 + 244 >> 2];
        $4_1 = $38_1 + HEAP32[$10_1 + 324 >> 2] | 0;
        $5_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $17_1 = ($6_1 | 0) == ($16_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
        $26_1 = ($6_1 | 0) == ($9_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $9_1 >>> 0;
        $4_1 = $43_1 + 8 | 0;
        $21_1 = HEAP32[$4_1 >> 2];
        $14_1 = HEAP32[$4_1 + 4 >> 2];
        $15_1 = ($9_1 | 0) == ($52_1 | 0) & $22_1 >>> 0 < $35_1 >>> 0 | $9_1 >>> 0 < $52_1 >>> 0;
        $9_1 = $47_1 + 8 | 0;
        $6_1 = HEAP32[$9_1 >> 2];
        $4_1 = $28_1 + 8 | 0;
        $22_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $15_1 + $22_1 | 0;
        $4_1 = ($6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
        $9_1 = $6_1;
        $6_1 = $6_1 + $21_1 | 0;
        $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $6_1 + $26_1 | 0;
        $4_1 = $9_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $13_1 >>> 20 | 0;
        $6_1 = $9_1 + $13_1 | 0;
        $4_1 = $13_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $9_1 = $6_1;
        $6_1 = $6_1 + $17_1 | 0;
        $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $6_1 << 12 | $16_1 >>> 20;
        $14_1 = $13_1 + $23_1 | 0;
        $15_1 = $4_1;
        $4_1 = $5_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
        $17_1 = $14_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($31_1, $14_1, $17_1, 0, 0, 15632, 16, 0, 0);
        $41_1 = $46_1 + 16 | 0;
        $28_1 = HEAP32[$10_1 + 480 >> 2];
        $6_1 = HEAP32[$10_1 + 128 >> 2];
        $26_1 = $28_1 + $6_1 | 0;
        $47_1 = HEAP32[$10_1 + 484 >> 2];
        $4_1 = $47_1 + HEAP32[$10_1 + 132 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = HEAP32[$10_1 + 400 >> 2];
        $22_1 = $6_1 + $26_1 | 0;
        $9_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 404 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = HEAP32[$10_1 + 32 >> 2];
        $21_1 = $6_1 + $22_1 | 0;
        $13_1 = $4_1;
        $4_1 = $4_1 + HEAP32[$10_1 + 36 >> 2] | 0;
        $6_1 = $6_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $43_1 = ($8_1 | 0) == ($12_1 | 0) & $18_1 >>> 0 < $24_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
        $35_1 = ($8_1 | 0) == ($27_1 | 0) & $25_1 >>> 0 > $24_1 >>> 0 | $8_1 >>> 0 < $27_1 >>> 0;
        $4_1 = $48_1 + 8 | 0;
        $31_1 = HEAP32[$4_1 >> 2];
        $24_1 = HEAP32[$4_1 + 4 >> 2];
        $18_1 = ($27_1 | 0) == ($34_1 | 0) & $25_1 >>> 0 < $49_1 >>> 0 | $27_1 >>> 0 < $34_1 >>> 0;
        $16_1 = $51_1 + 8 | 0;
        $8_1 = HEAP32[$16_1 >> 2];
        $4_1 = $50_1 + 8 | 0;
        $25_1 = $8_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$16_1 + 4 >> 2] | 0;
        $4_1 = $8_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $18_1 + $25_1 | 0;
        $4_1 = ($8_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $24_1 | 0;
        $16_1 = $8_1;
        $8_1 = $8_1 + $31_1 | 0;
        $4_1 = $16_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $16_1 = $8_1 + $35_1 | 0;
        $4_1 = $16_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $7_1 >>> 20 | 0;
        $8_1 = $7_1 + $16_1 | 0;
        $4_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $8_1;
        $8_1 = $8_1 + $43_1 | 0;
        $4_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $8_1 << 12 | $12_1 >>> 20;
        $16_1 = $12_1 + $21_1 | 0;
        $7_1 = $4_1;
        $4_1 = $6_1 + ($4_1 << 12 | $8_1 >>> 20) | 0;
        HEAP32[$41_1 >> 2] = $16_1;
        $12_1 = $12_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$41_1 + 4 >> 2] = $12_1 & 1048575;
        $25_1 = $10_1 + 16 | 0;
        $24_1 = $25_1;
        $18_1 = ($5_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $5_1 >>> 0 > $17_1 >>> 0;
        $14_1 = ($5_1 | 0) == ($38_1 | 0) & $23_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $38_1 >>> 0;
        $8_1 = $36_1 + 8 | 0;
        $5_1 = HEAP32[$8_1 >> 2];
        $4_1 = $40_1 + 8 | 0;
        $17_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $14_1 + $17_1 | 0;
        $4_1 = $8_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $15_1 >>> 20 | 0;
        $5_1 = $8_1 + $15_1 | 0;
        $4_1 = $15_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $5_1;
        $5_1 = $5_1 + $18_1 | 0;
        $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $69($24_1, $5_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
        $31_1 = $46_1 + 24 | 0;
        $27_1 = HEAP32[$10_1 + 20 >> 2];
        $4_1 = $27_1 + ($19_1 & 1048575) | 0;
        $24_1 = HEAP32[$10_1 + 16 >> 2];
        $8_1 = $30_1 + $24_1 | 0;
        $5_1 = $8_1 >>> 0 < $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $15_1 = $8_1;
        $23_1 = ($6_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $6_1 >>> 0 > $12_1 >>> 0;
        $17_1 = ($6_1 | 0) == ($13_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $13_1 >>> 0;
        $4_1 = $33_1 + 8 | 0;
        $21_1 = HEAP32[$4_1 >> 2];
        $19_1 = HEAP32[$4_1 + 4 >> 2];
        $18_1 = ($9_1 | 0) == ($13_1 | 0) & $22_1 >>> 0 < $26_1 >>> 0 | $9_1 >>> 0 > $13_1 >>> 0;
        $4_1 = $44_1 + 8 | 0;
        $14_1 = HEAP32[$4_1 >> 2];
        $16_1 = HEAP32[$4_1 + 4 >> 2];
        $13_1 = ($9_1 | 0) == ($47_1 | 0) & $26_1 >>> 0 < $28_1 >>> 0 | $9_1 >>> 0 < $47_1 >>> 0;
        $8_1 = $37_1 + 8 | 0;
        $6_1 = HEAP32[$8_1 >> 2];
        $4_1 = $42_1 + 8 | 0;
        $9_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
        $4_1 = $6_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $9_1 + $13_1 | 0;
        $4_1 = ($6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $16_1 | 0;
        $8_1 = $6_1;
        $6_1 = $6_1 + $14_1 | 0;
        $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $6_1;
        $6_1 = $6_1 + $18_1 | 0;
        $4_1 = ($8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $19_1 | 0;
        $8_1 = $6_1;
        $6_1 = $6_1 + $21_1 | 0;
        $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $6_1 + $17_1 | 0;
        $4_1 = $8_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $7_1 >>> 20 | 0;
        $6_1 = $7_1 + $8_1 | 0;
        $4_1 = $7_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $6_1;
        $6_1 = $6_1 + $23_1 | 0;
        $4_1 = $7_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $13_1 = $6_1 << 12 | $12_1 >>> 20;
        $7_1 = $13_1 + $15_1 | 0;
        $8_1 = $4_1;
        $4_1 = $5_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
        HEAP32[$31_1 >> 2] = $7_1;
        $6_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        HEAP32[$31_1 + 4 >> 2] = $6_1 & 1048575;
        $12_1 = $46_1 + 32 | 0;
        $9_1 = $20_1 & 65535;
        $13_1 = ($5_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
        $5_1 = ($5_1 | 0) == ($27_1 | 0) & $15_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 < $27_1 >>> 0;
        $4_1 = $25_1 + 8 | 0;
        $7_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
        $4_1 = HEAP32[$4_1 + 4 >> 2];
        $4_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $8_1 = $8_1 >>> 20 | 0;
        $5_1 = $7_1 + $8_1 | 0;
        $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $7_1 = $5_1;
        $5_1 = $5_1 + $13_1 | 0;
        $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $6_1 = $5_1 << 12 | $6_1 >>> 20;
        $8_1 = $6_1 + $11_1 | 0;
        $4_1 = $9_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
        HEAP32[$12_1 >> 2] = $8_1;
        HEAP32[$12_1 + 4 >> 2] = $6_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $2_1 = $2_1 + 88 | 0;
        $1_1 = $1_1 + 40 | 0;
        if (($1_1 | 0) != 320) {
          continue;
        }
        break;
      }
      ;
      $2_1 = ($32_1 | 0) < ($62_1 | 0) ? $62_1 : $32_1;
      $1_1 = 1;
    }
    label$8: {
      if (!$3_1) {
        $12_1 = 0;
        $13_1 = 0;
        break label$8;
      }
      $6_1 = $10_1 + 3648 | 0;
      $4_1 = $6_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      $5_1 = $10_1 + 3616 | 0;
      $4_1 = $5_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = 0;
      HEAP32[$4_1 + 4 >> 2] = 0;
      HEAP32[$10_1 + 3664 >> 2] = 0;
      HEAP32[$10_1 + 3668 >> 2] = 0;
      HEAP32[$10_1 + 3632 >> 2] = 0;
      HEAP32[$10_1 + 3636 >> 2] = 0;
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      HEAP32[$10_1 + 3648 >> 2] = HEAP32[$3_1 >> 2];
      HEAP32[$10_1 + 3652 >> 2] = $4_1;
      $4_1 = HEAP32[$3_1 + 12 >> 2];
      HEAP32[$10_1 + 3656 >> 2] = HEAP32[$3_1 + 8 >> 2];
      HEAP32[$10_1 + 3660 >> 2] = $4_1;
      $4_1 = HEAP32[$3_1 + 20 >> 2];
      HEAP32[$10_1 + 3616 >> 2] = HEAP32[$3_1 + 16 >> 2];
      HEAP32[$10_1 + 3620 >> 2] = $4_1;
      $4_1 = HEAP32[$3_1 + 28 >> 2];
      HEAP32[$10_1 + 3624 >> 2] = HEAP32[$3_1 + 24 >> 2];
      HEAP32[$10_1 + 3628 >> 2] = $4_1;
      $12_1 = $62($10_1 + 3088 | 0, $6_1, 4);
      $13_1 = $62($10_1 + 2560 | 0, $5_1, 4);
      $2_1 = ($2_1 | 0) < ($12_1 | 0) ? $12_1 : $2_1;
      $2_1 = ($2_1 | 0) < ($13_1 | 0) ? $13_1 : $2_1;
    }
    HEAP32[$0_1 + 120 >> 2] = 1;
    $14_1 = $68($0_1, 120);
    label$10: {
      if (($2_1 | 0) <= 0) {
        break label$10;
      }
      $0_1 = $2_1 - 1 | 0;
      label$11: {
        if (!$1_1) {
          $0_1 = $0_1 << 2;
          $3_1 = $0_1 + ($10_1 + 3088 | 0) | 0;
          $0_1 = ($10_1 + 2560 | 0) + $0_1 | 0;
          $11_1 = 1;
          while (1) {
            label$14: {
              if ($11_1) {
                HEAP32[$14_1 + 120 >> 2] = 1;
                $68($14_1, 120);
                break label$14;
              }
              $55($14_1, $14_1);
            }
            label$16: {
              if (($2_1 | 0) > ($12_1 | 0)) {
                break label$16;
              }
              $4_1 = HEAP32[$3_1 >> 2];
              if (!$4_1) {
                break label$16;
              }
              $1_1 = $10_1 + 3720 | 0;
              $63($1_1, 655920, $4_1);
              $64($14_1, $14_1, $1_1, $10_1 + 3680 | 0);
            }
            $1_1 = $2_1 - 1 | 0;
            label$17: {
              if (($2_1 | 0) > ($13_1 | 0)) {
                break label$17;
              }
              $4_1 = HEAP32[$0_1 >> 2];
              if (!$4_1) {
                break label$17;
              }
              $2_1 = $10_1 + 3720 | 0;
              $63($2_1, 656176, $4_1);
              $64($14_1, $14_1, $2_1, $10_1 + 3680 | 0);
            }
            if (($1_1 | 0) <= 0) {
              break label$11;
            }
            $3_1 = $3_1 - 4 | 0;
            $0_1 = $0_1 - 4 | 0;
            $11_1 = HEAP32[$14_1 + 120 >> 2];
            $2_1 = $1_1;
            continue;
          }
          ;
        }
        $16_1 = $10_1 + 3760 | 0;
        $3_1 = (($2_1 << 2) + $10_1 | 0) + 1008 | 0;
        $1_1 = $0_1 << 2;
        $0_1 = $1_1 + ($10_1 + 3088 | 0) | 0;
        $11_1 = ($10_1 + 2560 | 0) + $1_1 | 0;
        $7_1 = HEAP32[$10_1 + 1532 >> 2];
        $8_1 = HEAP32[$10_1 + 1528 >> 2];
        $4_1 = 1;
        while (1) {
          label$19: {
            if ($4_1) {
              HEAP32[$14_1 + 120 >> 2] = 1;
              $68($14_1, 120);
              break label$19;
            }
            $55($14_1, $14_1);
          }
          label$21: {
            if (($2_1 | 0) > ($8_1 | 0)) {
              break label$21;
            }
            $1_1 = HEAP32[$3_1 - 516 >> 2];
            if (!$1_1) {
              break label$21;
            }
            label$22: {
              if (($1_1 | 0) <= 0) {
                $70($10_1 + 3720 | 0, ($10_1 + 1536 | 0) + Math_imul(($1_1 ^ -1) / 2 | 0, 88) | 0, 88);
                $1_1 = HEAP32[$10_1 + 3760 >> 2];
                $4_1 = -3908 - $1_1 | 0;
                $1_1 = 4194299 - (HEAP32[$10_1 + 3764 >> 2] + ($1_1 >>> 0 > 4294963388) | 0) | 0;
                HEAP32[$10_1 + 3760 >> 2] = $4_1;
                HEAP32[$10_1 + 3764 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3768 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 4194303 - (HEAP32[$10_1 + 3772 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3768 >> 2] = $4_1;
                HEAP32[$10_1 + 3772 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3776 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 4194303 - (HEAP32[$10_1 + 3780 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3776 >> 2] = $4_1;
                HEAP32[$10_1 + 3780 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3784 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 4194303 - (HEAP32[$10_1 + 3788 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3784 >> 2] = $4_1;
                HEAP32[$10_1 + 3788 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3792 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 262143 - (HEAP32[$10_1 + 3796 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3792 >> 2] = $4_1;
                HEAP32[$10_1 + 3796 >> 2] = $1_1;
                break label$22;
              }
              $70($10_1 + 3720 | 0, ($10_1 + 1536 | 0) + Math_imul($1_1 - 1 >>> 1 | 0, 88) | 0, 88);
            }
            $65($14_1, $14_1, $10_1 + 3720 | 0, 0);
          }
          label$24: {
            if (($2_1 | 0) > ($7_1 | 0)) {
              break label$24;
            }
            $1_1 = HEAP32[$3_1 >> 2];
            if (!$1_1) {
              break label$24;
            }
            label$25: {
              if (($1_1 | 0) <= 0) {
                $6_1 = ($1_1 ^ -1) / 2 | 0;
                $9_1 = ($10_1 + 1536 | 0) + Math_imul($6_1, 88) | 0;
                $1_1 = HEAP32[$9_1 + 44 >> 2];
                HEAP32[$16_1 >> 2] = HEAP32[$9_1 + 40 >> 2];
                HEAP32[$16_1 + 4 >> 2] = $1_1;
                $5_1 = $9_1 + 48 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 8 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 56 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 16 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 - -64 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 24 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 72 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $16_1 + 32 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $9_1 = ($10_1 + 2240 | 0) + Math_imul($6_1, 40) | 0;
                $5_1 = $9_1 + 8 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $6_1 = $10_1 + 3720 | 0;
                $1_1 = $6_1 + 8 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 16 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $6_1 + 16 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 24 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $6_1 + 24 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                $5_1 = $9_1 + 32 | 0;
                $4_1 = HEAP32[$5_1 + 4 >> 2];
                $1_1 = $6_1 + 32 | 0;
                HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
                HEAP32[$1_1 + 4 >> 2] = $4_1;
                HEAP32[$10_1 + 3800 >> 2] = 0;
                $1_1 = HEAP32[$9_1 + 4 >> 2];
                HEAP32[$10_1 + 3720 >> 2] = HEAP32[$9_1 >> 2];
                HEAP32[$10_1 + 3724 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3760 >> 2];
                $4_1 = -3908 - $1_1 | 0;
                $1_1 = 4194299 - (HEAP32[$10_1 + 3764 >> 2] + ($1_1 >>> 0 > 4294963388) | 0) | 0;
                HEAP32[$10_1 + 3760 >> 2] = $4_1;
                HEAP32[$10_1 + 3764 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3768 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 4194303 - (HEAP32[$10_1 + 3772 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3768 >> 2] = $4_1;
                HEAP32[$10_1 + 3772 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3776 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 4194303 - (HEAP32[$10_1 + 3780 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3776 >> 2] = $4_1;
                HEAP32[$10_1 + 3780 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3784 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 4194303 - (HEAP32[$10_1 + 3788 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3784 >> 2] = $4_1;
                HEAP32[$10_1 + 3788 >> 2] = $1_1;
                $1_1 = HEAP32[$10_1 + 3792 >> 2];
                $4_1 = -4 - $1_1 | 0;
                $1_1 = 262143 - (HEAP32[$10_1 + 3796 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
                HEAP32[$10_1 + 3792 >> 2] = $4_1;
                HEAP32[$10_1 + 3796 >> 2] = $1_1;
                break label$25;
              }
              $4_1 = $1_1 - 1 >>> 1 | 0;
              $15_1 = ($10_1 + 1536 | 0) + Math_imul($4_1, 88) | 0;
              $1_1 = HEAP32[$15_1 + 44 >> 2];
              HEAP32[$16_1 >> 2] = HEAP32[$15_1 + 40 >> 2];
              HEAP32[$16_1 + 4 >> 2] = $1_1;
              $9_1 = ($10_1 + 2240 | 0) + Math_imul($4_1, 40) | 0;
              $5_1 = $9_1 + 8 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $6_1 = $10_1 + 3720 | 0;
              $1_1 = $6_1 + 8 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $9_1 + 16 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $6_1 + 16 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $9_1 + 24 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $6_1 + 24 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $9_1 + 32 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $6_1 + 32 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $15_1 + 48 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $16_1 + 8 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $15_1 + 56 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $16_1 + 16 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $15_1 - -64 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $16_1 + 24 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              $5_1 = $15_1 + 72 | 0;
              $4_1 = HEAP32[$5_1 + 4 >> 2];
              $1_1 = $16_1 + 32 | 0;
              HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
              HEAP32[$1_1 + 4 >> 2] = $4_1;
              HEAP32[$10_1 + 3800 >> 2] = 0;
              $1_1 = HEAP32[$9_1 + 4 >> 2];
              HEAP32[$10_1 + 3720 >> 2] = HEAP32[$9_1 >> 2];
              HEAP32[$10_1 + 3724 >> 2] = $1_1;
            }
            $65($14_1, $14_1, $10_1 + 3720 | 0, 0);
          }
          label$27: {
            if (($2_1 | 0) > ($12_1 | 0)) {
              break label$27;
            }
            $4_1 = HEAP32[$0_1 >> 2];
            if (!$4_1) {
              break label$27;
            }
            $1_1 = $10_1 + 3720 | 0;
            $63($1_1, 655920, $4_1);
            $64($14_1, $14_1, $1_1, $10_1 + 3680 | 0);
          }
          $1_1 = $2_1 - 1 | 0;
          label$28: {
            if (($2_1 | 0) > ($13_1 | 0)) {
              break label$28;
            }
            $4_1 = HEAP32[$11_1 >> 2];
            if (!$4_1) {
              break label$28;
            }
            $2_1 = $10_1 + 3720 | 0;
            $63($2_1, 656176, $4_1);
            $64($14_1, $14_1, $2_1, $10_1 + 3680 | 0);
          }
          if (($1_1 | 0) <= 0) {
            break label$11;
          }
          $0_1 = $0_1 - 4 | 0;
          $11_1 = $11_1 - 4 | 0;
          $3_1 = $3_1 - 4 | 0;
          $4_1 = HEAP32[$14_1 + 120 >> 2];
          $2_1 = $1_1;
          continue;
        }
        ;
      }
      if (HEAP32[$14_1 + 120 >> 2]) {
        break label$10;
      }
      $0_1 = $14_1 + 80 | 0;
      $34($0_1, $0_1, $10_1 + 3680 | 0);
    }
    global$0 = $10_1 + 3808 | 0;
  }
  function $43($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
    $8_1 = global$0 - 48 | 0;
    global$0 = $8_1;
    $3_1 = $8_1 + 8 | 0;
    $54($3_1, $1_1 + 80 | 0);
    $34($3_1, $3_1, $0_1);
    $5_1 = HEAP32[$1_1 + 24 >> 2];
    $4_1 = HEAP32[$1_1 + 28 >> 2];
    $9_1 = HEAP32[$1_1 + 16 >> 2];
    $6_1 = HEAP32[$1_1 + 20 >> 2];
    $3_1 = HEAP32[$1_1 + 8 >> 2];
    $11_1 = HEAP32[$1_1 + 12 >> 2];
    $2_1 = HEAP32[$1_1 >> 2];
    $7_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = HEAP32[$1_1 + 32 >> 2];
    $1_1 = HEAP32[$1_1 + 36 >> 2];
    $13_1 = $1_1;
    $0_1 = $2_1;
    $2_1 = __wasm_i64_mul($1_1 >>> 16 | 0, 0, 977, 1);
    $1_1 = $0_1 + $2_1 | 0;
    $0_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
    $0_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $2_1 = $1_1;
    $7_1 = $0_1;
    $0_1 = $11_1;
    $1_1 = $7_1 >>> 20 | 0;
    $10_1 = $1_1;
    $1_1 = $1_1 + $3_1 | 0;
    $11_1 = $10_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $6_1;
    $3_1 = $11_1 >>> 20 | 0;
    $9_1 = $3_1 + $9_1 | 0;
    $6_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $4_1;
    $3_1 = $6_1 >>> 20 | 0;
    $5_1 = $3_1 + $5_1 | 0;
    $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = HEAP32[$8_1 + 8 >> 2];
    $4_1 = $2_1 - $0_1 | 0;
    $14_1 = ($7_1 & 1048575) - (HEAP32[$8_1 + 12 >> 2] + ($0_1 >>> 0 > $2_1 >>> 0) | 0) | 0;
    $0_1 = HEAP32[$8_1 + 40 >> 2];
    $7_1 = $12_1 - $0_1 | 0;
    $0_1 = ($13_1 & 65535) - (HEAP32[$8_1 + 44 >> 2] + ($0_1 >>> 0 > $12_1 >>> 0) | 0) | 0;
    $2_1 = $3_1 >>> 20 | 0;
    $10_1 = $2_1;
    $2_1 = $2_1 + $7_1 | 0;
    $0_1 = ($10_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 262143 | 0;
    $10_1 = $4_1;
    $2_1 = $2_1 - 4 | 0;
    $12_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = __wasm_i64_mul($12_1 >>> 16 | 0, 0, 977, 1);
    $7_1 = $10_1 + $4_1 | 0;
    $0_1 = $14_1 + i64toi32_i32$HIGH_BITS | 0;
    $0_1 = ($7_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194299 | 0;
    $7_1 = $7_1 - 3908 | 0;
    $0_1 = $7_1 >>> 0 < 4294963388 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $0_1 & 1048575;
    $15_1 = $4_1;
    $13_1 = $7_1 ^ 976;
    $14_1 = $4_1 ^ 1;
    global$0 = $8_1 + 48 | 0;
    label$1: {
      if ($7_1 | $4_1) {
        $4_1 = 0;
        if (($13_1 | 0) != -1 | ($14_1 | 0) != 1048575) {
          break label$1;
        }
      }
      $4_1 = $2_1;
      $12_1 = $12_1 & 65535;
      $2_1 = HEAP32[$8_1 + 32 >> 2];
      $16_1 = $5_1 - $2_1 | 0;
      $10_1 = ($3_1 & 1048575) - (HEAP32[$8_1 + 36 >> 2] + ($2_1 >>> 0 > $5_1 >>> 0) | 0) | 0;
      $3_1 = HEAP32[$8_1 + 24 >> 2];
      $5_1 = $9_1 - $3_1 | 0;
      $9_1 = ($6_1 & 1048575) - (HEAP32[$8_1 + 28 >> 2] + ($3_1 >>> 0 > $9_1 >>> 0) | 0) | 0;
      $3_1 = $0_1;
      $0_1 = $11_1 & 1048575;
      $3_1 = $3_1 >>> 20 | 0;
      $2_1 = $3_1;
      $3_1 = $1_1 + $3_1 | 0;
      $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $2_1 = HEAP32[$8_1 + 16 >> 2];
      $1_1 = ($3_1 - $2_1 | 0) - 4 | 0;
      $0_1 = ($0_1 - (HEAP32[$8_1 + 20 >> 2] + ($3_1 >>> 0 < $2_1 >>> 0) | 0) | 0) + 4194303 | 0;
      $3_1 = $1_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $9_1;
      $2_1 = $3_1 >>> 20 | 0;
      $6_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $0_1 = ($6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
      $2_1 = $2_1 - 4 | 0;
      $9_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $10_1;
      $5_1 = $9_1 >>> 20 | 0;
      $6_1 = $5_1;
      $5_1 = $5_1 + $16_1 | 0;
      $0_1 = ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
      $5_1 = $5_1 - 4 | 0;
      $11_1 = $5_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $12_1;
      $6_1 = $11_1 >>> 20 | 0;
      $10_1 = $6_1;
      $6_1 = $4_1 + $6_1 | 0;
      $0_1 = $10_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      if (($1_1 & $13_1 & $2_1 & $5_1 & $6_1) == -1) {
        $4_1 = ($3_1 & $14_1 & $9_1 & $11_1 & ($0_1 ^ 983040)) == 1048575;
      } else {
        $4_1 = 0;
      }
      if ($4_1) {
        $1_1 = 0;
        $0_1 = 0;
      } else {
        $1_1 = $5_1 | ($2_1 | ($1_1 | $7_1)) | $6_1;
        $0_1 = $11_1 & 1048575 | ($9_1 & 1048575 | ($3_1 & 1048575 | $15_1)) | $0_1;
      }
      $4_1 = !($0_1 | $1_1);
    }
    return $4_1;
  }
  function $44($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    $2_1 = $2_1 | 0;
    $3_1 = $3_1 | 0;
    $4_1 = $4_1 | 0;
    $5_1 = $5_1 | 0;
    var $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0;
    $6_1 = global$0 - 224 | 0;
    global$0 = $6_1;
    $38($6_1 + 8 | 0, $1_1, 0);
    $1_1 = $2_1 + 16 | 0;
    $7_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $8_1 = $6_1 + 112 | 0;
    $9_1 = $8_1 + 16 | 0;
    HEAP32[$9_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$9_1 + 4 >> 2] = $7_1;
    $1_1 = $2_1 + 24 | 0;
    $7_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $8_1 = $8_1 + 24 | 0;
    HEAP32[$8_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$8_1 + 4 >> 2] = $7_1;
    $1_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    HEAP32[$6_1 + 112 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$6_1 + 116 >> 2] = $1_1;
    $1_1 = $2_1 + 8 | 0;
    $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    HEAP32[$6_1 + 120 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$6_1 + 124 >> 2] = $2_1;
    $1_1 = HEAP32[$6_1 + 12 >> 2];
    $9_1 = HEAP32[$6_1 + 8 >> 2];
    HEAP8[$6_1 + 175 | 0] = $9_1;
    $2_1 = HEAP32[$6_1 + 20 >> 2];
    $10_1 = HEAP32[$6_1 + 16 >> 2];
    HEAP8[$6_1 + 167 | 0] = $10_1;
    $7_1 = HEAP32[$6_1 + 28 >> 2];
    $11_1 = HEAP32[$6_1 + 24 >> 2];
    HEAP8[$6_1 + 159 | 0] = $11_1;
    $8_1 = HEAP32[$6_1 + 36 >> 2];
    $12_1 = HEAP32[$6_1 + 32 >> 2];
    HEAP8[$6_1 + 151 | 0] = $12_1;
    HEAP8[$6_1 + 174 | 0] = ($1_1 & 255) << 24 | $9_1 >>> 8;
    HEAP8[$6_1 + 173 | 0] = ($1_1 & 65535) << 16 | $9_1 >>> 16;
    HEAP8[$6_1 + 172 | 0] = ($1_1 & 16777215) << 8 | $9_1 >>> 24;
    HEAP8[$6_1 + 171 | 0] = $1_1;
    HEAP8[$6_1 + 170 | 0] = $1_1 >>> 8;
    HEAP8[$6_1 + 169 | 0] = $1_1 >>> 16;
    HEAP8[$6_1 + 168 | 0] = $1_1 >>> 24;
    HEAP8[$6_1 + 166 | 0] = ($2_1 & 255) << 24 | $10_1 >>> 8;
    HEAP8[$6_1 + 165 | 0] = ($2_1 & 65535) << 16 | $10_1 >>> 16;
    HEAP8[$6_1 + 164 | 0] = ($2_1 & 16777215) << 8 | $10_1 >>> 24;
    HEAP8[$6_1 + 163 | 0] = $2_1;
    HEAP8[$6_1 + 162 | 0] = $2_1 >>> 8;
    HEAP8[$6_1 + 161 | 0] = $2_1 >>> 16;
    HEAP8[$6_1 + 160 | 0] = $2_1 >>> 24;
    HEAP8[$6_1 + 158 | 0] = ($7_1 & 255) << 24 | $11_1 >>> 8;
    HEAP8[$6_1 + 157 | 0] = ($7_1 & 65535) << 16 | $11_1 >>> 16;
    HEAP8[$6_1 + 156 | 0] = ($7_1 & 16777215) << 8 | $11_1 >>> 24;
    HEAP8[$6_1 + 155 | 0] = $7_1;
    HEAP8[$6_1 + 154 | 0] = $7_1 >>> 8;
    HEAP8[$6_1 + 153 | 0] = $7_1 >>> 16;
    HEAP8[$6_1 + 152 | 0] = $7_1 >>> 24;
    HEAP8[$6_1 + 150 | 0] = ($8_1 & 255) << 24 | $12_1 >>> 8;
    HEAP8[$6_1 + 149 | 0] = ($8_1 & 65535) << 16 | $12_1 >>> 16;
    HEAP8[$6_1 + 148 | 0] = ($8_1 & 16777215) << 8 | $12_1 >>> 24;
    HEAP8[$6_1 + 147 | 0] = $8_1;
    HEAP8[$6_1 + 146 | 0] = $8_1 >>> 8;
    HEAP8[$6_1 + 145 | 0] = $8_1 >>> 16;
    HEAP8[$6_1 + 144 | 0] = $8_1 >>> 24;
    if ($4_1) {
      $1_1 = $4_1 + 24 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $7_1 = $6_1 + 200 | 0;
      HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$7_1 + 4 >> 2] = $2_1;
      $1_1 = $4_1 + 16 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $7_1 = $6_1 + 192 | 0;
      HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$7_1 + 4 >> 2] = $2_1;
      $1_1 = $4_1 + 8 | 0;
      $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $7_1 = $6_1 + 184 | 0;
      HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$7_1 + 4 >> 2] = $2_1;
      $1_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
      HEAP32[$6_1 + 176 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 180 >> 2] = $1_1;
      $2_1 = 96;
    } else {
      $2_1 = 64;
    }
    if ($3_1) {
      $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $1_1 = ($6_1 + 112 | 0) + $2_1 | 0;
      $7_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP8[$1_1 | 0] = $7_1;
      HEAP8[$1_1 + 1 | 0] = $7_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $7_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $7_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $4_1;
      HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
      $3_1 = $3_1 + 8 | 0;
      $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $1_1 = $1_1 + 8 | 0;
      $3_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP8[$1_1 | 0] = $3_1;
      HEAP8[$1_1 + 1 | 0] = $3_1 >>> 8;
      HEAP8[$1_1 + 2 | 0] = $3_1 >>> 16;
      HEAP8[$1_1 + 3 | 0] = $3_1 >>> 24;
      HEAP8[$1_1 + 4 | 0] = $4_1;
      HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
      HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
      HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
      $2_1 = $2_1 | 16;
    }
    $1_1 = $6_1 + 112 | 0;
    $45($6_1 + 40 | 0, $1_1, $2_1);
    $2_1 = 0;
    $68($1_1, 112);
    while (1) {
      $46($6_1 + 40 | 0, $0_1);
      $2_1 = $2_1 + 1 | 0;
      if ($5_1 >>> 0 >= $2_1 >>> 0) {
        continue;
      }
      break;
    }
    ;
    global$0 = $6_1 + 224 | 0;
    return 1;
  }
  function $45($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0;
    $3_1 = global$0 - 272 | 0;
    global$0 = $3_1;
    HEAP32[$0_1 >> 2] = 16843009;
    HEAP32[$0_1 + 4 >> 2] = 16843009;
    HEAP32[$0_1 + 32 >> 2] = 0;
    HEAP32[$0_1 + 36 >> 2] = 0;
    $6_1 = $0_1 + 24 | 0;
    HEAP32[$6_1 >> 2] = 16843009;
    HEAP32[$6_1 + 4 >> 2] = 16843009;
    $6_1 = $0_1 + 16 | 0;
    HEAP32[$6_1 >> 2] = 16843009;
    HEAP32[$6_1 + 4 >> 2] = 16843009;
    $6_1 = $0_1 + 8 | 0;
    HEAP32[$6_1 >> 2] = 16843009;
    HEAP32[$6_1 + 4 >> 2] = 16843009;
    $6_1 = $0_1 + 40 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $0_1 + 48 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $0_1 + 56 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $3_1 + 128 | 0;
    HEAP32[$6_1 >> 2] = 528734635;
    HEAP32[$6_1 + 4 >> 2] = 1541459225;
    $6_1 = $3_1 + 120 | 0;
    HEAP32[$6_1 >> 2] = 1359893119;
    HEAP32[$6_1 + 4 >> 2] = -1694144372;
    $6_1 = $3_1 + 112 | 0;
    HEAP32[$6_1 >> 2] = 1013904242;
    HEAP32[$6_1 + 4 >> 2] = -1521486534;
    $6_1 = $3_1 + 200 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $3_1 + 208 | 0;
    $4_1 = $6_1 + 56 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $6_1 + 48 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $6_1 + 40 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $6_1 + 32 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $6_1 + 24 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $6_1 = $6_1 + 16 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 104 >> 2] = 1779033703;
    HEAP32[$3_1 + 108 >> 2] = -1150833019;
    HEAP32[$3_1 + 216 >> 2] = 0;
    HEAP32[$3_1 + 220 >> 2] = 0;
    HEAP32[$3_1 + 208 >> 2] = 0;
    HEAP32[$3_1 + 212 >> 2] = 0;
    $6_1 = $0_1 + 32 | 0;
    $8_1 = $3_1 + 104 | 0;
    $4_1 = 0;
    while (1) {
      $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $7_1 = $5_1 + 1 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
      $7_1 = $5_1 + 2 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
      $5_1 = $5_1 + 3 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $29($8_1, $3_1 + 208 | 0, 64);
    HEAP32[$3_1 + 96 >> 2] = 0;
    HEAP32[$3_1 + 100 >> 2] = 0;
    HEAP32[$3_1 + 24 >> 2] = 528734635;
    HEAP32[$3_1 + 28 >> 2] = 1541459225;
    HEAP32[$3_1 + 16 >> 2] = 1359893119;
    HEAP32[$3_1 + 20 >> 2] = -1694144372;
    HEAP32[$3_1 + 8 >> 2] = 1013904242;
    HEAP32[$3_1 + 12 >> 2] = -1521486534;
    HEAP32[$3_1 >> 2] = 1779033703;
    HEAP32[$3_1 + 4 >> 2] = -1150833019;
    $4_1 = 0;
    while (1) {
      $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $7_1 = $5_1 + 1 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
      $7_1 = $5_1 + 2 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
      $5_1 = $5_1 + 3 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $5_1 = $3_1 + 208 | 0;
    $29($3_1, $5_1, 64);
    $29($3_1, $0_1, 32);
    $29($3_1, 690368, 1);
    $29($3_1, $1_1, $2_1);
    $30($3_1, $5_1);
    $29($8_1, $5_1, 32);
    $30($8_1, $6_1);
    $4_1 = $3_1 + 248 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $3_1 + 256 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $3_1 + 264 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $6_1 + 24 | 0;
    $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
    $9_1 = $5_1 + 24 | 0;
    HEAP32[$9_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
    HEAP32[$9_1 + 4 >> 2] = $7_1;
    $4_1 = $6_1 + 16 | 0;
    $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
    $5_1 = $5_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
    HEAP32[$5_1 + 4 >> 2] = $7_1;
    HEAP32[$3_1 + 200 >> 2] = 0;
    HEAP32[$3_1 + 204 >> 2] = 0;
    HEAP32[$3_1 + 128 >> 2] = 528734635;
    HEAP32[$3_1 + 132 >> 2] = 1541459225;
    HEAP32[$3_1 + 120 >> 2] = 1359893119;
    HEAP32[$3_1 + 124 >> 2] = -1694144372;
    HEAP32[$3_1 + 112 >> 2] = 1013904242;
    HEAP32[$3_1 + 116 >> 2] = -1521486534;
    HEAP32[$3_1 + 104 >> 2] = 1779033703;
    HEAP32[$3_1 + 108 >> 2] = -1150833019;
    HEAP32[$3_1 + 240 >> 2] = 0;
    HEAP32[$3_1 + 244 >> 2] = 0;
    $4_1 = $6_1 + 8 | 0;
    $5_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
    HEAP32[$3_1 + 216 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
    HEAP32[$3_1 + 220 >> 2] = $5_1;
    $4_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
    HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
    HEAP32[$3_1 + 212 >> 2] = $4_1;
    $4_1 = 0;
    while (1) {
      $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $7_1 = $5_1 + 1 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
      $7_1 = $5_1 + 2 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
      $5_1 = $5_1 + 3 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $29($8_1, $3_1 + 208 | 0, 64);
    HEAP32[$3_1 + 96 >> 2] = 0;
    HEAP32[$3_1 + 100 >> 2] = 0;
    HEAP32[$3_1 + 24 >> 2] = 528734635;
    HEAP32[$3_1 + 28 >> 2] = 1541459225;
    HEAP32[$3_1 + 16 >> 2] = 1359893119;
    HEAP32[$3_1 + 20 >> 2] = -1694144372;
    HEAP32[$3_1 + 8 >> 2] = 1013904242;
    HEAP32[$3_1 + 12 >> 2] = -1521486534;
    HEAP32[$3_1 >> 2] = 1779033703;
    HEAP32[$3_1 + 4 >> 2] = -1150833019;
    $4_1 = 0;
    while (1) {
      $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $7_1 = $5_1 + 1 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
      $7_1 = $5_1 + 2 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
      $5_1 = $5_1 + 3 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $5_1 = $3_1 + 208 | 0;
    $29($3_1, $5_1, 64);
    $29($3_1, $0_1, 32);
    $30($3_1, $5_1);
    $29($8_1, $5_1, 32);
    $30($8_1, $0_1);
    $4_1 = $3_1 + 248 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $3_1 + 256 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $3_1 + 264 | 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    $4_1 = $6_1 + 24 | 0;
    $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
    $9_1 = $5_1 + 24 | 0;
    HEAP32[$9_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
    HEAP32[$9_1 + 4 >> 2] = $7_1;
    $4_1 = $6_1 + 16 | 0;
    $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
    $5_1 = $5_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
    HEAP32[$5_1 + 4 >> 2] = $7_1;
    HEAP32[$3_1 + 200 >> 2] = 0;
    HEAP32[$3_1 + 204 >> 2] = 0;
    HEAP32[$3_1 + 128 >> 2] = 528734635;
    HEAP32[$3_1 + 132 >> 2] = 1541459225;
    HEAP32[$3_1 + 120 >> 2] = 1359893119;
    HEAP32[$3_1 + 124 >> 2] = -1694144372;
    HEAP32[$3_1 + 112 >> 2] = 1013904242;
    HEAP32[$3_1 + 116 >> 2] = -1521486534;
    HEAP32[$3_1 + 104 >> 2] = 1779033703;
    HEAP32[$3_1 + 108 >> 2] = -1150833019;
    HEAP32[$3_1 + 240 >> 2] = 0;
    HEAP32[$3_1 + 244 >> 2] = 0;
    $4_1 = $6_1 + 8 | 0;
    $5_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
    HEAP32[$3_1 + 216 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
    HEAP32[$3_1 + 220 >> 2] = $5_1;
    $4_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
    HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
    HEAP32[$3_1 + 212 >> 2] = $4_1;
    $4_1 = 0;
    while (1) {
      $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $7_1 = $5_1 + 1 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
      $7_1 = $5_1 + 2 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
      $5_1 = $5_1 + 3 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $29($8_1, $3_1 + 208 | 0, 64);
    HEAP32[$3_1 + 96 >> 2] = 0;
    HEAP32[$3_1 + 100 >> 2] = 0;
    HEAP32[$3_1 + 24 >> 2] = 528734635;
    HEAP32[$3_1 + 28 >> 2] = 1541459225;
    HEAP32[$3_1 + 16 >> 2] = 1359893119;
    HEAP32[$3_1 + 20 >> 2] = -1694144372;
    HEAP32[$3_1 + 8 >> 2] = 1013904242;
    HEAP32[$3_1 + 12 >> 2] = -1521486534;
    HEAP32[$3_1 >> 2] = 1779033703;
    HEAP32[$3_1 + 4 >> 2] = -1150833019;
    $4_1 = 0;
    while (1) {
      $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $7_1 = $5_1 + 1 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
      $7_1 = $5_1 + 2 | 0;
      HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
      $5_1 = $5_1 + 3 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $4_1 = $3_1 + 208 | 0;
    $29($3_1, $4_1, 64);
    $29($3_1, $0_1, 32);
    $29($3_1, 690369, 1);
    $29($3_1, $1_1, $2_1);
    $30($3_1, $4_1);
    $29($8_1, $4_1, 32);
    $30($8_1, $6_1);
    $1_1 = $3_1 + 248 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 256 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $3_1 + 264 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $6_1 + 24 | 0;
    $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $5_1 = $4_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$5_1 + 4 >> 2] = $2_1;
    $1_1 = $6_1 + 16 | 0;
    $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $4_1 = $4_1 + 16 | 0;
    HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$4_1 + 4 >> 2] = $2_1;
    HEAP32[$3_1 + 200 >> 2] = 0;
    HEAP32[$3_1 + 204 >> 2] = 0;
    HEAP32[$3_1 + 128 >> 2] = 528734635;
    HEAP32[$3_1 + 132 >> 2] = 1541459225;
    HEAP32[$3_1 + 120 >> 2] = 1359893119;
    HEAP32[$3_1 + 124 >> 2] = -1694144372;
    HEAP32[$3_1 + 112 >> 2] = 1013904242;
    HEAP32[$3_1 + 116 >> 2] = -1521486534;
    HEAP32[$3_1 + 104 >> 2] = 1779033703;
    HEAP32[$3_1 + 108 >> 2] = -1150833019;
    HEAP32[$3_1 + 240 >> 2] = 0;
    HEAP32[$3_1 + 244 >> 2] = 0;
    $1_1 = $6_1 + 8 | 0;
    $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    HEAP32[$3_1 + 216 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$3_1 + 220 >> 2] = $2_1;
    $1_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
    HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
    HEAP32[$3_1 + 212 >> 2] = $1_1;
    $4_1 = 0;
    while (1) {
      $1_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 92;
      $2_1 = $1_1 + 1 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
      $2_1 = $1_1 + 2 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
      $1_1 = $1_1 + 3 | 0;
      HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 92;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $29($8_1, $3_1 + 208 | 0, 64);
    HEAP32[$3_1 + 96 >> 2] = 0;
    HEAP32[$3_1 + 100 >> 2] = 0;
    HEAP32[$3_1 + 24 >> 2] = 528734635;
    HEAP32[$3_1 + 28 >> 2] = 1541459225;
    HEAP32[$3_1 + 16 >> 2] = 1359893119;
    HEAP32[$3_1 + 20 >> 2] = -1694144372;
    HEAP32[$3_1 + 8 >> 2] = 1013904242;
    HEAP32[$3_1 + 12 >> 2] = -1521486534;
    HEAP32[$3_1 >> 2] = 1779033703;
    HEAP32[$3_1 + 4 >> 2] = -1150833019;
    $4_1 = 0;
    while (1) {
      $1_1 = ($3_1 + 208 | 0) + $4_1 | 0;
      HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 106;
      $2_1 = $1_1 + 1 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
      $2_1 = $1_1 + 2 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
      $1_1 = $1_1 + 3 | 0;
      HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 106;
      $4_1 = $4_1 + 4 | 0;
      if (($4_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $1_1 = $3_1 + 208 | 0;
    $29($3_1, $1_1, 64);
    $29($3_1, $0_1, 32);
    $30($3_1, $1_1);
    $29($8_1, $1_1, 32);
    $30($8_1, $0_1);
    HEAP32[$0_1 + 64 >> 2] = 0;
    global$0 = $3_1 + 272 | 0;
  }
  function $46($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0;
    $4_1 = global$0 - 272 | 0;
    global$0 = $4_1;
    if (HEAP32[$0_1 + 64 >> 2]) {
      $2_1 = $4_1 + 208 | 0;
      $3_1 = $2_1 + 40 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 48 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $2_1 = $2_1 + 56 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $4_1 + 200 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $4_1 + 128 | 0;
      HEAP32[$2_1 >> 2] = 528734635;
      HEAP32[$2_1 + 4 >> 2] = 1541459225;
      $2_1 = $4_1 + 120 | 0;
      HEAP32[$2_1 >> 2] = 1359893119;
      HEAP32[$2_1 + 4 >> 2] = -1694144372;
      $2_1 = $4_1 + 112 | 0;
      HEAP32[$2_1 >> 2] = 1013904242;
      HEAP32[$2_1 + 4 >> 2] = -1521486534;
      $2_1 = $0_1 + 56 | 0;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $6_1 = $4_1 + 232 | 0;
      HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 4 >> 2] = $3_1;
      $2_1 = $0_1 + 48 | 0;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      $6_1 = $4_1 + 224 | 0;
      HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 4 >> 2] = $3_1;
      HEAP32[$4_1 + 104 >> 2] = 1779033703;
      HEAP32[$4_1 + 108 >> 2] = -1150833019;
      HEAP32[$4_1 + 240 >> 2] = 0;
      HEAP32[$4_1 + 244 >> 2] = 0;
      $2_1 = $0_1 + 40 | 0;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      HEAP32[$4_1 + 216 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 220 >> 2] = $3_1;
      $2_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
      HEAP32[$4_1 + 208 >> 2] = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
      HEAP32[$4_1 + 212 >> 2] = $2_1;
      $2_1 = $0_1 + 32 | 0;
      $6_1 = $4_1 + 104 | 0;
      $3_1 = 0;
      while (1) {
        $5_1 = ($4_1 + 208 | 0) + $3_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $3_1 = $3_1 + 4 | 0;
        if (($3_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($6_1, $4_1 + 208 | 0, 64);
      HEAP32[$4_1 + 96 >> 2] = 0;
      HEAP32[$4_1 + 100 >> 2] = 0;
      HEAP32[$4_1 + 24 >> 2] = 528734635;
      HEAP32[$4_1 + 28 >> 2] = 1541459225;
      HEAP32[$4_1 + 16 >> 2] = 1359893119;
      HEAP32[$4_1 + 20 >> 2] = -1694144372;
      HEAP32[$4_1 + 8 >> 2] = 1013904242;
      HEAP32[$4_1 + 12 >> 2] = -1521486534;
      HEAP32[$4_1 >> 2] = 1779033703;
      HEAP32[$4_1 + 4 >> 2] = -1150833019;
      $3_1 = 0;
      while (1) {
        $5_1 = ($4_1 + 208 | 0) + $3_1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $7_1 = $5_1 + 1 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $7_1 = $5_1 + 2 | 0;
        HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
        $5_1 = $5_1 + 3 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $3_1 = $3_1 + 4 | 0;
        if (($3_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $5_1 = $4_1 + 208 | 0;
      $29($4_1, $5_1, 64);
      $29($4_1, $0_1, 32);
      $29($4_1, 690370, 1);
      $30($4_1, $5_1);
      $29($6_1, $5_1, 32);
      $30($6_1, $2_1);
      $3_1 = $4_1 + 248 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $4_1 + 256 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $4_1 + 264 | 0;
      HEAP32[$3_1 >> 2] = 0;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $3_1 = $2_1 + 24 | 0;
      $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $8_1 = $5_1 + 24 | 0;
      HEAP32[$8_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP32[$8_1 + 4 >> 2] = $7_1;
      $3_1 = $2_1 + 16 | 0;
      $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $5_1 = $5_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP32[$5_1 + 4 >> 2] = $7_1;
      HEAP32[$4_1 + 200 >> 2] = 0;
      HEAP32[$4_1 + 204 >> 2] = 0;
      HEAP32[$4_1 + 128 >> 2] = 528734635;
      HEAP32[$4_1 + 132 >> 2] = 1541459225;
      HEAP32[$4_1 + 120 >> 2] = 1359893119;
      HEAP32[$4_1 + 124 >> 2] = -1694144372;
      HEAP32[$4_1 + 112 >> 2] = 1013904242;
      HEAP32[$4_1 + 116 >> 2] = -1521486534;
      HEAP32[$4_1 + 104 >> 2] = 1779033703;
      HEAP32[$4_1 + 108 >> 2] = -1150833019;
      HEAP32[$4_1 + 240 >> 2] = 0;
      HEAP32[$4_1 + 244 >> 2] = 0;
      $3_1 = $2_1 + 8 | 0;
      $5_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      HEAP32[$4_1 + 216 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 220 >> 2] = $5_1;
      $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
      HEAP32[$4_1 + 208 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 212 >> 2] = $3_1;
      $3_1 = 0;
      while (1) {
        $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
        $5_1 = $2_1 + 1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $5_1 = $2_1 + 2 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
        $2_1 = $2_1 + 3 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
        $3_1 = $3_1 + 4 | 0;
        if (($3_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $29($6_1, $4_1 + 208 | 0, 64);
      HEAP32[$4_1 + 96 >> 2] = 0;
      HEAP32[$4_1 + 100 >> 2] = 0;
      HEAP32[$4_1 + 24 >> 2] = 528734635;
      HEAP32[$4_1 + 28 >> 2] = 1541459225;
      HEAP32[$4_1 + 16 >> 2] = 1359893119;
      HEAP32[$4_1 + 20 >> 2] = -1694144372;
      HEAP32[$4_1 + 8 >> 2] = 1013904242;
      HEAP32[$4_1 + 12 >> 2] = -1521486534;
      HEAP32[$4_1 >> 2] = 1779033703;
      HEAP32[$4_1 + 4 >> 2] = -1150833019;
      $3_1 = 0;
      while (1) {
        $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
        $5_1 = $2_1 + 1 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $5_1 = $2_1 + 2 | 0;
        HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
        $2_1 = $2_1 + 3 | 0;
        HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
        $3_1 = $3_1 + 4 | 0;
        if (($3_1 | 0) != 64) {
          continue;
        }
        break;
      }
      ;
      $2_1 = $4_1 + 208 | 0;
      $29($4_1, $2_1, 64);
      $29($4_1, $0_1, 32);
      $30($4_1, $2_1);
      $29($6_1, $2_1, 32);
      $30($6_1, $0_1);
    }
    $2_1 = $4_1 + 208 | 0;
    $3_1 = $2_1 + 40 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $3_1 = $2_1 + 48 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    $2_1 = $2_1 + 56 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $4_1 + 200 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $4_1 + 128 | 0;
    HEAP32[$2_1 >> 2] = 528734635;
    HEAP32[$2_1 + 4 >> 2] = 1541459225;
    $2_1 = $4_1 + 120 | 0;
    HEAP32[$2_1 >> 2] = 1359893119;
    HEAP32[$2_1 + 4 >> 2] = -1694144372;
    $2_1 = $4_1 + 112 | 0;
    HEAP32[$2_1 >> 2] = 1013904242;
    HEAP32[$2_1 + 4 >> 2] = -1521486534;
    $2_1 = $0_1 + 56 | 0;
    $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $6_1 = $4_1 + 232 | 0;
    HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$6_1 + 4 >> 2] = $3_1;
    $2_1 = $0_1 + 48 | 0;
    $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $6_1 = $4_1 + 224 | 0;
    HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$6_1 + 4 >> 2] = $3_1;
    HEAP32[$4_1 + 104 >> 2] = 1779033703;
    HEAP32[$4_1 + 108 >> 2] = -1150833019;
    HEAP32[$4_1 + 240 >> 2] = 0;
    HEAP32[$4_1 + 244 >> 2] = 0;
    $2_1 = $0_1 + 40 | 0;
    $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    HEAP32[$4_1 + 216 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$4_1 + 220 >> 2] = $3_1;
    $2_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
    HEAP32[$4_1 + 208 >> 2] = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
    HEAP32[$4_1 + 212 >> 2] = $2_1;
    $6_1 = $4_1 + 104 | 0;
    $3_1 = 0;
    while (1) {
      $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
      $5_1 = $2_1 + 1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $5_1 = $2_1 + 2 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
      $2_1 = $2_1 + 3 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
      $3_1 = $3_1 + 4 | 0;
      if (($3_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $29($6_1, $4_1 + 208 | 0, 64);
    HEAP32[$4_1 + 96 >> 2] = 0;
    HEAP32[$4_1 + 100 >> 2] = 0;
    HEAP32[$4_1 + 24 >> 2] = 528734635;
    HEAP32[$4_1 + 28 >> 2] = 1541459225;
    HEAP32[$4_1 + 16 >> 2] = 1359893119;
    HEAP32[$4_1 + 20 >> 2] = -1694144372;
    HEAP32[$4_1 + 8 >> 2] = 1013904242;
    HEAP32[$4_1 + 12 >> 2] = -1521486534;
    HEAP32[$4_1 >> 2] = 1779033703;
    HEAP32[$4_1 + 4 >> 2] = -1150833019;
    $3_1 = 0;
    while (1) {
      $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
      $5_1 = $2_1 + 1 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $5_1 = $2_1 + 2 | 0;
      HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
      $2_1 = $2_1 + 3 | 0;
      HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
      $3_1 = $3_1 + 4 | 0;
      if (($3_1 | 0) != 64) {
        continue;
      }
      break;
    }
    ;
    $2_1 = $4_1 + 208 | 0;
    $29($4_1, $2_1, 64);
    $29($4_1, $0_1, 32);
    $30($4_1, $2_1);
    $29($6_1, $2_1, 32);
    $30($6_1, $0_1);
    $2_1 = $0_1 + 24 | 0;
    $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $3_1 = $1_1 + 24 | 0;
    $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP8[$3_1 | 0] = $2_1;
    HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $6_1;
    HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
    $2_1 = $0_1 + 16 | 0;
    $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $3_1 = $1_1 + 16 | 0;
    $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP8[$3_1 | 0] = $2_1;
    HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $6_1;
    HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
    $2_1 = $0_1 + 8 | 0;
    $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $3_1 = $1_1 + 8 | 0;
    $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP8[$3_1 | 0] = $2_1;
    HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $6_1;
    HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $3_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP8[$1_1 | 0] = $3_1;
    HEAP8[$1_1 + 1 | 0] = $3_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $3_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $3_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $2_1;
    HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
    HEAP32[$0_1 + 64 >> 2] = 1;
    global$0 = $4_1 + 272 | 0;
  }
  function $47($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
    var $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0;
    $11_1 = global$0 - 464 | 0;
    global$0 = $11_1;
    $6_1 = $1_1 + 24 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $1_1 + 16 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $1_1 + 8 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $6_1 = $2_1 + 24 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $2_1 + 16 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    $6_1 = $2_1 + 8 | 0;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    if ($3_1) {
      HEAP32[$3_1 >> 2] = 0;
    }
    $38($11_1 + 96 | 0, 690788, $11_1 + 256 | 0);
    $14_1 = HEAP32[$11_1 + 120 >> 2];
    $13_1 = HEAP32[$11_1 + 112 >> 2];
    $10_1 = HEAP32[$11_1 + 104 >> 2];
    $12_1 = HEAP32[$11_1 + 96 >> 2];
    $18_1 = HEAP32[$11_1 + 124 >> 2];
    $16_1 = HEAP32[$11_1 + 116 >> 2];
    $8_1 = HEAP32[$11_1 + 108 >> 2];
    $15_1 = HEAP32[$11_1 + 100 >> 2];
    $7_1 = HEAP32[$11_1 + 256 >> 2] | !($14_1 | ($13_1 | ($10_1 | $12_1)) | ($18_1 | ($16_1 | ($8_1 | $15_1))));
    $6_1 = $7_1 ? 0 : -1;
    HEAP32[$11_1 + 120 >> 2] = $6_1 & $14_1;
    HEAP32[$11_1 + 124 >> 2] = $6_1 & $18_1;
    HEAP32[$11_1 + 112 >> 2] = $6_1 & $13_1;
    HEAP32[$11_1 + 116 >> 2] = $6_1 & $16_1;
    HEAP32[$11_1 + 104 >> 2] = $6_1 & $10_1;
    HEAP32[$11_1 + 108 >> 2] = $6_1 & $8_1;
    HEAP32[$11_1 + 96 >> 2] = $6_1 & $12_1 | ($7_1 | 0) != 0;
    HEAP32[$11_1 + 100 >> 2] = $6_1 & $15_1;
    $38($11_1 + 32 | 0, 655649, 0);
    $31_1 = !$7_1;
    $28_1 = $4_1 ? $4_1 : 4;
    label$2: {
      if (!(FUNCTION_TABLE[$28_1 | 0]($11_1, 655649, 690788, 0, $5_1, 0) | 0)) {
        break label$2;
      }
      $4_1 = 1;
      while (1) {
        $29_1 = $4_1;
        $38($11_1 - -64 | 0, $11_1, $11_1 + 256 | 0);
        label$4: {
          if (HEAP32[$11_1 + 256 >> 2] | !(HEAP32[$11_1 + 88 >> 2] | (HEAP32[$11_1 + 80 >> 2] | (HEAP32[$11_1 + 72 >> 2] | HEAP32[$11_1 + 64 >> 2])) | (HEAP32[$11_1 + 92 >> 2] | (HEAP32[$11_1 + 84 >> 2] | (HEAP32[$11_1 + 76 >> 2] | HEAP32[$11_1 + 68 >> 2]))))) {
            break label$4;
          }
          HEAP32[$11_1 + 132 >> 2] = 0;
          $4_1 = $11_1 + 256 | 0;
          $48($0_1, $4_1, $11_1 - -64 | 0);
          $49($11_1 + 168 | 0, $4_1);
          $6_1 = $11_1;
          $16_1 = HEAP32[$6_1 + 232 >> 2];
          $18_1 = HEAP32[$6_1 + 236 >> 2];
          $14_1 = HEAP32[$6_1 + 224 >> 2];
          $15_1 = HEAP32[$6_1 + 228 >> 2];
          $10_1 = HEAP32[$6_1 + 216 >> 2];
          $8_1 = HEAP32[$6_1 + 220 >> 2];
          $9_1 = HEAP32[$6_1 + 212 >> 2];
          $12_1 = HEAP32[$6_1 + 240 >> 2];
          $13_1 = HEAP32[$6_1 + 244 >> 2];
          $20_1 = $13_1;
          $4_1 = HEAP32[$6_1 + 208 >> 2];
          $13_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1);
          $7_1 = $4_1 + $13_1 | 0;
          $4_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
          $13_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $8_1;
          $9_1 = $13_1 >>> 20 | 0;
          $17_1 = $9_1;
          $9_1 = $10_1 + $9_1 | 0;
          $8_1 = $17_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $15_1;
          $10_1 = $8_1 >>> 20 | 0;
          $15_1 = $10_1;
          $10_1 = $10_1 + $14_1 | 0;
          $14_1 = $15_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $18_1;
          $15_1 = $14_1 >>> 20 | 0;
          $17_1 = $15_1;
          $15_1 = $16_1 + $15_1 | 0;
          $4_1 = $17_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $21_1 = $10_1;
          $16_1 = $4_1;
          $30_1 = $14_1 & 1048575;
          $14_1 = ($15_1 & ($10_1 & $9_1)) == -1 & ($4_1 & ($30_1 & $8_1)) == 1048575;
          $4_1 = $20_1 & 65535;
          $10_1 = $16_1 >>> 20 | 0;
          $17_1 = $10_1;
          $10_1 = $10_1 + $12_1 | 0;
          $18_1 = $17_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $13_1 & 1048575;
          $22_1 = $10_1;
          $10_1 = __wasm_i64_mul($14_1 & (($10_1 | 0) == -1 & ($18_1 | 0) == 65535) & (($4_1 | 0) == 1048574 & $7_1 >>> 0 > 4294966318 | $4_1 >>> 0 > 1048574) | $18_1 >>> 16, 0, 977, 1) + $7_1 | 0;
          $4_1 = i64toi32_i32$HIGH_BITS + $4_1 | 0;
          $27_1 = $10_1;
          HEAP32[$6_1 + 208 >> 2] = $10_1;
          $14_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$6_1 + 212 >> 2] = $14_1 & 1048575;
          $20_1 = HEAP32[$6_1 + 192 >> 2];
          $17_1 = HEAP32[$6_1 + 196 >> 2];
          $13_1 = HEAP32[$6_1 + 184 >> 2];
          $23_1 = HEAP32[$6_1 + 188 >> 2];
          $12_1 = HEAP32[$6_1 + 176 >> 2];
          $19_1 = HEAP32[$6_1 + 180 >> 2];
          $25_1 = HEAP32[$6_1 + 172 >> 2];
          $26_1 = HEAP32[$6_1 + 200 >> 2];
          $10_1 = HEAP32[$6_1 + 204 >> 2];
          $32_1 = $10_1;
          $4_1 = HEAP32[$6_1 + 168 >> 2];
          $7_1 = __wasm_i64_mul($10_1 >>> 16 | 0, 0, 977, 1);
          $10_1 = $4_1 + $7_1 | 0;
          $4_1 = $25_1 + i64toi32_i32$HIGH_BITS | 0;
          $25_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $19_1;
          $7_1 = $25_1 >>> 20 | 0;
          $19_1 = $7_1;
          $7_1 = $7_1 + $12_1 | 0;
          $19_1 = $19_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $23_1;
          $12_1 = $19_1 >>> 20 | 0;
          $23_1 = $12_1;
          $12_1 = $12_1 + $13_1 | 0;
          $24_1 = $23_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $17_1;
          $13_1 = $24_1 >>> 20 | 0;
          $20_1 = $13_1 + $20_1 | 0;
          $4_1 = $13_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $13_1 = $19_1 & 1048575;
          $23_1 = $12_1;
          $17_1 = $4_1;
          $24_1 = $24_1 & 1048575;
          $12_1 = ($7_1 & $12_1 & $20_1) == -1 & ($4_1 & ($19_1 & $24_1)) == 1048575;
          $4_1 = $32_1 & 65535;
          $6_1 = $17_1 >>> 20 | 0;
          $19_1 = $6_1;
          $6_1 = $6_1 + $26_1 | 0;
          $19_1 = $19_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $25_1 & 1048575;
          $26_1 = $6_1;
          $6_1 = __wasm_i64_mul($12_1 & (($6_1 | 0) == -1 & ($19_1 | 0) == 65535) & (($4_1 | 0) == 1048574 & $10_1 >>> 0 > 4294966318 | $4_1 >>> 0 > 1048574) | $19_1 >>> 16, 0, 977, 1) + $10_1 | 0;
          $4_1 = i64toi32_i32$HIGH_BITS + $4_1 | 0;
          $4_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $10_1 = $6_1;
          $6_1 = $4_1;
          $4_1 = $13_1;
          $12_1 = $6_1 >>> 20 | 0;
          $13_1 = $12_1;
          $12_1 = $7_1 + $12_1 | 0;
          $4_1 = $13_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$11_1 + 176 >> 2] = $12_1;
          $7_1 = $4_1;
          HEAP32[$11_1 + 180 >> 2] = $4_1 & 1048575;
          $4_1 = $8_1 & 1048575;
          $14_1 = $14_1 >>> 20 | 0;
          $9_1 = $9_1 + $14_1 | 0;
          $4_1 = $14_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$11_1 + 216 >> 2] = $9_1;
          HEAP32[$11_1 + 220 >> 2] = $4_1 & 1048575;
          $9_1 = $4_1;
          $4_1 = $30_1;
          $9_1 = ($9_1 >>> 20 | 0) + $21_1 | 0;
          $4_1 = $9_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$11_1 + 224 >> 2] = $9_1;
          $21_1 = $4_1;
          HEAP32[$11_1 + 228 >> 2] = $4_1 & 1048575;
          $8_1 = $11_1;
          $9_1 = $20_1;
          $17_1 = $17_1 & 1048575;
          $4_1 = $24_1;
          $20_1 = $7_1;
          $13_1 = ($7_1 >>> 20 | 0) + $23_1 | 0;
          $7_1 = $13_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $17_1;
          $14_1 = $7_1 >>> 20 | 0;
          $17_1 = $14_1;
          $14_1 = $9_1 + $14_1 | 0;
          $4_1 = $17_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$8_1 + 192 >> 2] = $14_1;
          $9_1 = $4_1;
          HEAP32[$8_1 + 196 >> 2] = $4_1 & 1048575;
          $4_1 = $16_1 & 1048575;
          $16_1 = $21_1 >>> 20 | 0;
          $15_1 = $16_1 + $15_1 | 0;
          $4_1 = $16_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$8_1 + 232 >> 2] = $15_1;
          $15_1 = $4_1;
          HEAP32[$8_1 + 236 >> 2] = $4_1 & 1048575;
          $4_1 = $19_1;
          $16_1 = $9_1;
          $17_1 = ($9_1 >>> 20 | 0) + $26_1 | 0;
          $4_1 = $17_1 >>> 0 < $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$8_1 + 200 >> 2] = $17_1;
          $9_1 = $4_1;
          HEAP32[$8_1 + 204 >> 2] = $4_1 & 65535;
          $4_1 = $18_1;
          $15_1 = ($15_1 >>> 20 | 0) + $22_1 | 0;
          $4_1 = $15_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$8_1 + 240 >> 2] = $15_1;
          HEAP32[$8_1 + 244 >> 2] = $4_1 & 65535;
          $15_1 = $13_1;
          HEAP32[$8_1 + 184 >> 2] = $13_1;
          $4_1 = $7_1 & 1048575;
          HEAP32[$8_1 + 188 >> 2] = $4_1;
          HEAP32[$8_1 + 168 >> 2] = $10_1;
          $13_1 = $6_1 & 1048575;
          HEAP32[$8_1 + 172 >> 2] = $13_1;
          HEAP8[$8_1 + 415 | 0] = $10_1;
          HEAP8[$8_1 + 414 | 0] = ($6_1 & 255) << 24 | $10_1 >>> 8;
          HEAP8[$8_1 + 413 | 0] = ($6_1 & 65535) << 16 | $10_1 >>> 16;
          HEAP8[$8_1 + 412 | 0] = ($6_1 & 16777215) << 8 | $10_1 >>> 24;
          HEAP8[$8_1 + 411 | 0] = $6_1;
          HEAP8[$8_1 + 410 | 0] = $6_1 >>> 8;
          $6_1 = $12_1 >>> 28 | 0;
          HEAP8[$8_1 + 409 | 0] = $12_1 << 4 | $13_1 >>> 16;
          HEAP8[$8_1 + 408 | 0] = ($20_1 & 15) << 28 | $12_1 >>> 4;
          HEAP8[$8_1 + 407 | 0] = ($20_1 & 4095) << 20 | $12_1 >>> 12;
          HEAP8[$8_1 + 406 | 0] = ($20_1 & 1048575) << 12 | $12_1 >>> 20;
          HEAP8[$8_1 + 405 | 0] = $6_1 | ($20_1 & 268435455) << 4;
          HEAP8[$8_1 + 404 | 0] = $20_1 >>> 4;
          HEAP8[$8_1 + 403 | 0] = $20_1 >>> 12;
          HEAP8[$8_1 + 402 | 0] = $15_1;
          HEAP8[$8_1 + 401 | 0] = ($7_1 & 255) << 24 | $15_1 >>> 8;
          HEAP8[$8_1 + 400 | 0] = ($7_1 & 65535) << 16 | $15_1 >>> 16;
          HEAP8[$8_1 + 399 | 0] = ($7_1 & 16777215) << 8 | $15_1 >>> 24;
          HEAP8[$8_1 + 398 | 0] = $7_1;
          HEAP8[$8_1 + 397 | 0] = $7_1 >>> 8;
          $6_1 = $14_1 >>> 28 | 0;
          HEAP8[$8_1 + 396 | 0] = $14_1 << 4 | $4_1 >>> 16;
          HEAP8[$8_1 + 395 | 0] = ($16_1 & 15) << 28 | $14_1 >>> 4;
          HEAP8[$8_1 + 394 | 0] = ($16_1 & 4095) << 20 | $14_1 >>> 12;
          HEAP8[$8_1 + 393 | 0] = ($16_1 & 1048575) << 12 | $14_1 >>> 20;
          HEAP8[$8_1 + 392 | 0] = $6_1 | ($16_1 & 268435455) << 4;
          HEAP8[$8_1 + 391 | 0] = $16_1 >>> 4;
          HEAP8[$8_1 + 390 | 0] = $16_1 >>> 12;
          HEAP8[$8_1 + 389 | 0] = $17_1;
          HEAP8[$8_1 + 388 | 0] = ($9_1 & 255) << 24 | $17_1 >>> 8;
          HEAP8[$8_1 + 387 | 0] = ($9_1 & 65535) << 16 | $17_1 >>> 16;
          HEAP8[$8_1 + 386 | 0] = ($9_1 & 16777215) << 8 | $17_1 >>> 24;
          HEAP8[$8_1 + 385 | 0] = $9_1;
          HEAP8[$8_1 + 384 | 0] = $9_1 >>> 8;
          $38($1_1, $8_1 + 384 | 0, $8_1 + 132 | 0);
          if ($3_1) {
            HEAP32[$3_1 >> 2] = $27_1 & 1 | HEAP32[$8_1 + 132 >> 2] << 1;
          }
          $21_1 = $8_1 + 136 | 0;
          $41($21_1, $1_1, $8_1 + 96 | 0);
          $7_1 = HEAP32[$8_1 + 32 >> 2];
          $9_1 = HEAP32[$8_1 + 136 >> 2];
          $15_1 = $7_1 + $9_1 | 0;
          $6_1 = HEAP32[$8_1 + 36 >> 2];
          $4_1 = $6_1 + HEAP32[$8_1 + 140 >> 2] | 0;
          $10_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $18_1 = ($6_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $15_1 >>> 0 | $6_1 >>> 0 > $10_1 >>> 0;
          $7_1 = HEAP32[$8_1 + 144 >> 2];
          $6_1 = $18_1 + $7_1 | 0;
          $4_1 = HEAP32[$8_1 + 148 >> 2];
          $4_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $9_1 = $6_1;
          $6_1 = HEAP32[$8_1 + 40 >> 2];
          $13_1 = $9_1 + $6_1 | 0;
          $7_1 = $4_1;
          $4_1 = $4_1 + HEAP32[$8_1 + 44 >> 2] | 0;
          $12_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $19_1 = HEAP32[$8_1 + 48 >> 2];
          $6_1 = HEAP32[$8_1 + 152 >> 2];
          $14_1 = $19_1 + $6_1 | 0;
          $20_1 = HEAP32[$8_1 + 52 >> 2];
          $4_1 = $20_1 + HEAP32[$8_1 + 156 >> 2] | 0;
          $6_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $16_1 = $14_1;
          $4_1 = !$7_1 & $9_1 >>> 0 < $18_1 >>> 0;
          $9_1 = ($7_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $7_1 >>> 0 > $12_1 >>> 0;
          $7_1 = $4_1 + $9_1 | 0;
          $4_1 = ($7_1 >>> 0 < $9_1 >>> 0) + $6_1 | 0;
          $14_1 = $7_1 + $14_1 | 0;
          $9_1 = $14_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $22_1 = HEAP32[$8_1 + 56 >> 2];
          $7_1 = HEAP32[$8_1 + 160 >> 2];
          $18_1 = $22_1 + $7_1 | 0;
          $17_1 = HEAP32[$8_1 + 60 >> 2];
          $4_1 = $17_1 + HEAP32[$8_1 + 164 >> 2] | 0;
          $7_1 = $7_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = ($6_1 | 0) == ($20_1 | 0) & $16_1 >>> 0 < $19_1 >>> 0 | $6_1 >>> 0 < $20_1 >>> 0;
          $16_1 = ($6_1 | 0) == ($9_1 | 0) & $14_1 >>> 0 < $16_1 >>> 0 | $6_1 >>> 0 > $9_1 >>> 0;
          $6_1 = $4_1 + $16_1 | 0;
          $4_1 = ($6_1 >>> 0 < $16_1 >>> 0) + $7_1 | 0;
          $16_1 = $6_1;
          $6_1 = $6_1 + $18_1 | 0;
          $4_1 = $16_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $16_1 = $6_1;
          $6_1 = $8_1;
          $20_1 = $4_1;
          $17_1 = (($7_1 | 0) == ($17_1 | 0) & $18_1 >>> 0 < $22_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0) + (($7_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0) | 0;
          $7_1 = ($9_1 | 0) == -1;
          $8_1 = $7_1 & $14_1 >>> 0 < 4294967294 | ($9_1 | 0) != -1 | ($16_1 & $4_1) != -1;
          $4_1 = ($12_1 | 0) == -1162945306;
          $18_1 = ($8_1 | ($4_1 & $13_1 >>> 0 < 2940772411 | $12_1 >>> 0 < 3132021990)) ^ -1;
          $19_1 = $17_1 + ($18_1 & (($10_1 | 0) == -1076732276 & $15_1 >>> 0 > 3493216576 | $10_1 >>> 0 > 3218235020) | ($18_1 & ($4_1 & $13_1 >>> 0 > 2940772411 | $12_1 >>> 0 > 3132021990) | ($14_1 | 0) == -1 & $7_1 & ($8_1 ^ -1))) | 0;
          $8_1 = __wasm_i64_mul($19_1, 0, 801750719, 1076732275);
          $7_1 = $8_1 + $15_1 | 0;
          $4_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
          $17_1 = $7_1;
          HEAP32[$6_1 + 136 >> 2] = $7_1;
          $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$6_1 + 140 >> 2] = $8_1;
          $7_1 = $6_1;
          $6_1 = __wasm_i64_mul($19_1, 0, 1354194884, 1162945305);
          $18_1 = $6_1 + $13_1 | 0;
          $4_1 = $12_1 + i64toi32_i32$HIGH_BITS | 0;
          $8_1 = ($8_1 | 0) == ($10_1 | 0) & $15_1 >>> 0 > $17_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
          $10_1 = $18_1 + $8_1 | 0;
          $4_1 = $6_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $4_1;
          $17_1 = $10_1;
          HEAP32[$7_1 + 144 >> 2] = $10_1;
          $8_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$7_1 + 148 >> 2] = $8_1;
          $10_1 = $7_1;
          $4_1 = $9_1;
          $15_1 = $14_1 + $19_1 | 0;
          $7_1 = $15_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = ($6_1 | 0) == ($12_1 | 0) & $13_1 >>> 0 > $18_1 >>> 0 | $6_1 >>> 0 < $12_1 >>> 0;
          $12_1 = ($6_1 | 0) == ($8_1 | 0) & $18_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 > $8_1 >>> 0;
          $6_1 = $4_1 + $12_1 | 0;
          $4_1 = ($6_1 >>> 0 < $12_1 >>> 0) + $7_1 | 0;
          $17_1 = $6_1;
          $6_1 = $6_1 + $15_1 | 0;
          $4_1 = $17_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$10_1 + 152 >> 2] = $6_1;
          HEAP32[$10_1 + 156 >> 2] = $4_1;
          $9_1 = ($7_1 | 0) == ($9_1 | 0) & $14_1 >>> 0 > $15_1 >>> 0 | $7_1 >>> 0 < $9_1 >>> 0;
          $7_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
          $6_1 = $9_1 + $7_1 | 0;
          $4_1 = $20_1 + ($6_1 >>> 0 < $7_1 >>> 0) | 0;
          $6_1 = $6_1 + $16_1 | 0;
          $4_1 = $6_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          HEAP32[$10_1 + 160 >> 2] = $6_1;
          HEAP32[$10_1 + 164 >> 2] = $4_1;
          $6_1 = HEAP32[$10_1 + 88 >> 2];
          $7_1 = HEAP32[$10_1 + 92 >> 2];
          HEAP32[$10_1 + 456 >> 2] = $7_1 >>> 24;
          HEAP32[$10_1 + 460 >> 2] = 0;
          $7_1 = $7_1 << 6 | $6_1 >>> 26;
          $9_1 = HEAP32[$10_1 + 80 >> 2];
          $12_1 = HEAP32[$10_1 + 84 >> 2];
          HEAP32[$10_1 + 448 >> 2] = $6_1 << 6 | $12_1 >>> 26;
          HEAP32[$10_1 + 452 >> 2] = $7_1 & 1073741823;
          $6_1 = $9_1;
          $7_1 = $12_1 << 4 | $6_1 >>> 28;
          $9_1 = HEAP32[$10_1 + 72 >> 2];
          $12_1 = HEAP32[$10_1 + 76 >> 2];
          HEAP32[$10_1 + 440 >> 2] = $6_1 << 4 | $12_1 >>> 28;
          HEAP32[$10_1 + 444 >> 2] = $7_1 & 1073741823;
          $6_1 = $9_1;
          $7_1 = $12_1 << 2 | $6_1 >>> 30;
          $9_1 = HEAP32[$11_1 + 64 >> 2];
          $10_1 = HEAP32[$11_1 + 68 >> 2];
          HEAP32[$11_1 + 432 >> 2] = $6_1 << 2 | $10_1 >>> 30;
          HEAP32[$11_1 + 436 >> 2] = $7_1 & 1073741823;
          HEAP32[$11_1 + 424 >> 2] = $9_1;
          HEAP32[$11_1 + 428 >> 2] = $10_1 & 1073741823;
          $50($11_1 + 424 | 0, 690320);
          $7_1 = HEAP32[$11_1 + 456 >> 2] << 24;
          $10_1 = HEAP32[$11_1 + 452 >> 2];
          $4_1 = $10_1 >>> 6 | 0;
          $9_1 = HEAP32[$11_1 + 448 >> 2];
          HEAP32[$2_1 + 24 >> 2] = ($10_1 & 63) << 26 | $9_1 >>> 6;
          HEAP32[$2_1 + 28 >> 2] = $4_1 | $7_1;
          $7_1 = $9_1 << 26;
          $10_1 = HEAP32[$11_1 + 444 >> 2];
          $4_1 = $10_1 >>> 4 | 0;
          $9_1 = HEAP32[$11_1 + 440 >> 2];
          HEAP32[$2_1 + 16 >> 2] = ($10_1 & 15) << 28 | $9_1 >>> 4;
          HEAP32[$2_1 + 20 >> 2] = $4_1 | $7_1;
          $7_1 = $9_1 << 28;
          $10_1 = HEAP32[$11_1 + 436 >> 2];
          $4_1 = $10_1 >>> 2 | 0;
          $9_1 = HEAP32[$11_1 + 432 >> 2];
          HEAP32[$2_1 + 8 >> 2] = ($10_1 & 3) << 30 | $9_1 >>> 2;
          HEAP32[$2_1 + 12 >> 2] = $4_1 | $7_1;
          $7_1 = HEAP32[$11_1 + 428 >> 2];
          $4_1 = $9_1 << 30;
          HEAP32[$2_1 >> 2] = HEAP32[$11_1 + 424 >> 2];
          HEAP32[$2_1 + 4 >> 2] = $4_1 | $7_1;
          $41($2_1, $2_1, $21_1);
          $4_1 = HEAP32[$2_1 + 28 >> 2];
          $18_1 = $4_1;
          $4_1 = $4_1 >>> 31 | 0;
          $6_1 = $4_1 ^ -1;
          $8_1 = HEAP32[$2_1 + 12 >> 2];
          $9_1 = ($8_1 | 0) == 1566010995;
          $13_1 = HEAP32[$2_1 + 8 >> 2];
          $17_1 = HEAP32[$2_1 + 16 >> 2];
          $19_1 = HEAP32[$2_1 + 20 >> 2];
          $20_1 = HEAP32[$2_1 + 24 >> 2];
          $6_1 = ($6_1 & ($9_1 & $13_1 >>> 0 < 1470386205 | $8_1 >>> 0 < 1566010995) | (($17_1 & $19_1) != -1 & $6_1 | (($18_1 | 0) == 2147483647 & ($20_1 | 0) != -1 | $18_1 >>> 0 < 2147483647))) ^ -1;
          $7_1 = HEAP32[$2_1 + 4 >> 2];
          $12_1 = HEAP32[$2_1 >> 2];
          $16_1 = $6_1 & (($7_1 | 0) == -538366138 & $12_1 >>> 0 > 1746608288 | $7_1 >>> 0 > 3756601158) | ($6_1 & ($9_1 & $13_1 >>> 0 > 1470386205 | $8_1 >>> 0 > 1566010995) | $4_1);
          $15_1 = $16_1 ? -801750718 : 0;
          $10_1 = $16_1 ? -1 : 0;
          $9_1 = $10_1 ^ $12_1;
          $6_1 = $15_1 + $9_1 | 0;
          $21_1 = $16_1 ? -1076732276 : 0;
          $4_1 = $21_1 + ($7_1 ^ $10_1) | 0;
          $12_1 = $17_1 | $20_1 | $13_1 | $12_1 | ($18_1 | $19_1 | $8_1 | $7_1) ? -1 : 0;
          $23_1 = $6_1 & $12_1;
          HEAP32[$2_1 >> 2] = $23_1;
          $9_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $26_1 = $12_1 & $9_1;
          HEAP32[$2_1 + 4 >> 2] = $26_1;
          $7_1 = $2_1;
          $22_1 = $16_1 ? -1162945306 : 0;
          $4_1 = $22_1 + ($8_1 ^ $10_1) | 0;
          $14_1 = ($9_1 | 0) == ($21_1 | 0) & $6_1 >>> 0 < $15_1 >>> 0 | $9_1 >>> 0 < $21_1 >>> 0;
          $27_1 = $16_1 ? -1354194885 : 0;
          $6_1 = $10_1 ^ $13_1;
          $13_1 = $27_1 + $6_1 | 0;
          $9_1 = $14_1 + $13_1 | 0;
          $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $4_1;
          $15_1 = $9_1;
          $21_1 = $9_1 & $12_1;
          HEAP32[$7_1 + 8 >> 2] = $21_1;
          $14_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $25_1 = $12_1 & $14_1;
          HEAP32[$7_1 + 12 >> 2] = $25_1;
          $9_1 = $7_1;
          $24_1 = $16_1 ? -2 : 0;
          $7_1 = $10_1 ^ $17_1;
          $8_1 = $24_1 + $7_1 | 0;
          $17_1 = $16_1 ? -1 : 0;
          $4_1 = $17_1 + ($10_1 ^ $19_1) | 0;
          $7_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = ($6_1 | 0) == ($22_1 | 0) & $13_1 >>> 0 < $27_1 >>> 0 | $6_1 >>> 0 < $22_1 >>> 0;
          $13_1 = ($6_1 | 0) == ($14_1 | 0) & $13_1 >>> 0 > $15_1 >>> 0 | $6_1 >>> 0 > $14_1 >>> 0;
          $6_1 = $4_1 + $13_1 | 0;
          $4_1 = ($6_1 >>> 0 < $13_1 >>> 0) + $7_1 | 0;
          $15_1 = $6_1;
          $6_1 = $6_1 + $8_1 | 0;
          $4_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $13_1 = $6_1 & $12_1;
          HEAP32[$9_1 + 16 >> 2] = $13_1;
          $14_1 = $4_1 & $12_1;
          HEAP32[$9_1 + 20 >> 2] = $14_1;
          $9_1 = ($7_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $24_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
          $7_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
          $6_1 = $9_1 + $7_1 | 0;
          $4_1 = $6_1 >>> 0 < $7_1 >>> 0;
          $7_1 = $10_1 ^ $20_1;
          $9_1 = $7_1 - $16_1 | 0;
          $6_1 = $9_1 + $6_1 | 0;
          $4_1 = $4_1 + (($10_1 ^ $18_1) - ($7_1 >>> 0 < $16_1 >>> 0) | 0) | 0;
          $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $6_1 = $6_1 & $12_1;
          HEAP32[$2_1 + 24 >> 2] = $6_1;
          $4_1 = $4_1 & $12_1;
          HEAP32[$2_1 + 28 >> 2] = $4_1;
          if ($3_1) {
            HEAP32[$3_1 >> 2] = HEAP32[$3_1 >> 2] ^ $16_1;
          }
          if (!($21_1 | $23_1 | $13_1 | $6_1 | ($25_1 | $26_1 | $14_1 | $4_1))) {
            break label$4;
          }
          if (!(HEAP32[$1_1 + 24 >> 2] | (HEAP32[$1_1 + 16 >> 2] | (HEAP32[$1_1 + 8 >> 2] | HEAP32[$1_1 >> 2])) | (HEAP32[$1_1 + 28 >> 2] | (HEAP32[$1_1 + 20 >> 2] | (HEAP32[$1_1 + 12 >> 2] | HEAP32[$1_1 + 4 >> 2]))))) {
            break label$4;
          }
          $9_1 = 1;
          break label$2;
        }
        $4_1 = $29_1 + 1 | 0;
        $9_1 = 0;
        if (FUNCTION_TABLE[$28_1 | 0]($11_1, 655649, 690788, 0, $5_1, $29_1) | 0) {
          continue;
        }
        break;
      }
      ;
    }
    $6_1 = $9_1 & $31_1;
    $5_1 = !$6_1;
    $0_1 = $5_1 - 1 | 0;
    $4_1 = 0 - !$5_1 | 0;
    $7_1 = $4_1 & HEAP32[$1_1 + 4 >> 2];
    HEAP32[$1_1 >> 2] = $0_1 & HEAP32[$1_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $7_1;
    $7_1 = HEAP32[$1_1 + 12 >> 2] & $4_1;
    HEAP32[$1_1 + 8 >> 2] = HEAP32[$1_1 + 8 >> 2] & $0_1;
    HEAP32[$1_1 + 12 >> 2] = $7_1;
    $7_1 = HEAP32[$1_1 + 20 >> 2] & $4_1;
    HEAP32[$1_1 + 16 >> 2] = HEAP32[$1_1 + 16 >> 2] & $0_1;
    HEAP32[$1_1 + 20 >> 2] = $7_1;
    $7_1 = HEAP32[$1_1 + 28 >> 2] & $4_1;
    HEAP32[$1_1 + 24 >> 2] = HEAP32[$1_1 + 24 >> 2] & $0_1;
    HEAP32[$1_1 + 28 >> 2] = $7_1;
    $1_1 = HEAP32[$2_1 + 4 >> 2] & $4_1;
    HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2] & $0_1;
    HEAP32[$2_1 + 4 >> 2] = $1_1;
    $1_1 = HEAP32[$2_1 + 12 >> 2] & $4_1;
    HEAP32[$2_1 + 8 >> 2] = HEAP32[$2_1 + 8 >> 2] & $0_1;
    HEAP32[$2_1 + 12 >> 2] = $1_1;
    $1_1 = HEAP32[$2_1 + 20 >> 2] & $4_1;
    HEAP32[$2_1 + 16 >> 2] = HEAP32[$2_1 + 16 >> 2] & $0_1;
    HEAP32[$2_1 + 20 >> 2] = $1_1;
    $1_1 = HEAP32[$2_1 + 28 >> 2] & $4_1;
    HEAP32[$2_1 + 24 >> 2] = HEAP32[$2_1 + 24 >> 2] & $0_1;
    HEAP32[$2_1 + 28 >> 2] = $1_1;
    if ($3_1) {
      HEAP32[$11_1 + 256 >> 2] = $5_1;
      HEAP32[$3_1 >> 2] = HEAP32[$3_1 >> 2] & HEAP32[$11_1 + 256 >> 2] - 1;
    }
    global$0 = $11_1 + 464 | 0;
    return $6_1;
  }
  function $48($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0;
    $5_1 = global$0 - 128 | 0;
    global$0 = $5_1;
    $26_1 = $70($1_1, $0_1 + 40 | 0, 128);
    $6_1 = HEAP32[$0_1 + 8 >> 2];
    $9_1 = HEAP32[$2_1 >> 2];
    $20_1 = $6_1 + $9_1 | 0;
    $1_1 = HEAP32[$0_1 + 12 >> 2];
    $3_1 = $1_1 + HEAP32[$2_1 + 4 >> 2] | 0;
    $7_1 = $9_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($1_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $20_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $6_1 = HEAP32[$2_1 + 8 >> 2];
    $3_1 = $8_1 + $6_1 | 0;
    $1_1 = HEAP32[$2_1 + 12 >> 2];
    $1_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $6_1 = $3_1;
    $3_1 = $0_1 + 16 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $19_1 = $6_1 + $9_1 | 0;
    $3_1 = $1_1 + HEAP32[$3_1 + 4 >> 2] | 0;
    $8_1 = !$1_1 & $6_1 >>> 0 < $8_1 >>> 0;
    $9_1 = $9_1 >>> 0 > $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = ($1_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 > $19_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $3_1 = $8_1 + $6_1 | 0;
    $1_1 = $3_1 >>> 0 < $6_1 >>> 0;
    $13_1 = $3_1;
    $3_1 = HEAP32[$2_1 + 16 >> 2];
    $8_1 = $13_1 + $3_1 | 0;
    $6_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$2_1 + 20 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $0_1 + 24 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $11_1 = $17_1 + $8_1 | 0;
    $1_1 = $3_1 + HEAP32[$1_1 + 4 >> 2] | 0;
    $13_1 = ($3_1 | 0) == ($6_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
    $6_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $8_1;
    $8_1 = $11_1;
    $11_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 > $6_1 >>> 0;
    $3_1 = $13_1 + $11_1 | 0;
    $1_1 = $3_1 >>> 0 < $11_1 >>> 0;
    $17_1 = $3_1;
    $13_1 = HEAP32[$2_1 + 24 >> 2];
    $11_1 = $3_1 + $13_1 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$2_1 + 28 >> 2] | 0;
    $1_1 = $11_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $0_1 = $0_1 + 32 | 0;
    $13_1 = HEAP32[$0_1 >> 2];
    $2_1 = $13_1 + $11_1 | 0;
    $0_1 = $1_1 + HEAP32[$0_1 + 4 >> 2] | 0;
    $21_1 = $2_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $13_1 = $2_1;
    $17_1 = (($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $3_1 >>> 0) + (($1_1 | 0) == ($21_1 | 0) & $2_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $21_1 >>> 0) | 0;
    $1_1 = ($6_1 | 0) == -1;
    $2_1 = $1_1 & $8_1 >>> 0 < 4294967294 | ($6_1 | 0) != -1 | ($2_1 & $21_1) != -1;
    $0_1 = ($9_1 | 0) == -1162945306;
    $3_1 = ($2_1 | ($0_1 & $19_1 >>> 0 < 2940772411 | $9_1 >>> 0 < 3132021990)) ^ -1;
    $11_1 = $17_1 + ($3_1 & (($7_1 | 0) == -1076732276 & $20_1 >>> 0 > 3493216576 | $7_1 >>> 0 > 3218235020) | ($3_1 & ($0_1 & $19_1 >>> 0 > 2940772411 | $9_1 >>> 0 > 3132021990) | ($8_1 | 0) == -1 & $1_1 & ($2_1 ^ -1))) | 0;
    $0_1 = __wasm_i64_mul($11_1, 0, 801750719, 1076732275);
    $2_1 = $0_1 + $20_1 | 0;
    $1_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
    HEAP32[$5_1 + 8 >> 2] = $2_1;
    $1_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$5_1 + 12 >> 2] = $1_1;
    $0_1 = $5_1;
    $7_1 = ($1_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
    $3_1 = __wasm_i64_mul($11_1, 0, 1354194884, 1162945305);
    $2_1 = $3_1 + $19_1 | 0;
    $1_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
    $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $7_1 = $2_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$0_1 + 16 >> 2] = $7_1;
    HEAP32[$0_1 + 20 >> 2] = $3_1;
    $3_1 = ($1_1 | 0) == ($3_1 | 0) & $2_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
    $2_1 = $3_1 + (($1_1 | 0) == ($9_1 | 0) & $2_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0) | 0;
    $1_1 = $2_1 >>> 0 < $3_1 >>> 0;
    $3_1 = $2_1;
    $9_1 = $1_1;
    $1_1 = $6_1;
    $7_1 = $8_1 + $11_1 | 0;
    $2_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $1_1 = $2_1 + $9_1 | 0;
    $17_1 = $3_1;
    $3_1 = $7_1;
    $7_1 = $17_1 + $3_1 | 0;
    HEAP32[$0_1 + 24 >> 2] = $7_1;
    $1_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    HEAP32[$0_1 + 28 >> 2] = $1_1;
    $0_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
    $2_1 = ($1_1 | 0) == ($2_1 | 0) & $3_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
    $1_1 = $0_1 + $2_1 | 0;
    $3_1 = $21_1 + ($1_1 >>> 0 < $2_1 >>> 0) | 0;
    $0_1 = $1_1 + $13_1 | 0;
    $3_1 = $0_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 32 >> 2] = $0_1;
    HEAP32[$5_1 + 36 >> 2] = $3_1;
    $2_1 = 0;
    $19_1 = 0;
    $6_1 = 0;
    $20_1 = 0;
    $11_1 = 0;
    $13_1 = 0;
    $9_1 = 0;
    $7_1 = 0;
    $17_1 = 0;
    $8_1 = 0;
    $21_1 = 0;
    while (1) {
      HEAP32[$5_1 + 120 >> 2] = 0;
      $1_1 = ($5_1 + 8 | 0) + ($27_1 >>> 2 & 1073741816) | 0;
      $0_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $28_1 & 62;
      $1_1 = $4_1 & 31;
      if ($4_1 >>> 0 >= 32) {
        $0_1 = $3_1 >>> $1_1 | 0;
      } else {
        $0_1 = ((1 << $1_1) - 1 & $3_1) << 32 - $1_1 | $0_1 >>> $1_1;
      }
      $12_1 = $0_1 & 3;
      $14_1 = ($12_1 | 0) == 1;
      $4_1 = $22_1 + 656432 | 0;
      $0_1 = $4_1 + 248 | 0;
      $1_1 = $4_1 + 184 | 0;
      $3_1 = $4_1 + 120 | 0;
      $10_1 = $4_1 + 56 | 0;
      $15_1 = ($12_1 | 0) == 2;
      $16_1 = ($12_1 | 0) == 3;
      $2_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $2_1 : HEAP32[$10_1 >> 2];
      $1_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $19_1 : HEAP32[$10_1 + 4 >> 2];
      $19_1 = $1_1;
      $0_1 = $1_1 >>> 16 | 0;
      HEAP32[$5_1 + 112 >> 2] = ($1_1 & 65535) << 16 | $2_1 >>> 16;
      HEAP32[$5_1 + 116 >> 2] = $0_1;
      $0_1 = $4_1 + 224 | 0;
      $1_1 = $4_1 + 160 | 0;
      $3_1 = $4_1 + 96 | 0;
      $10_1 = $4_1 + 32 | 0;
      $29_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $29_1 : HEAP32[$10_1 >> 2];
      $9_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $9_1 : HEAP32[$10_1 + 4 >> 2];
      HEAP32[$5_1 + 80 >> 2] = $29_1;
      HEAP32[$5_1 + 84 >> 2] = $9_1 & 1048575;
      $0_1 = $4_1 + 216 | 0;
      $1_1 = $4_1 + 152 | 0;
      $3_1 = $4_1 + 88 | 0;
      $10_1 = $4_1 + 24 | 0;
      $7_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $7_1 : HEAP32[$10_1 >> 2];
      $0_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $17_1 : HEAP32[$10_1 + 4 >> 2];
      $17_1 = $0_1;
      $3_1 = $0_1 >>> 16 | 0;
      HEAP32[$5_1 + 72 >> 2] = ($0_1 & 65535) << 16 | $7_1 >>> 16;
      HEAP32[$5_1 + 76 >> 2] = $3_1;
      $0_1 = $4_1 + 192 | 0;
      $1_1 = $4_1 + 128 | 0;
      $3_1 = $4_1 - -64 | 0;
      $30_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $30_1 : HEAP32[$4_1 >> 2];
      $23_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $23_1 : HEAP32[$4_1 + 4 >> 2];
      HEAP32[$5_1 + 40 >> 2] = $30_1;
      HEAP32[$5_1 + 44 >> 2] = $23_1 & 1048575;
      $3_1 = $2_1 << 4 & 1048560;
      $0_1 = $4_1 + 240 | 0;
      $1_1 = $4_1 + 176 | 0;
      $10_1 = $4_1 + 112 | 0;
      $18_1 = $4_1 + 48 | 0;
      $6_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$10_1 >> 2] : $12_1 ? $6_1 : HEAP32[$18_1 >> 2];
      $1_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$10_1 + 4 >> 2] : $12_1 ? $20_1 : HEAP32[$18_1 + 4 >> 2];
      $20_1 = $1_1;
      $0_1 = $1_1 >>> 28 | 0;
      HEAP32[$5_1 + 104 >> 2] = ($1_1 & 268435455) << 4 | $6_1 >>> 28;
      HEAP32[$5_1 + 108 >> 2] = $0_1 | $3_1;
      $3_1 = $4_1 + 232 | 0;
      $10_1 = $4_1 + 168 | 0;
      $18_1 = $4_1 + 104 | 0;
      $0_1 = $4_1 + 40 | 0;
      $11_1 = $16_1 ? HEAP32[$3_1 >> 2] : $15_1 ? HEAP32[$10_1 >> 2] : $14_1 ? HEAP32[$18_1 >> 2] : $12_1 ? $11_1 : HEAP32[$0_1 >> 2];
      $13_1 = $16_1 ? HEAP32[$3_1 + 4 >> 2] : $15_1 ? HEAP32[$10_1 + 4 >> 2] : $14_1 ? HEAP32[$18_1 + 4 >> 2] : $12_1 ? $13_1 : HEAP32[$0_1 + 4 >> 2];
      HEAP32[$5_1 + 96 >> 2] = $6_1 << 24 & -16777216 | $13_1 >>> 8;
      HEAP32[$5_1 + 100 >> 2] = ($1_1 << 24 | $6_1 >>> 8) & 1048575;
      HEAP32[$5_1 + 88 >> 2] = $11_1 << 12 & -4096 | $9_1 >>> 20;
      HEAP32[$5_1 + 92 >> 2] = ($13_1 << 12 | $11_1 >>> 20) & 1048575;
      $0_1 = $4_1 + 208 | 0;
      $1_1 = $4_1 + 144 | 0;
      $10_1 = $4_1 + 80 | 0;
      $18_1 = $4_1 + 16 | 0;
      $8_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$10_1 >> 2] : $12_1 ? $8_1 : HEAP32[$18_1 >> 2];
      $0_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$10_1 + 4 >> 2] : $12_1 ? $21_1 : HEAP32[$18_1 + 4 >> 2];
      $21_1 = $0_1;
      $1_1 = $0_1 >>> 28 | 0;
      HEAP32[$5_1 + 64 >> 2] = ($0_1 & 268435455) << 4 | $8_1 >>> 28;
      HEAP32[$5_1 + 68 >> 2] = $1_1 | $7_1 << 4 & 1048560;
      $1_1 = $8_1 << 24 & -16777216;
      $0_1 = $4_1 + 200 | 0;
      $10_1 = $4_1 + 136 | 0;
      $18_1 = $4_1 + 72 | 0;
      $4_1 = $4_1 + 8 | 0;
      $24_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$10_1 >> 2] : $14_1 ? HEAP32[$18_1 >> 2] : $12_1 ? $24_1 : HEAP32[$4_1 >> 2];
      $25_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$10_1 + 4 >> 2] : $14_1 ? HEAP32[$18_1 + 4 >> 2] : $12_1 ? $25_1 : HEAP32[$4_1 + 4 >> 2];
      HEAP32[$5_1 + 56 >> 2] = $25_1 >>> 8 | $1_1;
      HEAP32[$5_1 + 60 >> 2] = ($21_1 << 24 | $8_1 >>> 8) & 1048575;
      HEAP32[$5_1 + 48 >> 2] = $24_1 << 12 & -4096 | $23_1 >>> 20;
      HEAP32[$5_1 + 52 >> 2] = ($25_1 << 12 | $24_1 >>> 20) & 1048575;
      $53($26_1, $26_1, $5_1 + 40 | 0);
      $28_1 = $28_1 + 2 | 0;
      $27_1 = $27_1 + 1 | 0;
      $22_1 = $22_1 + 256 | 0;
      if (($22_1 | 0) != 32768) {
        continue;
      }
      break;
    }
    ;
    global$0 = $5_1 + 128 | 0;
  }
  function $49($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0;
    $6_1 = global$0 - 80 | 0;
    global$0 = $6_1;
    HEAP32[$0_1 + 80 >> 2] = HEAP32[$1_1 + 120 >> 2];
    $13_1 = $1_1 + 104 | 0;
    $11_1 = HEAP32[$13_1 >> 2];
    $12_1 = HEAP32[$13_1 + 4 >> 2];
    $14_1 = $1_1 + 96 | 0;
    $7_1 = HEAP32[$14_1 >> 2];
    $10_1 = HEAP32[$14_1 + 4 >> 2];
    $15_1 = $1_1 + 88 | 0;
    $5_1 = HEAP32[$15_1 >> 2];
    $8_1 = HEAP32[$15_1 + 4 >> 2];
    $9_1 = HEAP32[$1_1 + 84 >> 2];
    $16_1 = $1_1 + 112 | 0;
    $17_1 = HEAP32[$16_1 >> 2];
    $4_1 = HEAP32[$16_1 + 4 >> 2];
    $21_1 = $4_1;
    $2_1 = HEAP32[$1_1 + 80 >> 2];
    $3_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
    $4_1 = $2_1 + $3_1 | 0;
    $2_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
    $9_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $8_1;
    $3_1 = $9_1 >>> 20 | 0;
    $8_1 = $3_1;
    $3_1 = $3_1 + $5_1 | 0;
    $8_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $10_1;
    $5_1 = $8_1 >>> 20 | 0;
    $10_1 = $5_1;
    $5_1 = $5_1 + $7_1 | 0;
    $10_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $12_1;
    $7_1 = $10_1 >>> 20 | 0;
    $12_1 = $7_1;
    $7_1 = $7_1 + $11_1 | 0;
    $11_1 = $12_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $22_1 = $8_1 & 1048575;
    $2_1 = $9_1 & 1048575;
    $19_1 = $4_1;
    $18_1 = $2_1;
    $12_1 = $3_1;
    $9_1 = $5_1;
    $20_1 = $10_1 & 1048575;
    $5_1 = ($3_1 & $5_1 & $7_1) == -1 & ($20_1 & $8_1 & $11_1) == 1048575;
    $2_1 = $21_1 & 65535;
    $3_1 = $11_1 >>> 20 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + $17_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $3_1;
    $4_1 = $2_1;
    $5_1 = __wasm_i64_mul($5_1 & (($3_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($18_1 | 0) == 1048574 & $19_1 >>> 0 > 4294966318 | $18_1 >>> 0 > 1048574) | $2_1 >>> 16, 0, 977, 1);
    $3_1 = $5_1 + $19_1 | 0;
    $2_1 = $18_1 + i64toi32_i32$HIGH_BITS | 0;
    $2_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $17_1 = $2_1;
    $2_1 = $22_1;
    $3_1 = $17_1 >>> 20 | 0;
    $10_1 = $3_1 + $12_1 | 0;
    $3_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 40 >> 2] = $5_1;
    HEAP32[$6_1 + 44 >> 2] = $10_1 << 20 & 1072693248 | $17_1 & 1048575;
    $2_1 = $20_1;
    $12_1 = $9_1;
    $5_1 = $3_1;
    $9_1 = ($3_1 >>> 20 | 0) + $9_1 | 0;
    $3_1 = $12_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $17_1 = $9_1 << 10 & 1073740800;
    $2_1 = $5_1 >>> 10 | 0;
    HEAP32[$6_1 + 48 >> 2] = ($5_1 & 1023) << 22 | $10_1 >>> 10;
    HEAP32[$6_1 + 52 >> 2] = $17_1 | $2_1 & 1023;
    $2_1 = $11_1 & 1048575;
    $5_1 = $3_1;
    $3_1 = $3_1 >>> 20 | 0;
    $7_1 = $3_1 + $7_1 | 0;
    $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 56 >> 2] = ($5_1 & 1048575) << 12 | $9_1 >>> 20;
    HEAP32[$6_1 + 60 >> 2] = $7_1 & 1073741823;
    $2_1 = $4_1;
    $4_1 = ($3_1 >>> 20 | 0) + $8_1 | 0;
    $2_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 72 >> 2] = $2_1 >>> 8 & 255;
    HEAP32[$6_1 + 76 >> 2] = 0;
    $2_1 = $2_1 << 22 | $4_1 >>> 10;
    HEAP32[$6_1 + 64 >> 2] = (($3_1 & 1073741823) << 2 | $7_1 >>> 30) & 4194303 | $4_1 << 22 & -4194304;
    HEAP32[$6_1 + 68 >> 2] = $2_1 & 1073741823;
    $8_1 = $6_1 + 40 | 0;
    $50($8_1, 690464);
    $3_1 = HEAP32[$6_1 + 44 >> 2];
    $4_1 = $3_1;
    HEAP32[$1_1 + 80 >> 2] = HEAP32[$6_1 + 40 >> 2];
    HEAP32[$1_1 + 84 >> 2] = $3_1 & 1048575;
    $5_1 = HEAP32[$6_1 + 72 >> 2] << 8;
    $11_1 = HEAP32[$6_1 + 68 >> 2];
    $2_1 = $11_1 >>> 22 | 0;
    $7_1 = HEAP32[$6_1 + 64 >> 2];
    HEAP32[$16_1 >> 2] = ($11_1 & 4194303) << 10 | $7_1 >>> 22;
    HEAP32[$16_1 + 4 >> 2] = $2_1 | $5_1;
    $3_1 = $7_1;
    $2_1 = $11_1 << 30 | $3_1 >>> 2;
    $7_1 = $3_1 << 30 & -1073741824;
    $3_1 = HEAP32[$6_1 + 56 >> 2];
    $5_1 = HEAP32[$6_1 + 60 >> 2];
    HEAP32[$13_1 >> 2] = $5_1 | $7_1;
    HEAP32[$13_1 + 4 >> 2] = $2_1 & 1048575;
    $2_1 = $5_1 << 20 | $3_1 >>> 12;
    $7_1 = $3_1 << 20 & -1048576;
    $3_1 = HEAP32[$6_1 + 48 >> 2];
    $5_1 = HEAP32[$6_1 + 52 >> 2];
    HEAP32[$14_1 >> 2] = $5_1 >>> 10 | $7_1;
    HEAP32[$14_1 + 4 >> 2] = $2_1 & 1048575;
    $5_1 = ($5_1 << 10 | $3_1 >>> 22) & 1048575;
    HEAP32[$15_1 >> 2] = $3_1 << 10 & -1024 | $4_1 >>> 20;
    HEAP32[$15_1 + 4 >> 2] = $5_1;
    $2_1 = $1_1 + 80 | 0;
    $54($8_1, $2_1);
    $34($6_1, $2_1, $8_1);
    $34($1_1, $1_1, $8_1);
    $2_1 = $1_1 + 40 | 0;
    $34($2_1, $2_1, $6_1);
    HEAP32[$16_1 >> 2] = 0;
    HEAP32[$16_1 + 4 >> 2] = 0;
    HEAP32[$13_1 >> 2] = 0;
    HEAP32[$13_1 + 4 >> 2] = 0;
    HEAP32[$14_1 >> 2] = 0;
    HEAP32[$14_1 + 4 >> 2] = 0;
    HEAP32[$15_1 >> 2] = 0;
    HEAP32[$15_1 + 4 >> 2] = 0;
    HEAP32[$1_1 + 80 >> 2] = 1;
    HEAP32[$1_1 + 84 >> 2] = 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$0_1 + 4 >> 2] = $2_1;
    $2_1 = $1_1 + 8 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 + 8 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $2_1 = $1_1 + 16 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 + 16 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $2_1 = $1_1 + 24 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 + 24 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $2_1 = $1_1 + 32 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 + 32 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $2_1 = HEAP32[$1_1 + 44 >> 2];
    HEAP32[$0_1 + 40 >> 2] = HEAP32[$1_1 + 40 >> 2];
    HEAP32[$0_1 + 44 >> 2] = $2_1;
    $2_1 = $1_1 + 48 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 + 48 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $2_1 = $1_1 + 56 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 + 56 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $2_1 = $1_1 - -64 | 0;
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $0_1 - -64 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $1_1 + 72 | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $0_1 = $0_1 + 72 | 0;
    HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$0_1 + 4 >> 2] = $2_1;
    global$0 = $6_1 + 80 | 0;
  }
  function $50($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0;
    $7_1 = global$0 - 432 | 0;
    global$0 = $7_1;
    $3_1 = $7_1 + 392 | 0;
    $2_1 = $3_1 + 32 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $3_1 + 24 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $3_1 + 16 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $3_1 = $3_1 + 8 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    HEAP32[$7_1 + 392 >> 2] = 0;
    HEAP32[$7_1 + 396 >> 2] = 0;
    $3_1 = $7_1 + 352 | 0;
    $2_1 = $3_1 + 32 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $3_1 + 24 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $3_1 = $3_1 + 16 | 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    HEAP32[$7_1 + 360 >> 2] = 0;
    HEAP32[$7_1 + 364 >> 2] = 0;
    HEAP32[$7_1 + 352 >> 2] = 1;
    HEAP32[$7_1 + 356 >> 2] = 0;
    $34_1 = $0_1;
    $41_1 = HEAP32[$0_1 + 32 >> 2];
    $43_1 = HEAP32[$0_1 + 36 >> 2];
    $20_1 = HEAP32[$0_1 + 24 >> 2];
    $39_1 = HEAP32[$0_1 + 28 >> 2];
    $26_1 = HEAP32[$0_1 + 16 >> 2];
    $29_1 = HEAP32[$0_1 + 20 >> 2];
    $22_1 = HEAP32[$0_1 + 8 >> 2];
    $35_1 = HEAP32[$0_1 + 12 >> 2];
    $3_1 = HEAP32[$0_1 >> 2];
    $9_1 = HEAP32[$0_1 + 4 >> 2];
    $42_1 = HEAP32[$1_1 + 32 >> 2];
    $23_1 = HEAP32[$1_1 + 36 >> 2];
    $30_1 = HEAP32[$1_1 + 24 >> 2];
    $31_1 = HEAP32[$1_1 + 28 >> 2];
    $27_1 = HEAP32[$1_1 + 16 >> 2];
    $32_1 = HEAP32[$1_1 + 20 >> 2];
    $24_1 = HEAP32[$1_1 + 8 >> 2];
    $33_1 = HEAP32[$1_1 + 12 >> 2];
    $2_1 = HEAP32[$1_1 >> 2];
    $11_1 = HEAP32[$1_1 + 4 >> 2];
    $44_1 = -1;
    $21_1 = -1;
    while (1) {
      $5_1 = 8;
      $4_1 = 0;
      $36_1 = 59;
      $6_1 = 0;
      $14_1 = 0;
      $8_1 = $3_1;
      $0_1 = $9_1;
      $12_1 = $2_1;
      $19_1 = $11_1;
      $10_1 = 0;
      $15_1 = 0;
      $16_1 = 8;
      $13_1 = 0;
      while (1) {
        $18_1 = $0_1;
        $0_1 = $8_1 & 1;
        $28_1 = 0 - $0_1 | 0;
        $37_1 = 0 - $0_1 | 0;
        $25_1 = $37_1;
        $38_1 = $21_1;
        $0_1 = $21_1 >> 31;
        $17_1 = $0_1;
        $0_1 = $0_1 ^ $12_1;
        $21_1 = $0_1 - $17_1 & $28_1;
        $8_1 = $21_1 + $8_1 | 0;
        $0_1 = $18_1 + ($25_1 & ($17_1 ^ $19_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0)) | 0;
        $40_1 = $8_1;
        $8_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $18_1 = $17_1 & $25_1;
        $0_1 = ($8_1 & $18_1) + $19_1 | 0;
        $19_1 = $12_1;
        $21_1 = $17_1 & $28_1;
        $12_1 = ($21_1 & $40_1) + $12_1 | 0;
        $19_1 = $19_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = $6_1 ^ $17_1;
        $25_1 = $0_1 - $17_1 & $28_1;
        $16_1 = $25_1 + $16_1 | 0;
        $0_1 = $13_1 + (($14_1 ^ $17_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0) & $37_1) | 0;
        $13_1 = $16_1 >>> 0 < $25_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = ($13_1 & $18_1) + $14_1 | 0;
        $14_1 = $6_1;
        $6_1 = ($16_1 & $21_1) + $6_1 | 0;
        $0_1 = ($14_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 1 | $6_1 >>> 31;
        $6_1 = $6_1 << 1;
        $14_1 = $0_1;
        $25_1 = $21_1;
        $0_1 = $5_1 ^ $17_1;
        $21_1 = ($0_1 - $17_1 & $28_1) + $10_1 | 0;
        $0_1 = (($4_1 ^ $17_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0) & $37_1) + $15_1 | 0;
        $15_1 = $10_1 >>> 0 > $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
        $0_1 = ($15_1 & $18_1) + $4_1 | 0;
        $4_1 = $5_1;
        $10_1 = $21_1;
        $5_1 = ($25_1 & $10_1) + $5_1 | 0;
        $0_1 = ($4_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 1 | $5_1 >>> 31;
        $5_1 = $5_1 << 1;
        $4_1 = $0_1;
        $0_1 = $25_1 ^ $44_1;
        $44_1 = $0_1 - 1 | 0;
        $21_1 = ($18_1 ^ $38_1) - !$0_1 | 0;
        $0_1 = $8_1 >>> 1 | 0;
        $8_1 = ($8_1 & 1) << 31 | $40_1 >>> 1;
        $36_1 = $36_1 - 1 | 0;
        if ($36_1) {
          continue;
        }
        break;
      }
      ;
      HEAP32[$7_1 + 344 >> 2] = $16_1;
      HEAP32[$7_1 + 348 >> 2] = $13_1;
      HEAP32[$7_1 + 336 >> 2] = $10_1;
      HEAP32[$7_1 + 340 >> 2] = $15_1;
      HEAP32[$7_1 + 328 >> 2] = $6_1;
      HEAP32[$7_1 + 332 >> 2] = $14_1;
      HEAP32[$7_1 + 320 >> 2] = $5_1;
      HEAP32[$7_1 + 324 >> 2] = $4_1;
      $67($7_1 + 392 | 0, $7_1 + 352 | 0, $7_1 + 320 | 0, $1_1);
      $0_1 = $11_1 >> 31;
      $40_1 = $7_1 + 304 | 0;
      $8_1 = $4_1 >> 31;
      $12_1 = $2_1;
      $19_1 = $0_1;
      $69($40_1, $5_1, $4_1, $8_1, $8_1, $2_1, $11_1, $0_1, $0_1);
      $0_1 = $9_1 >> 31;
      $25_1 = $7_1 + 272 | 0;
      $2_1 = $14_1 >> 31;
      $18_1 = $3_1;
      $17_1 = $0_1;
      $69($25_1, $6_1, $14_1, $2_1, $2_1, $3_1, $9_1, $0_1, $0_1);
      $0_1 = $15_1 >> 31;
      $28_1 = $7_1 + 288 | 0;
      $38_1 = $10_1;
      $3_1 = $0_1;
      $69($28_1, $10_1, $15_1, $0_1, $0_1, $12_1, $11_1, $19_1, $19_1);
      $0_1 = $13_1 >> 31;
      $11_1 = $7_1 + 256 | 0;
      $10_1 = $0_1;
      $69($11_1, $16_1, $13_1, $0_1, $0_1, $18_1, $9_1, $17_1, $17_1);
      $0_1 = $33_1 >> 31;
      $12_1 = $7_1 + 240 | 0;
      $9_1 = $0_1;
      $69($12_1, $5_1, $4_1, $8_1, $8_1, $24_1, $33_1, $0_1, $0_1);
      $19_1 = $7_1 + 208 | 0;
      $18_1 = $35_1;
      $0_1 = $18_1 >> 31;
      $69($19_1, $6_1, $14_1, $2_1, $2_1, $22_1, $18_1, $0_1, $0_1);
      $18_1 = $7_1 + 224 | 0;
      $69($18_1, $38_1, $15_1, $3_1, $3_1, $24_1, $33_1, $9_1, $9_1);
      $17_1 = $7_1 + 192 | 0;
      $69($17_1, $16_1, $13_1, $10_1, $10_1, $22_1, $35_1, $0_1, $0_1);
      $0_1 = $32_1 >> 31;
      $22_1 = $7_1 + 176 | 0;
      $9_1 = $0_1;
      $69($22_1, $5_1, $4_1, $8_1, $8_1, $27_1, $32_1, $0_1, $0_1);
      $35_1 = $7_1 + 144 | 0;
      $0_1 = $29_1 >> 31;
      $69($35_1, $6_1, $14_1, $2_1, $2_1, $26_1, $29_1, $0_1, $0_1);
      $33_1 = $7_1 + 160 | 0;
      $69($33_1, $38_1, $15_1, $3_1, $3_1, $27_1, $32_1, $9_1, $9_1);
      $32_1 = $7_1 + 128 | 0;
      $69($32_1, $16_1, $13_1, $10_1, $10_1, $26_1, $29_1, $0_1, $0_1);
      $0_1 = $31_1 >> 31;
      $26_1 = $7_1 + 112 | 0;
      $9_1 = $0_1;
      $69($26_1, $5_1, $4_1, $8_1, $8_1, $30_1, $31_1, $0_1, $0_1);
      $29_1 = $7_1 + 80 | 0;
      $24_1 = $39_1;
      $0_1 = $24_1 >> 31;
      $69($29_1, $6_1, $14_1, $2_1, $2_1, $20_1, $24_1, $0_1, $0_1);
      $37_1 = $7_1 + 96 | 0;
      $69($37_1, $38_1, $15_1, $3_1, $3_1, $30_1, $31_1, $9_1, $9_1);
      $31_1 = $7_1 - -64 | 0;
      $69($31_1, $16_1, $13_1, $10_1, $10_1, $20_1, $24_1, $0_1, $0_1);
      $0_1 = $23_1 >> 31;
      $20_1 = $7_1 + 48 | 0;
      $9_1 = $8_1;
      $8_1 = $0_1;
      $69($20_1, $5_1, $4_1, $9_1, $9_1, $42_1, $23_1, $0_1, $0_1);
      $39_1 = $7_1 + 16 | 0;
      $4_1 = $43_1;
      $0_1 = $4_1 >> 31;
      $69($39_1, $6_1, $14_1, $2_1, $2_1, $41_1, $4_1, $0_1, $0_1);
      $36_1 = $7_1 + 32 | 0;
      $69($36_1, $38_1, $15_1, $3_1, $3_1, $42_1, $23_1, $8_1, $8_1);
      $69($7_1, $16_1, $13_1, $10_1, $10_1, $41_1, $4_1, $0_1, $0_1);
      $5_1 = HEAP32[$7_1 + 272 >> 2];
      $2_1 = HEAP32[$7_1 + 304 >> 2];
      $3_1 = $5_1 + $2_1 | 0;
      $8_1 = HEAP32[$7_1 + 276 >> 2];
      $0_1 = $8_1 + HEAP32[$7_1 + 308 >> 2] | 0;
      $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $2_1 = $3_1;
      $3_1 = $0_1;
      $8_1 = ($8_1 | 0) == ($0_1 | 0) & $2_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $8_1 >>> 0;
      $0_1 = $40_1 + 8 | 0;
      $5_1 = HEAP32[$0_1 >> 2];
      $4_1 = $25_1 + 8 | 0;
      $2_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
      $0_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = $2_1 + $8_1 | 0;
      $2_1 = $8_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $2_1 << 2 | $8_1 >>> 30;
      $4_1 = $8_1 << 2 | $3_1 >>> 30;
      $10_1 = HEAP32[$7_1 + 208 >> 2];
      $8_1 = HEAP32[$7_1 + 240 >> 2];
      $3_1 = $10_1 + $8_1 | 0;
      $6_1 = HEAP32[$7_1 + 212 >> 2];
      $0_1 = $6_1 + HEAP32[$7_1 + 244 >> 2] | 0;
      $8_1 = $3_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $8_1 + $5_1 | 0;
      $5_1 = $3_1;
      $4_1 = $3_1 + $4_1 | 0;
      $3_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $8_1;
      $8_1 = $4_1;
      $14_1 = ($3_1 | 0) == ($0_1 | 0) & $4_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
      $4_1 = ($0_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
      $0_1 = $12_1 + 8 | 0;
      $6_1 = HEAP32[$0_1 >> 2];
      $10_1 = $19_1 + 8 | 0;
      $5_1 = $6_1 + HEAP32[$10_1 >> 2] | 0;
      $0_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $5_1;
      $5_1 = $4_1 + $5_1 | 0;
      $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $4_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $2_1 + $14_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 << 2 | $5_1 >>> 30;
      $14_1 = $3_1;
      $10_1 = $5_1 << 2 | $3_1 >>> 30;
      $13_1 = HEAP32[$7_1 + 144 >> 2];
      $5_1 = HEAP32[$7_1 + 176 >> 2];
      $3_1 = $13_1 + $5_1 | 0;
      $6_1 = HEAP32[$7_1 + 148 >> 2];
      $0_1 = $6_1 + HEAP32[$7_1 + 180 >> 2] | 0;
      $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $5_1 + $4_1 | 0;
      $4_1 = $3_1;
      $24_1 = $3_1 + $10_1 | 0;
      $3_1 = $3_1 >>> 0 > $24_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $10_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $24_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
      $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
      $0_1 = $22_1 + 8 | 0;
      $6_1 = HEAP32[$0_1 >> 2];
      $15_1 = $35_1 + 8 | 0;
      $5_1 = $6_1 + HEAP32[$15_1 >> 2] | 0;
      $0_1 = HEAP32[$15_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $5_1;
      $5_1 = $4_1 + $5_1 | 0;
      $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $4_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $2_1 + $10_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 << 2 | $5_1 >>> 30;
      $10_1 = $3_1;
      $15_1 = $5_1 << 2 | $3_1 >>> 30;
      $16_1 = HEAP32[$7_1 + 80 >> 2];
      $5_1 = HEAP32[$7_1 + 112 >> 2];
      $3_1 = $16_1 + $5_1 | 0;
      $6_1 = HEAP32[$7_1 + 84 >> 2];
      $0_1 = $6_1 + HEAP32[$7_1 + 116 >> 2] | 0;
      $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $5_1 + $4_1 | 0;
      $4_1 = $3_1;
      $27_1 = $3_1 + $15_1 | 0;
      $3_1 = $3_1 >>> 0 > $27_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $15_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $27_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
      $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
      $0_1 = $26_1 + 8 | 0;
      $6_1 = HEAP32[$0_1 >> 2];
      $13_1 = $29_1 + 8 | 0;
      $5_1 = $6_1 + HEAP32[$13_1 >> 2] | 0;
      $0_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $5_1;
      $5_1 = $4_1 + $5_1 | 0;
      $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $4_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $2_1 + $15_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 << 2 | $5_1 >>> 30;
      $15_1 = $3_1;
      $13_1 = $5_1 << 2 | $3_1 >>> 30;
      $9_1 = HEAP32[$7_1 + 16 >> 2];
      $5_1 = HEAP32[$7_1 + 48 >> 2];
      $3_1 = $9_1 + $5_1 | 0;
      $6_1 = HEAP32[$7_1 + 20 >> 2];
      $0_1 = $6_1 + HEAP32[$7_1 + 52 >> 2] | 0;
      $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $5_1 + $4_1 | 0;
      $4_1 = $3_1;
      $30_1 = $3_1 + $13_1 | 0;
      $3_1 = $3_1 >>> 0 > $30_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $13_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $30_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
      $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $9_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
      $0_1 = $20_1 + 8 | 0;
      $6_1 = HEAP32[$0_1 >> 2];
      $16_1 = $39_1 + 8 | 0;
      $5_1 = $6_1 + HEAP32[$16_1 >> 2] | 0;
      $0_1 = HEAP32[$16_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $5_1;
      $5_1 = $4_1 + $5_1 | 0;
      $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $4_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $13_1 | 0;
      $5_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 2 | $2_1 >>> 30;
      $13_1 = $3_1;
      $42_1 = $2_1 << 2 | $3_1 >>> 30;
      $23_1 = $5_1;
      $4_1 = HEAP32[$7_1 + 256 >> 2];
      $2_1 = HEAP32[$7_1 + 288 >> 2];
      $3_1 = $4_1 + $2_1 | 0;
      $5_1 = HEAP32[$7_1 + 260 >> 2];
      $0_1 = $5_1 + HEAP32[$7_1 + 292 >> 2] | 0;
      $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $2_1 = $3_1;
      $3_1 = $0_1;
      $5_1 = ($5_1 | 0) == ($0_1 | 0) & $2_1 >>> 0 < $4_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
      $0_1 = $28_1 + 8 | 0;
      $4_1 = HEAP32[$0_1 >> 2];
      $6_1 = $11_1 + 8 | 0;
      $2_1 = $4_1 + HEAP32[$6_1 >> 2] | 0;
      $0_1 = HEAP32[$6_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $2_1 + $5_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 << 2 | $5_1 >>> 30;
      $6_1 = $5_1 << 2 | $3_1 >>> 30;
      $11_1 = HEAP32[$7_1 + 192 >> 2];
      $5_1 = HEAP32[$7_1 + 224 >> 2];
      $3_1 = $11_1 + $5_1 | 0;
      $16_1 = HEAP32[$7_1 + 196 >> 2];
      $0_1 = $16_1 + HEAP32[$7_1 + 228 >> 2] | 0;
      $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $5_1 + $4_1 | 0;
      $4_1 = $3_1;
      $6_1 = $3_1 + $6_1 | 0;
      $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $5_1;
      $5_1 = $6_1;
      $9_1 = ($3_1 | 0) == ($0_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
      $6_1 = ($0_1 | 0) == ($16_1 | 0) & $4_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $16_1 >>> 0;
      $0_1 = $18_1 + 8 | 0;
      $16_1 = HEAP32[$0_1 >> 2];
      $11_1 = $17_1 + 8 | 0;
      $4_1 = $16_1 + HEAP32[$11_1 >> 2] | 0;
      $0_1 = HEAP32[$11_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $19_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $0_1 = ($2_1 >> 31) + ($19_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $6_1 = $2_1;
      $2_1 = $2_1 + $4_1 | 0;
      $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 + $9_1 | 0;
      $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $2_1 << 2 | $4_1 >>> 30;
      $16_1 = $3_1;
      $11_1 = $4_1 << 2 | $3_1 >>> 30;
      $20_1 = HEAP32[$7_1 + 128 >> 2];
      $4_1 = HEAP32[$7_1 + 160 >> 2];
      $3_1 = $20_1 + $4_1 | 0;
      $9_1 = HEAP32[$7_1 + 132 >> 2];
      $0_1 = $9_1 + HEAP32[$7_1 + 164 >> 2] | 0;
      $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1 + $6_1 | 0;
      $6_1 = $3_1;
      $22_1 = $3_1 + $11_1 | 0;
      $3_1 = $3_1 >>> 0 > $22_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $11_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $22_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $6_1 = ($4_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
      $0_1 = $33_1 + 8 | 0;
      $9_1 = HEAP32[$0_1 >> 2];
      $12_1 = $32_1 + 8 | 0;
      $4_1 = $9_1 + HEAP32[$12_1 >> 2] | 0;
      $0_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $9_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $0_1 = ($2_1 >> 31) + ($9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $6_1 = $2_1;
      $2_1 = $2_1 + $4_1 | 0;
      $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 + $11_1 | 0;
      $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $2_1 << 2 | $4_1 >>> 30;
      $9_1 = $3_1;
      $12_1 = $4_1 << 2 | $3_1 >>> 30;
      $19_1 = HEAP32[$7_1 + 64 >> 2];
      $4_1 = HEAP32[$7_1 + 96 >> 2];
      $3_1 = $19_1 + $4_1 | 0;
      $11_1 = HEAP32[$7_1 + 68 >> 2];
      $0_1 = $11_1 + HEAP32[$7_1 + 100 >> 2] | 0;
      $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1 + $6_1 | 0;
      $6_1 = $3_1;
      $26_1 = $3_1 + $12_1 | 0;
      $3_1 = $3_1 >>> 0 > $26_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $12_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $26_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $6_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $11_1 >>> 0;
      $0_1 = $37_1 + 8 | 0;
      $11_1 = HEAP32[$0_1 >> 2];
      $20_1 = $31_1 + 8 | 0;
      $4_1 = $11_1 + HEAP32[$20_1 >> 2] | 0;
      $0_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $19_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $0_1 = ($2_1 >> 31) + ($19_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $6_1 = $2_1;
      $2_1 = $2_1 + $4_1 | 0;
      $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1 + $12_1 | 0;
      $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $6_1 = $2_1 << 2 | $4_1 >>> 30;
      $11_1 = $3_1;
      $20_1 = $4_1 << 2 | $3_1 >>> 30;
      $18_1 = HEAP32[$7_1 >> 2];
      $4_1 = HEAP32[$7_1 + 32 >> 2];
      $3_1 = $18_1 + $4_1 | 0;
      $12_1 = HEAP32[$7_1 + 4 >> 2];
      $0_1 = $12_1 + HEAP32[$7_1 + 36 >> 2] | 0;
      $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $4_1 + $6_1 | 0;
      $6_1 = $3_1;
      $20_1 = $3_1 + $20_1 | 0;
      $3_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $19_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
      $6_1 = ($4_1 | 0) == ($12_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
      $0_1 = $36_1 + 8 | 0;
      $12_1 = HEAP32[$0_1 >> 2];
      $18_1 = $7_1 + 8 | 0;
      $4_1 = $12_1 + HEAP32[$18_1 >> 2] | 0;
      $0_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
      $0_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $12_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $0_1 = ($2_1 >> 31) + ($12_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
      $2_1 = $2_1 >> 30;
      $6_1 = $2_1;
      $2_1 = $2_1 + $4_1 | 0;
      $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = $2_1;
      $2_1 = $2_1 + $19_1 | 0;
      $4_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 2 | $2_1 >>> 30;
      $41_1 = $2_1 << 2 | $3_1 >>> 30;
      $43_1 = $4_1;
      $39_1 = $3_1 & 1073741823;
      $31_1 = $13_1 & 1073741823;
      $29_1 = $11_1 & 1073741823;
      $32_1 = $15_1 & 1073741823;
      $35_1 = $9_1 & 1073741823;
      $33_1 = $10_1 & 1073741823;
      $3_1 = $5_1;
      $9_1 = $16_1 & 1073741823;
      $2_1 = $8_1;
      $11_1 = $14_1 & 1073741823;
      $45_1 = $45_1 + 1 | 0;
      if (($45_1 | 0) != 10) {
        continue;
      }
      break;
    }
    ;
    $0_1 = $23_1 >> 31;
    $3_1 = $0_1;
    $14_1 = $7_1 + 392 | 0;
    $8_1 = $14_1 + 32 | 0;
    $15_1 = HEAP32[$8_1 >> 2];
    $0_1 = HEAP32[$8_1 + 4 >> 2];
    $9_1 = $0_1;
    $0_1 = $0_1 >> 31;
    $2_1 = $0_1;
    $4_1 = HEAP32[$1_1 >> 2];
    $13_1 = $0_1 & $4_1;
    $5_1 = $13_1 + HEAP32[$7_1 + 392 >> 2] | 0;
    $6_1 = HEAP32[$1_1 + 4 >> 2];
    $0_1 = HEAP32[$7_1 + 396 >> 2] + ($6_1 & $0_1) | 0;
    $0_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = $3_1 ^ $5_1;
    $20_1 = $5_1 - $3_1 | 0;
    $5_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $5_1 >>> 0) + $3_1 | 0) | 0;
    $13_1 = $4_1;
    $16_1 = $6_1;
    $0_1 = HEAP32[$1_1 + 32 >> 2];
    $26_1 = $0_1;
    $6_1 = $0_1 & $2_1;
    $4_1 = $6_1 + $15_1 | 0;
    $22_1 = HEAP32[$1_1 + 36 >> 2];
    $0_1 = $9_1 + ($22_1 & $2_1) | 0;
    $0_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $3_1 ^ $4_1;
    $15_1 = $4_1 - $3_1 | 0;
    $12_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $4_1 >>> 0) + $3_1 | 0) | 0;
    $0_1 = HEAP32[$1_1 + 24 >> 2];
    $30_1 = $0_1;
    $10_1 = $0_1 & $2_1;
    $4_1 = $14_1 + 24 | 0;
    $6_1 = $10_1 + HEAP32[$4_1 >> 2] | 0;
    $27_1 = HEAP32[$1_1 + 28 >> 2];
    $0_1 = HEAP32[$4_1 + 4 >> 2] + ($27_1 & $2_1) | 0;
    $0_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $6_1 = $3_1 ^ $6_1;
    $11_1 = $6_1 - $3_1 | 0;
    $24_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $6_1 >>> 0) + $3_1 | 0) | 0;
    $0_1 = HEAP32[$1_1 + 16 >> 2];
    $19_1 = $0_1;
    $9_1 = $0_1 & $2_1;
    $6_1 = $14_1 + 16 | 0;
    $10_1 = $9_1 + HEAP32[$6_1 >> 2] | 0;
    $21_1 = HEAP32[$1_1 + 20 >> 2];
    $0_1 = HEAP32[$6_1 + 4 >> 2] + ($21_1 & $2_1) | 0;
    $0_1 = $9_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $10_1 = $3_1 ^ $10_1;
    $23_1 = $10_1 - $3_1 | 0;
    $10_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $10_1 >>> 0) + $3_1 | 0) | 0;
    $18_1 = HEAP32[$1_1 + 8 >> 2];
    $9_1 = $18_1 & $2_1;
    $0_1 = $14_1 + 8 | 0;
    $14_1 = $9_1 + HEAP32[$0_1 >> 2] | 0;
    $17_1 = HEAP32[$1_1 + 12 >> 2];
    $0_1 = HEAP32[$0_1 + 4 >> 2] + ($17_1 & $2_1) | 0;
    $1_1 = $3_1 ^ $14_1;
    $2_1 = $1_1 - $3_1 | 0;
    $0_1 = (($3_1 ^ ($9_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1)) - (($1_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0) + ($5_1 >> 31) | 0;
    $1_1 = $5_1 >> 30;
    $2_1 = $1_1 + $2_1 | 0;
    $9_1 = $1_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = ($9_1 >> 31) + $10_1 | 0;
    $1_1 = $9_1 >> 30;
    $14_1 = $1_1 + $23_1 | 0;
    $23_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = ($23_1 >> 31) + $24_1 | 0;
    $1_1 = $23_1 >> 30;
    $10_1 = $1_1 + $11_1 | 0;
    $11_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = ($11_1 >> 31) + $12_1 | 0;
    $1_1 = $11_1 >> 30;
    $15_1 = $1_1 + $15_1 | 0;
    $12_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $12_1 >> 31;
    $0_1 = ($1_1 & $16_1) + ($5_1 & 1073741823) | 0;
    $3_1 = $1_1;
    $1_1 = ($3_1 & $13_1) + $20_1 | 0;
    $0_1 = $1_1 >>> 0 < $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$34_1 >> 2] = $1_1;
    $1_1 = $0_1;
    HEAP32[$34_1 + 4 >> 2] = $0_1 & 1073741823;
    $13_1 = $34_1 + 8 | 0;
    $0_1 = ($3_1 & $17_1) + ($9_1 & 1073741823) | 0;
    $5_1 = $2_1;
    $2_1 = ($3_1 & $18_1) + $2_1 | 0;
    $0_1 = ($1_1 >> 31) + ($5_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
    $1_1 = $1_1 >> 30;
    $5_1 = $1_1;
    $1_1 = $1_1 + $2_1 | 0;
    $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$13_1 >> 2] = $1_1;
    $1_1 = $0_1;
    HEAP32[$13_1 + 4 >> 2] = $0_1 & 1073741823;
    $0_1 = ($3_1 & $21_1) + ($23_1 & 1073741823) | 0;
    $2_1 = ($3_1 & $19_1) + $14_1 | 0;
    $0_1 = ($1_1 >> 31) + ($2_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
    $1_1 = $1_1 >> 30;
    $5_1 = $1_1;
    $1_1 = $1_1 + $2_1 | 0;
    $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $2_1 = $1_1;
    HEAP32[$6_1 >> 2] = $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 & 1073741823;
    HEAP32[$6_1 + 4 >> 2] = $0_1;
    $5_1 = $34_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = $2_1;
    HEAP32[$5_1 + 4 >> 2] = $0_1;
    $0_1 = ($3_1 & $27_1) + ($11_1 & 1073741823) | 0;
    $2_1 = ($3_1 & $30_1) + $10_1 | 0;
    $0_1 = ($1_1 >> 31) + ($2_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
    $1_1 = $1_1 >> 30;
    $5_1 = $1_1;
    $1_1 = $1_1 + $2_1 | 0;
    $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $2_1 = $1_1;
    HEAP32[$4_1 >> 2] = $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 & 1073741823;
    HEAP32[$4_1 + 4 >> 2] = $0_1;
    $5_1 = $34_1 + 24 | 0;
    HEAP32[$5_1 >> 2] = $2_1;
    HEAP32[$5_1 + 4 >> 2] = $0_1;
    $0_1 = ($3_1 & $22_1) + $12_1 | 0;
    $3_1 = ($3_1 & $26_1) + $15_1 | 0;
    $0_1 = ($1_1 >> 31) + ($3_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
    $1_1 = $1_1 >> 30;
    $2_1 = $1_1;
    $1_1 = $1_1 + $3_1 | 0;
    $0_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$8_1 >> 2] = $1_1;
    HEAP32[$8_1 + 4 >> 2] = $0_1;
    $3_1 = $34_1 + 32 | 0;
    HEAP32[$3_1 >> 2] = $1_1;
    HEAP32[$3_1 + 4 >> 2] = $0_1;
    global$0 = $7_1 + 432 | 0;
  }
  function $51($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
    $4_1 = global$0 - 48 | 0;
    global$0 = $4_1;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689571, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      $14_1 = $4_1 + 8 | 0;
      $38($14_1, $1_1, $4_1 + 44 | 0);
      $8_1 = HEAP32[$4_1 + 32 >> 2];
      $2_1 = HEAP32[$4_1 + 24 >> 2];
      $7_1 = HEAP32[$4_1 + 16 >> 2];
      $3_1 = HEAP32[$4_1 + 8 >> 2];
      $11_1 = HEAP32[$4_1 + 36 >> 2];
      $9_1 = HEAP32[$4_1 + 28 >> 2];
      $5_1 = HEAP32[$4_1 + 20 >> 2];
      $6_1 = HEAP32[$4_1 + 12 >> 2];
      $15_1 = HEAP32[$4_1 + 44 >> 2] | !($8_1 | ($2_1 | ($7_1 | $3_1)) | ($11_1 | ($9_1 | ($5_1 | $6_1))));
      $0_1 = $15_1 ? 0 : -1;
      $8_1 = $0_1 & $8_1;
      $12_1 = $0_1 & $2_1;
      $10_1 = $0_1 & $7_1;
      $3_1 = $0_1 & $3_1;
      $11_1 = $0_1 & $11_1;
      $16_1 = $0_1 & $9_1;
      $13_1 = $0_1 & $5_1;
      $2_1 = $0_1 & $6_1;
      $7_1 = $8_1 | ($12_1 | ($10_1 | $3_1)) | ($11_1 | ($16_1 | ($13_1 | $2_1))) ? -1 : 0;
      $3_1 = $3_1 ^ -1;
      $6_1 = $3_1 - 801750718 | 0;
      HEAP32[$4_1 + 8 >> 2] = $7_1 & $6_1;
      $2_1 = $2_1 ^ -1;
      $5_1 = $2_1 - (($3_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
      HEAP32[$4_1 + 12 >> 2] = $5_1 & $7_1;
      $0_1 = ($2_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 > $5_1 >>> 0;
      $5_1 = $10_1 ^ -1;
      $3_1 = $0_1 + $5_1 | 0;
      $6_1 = $13_1 ^ -1;
      $2_1 = $6_1;
      $13_1 = $3_1 - 1354194885 | 0;
      HEAP32[$4_1 + 16 >> 2] = $13_1 & $7_1;
      $2_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $9_1 = $2_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
      HEAP32[$4_1 + 20 >> 2] = $9_1 & $7_1;
      $12_1 = $12_1 ^ -1;
      $0_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
      $5_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 > $9_1 >>> 0;
      $2_1 = $0_1 + $5_1 | 0;
      $10_1 = $16_1 ^ -1;
      $3_1 = $10_1 + ($2_1 >>> 0 < $5_1 >>> 0) | 0;
      $0_1 = $2_1;
      $2_1 = $2_1 + $12_1 | 0;
      $3_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $6_1 = $2_1 - 2 | 0;
      HEAP32[$4_1 + 24 >> 2] = $6_1 & $7_1;
      $5_1 = $3_1 - ($2_1 >>> 0 < 2) | 0;
      HEAP32[$4_1 + 28 >> 2] = $5_1 & $7_1;
      $0_1 = ($3_1 | 0) == ($10_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $10_1 >>> 0;
      $2_1 = ($3_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 > $6_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
      $0_1 = $0_1 + $2_1 | 0;
      $3_1 = $0_1 >>> 0 < $2_1 >>> 0;
      $2_1 = $0_1 - $8_1 | 0;
      HEAP32[$4_1 + 32 >> 2] = $2_1 - 2 & $7_1;
      HEAP32[$4_1 + 36 >> 2] = ($3_1 - (($0_1 >>> 0 < $8_1 >>> 0) + $11_1 | 0) | 0) - ($2_1 >>> 0 < 2) & $7_1;
      $39($1_1, $14_1);
      $0_1 = !$15_1;
    }
    global$0 = $4_1 + 48 | 0;
    return $0_1;
  }
  function $52() {
    var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0;
    $4_1 = global$0 - 80 | 0;
    global$0 = $4_1;
    $24_1 = $4_1 + 8 | 0;
    $0_1 = $4_1 + 48 | 0;
    $38($24_1, 690788, $0_1);
    $29_1 = HEAP32[$4_1 + 48 >> 2];
    $20_1 = HEAP32[$4_1 + 32 >> 2];
    $25_1 = HEAP32[$4_1 + 36 >> 2];
    $21_1 = HEAP32[$4_1 + 24 >> 2];
    $26_1 = HEAP32[$4_1 + 28 >> 2];
    $22_1 = HEAP32[$4_1 + 8 >> 2];
    $27_1 = HEAP32[$4_1 + 12 >> 2];
    $23_1 = HEAP32[$4_1 + 16 >> 2];
    $28_1 = HEAP32[$4_1 + 20 >> 2];
    HEAP32[$4_1 + 44 >> 2] = 0;
    $38($0_1, 690949, $4_1 + 44 | 0);
    $3_1 = HEAP32[$4_1 + 52 >> 2];
    $0_1 = $3_1 + $27_1 | 0;
    $2_1 = HEAP32[$4_1 + 48 >> 2];
    $18_1 = $2_1 + $22_1 | 0;
    $15_1 = $18_1 >>> 0 < $22_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = HEAP32[$4_1 + 60 >> 2];
    $0_1 = $5_1 + $28_1 | 0;
    $9_1 = $0_1 + 1 | 0;
    $10_1 = $0_1;
    $0_1 = HEAP32[$4_1 + 56 >> 2];
    $1_1 = $0_1 + $23_1 | 0;
    $6_1 = $1_1 >>> 0 < $23_1 >>> 0 ? $9_1 : $10_1;
    $5_1 = ($6_1 | 0) == ($5_1 | 0) & $0_1 >>> 0 > $1_1 >>> 0 | $6_1 >>> 0 < $5_1 >>> 0;
    $0_1 = ($3_1 | 0) == ($15_1 | 0) & $2_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 > $15_1 >>> 0;
    $17_1 = $0_1 + $1_1 | 0;
    $13_1 = $17_1 >>> 0 < $0_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
    $2_1 = ($13_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 > $13_1 >>> 0;
    $5_1 = $5_1 + $2_1 | 0;
    $1_1 = HEAP32[$4_1 + 68 >> 2];
    $0_1 = $1_1 + $26_1 | 0;
    $9_1 = $0_1 + 1 | 0;
    $10_1 = $0_1;
    $0_1 = HEAP32[$4_1 + 64 >> 2];
    $6_1 = $0_1 + $21_1 | 0;
    $7_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $9_1 : $10_1;
    $2_1 = $7_1 + ($2_1 >>> 0 > $5_1 >>> 0) | 0;
    $16_1 = $6_1 + $5_1 | 0;
    $5_1 = $16_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = ($5_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $16_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
    $8_1 = $3_1 + (($1_1 | 0) == ($7_1 | 0) & $0_1 >>> 0 > $6_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0) | 0;
    $0_1 = $5_1;
    $6_1 = ($0_1 | 0) == -1;
    $14_1 = HEAP32[$4_1 + 76 >> 2];
    $2_1 = $14_1 + $25_1 | 0;
    $1_1 = HEAP32[$4_1 + 72 >> 2];
    $12_1 = $1_1 + $20_1 | 0;
    $11_1 = $12_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $11_1 + ($3_1 >>> 0 > $8_1 >>> 0) | 0;
    $9_1 = $2_1 + 1 | 0;
    $10_1 = $2_1;
    $2_1 = $8_1 + $12_1 | 0;
    $19_1 = $2_1 >>> 0 < $8_1 >>> 0 ? $9_1 : $10_1;
    $3_1 = $6_1 & $16_1 >>> 0 < 4294967294 | ($0_1 | 0) != -1 | ($19_1 & $2_1) != -1;
    $7_1 = ($13_1 | 0) == -1162945306;
    $8_1 = ($3_1 | ($7_1 & $17_1 >>> 0 < 2940772411 | $13_1 >>> 0 < 3132021990)) ^ -1;
    $3_1 = ((($11_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 > $12_1 >>> 0 | $11_1 >>> 0 < $14_1 >>> 0) + (($11_1 | 0) == ($19_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $11_1 >>> 0 > $19_1 >>> 0) | 0) + ($8_1 & (($15_1 | 0) == -1076732276 & $18_1 >>> 0 > 3493216576 | $15_1 >>> 0 > 3218235020) | ($8_1 & ($7_1 & $17_1 >>> 0 > 2940772411 | $13_1 >>> 0 > 3132021990) | ($16_1 | 0) == -1 & $6_1 & ($3_1 ^ -1))) | 0;
    $12_1 = $3_1 + $16_1 | 0;
    if ($12_1 >>> 0 < $16_1 >>> 0) {
      $0_1 = $0_1 + 1 | 0;
    }
    $7_1 = __wasm_i64_mul($3_1, 0, 1354194884, 1162945305);
    $6_1 = $13_1 + i64toi32_i32$HIGH_BITS | 0;
    $1_1 = __wasm_i64_mul($3_1, 0, 801750719, 1076732275);
    $9_1 = $1_1 + $18_1 | 0;
    $14_1 = $7_1 + $17_1 | 0;
    $3_1 = $15_1 + i64toi32_i32$HIGH_BITS | 0;
    $8_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = ($8_1 | 0) == ($15_1 | 0) & $18_1 >>> 0 > $9_1 >>> 0 | $8_1 >>> 0 < $15_1 >>> 0;
    $11_1 = $14_1 + $3_1 | 0;
    $1_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
    $7_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
    $3_1 = ($1_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $1_1 = $3_1 + (($1_1 | 0) == ($13_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $13_1 >>> 0) | 0;
    $10_1 = ($0_1 | 0) == ($5_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
    $3_1 = ($1_1 >>> 0 < $3_1 >>> 0) + $0_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $6_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $0_1 = ($6_1 | 0) == ($0_1 | 0) & $1_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $6_1 >>> 0;
    $5_1 = $10_1 + $0_1 | 0;
    $0_1 = $19_1 + ($0_1 >>> 0 > $5_1 >>> 0) | 0;
    $5_1 = $2_1 + $5_1 | 0;
    $3_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $4_1;
    if ($5_1 | ($11_1 | $9_1 | $1_1) | ($3_1 | ($7_1 | $8_1 | $6_1))) {
      $10_1 = HEAP32[$0_1 + 44 >> 2] | ($29_1 | !($20_1 | ($21_1 | ($22_1 | $23_1)) | ($25_1 | ($26_1 | ($27_1 | $28_1)))));
    } else {
      $10_1 = 1;
    }
    $4_1 = !$10_1;
    $2_1 = 0 - $4_1 | 0;
    HEAP32[$0_1 + 32 >> 2] = $5_1 & $2_1;
    HEAP32[$0_1 + 36 >> 2] = $2_1 & $3_1;
    HEAP32[$0_1 + 24 >> 2] = $1_1 & $2_1;
    HEAP32[$0_1 + 28 >> 2] = $2_1 & $6_1;
    HEAP32[$0_1 + 16 >> 2] = $2_1 & $11_1;
    HEAP32[$0_1 + 20 >> 2] = $2_1 & $7_1;
    HEAP32[$0_1 + 8 >> 2] = $2_1 & $9_1;
    HEAP32[$0_1 + 12 >> 2] = $2_1 & $8_1;
    $39(690788, $24_1);
    global$0 = $0_1 + 80 | 0;
    return $4_1;
  }
  function $53($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0, $65_1 = 0, $66_1 = 0, $67_1 = 0, $68_1 = 0, $69_1 = 0, $70_1 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
    $5_1 = global$0 - 1744 | 0;
    global$0 = $5_1;
    $15_1 = $5_1 + 1704 | 0;
    $69_1 = $1_1 + 80 | 0;
    $54($15_1, $69_1);
    $35_1 = $5_1 + 1664 | 0;
    $20_1 = $35_1 + 8 | 0;
    $6_1 = $20_1;
    $3_1 = $1_1 + 8 | 0;
    $27_1 = HEAP32[$3_1 >> 2];
    $19_1 = HEAP32[$3_1 + 4 >> 2];
    $7_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $1_1 + 32 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $9_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = $9_1;
    $4_1 = HEAP32[$1_1 >> 2];
    $9_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
    $4_1 = $4_1 + $9_1 | 0;
    $3_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
    $7_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $19_1;
    $9_1 = $7_1 >>> 20 | 0;
    $24_1 = $9_1 + $27_1 | 0;
    $3_1 = $9_1 >>> 0 > $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$6_1 >> 2] = $24_1;
    $71 = $3_1 & 1048575;
    HEAP32[$6_1 + 4 >> 2] = $71;
    $27_1 = $35_1 + 16 | 0;
    $9_1 = $27_1;
    $6_1 = $1_1 + 16 | 0;
    $19_1 = HEAP32[$6_1 >> 2];
    $13_1 = HEAP32[$6_1 + 4 >> 2];
    $6_1 = $3_1;
    $3_1 = $13_1;
    $6_1 = $6_1 >>> 20 | 0;
    $25_1 = $6_1 + $19_1 | 0;
    $3_1 = $6_1 >>> 0 > $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$9_1 >> 2] = $25_1;
    $72 = $3_1 & 1048575;
    HEAP32[$9_1 + 4 >> 2] = $72;
    $19_1 = $35_1 + 24 | 0;
    $9_1 = $19_1;
    $6_1 = $1_1 + 24 | 0;
    $13_1 = HEAP32[$6_1 >> 2];
    $47_1 = HEAP32[$6_1 + 4 >> 2];
    $6_1 = $3_1;
    $3_1 = $47_1;
    $6_1 = $6_1 >>> 20 | 0;
    $28_1 = $6_1 + $13_1 | 0;
    $3_1 = $6_1 >>> 0 > $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$9_1 >> 2] = $28_1;
    $73 = $3_1 & 1048575;
    HEAP32[$9_1 + 4 >> 2] = $73;
    $13_1 = $35_1 + 32 | 0;
    $9_1 = $13_1;
    $6_1 = $3_1;
    $3_1 = $8_1 & 65535;
    $6_1 = $6_1 >>> 20 | 0;
    $45_1 = $6_1 + $11_1 | 0;
    $3_1 = $6_1 >>> 0 > $45_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$9_1 >> 2] = $45_1;
    $57_1 = $3_1;
    HEAP32[$9_1 + 4 >> 2] = $3_1;
    $54_1 = $4_1;
    HEAP32[$5_1 + 1664 >> 2] = $4_1;
    $74 = $7_1 & 1048575;
    HEAP32[$5_1 + 1668 >> 2] = $74;
    $34($5_1 + 1624 | 0, $2_1, $15_1);
    $3_1 = $1_1 - -64 | 0;
    $22_1 = HEAP32[$3_1 >> 2];
    $16_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $1_1 + 56 | 0;
    $21_1 = HEAP32[$3_1 >> 2];
    $33_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $1_1 + 48 | 0;
    $38_1 = HEAP32[$3_1 >> 2];
    $42_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $1_1 + 72 | 0;
    $44_1 = HEAP32[$3_1 >> 2];
    $47_1 = HEAP32[$3_1 + 4 >> 2];
    $36_1 = HEAP32[$1_1 + 40 >> 2];
    $26_1 = HEAP32[$1_1 + 44 >> 2];
    $3_1 = $5_1 + 1584 | 0;
    $34($3_1, $2_1 + 40 | 0, $15_1);
    $34($3_1, $3_1, $69_1);
    $34_1 = HEAP32[$5_1 + 1636 >> 2];
    $3_1 = $34_1 + HEAP32[$20_1 + 4 >> 2] | 0;
    $63_1 = $5_1 + 1544 | 0;
    $65_1 = $63_1 + 8 | 0;
    $4_1 = $65_1;
    $58_1 = HEAP32[$5_1 + 1632 >> 2];
    $11_1 = HEAP32[$20_1 >> 2];
    $9_1 = $58_1 + $11_1 | 0;
    HEAP32[$4_1 >> 2] = $9_1;
    $15_1 = $9_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$4_1 + 4 >> 2] = $15_1;
    $31_1 = HEAP32[$5_1 + 1644 >> 2];
    $3_1 = $31_1 + HEAP32[$27_1 + 4 >> 2] | 0;
    $66_1 = $63_1 + 16 | 0;
    $7_1 = $66_1;
    $59_1 = HEAP32[$5_1 + 1640 >> 2];
    $4_1 = HEAP32[$27_1 >> 2];
    $11_1 = $59_1 + $4_1 | 0;
    HEAP32[$7_1 >> 2] = $11_1;
    $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$7_1 + 4 >> 2] = $4_1;
    $32_1 = HEAP32[$5_1 + 1652 >> 2];
    $3_1 = $32_1 + HEAP32[$19_1 + 4 >> 2] | 0;
    $67_1 = $63_1 + 24 | 0;
    $20_1 = $67_1;
    $39_1 = HEAP32[$5_1 + 1648 >> 2];
    $7_1 = HEAP32[$19_1 >> 2];
    $6_1 = $39_1 + $7_1 | 0;
    HEAP32[$20_1 >> 2] = $6_1;
    $7_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$20_1 + 4 >> 2] = $7_1;
    $48_1 = HEAP32[$5_1 + 1660 >> 2];
    $3_1 = $48_1 + HEAP32[$13_1 + 4 >> 2] | 0;
    $61_1 = $63_1 + 32 | 0;
    $27_1 = $61_1;
    $37_1 = HEAP32[$5_1 + 1656 >> 2];
    $19_1 = HEAP32[$13_1 >> 2];
    $20_1 = $37_1 + $19_1 | 0;
    HEAP32[$27_1 >> 2] = $20_1;
    $13_1 = $19_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$27_1 + 4 >> 2] = $13_1;
    $51_1 = HEAP32[$5_1 + 1628 >> 2];
    $3_1 = $51_1 + HEAP32[$5_1 + 1668 >> 2] | 0;
    $30_1 = HEAP32[$5_1 + 1624 >> 2];
    $19_1 = HEAP32[$5_1 + 1664 >> 2];
    $27_1 = $30_1 + $19_1 | 0;
    HEAP32[$5_1 + 1544 >> 2] = $27_1;
    $19_1 = $19_1 >>> 0 > $27_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 1548 >> 2] = $19_1;
    $56_1 = $5_1 + 1232 | 0;
    $12_1 = $27_1 << 1;
    $10_1 = $19_1 << 1 | $27_1 >>> 31;
    $69($56_1, $6_1, $7_1, 0, 0, $12_1, $10_1, 0, 0);
    $40_1 = $5_1 + 1312 | 0;
    $23_1 = $9_1 << 1;
    $17_1 = $15_1;
    $14_1 = $9_1;
    $15_1 = $15_1 << 1 | $9_1 >>> 31;
    $69($40_1, $11_1, $4_1, 0, 0, $23_1, $15_1, 0, 0);
    $18_1 = $5_1 + 1168 | 0;
    $3_1 = $13_1;
    $69($18_1, $20_1, $3_1, 0, 0, $20_1, $3_1, 0, 0);
    $52_1 = $5_1 + 1152 | 0;
    $69($52_1, HEAP32[$5_1 + 1168 >> 2], HEAP32[$5_1 + 1172 >> 2], 0, 0, 15632, 16, 0, 0);
    $43_1 = $5_1 + 1120 | 0;
    $9_1 = $20_1 << 1;
    $13_1 = $3_1 << 1 | $20_1 >>> 31;
    $69($43_1, $9_1, $13_1, 0, 0, $27_1, $19_1, 0, 0);
    $46_1 = $5_1 + 1216 | 0;
    $69($46_1, $6_1, $7_1, 0, 0, $23_1, $15_1, 0, 0);
    $53_1 = $5_1 + 1328 | 0;
    $69($53_1, $11_1, $4_1, 0, 0, $11_1, $4_1, 0, 0);
    $49_1 = $5_1 + 1136 | 0;
    $3_1 = $18_1 + 8 | 0;
    $69($49_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $60_1 = $5_1 + 1248 | 0;
    $69($60_1, $27_1, $19_1, 0, 0, $27_1, $19_1, 0, 0);
    $50_1 = $5_1 + 1104 | 0;
    $69($50_1, $9_1, $13_1, 0, 0, $14_1, $17_1, 0, 0);
    $41_1 = $4_1;
    $27_1 = $11_1;
    $3_1 = $4_1 << 1 | $11_1 >>> 31;
    $55_1 = $5_1 + 1200 | 0;
    $23_1 = $6_1;
    $18_1 = $7_1;
    $69($55_1, $6_1, $7_1, 0, 0, $11_1 << 1, $3_1, 0, 0);
    $15_1 = HEAP32[$5_1 + 1232 >> 2];
    $4_1 = HEAP32[$5_1 + 1312 >> 2];
    $11_1 = $15_1 + $4_1 | 0;
    $6_1 = HEAP32[$5_1 + 1236 >> 2];
    $3_1 = $6_1 + HEAP32[$5_1 + 1316 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + HEAP32[$5_1 + 1156 >> 2] | 0;
    $7_1 = $11_1;
    $20_1 = HEAP32[$5_1 + 1152 >> 2];
    $11_1 = $7_1 + $20_1 | 0;
    $29_1 = $11_1;
    $11_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 > $29_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
    $3_1 = $52_1 + 8 | 0;
    $19_1 = HEAP32[$3_1 >> 2];
    $8_1 = HEAP32[$3_1 + 4 >> 2];
    $6_1 = ($4_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
    $3_1 = $40_1 + 8 | 0;
    $15_1 = HEAP32[$3_1 >> 2];
    $4_1 = $56_1 + 8 | 0;
    $7_1 = $15_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $6_1 + $7_1 | 0;
    $3_1 = ($4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $8_1 | 0;
    $6_1 = $4_1;
    $4_1 = $4_1 + $19_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $20_1 | 0;
    $7_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $7_1 << 12 | $4_1 >>> 20;
    $40_1 = $11_1;
    $11_1 = $4_1 << 12 | $11_1 >>> 20;
    $56_1 = $6_1;
    $62_1 = HEAP32[$5_1 + 1216 >> 2];
    $6_1 = HEAP32[$5_1 + 1328 >> 2];
    $4_1 = $62_1 + $6_1 | 0;
    $52_1 = HEAP32[$5_1 + 1220 >> 2];
    $3_1 = $52_1 + HEAP32[$5_1 + 1332 >> 2] | 0;
    $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = $4_1;
    $15_1 = HEAP32[$5_1 + 1120 >> 2];
    $3_1 = $4_1 + $15_1 | 0;
    $4_1 = $6_1 + HEAP32[$5_1 + 1124 >> 2] | 0;
    $15_1 = $3_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $19_1 = $3_1;
    $8_1 = HEAP32[$5_1 + 1136 >> 2];
    $4_1 = $3_1 + $8_1 | 0;
    $3_1 = $15_1 + HEAP32[$5_1 + 1140 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $56_1 | 0;
    $68_1 = $5_1 + 1088 | 0;
    $56_1 = $8_1 + $11_1 | 0;
    $11_1 = $56_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $64_1 = ($4_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 > $56_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
    $8_1 = ($4_1 | 0) == ($15_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
    $3_1 = $49_1 + 8 | 0;
    $49_1 = HEAP32[$3_1 >> 2];
    $70_1 = HEAP32[$3_1 + 4 >> 2];
    $15_1 = ($6_1 | 0) == ($15_1 | 0) & $19_1 >>> 0 < $20_1 >>> 0 | $6_1 >>> 0 > $15_1 >>> 0;
    $3_1 = $43_1 + 8 | 0;
    $19_1 = HEAP32[$3_1 >> 2];
    $43_1 = HEAP32[$3_1 + 4 >> 2];
    $20_1 = ($6_1 | 0) == ($52_1 | 0) & $20_1 >>> 0 < $62_1 >>> 0 | $6_1 >>> 0 < $52_1 >>> 0;
    $3_1 = $53_1 + 8 | 0;
    $52_1 = HEAP32[$3_1 >> 2];
    $4_1 = $46_1 + 8 | 0;
    $6_1 = $52_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $6_1 >>> 0 < $52_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $6_1 + $20_1 | 0;
    $3_1 = ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $43_1 | 0;
    $6_1 = $4_1;
    $4_1 = $4_1 + $19_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $15_1 | 0;
    $3_1 = ($6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $70_1 | 0;
    $6_1 = $4_1 + $49_1 | 0;
    $4_1 = $6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 + $8_1 | 0;
    $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $3_1;
    $3_1 = $4_1;
    $7_1 = $7_1 >>> 20 | 0;
    $4_1 = $6_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $64_1 | 0;
    $7_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $7_1 << 12 | $4_1 >>> 20;
    $6_1 = $11_1;
    $4_1 = $4_1 << 12 | $6_1 >>> 20;
    $11_1 = $15_1;
    $8_1 = HEAP32[$5_1 + 1104 >> 2];
    $15_1 = HEAP32[$5_1 + 1200 >> 2];
    $20_1 = $8_1 + $15_1 | 0;
    $19_1 = HEAP32[$5_1 + 1108 >> 2];
    $3_1 = $19_1 + HEAP32[$5_1 + 1204 >> 2] | 0;
    $15_1 = $15_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $20_1 | 0;
    $4_1 = $11_1 + $15_1 | 0;
    $11_1 = $3_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $3_1;
    $3_1 = $11_1 << 4 | $3_1 >>> 28;
    $43_1 = $4_1 << 4 & -16;
    $52_1 = $6_1;
    $69($68_1, $43_1 | $6_1 >>> 16 & 15, $3_1 & 16777215, 0, 0, 977, 1, 0, 0);
    $43_1 = $5_1 + 1280 | 0;
    $69($43_1, $14_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
    $46_1 = $5_1 + 1072 | 0;
    $69($46_1, $9_1, $13_1, 0, 0, $27_1, $41_1, 0, 0);
    $53_1 = $5_1 + 1184 | 0;
    $69($53_1, $23_1, $18_1, 0, 0, $23_1, $18_1, 0, 0);
    $64_1 = $5_1 + 1056 | 0;
    $49_1 = $64_1;
    $62_1 = ($11_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $20_1 >>> 0 | $11_1 >>> 0 < $15_1 >>> 0;
    $6_1 = ($15_1 | 0) == ($19_1 | 0) & $8_1 >>> 0 > $20_1 >>> 0 | $15_1 >>> 0 < $19_1 >>> 0;
    $3_1 = $55_1 + 8 | 0;
    $15_1 = HEAP32[$3_1 >> 2];
    $20_1 = $50_1 + 8 | 0;
    $4_1 = $15_1 + HEAP32[$20_1 >> 2] | 0;
    $3_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = $4_1 + $6_1 | 0;
    $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $7_1 >>> 20 | 0;
    $6_1 = $7_1;
    $7_1 = $4_1 + $7_1 | 0;
    $4_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $7_1 + $62_1 | 0;
    $4_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $4_1 << 12 | $3_1 >>> 20;
    $7_1 = $3_1 << 12 | $11_1 >>> 20;
    $15_1 = $6_1;
    $19_1 = HEAP32[$5_1 + 1072 >> 2];
    $6_1 = HEAP32[$5_1 + 1184 >> 2];
    $11_1 = $19_1 + $6_1 | 0;
    $20_1 = HEAP32[$5_1 + 1076 >> 2];
    $3_1 = $20_1 + HEAP32[$5_1 + 1188 >> 2] | 0;
    $3_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $11_1;
    $11_1 = $3_1;
    $3_1 = $3_1 + $15_1 | 0;
    $7_1 = $6_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $7_1;
    $7_1 = $3_1;
    $69($49_1, $15_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $8_1 = $5_1 + 1264 | 0;
    $69($8_1, $27_1, $41_1, 0, 0, $12_1, $10_1, 0, 0);
    $10_1 = $5_1 + 1296 | 0;
    $69($10_1, $14_1, $17_1, 0, 0, $14_1, $17_1, 0, 0);
    $27_1 = $5_1 + 1040 | 0;
    $69($27_1, $9_1, $13_1, 0, 0, $23_1, $18_1, 0, 0);
    $12_1 = $5_1 + 1024 | 0;
    $9_1 = $12_1;
    $15_1 = ($3_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $15_1 >>> 0 | $3_1 >>> 0 < $11_1 >>> 0;
    $6_1 = ($11_1 | 0) == ($20_1 | 0) & $6_1 >>> 0 < $19_1 >>> 0 | $11_1 >>> 0 < $20_1 >>> 0;
    $3_1 = $53_1 + 8 | 0;
    $20_1 = HEAP32[$3_1 >> 2];
    $19_1 = $46_1 + 8 | 0;
    $11_1 = $20_1 + HEAP32[$19_1 >> 2] | 0;
    $3_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $11_1;
    $11_1 = $6_1 + $11_1 | 0;
    $3_1 = $13_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $6_1 = $4_1;
    $4_1 = $4_1 + $11_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $11_1 = $4_1 + $15_1 | 0;
    $4_1 = $11_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1 << 12 | $11_1 >>> 20;
    $15_1 = $11_1 << 12 | $7_1 >>> 20;
    $20_1 = HEAP32[$5_1 + 1040 >> 2];
    $11_1 = $15_1 + $20_1 | 0;
    $7_1 = $6_1;
    $3_1 = $6_1 + HEAP32[$5_1 + 1044 >> 2] | 0;
    $3_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($9_1, $11_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $14_1 = $5_1 + 1008 | 0;
    $6_1 = $14_1;
    $11_1 = ($3_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $27_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $9_1 = $4_1;
    $4_1 = $4_1 + $7_1 | 0;
    $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $4_1;
    $4_1 = $4_1 + $11_1 | 0;
    $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($6_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $49_1 = HEAP32[$5_1 + 1608 >> 2];
    $53_1 = HEAP32[$5_1 + 1612 >> 2];
    $50_1 = HEAP32[$5_1 + 1600 >> 2];
    $70_1 = HEAP32[$5_1 + 1604 >> 2];
    $62_1 = HEAP32[$5_1 + 1584 >> 2];
    $75 = HEAP32[$5_1 + 1588 >> 2];
    $27_1 = HEAP32[$5_1 + 1616 >> 2];
    $19_1 = HEAP32[$5_1 + 1620 >> 2];
    $55_1 = HEAP32[$5_1 + 1592 >> 2];
    $76 = HEAP32[$5_1 + 1596 >> 2];
    HEAP32[$5_1 + 1416 >> 2] = -4 - $37_1;
    HEAP32[$5_1 + 1420 >> 2] = 262143 - (($37_1 >>> 0 > 4294967292) + $48_1 | 0);
    HEAP32[$5_1 + 1408 >> 2] = -4 - $39_1;
    HEAP32[$5_1 + 1412 >> 2] = 4194303 - (($39_1 >>> 0 > 4294967292) + $32_1 | 0);
    HEAP32[$5_1 + 1400 >> 2] = -4 - $59_1;
    HEAP32[$5_1 + 1404 >> 2] = 4194303 - (($59_1 >>> 0 > 4294967292) + $31_1 | 0);
    HEAP32[$5_1 + 1392 >> 2] = -4 - $58_1;
    HEAP32[$5_1 + 1396 >> 2] = 4194303 - (($58_1 >>> 0 > 4294967292) + $34_1 | 0);
    HEAP32[$5_1 + 1384 >> 2] = -3908 - $30_1;
    HEAP32[$5_1 + 1388 >> 2] = 4194299 - (($30_1 >>> 0 > 4294963388) + $51_1 | 0);
    $3_1 = $60_1 + 8 | 0;
    $17_1 = HEAP32[$3_1 >> 2];
    $23_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $68_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $39_1 = HEAP32[$3_1 + 4 >> 2];
    $11_1 = HEAP32[$5_1 + 1248 >> 2];
    $3_1 = HEAP32[$5_1 + 1252 >> 2];
    $6_1 = HEAP32[$5_1 + 1088 >> 2];
    $4_1 = HEAP32[$5_1 + 1092 >> 2];
    $15_1 = $43_1 + 8 | 0;
    $37_1 = HEAP32[$15_1 >> 2];
    $30_1 = HEAP32[$15_1 + 4 >> 2];
    $15_1 = $64_1 + 8 | 0;
    $9_1 = HEAP32[$15_1 >> 2];
    $34_1 = HEAP32[$15_1 + 4 >> 2];
    $20_1 = HEAP32[$5_1 + 1280 >> 2];
    $31_1 = HEAP32[$5_1 + 1284 >> 2];
    $13_1 = HEAP32[$5_1 + 1056 >> 2];
    $15_1 = HEAP32[$5_1 + 1060 >> 2];
    $10_1 = $10_1 + 8 | 0;
    $60_1 = HEAP32[$10_1 >> 2];
    $68_1 = HEAP32[$10_1 + 4 >> 2];
    $8_1 = $8_1 + 8 | 0;
    $51_1 = HEAP32[$8_1 >> 2];
    $64_1 = HEAP32[$8_1 + 4 >> 2];
    $8_1 = HEAP32[$5_1 + 1296 >> 2];
    $77 = HEAP32[$5_1 + 1300 >> 2];
    $43_1 = HEAP32[$5_1 + 1264 >> 2];
    $32_1 = HEAP32[$5_1 + 1268 >> 2];
    $10_1 = $12_1 + 8 | 0;
    $41_1 = HEAP32[$10_1 >> 2];
    $58_1 = HEAP32[$10_1 + 4 >> 2];
    $10_1 = HEAP32[$5_1 + 1024 >> 2];
    $12_1 = HEAP32[$5_1 + 1028 >> 2];
    $46_1 = HEAP32[$5_1 + 1008 >> 2];
    $48_1 = HEAP32[$5_1 + 1012 >> 2];
    $14_1 = $14_1 + 8 | 0;
    $78 = HEAP32[$14_1 >> 2];
    $59_1 = HEAP32[$14_1 + 4 >> 2];
    $79 = $5_1 + 1384 | 0;
    $34($5_1 + 1504 | 0, $35_1, $79);
    $3_1 = $3_1 + $4_1 | 0;
    $18_1 = $6_1 + $11_1 | 0;
    $11_1 = $18_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
    $4_1 = $23_1 + $39_1 | 0;
    $3_1 = $7_1;
    $7_1 = $7_1 + $17_1 | 0;
    $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $6_1 + $7_1 | 0;
    $7_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $7_1 << 12 | $4_1 >>> 20;
    $35_1 = $11_1;
    $11_1 = $4_1 << 12 | $11_1 >>> 20;
    $14_1 = $3_1;
    $3_1 = $15_1 + $31_1 | 0;
    $6_1 = $13_1 + $20_1 | 0;
    $4_1 = $6_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $14_1 | 0;
    $23_1 = $6_1 + $11_1 | 0;
    $11_1 = $23_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $23_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
    $15_1 = ($4_1 | 0) == ($15_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
    $3_1 = $30_1 + $34_1 | 0;
    $6_1 = $9_1 + $37_1 | 0;
    $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 + $15_1 | 0;
    $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $3_1;
    $3_1 = $4_1;
    $7_1 = $7_1 >>> 20 | 0;
    $4_1 = $6_1 + $7_1 | 0;
    $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $20_1 | 0;
    $15_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $15_1 << 12 | $4_1 >>> 20;
    $39_1 = $11_1;
    $11_1 = $4_1 << 12 | $11_1 >>> 20;
    $3_1 = $32_1 + $77 | 0;
    $14_1 = $8_1 + $43_1 | 0;
    $9_1 = $14_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $9_1 + $12_1 | 0;
    $12_1 = $10_1 + $14_1 | 0;
    $20_1 = $12_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $3_1 = $20_1 + $7_1 | 0;
    $17_1 = $11_1 + $12_1 | 0;
    $11_1 = $17_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $27_1;
    $6_1 = $19_1;
    $10_1 = $44_1;
    $44_1 = $47_1 & 65535;
    $4_1 = __wasm_i64_mul($47_1 >>> 16 | 0, 0, 977, 1);
    $19_1 = $4_1 + $36_1 | 0;
    $3_1 = $26_1 + i64toi32_i32$HIGH_BITS | 0;
    $37_1 = $4_1 >>> 0 > $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $42_1;
    $4_1 = $37_1 >>> 20 | 0;
    $27_1 = $4_1 + $38_1 | 0;
    $30_1 = $4_1 >>> 0 > $27_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $33_1;
    $4_1 = $30_1 >>> 20 | 0;
    $13_1 = $4_1 + $21_1 | 0;
    $34_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $16_1;
    $3_1 = $44_1;
    $8_1 = $34_1 >>> 20 | 0;
    $16_1 = $8_1;
    $8_1 = $8_1 + $22_1 | 0;
    $31_1 = $16_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $31_1 >>> 20 | 0;
    $47_1 = $4_1 + $10_1 | 0;
    $10_1 = $4_1 >>> 0 > $47_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $10_1 + $6_1 | 0;
    $6_1 = $7_1 + $47_1 | 0;
    $7_1 = $6_1 >>> 0 < $47_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = HEAP32[$5_1 + 1528 >> 2];
    $21_1 = HEAP32[$5_1 + 1532 >> 2];
    $22_1 = ($11_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 > $17_1 >>> 0 | $11_1 >>> 0 < $20_1 >>> 0;
    $20_1 = ($9_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $9_1 >>> 0 > $20_1 >>> 0;
    $12_1 = ($9_1 | 0) == ($32_1 | 0) & $14_1 >>> 0 < $43_1 >>> 0 | $9_1 >>> 0 < $32_1 >>> 0;
    $3_1 = $64_1 + $68_1 | 0;
    $9_1 = $51_1 + $60_1 | 0;
    $4_1 = $9_1 >>> 0 < $51_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1;
    $9_1 = $9_1 + $12_1 | 0;
    $3_1 = ($3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $58_1 | 0;
    $4_1 = $9_1 + $41_1 | 0;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $4_1;
    $4_1 = $4_1 + $20_1 | 0;
    $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $15_1 >>> 20 | 0;
    $4_1 = $4_1 + $15_1 | 0;
    $3_1 = $15_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $4_1;
    $4_1 = $4_1 + $22_1 | 0;
    $15_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1;
    $4_1 = $15_1 << 12 | $3_1 >>> 20;
    $22_1 = $11_1;
    $11_1 = $3_1 << 12 | $11_1 >>> 20;
    $12_1 = $4_1;
    $9_1 = $29_1 & -2;
    $4_1 = $9_1 + $46_1 | 0;
    $3_1 = $48_1 + ($40_1 & 1048575) | 0;
    $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1 + $12_1 | 0;
    $20_1 = $4_1;
    $33_1 = $4_1 + $11_1 | 0;
    $11_1 = $4_1 >>> 0 > $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $21_1 + ($11_1 & 1048575) | 0;
    $12_1 = $16_1 + $33_1 | 0;
    $14_1 = $12_1 >>> 0 < $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = HEAP32[$5_1 + 1524 >> 2] + ($22_1 & 1048575) | 0;
    $4_1 = $17_1;
    $17_1 = HEAP32[$5_1 + 1520 >> 2] + $17_1 | 0;
    $22_1 = $4_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = HEAP32[$5_1 + 1516 >> 2] + ($39_1 & 1048575) | 0;
    $4_1 = $23_1;
    $23_1 = HEAP32[$5_1 + 1512 >> 2] + $23_1 | 0;
    $16_1 = $4_1 >>> 0 > $23_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = HEAP32[$5_1 + 1508 >> 2] + ($35_1 & 1048575) | 0;
    $3_1 = $18_1;
    $18_1 = HEAP32[$5_1 + 1504 >> 2] + $18_1 | 0;
    $21_1 = $3_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $3_1 = HEAP32[$5_1 + 1540 >> 2] + ($52_1 & 65535) | 0;
    $4_1 = HEAP32[$5_1 + 1536 >> 2] + $56_1 | 0;
    $3_1 = $4_1 >>> 0 < $56_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $56_1 = $4_1;
    $38_1 = $3_1;
    $33_1 = ($9_1 | 0) == ($11_1 | 0) & $20_1 >>> 0 > $33_1 >>> 0 | $9_1 >>> 0 > $11_1 >>> 0;
    $9_1 = ($9_1 | 0) == ($48_1 | 0) & $20_1 >>> 0 < $46_1 >>> 0 | $9_1 >>> 0 < $48_1 >>> 0;
    $4_1 = $9_1 + $78 | 0;
    $3_1 = $59_1;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $15_1 >>> 20 | 0;
    $9_1 = $15_1;
    $15_1 = $4_1 + $15_1 | 0;
    $4_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $15_1;
    $15_1 = $15_1 + $33_1 | 0;
    $3_1 = ($3_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $15_1 >>> 20;
    $4_1 = $15_1 << 12 | $11_1 >>> 20;
    $11_1 = $4_1 + $56_1 | 0;
    $3_1 = $3_1 + $38_1 | 0;
    $15_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = __wasm_i64_mul($15_1 >>> 16 | 0, 0, 977, 1);
    $4_1 = $9_1 + $18_1 | 0;
    $3_1 = $21_1 + i64toi32_i32$HIGH_BITS | 0;
    $33_1 = $4_1;
    $38_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $16_1;
    $4_1 = $38_1 >>> 20 | 0;
    $42_1 = $4_1 + $23_1 | 0;
    $44_1 = $4_1 >>> 0 > $42_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $22_1;
    $3_1 = $14_1;
    $9_1 = $44_1 >>> 20 | 0;
    $36_1 = $9_1 + $17_1 | 0;
    $26_1 = $9_1 >>> 0 > $36_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $26_1 >>> 20 | 0;
    $41_1 = $4_1 + $12_1 | 0;
    $9_1 = $4_1 >>> 0 > $41_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $15_1 & 65535;
    $4_1 = $9_1 >>> 20 | 0;
    $29_1 = $4_1 + $11_1 | 0;
    $40_1 = $4_1 >>> 0 > $29_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $48_1 = $47_1 << 1;
    $51_1 = $10_1 << 1 | $47_1 >>> 31;
    $43_1 = $11_1;
    $46_1 = $15_1;
    $47_1 = $6_1;
    $60_1 = $7_1 & 65535;
    $4_1 = $53_1;
    $53_1 = $31_1 & 1048575;
    $3_1 = $4_1 + $53_1 | 0;
    $52_1 = $8_1 + $49_1 | 0;
    $15_1 = $52_1 >>> 0 < $49_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $49_1 = $34_1 & 1048575;
    $3_1 = $49_1 + $70_1 | 0;
    $58_1 = $13_1 + $50_1 | 0;
    $20_1 = $58_1 >>> 0 < $50_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $50_1 = $30_1 & 1048575;
    $4_1 = $50_1 + $76 | 0;
    $6_1 = $27_1;
    $59_1 = $6_1 + $55_1 | 0;
    $27_1 = $59_1 >>> 0 < $55_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $55_1 = $37_1 & 1048575;
    $3_1 = $55_1 + $75 | 0;
    $10_1 = $19_1;
    $19_1 = $10_1 + $62_1 | 0;
    $11_1 = $19_1 >>> 0 < $62_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $56_1 = $7_1;
    $7_1 = __wasm_i64_mul($7_1 >>> 16 | 0, 0, 977, 1);
    $4_1 = $7_1 + $19_1 | 0;
    $3_1 = $11_1 + i64toi32_i32$HIGH_BITS | 0;
    $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $4_1;
    $35_1 = $3_1;
    $3_1 = $27_1;
    $4_1 = $35_1 >>> 20 | 0;
    $39_1 = $4_1 + $59_1 | 0;
    $37_1 = $4_1 >>> 0 > $39_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $20_1;
    $4_1 = $37_1 >>> 20 | 0;
    $30_1 = $4_1 + $58_1 | 0;
    $34_1 = $4_1 >>> 0 > $30_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $15_1;
    $3_1 = $60_1;
    $31_1 = $34_1 >>> 20 | 0;
    $32_1 = $31_1;
    $31_1 = $31_1 + $52_1 | 0;
    $4_1 = $32_1 >>> 0 > $31_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $32_1 = $4_1 >>> 20 | 0;
    $60_1 = $32_1;
    $32_1 = $32_1 + $47_1 | 0;
    $3_1 = $60_1 >>> 0 > $32_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    if ($32_1 | ($31_1 | ($7_1 | $39_1 | $30_1)) | ($3_1 | ($35_1 | $37_1 | $34_1 | $4_1) & 1048575)) {
      if (($39_1 & ($7_1 ^ 976) & $30_1 & $31_1 & $32_1) == -1) {
        $4_1 = ($37_1 & ($35_1 ^ 1) & $34_1 & $4_1 & ($3_1 ^ 983040)) == 1048575;
      } else {
        $4_1 = 0;
      }
    } else {
      $4_1 = 1;
    }
    $3_1 = $4_1;
    if ($41_1 | ($33_1 | $42_1 | $36_1) | $29_1 | (($44_1 | $38_1 | $26_1 | $9_1) & 1048575 | $40_1)) {
      if (($42_1 & ($33_1 ^ 976) & $36_1 & $41_1 & $29_1) == -1) {
        $4_1 = ($44_1 & ($38_1 ^ 1) & $26_1 & $9_1 & ($40_1 ^ 983040)) == 1048575;
      } else {
        $4_1 = 0;
      }
    } else {
      $4_1 = 1;
    }
    $29_1 = $3_1 & $4_1;
    HEAP32[$5_1 + 1376 >> 2] = $29_1 ? $48_1 : $43_1;
    HEAP32[$5_1 + 1380 >> 2] = $29_1 ? $51_1 : $46_1;
    HEAP32[$5_1 + 1368 >> 2] = $29_1 ? $8_1 << 1 : $12_1;
    HEAP32[$5_1 + 1372 >> 2] = $29_1 ? $53_1 << 1 | $8_1 >>> 31 : $14_1;
    HEAP32[$5_1 + 1360 >> 2] = $29_1 ? $13_1 << 1 : $17_1;
    HEAP32[$5_1 + 1364 >> 2] = $29_1 ? $49_1 << 1 | $13_1 >>> 31 : $22_1;
    HEAP32[$5_1 + 1352 >> 2] = $29_1 ? $6_1 << 1 : $23_1;
    HEAP32[$5_1 + 1356 >> 2] = $29_1 ? $50_1 << 1 | $6_1 >>> 31 : $16_1;
    HEAP32[$5_1 + 1344 >> 2] = $29_1 ? $10_1 << 1 : $18_1;
    HEAP32[$5_1 + 1348 >> 2] = $29_1 ? $55_1 << 1 | $10_1 >>> 31 : $21_1;
    $3_1 = HEAP32[$5_1 + 1420 >> 2] + $57_1 | 0;
    $4_1 = HEAP32[$5_1 + 1416 >> 2] + $45_1 | 0;
    $3_1 = $4_1 >>> 0 < $45_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $29_1 ? $4_1 : $47_1;
    HEAP32[$5_1 + 1416 >> 2] = $8_1;
    $10_1 = $29_1 ? $3_1 : $56_1;
    HEAP32[$5_1 + 1420 >> 2] = $10_1;
    $3_1 = HEAP32[$5_1 + 1412 >> 2] + $73 | 0;
    $4_1 = HEAP32[$5_1 + 1408 >> 2] + $28_1 | 0;
    $3_1 = $4_1 >>> 0 < $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $41_1 = $29_1 ? $4_1 : $52_1;
    HEAP32[$5_1 + 1408 >> 2] = $41_1;
    $40_1 = $29_1 ? $3_1 : $15_1;
    HEAP32[$5_1 + 1412 >> 2] = $40_1;
    $3_1 = HEAP32[$5_1 + 1404 >> 2] + $72 | 0;
    $4_1 = HEAP32[$5_1 + 1400 >> 2] + $25_1 | 0;
    $3_1 = $4_1 >>> 0 < $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $29_1 ? $4_1 : $58_1;
    HEAP32[$5_1 + 1400 >> 2] = $7_1;
    $6_1 = $29_1 ? $3_1 : $20_1;
    HEAP32[$5_1 + 1404 >> 2] = $6_1;
    $3_1 = HEAP32[$5_1 + 1396 >> 2] + $71 | 0;
    $4_1 = HEAP32[$5_1 + 1392 >> 2] + $24_1 | 0;
    $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $29_1 ? $4_1 : $59_1;
    HEAP32[$5_1 + 1392 >> 2] = $4_1;
    $9_1 = $29_1 ? $3_1 : $27_1;
    HEAP32[$5_1 + 1396 >> 2] = $9_1;
    $3_1 = HEAP32[$5_1 + 1388 >> 2] + $74 | 0;
    $13_1 = HEAP32[$5_1 + 1384 >> 2] + $54_1 | 0;
    $3_1 = $13_1 >>> 0 < $54_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $29_1 ? $13_1 : $19_1;
    HEAP32[$5_1 + 1384 >> 2] = $13_1;
    $3_1 = $29_1 ? $3_1 : $11_1;
    $12_1 = $3_1;
    HEAP32[$5_1 + 1388 >> 2] = $3_1;
    $14_1 = $5_1 + 896 | 0;
    $25_1 = $13_1 << 1;
    $24_1 = $3_1 << 1 | $13_1 >>> 31;
    $69($14_1, $25_1, $24_1, 0, 0, $41_1, $40_1, 0, 0);
    $33_1 = $9_1;
    $28_1 = $4_1;
    $4_1 = $9_1 << 1 | $4_1 >>> 31;
    $17_1 = $5_1 + 944 | 0;
    $9_1 = $28_1 << 1;
    $69($17_1, $9_1, $4_1, 0, 0, $7_1, $6_1, 0, 0);
    $22_1 = $5_1 + 832 | 0;
    $69($22_1, $8_1, $10_1, 0, 0, $8_1, $10_1, 0, 0);
    $23_1 = $5_1 + 816 | 0;
    $69($23_1, HEAP32[$5_1 + 832 >> 2], HEAP32[$5_1 + 836 >> 2], 0, 0, 15632, 16, 0, 0);
    $18_1 = $5_1 + 784 | 0;
    $16_1 = $8_1 << 1;
    $45_1 = $10_1 << 1 | $8_1 >>> 31;
    $69($18_1, $16_1, $45_1, 0, 0, $13_1, $3_1, 0, 0);
    $21_1 = $5_1 + 880 | 0;
    $69($21_1, $9_1, $4_1, 0, 0, $41_1, $40_1, 0, 0);
    $36_1 = $5_1 + 928 | 0;
    $69($36_1, $7_1, $6_1, 0, 0, $7_1, $6_1, 0, 0);
    $26_1 = $5_1 + 800 | 0;
    $3_1 = $22_1 + 8 | 0;
    $69($26_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $39_1 = $5_1 + 992 | 0;
    $69($39_1, $13_1, $12_1, 0, 0, $13_1, $12_1, 0, 0);
    $35_1 = $5_1 + 768 | 0;
    $69($35_1, $16_1, $45_1, 0, 0, $28_1, $33_1, 0, 0);
    $38_1 = $6_1;
    $54_1 = $7_1;
    $4_1 = $6_1 << 1 | $7_1 >>> 31;
    $37_1 = $5_1 + 864 | 0;
    $69($37_1, $7_1 << 1, $4_1, 0, 0, $41_1, $40_1, 0, 0);
    $13_1 = HEAP32[$5_1 + 896 >> 2];
    $7_1 = HEAP32[$5_1 + 944 >> 2];
    $4_1 = $13_1 + $7_1 | 0;
    $9_1 = HEAP32[$5_1 + 900 >> 2];
    $3_1 = $9_1 + HEAP32[$5_1 + 948 >> 2] | 0;
    $7_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $7_1 + HEAP32[$5_1 + 820 >> 2] | 0;
    $6_1 = $4_1;
    $8_1 = HEAP32[$5_1 + 816 >> 2];
    $4_1 = $4_1 + $8_1 | 0;
    $42_1 = $4_1;
    $4_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = ($7_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $42_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $23_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $12_1 = HEAP32[$3_1 + 4 >> 2];
    $6_1 = ($7_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $7_1 >>> 0 < $9_1 >>> 0;
    $3_1 = $17_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $13_1 = $14_1 + 8 | 0;
    $7_1 = $9_1 + HEAP32[$13_1 >> 2] | 0;
    $3_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $7_1;
    $7_1 = $6_1 + $7_1 | 0;
    $3_1 = ($9_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $12_1 | 0;
    $6_1 = $7_1;
    $7_1 = $7_1 + $10_1 | 0;
    $3_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $7_1;
    $7_1 = $7_1 + $8_1 | 0;
    $6_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $6_1 << 12 | $7_1 >>> 20;
    $44_1 = $4_1;
    $7_1 = $7_1 << 12 | $4_1 >>> 20;
    $13_1 = $9_1;
    $22_1 = HEAP32[$5_1 + 880 >> 2];
    $9_1 = HEAP32[$5_1 + 928 >> 2];
    $3_1 = $22_1 + $9_1 | 0;
    $17_1 = HEAP32[$5_1 + 884 >> 2];
    $4_1 = $17_1 + HEAP32[$5_1 + 932 >> 2] | 0;
    $8_1 = $3_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $10_1 = $3_1;
    $9_1 = HEAP32[$5_1 + 784 >> 2];
    $4_1 = $3_1 + $9_1 | 0;
    $3_1 = $8_1 + HEAP32[$5_1 + 788 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $14_1 = HEAP32[$5_1 + 800 >> 2];
    $4_1 = $4_1 + $14_1 | 0;
    $9_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 804 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $4_1;
    $4_1 = $3_1 + $13_1 | 0;
    $30_1 = $5_1 + 752 | 0;
    $23_1 = $30_1;
    $13_1 = $7_1 + $14_1 | 0;
    $7_1 = $13_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $34_1 = ($3_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $14_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
    $14_1 = ($3_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 > $14_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
    $3_1 = $26_1 + 8 | 0;
    $26_1 = HEAP32[$3_1 >> 2];
    $31_1 = HEAP32[$3_1 + 4 >> 2];
    $9_1 = ($8_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 > $12_1 >>> 0 | $8_1 >>> 0 > $9_1 >>> 0;
    $3_1 = $18_1 + 8 | 0;
    $12_1 = HEAP32[$3_1 >> 2];
    $18_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($8_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $22_1 >>> 0 | $8_1 >>> 0 < $17_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $17_1 = $21_1 + 8 | 0;
    $4_1 = $10_1 + HEAP32[$17_1 >> 2] | 0;
    $3_1 = HEAP32[$17_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = ($10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $8_1 = $4_1;
    $4_1 = $4_1 + $12_1 | 0;
    $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $4_1 + $9_1 | 0;
    $4_1 = ($9_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $31_1 | 0;
    $3_1 = $9_1;
    $9_1 = $9_1 + $26_1 | 0;
    $3_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $9_1 + $14_1 | 0;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $4_1 + $6_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $34_1 | 0;
    $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $6_1 << 12 | $4_1 >>> 20;
    $10_1 = $4_1 << 12 | $7_1 >>> 20;
    $3_1 = $9_1;
    $18_1 = HEAP32[$5_1 + 768 >> 2];
    $9_1 = HEAP32[$5_1 + 864 >> 2];
    $8_1 = $18_1 + $9_1 | 0;
    $14_1 = HEAP32[$5_1 + 772 >> 2];
    $4_1 = $14_1 + HEAP32[$5_1 + 868 >> 2] | 0;
    $9_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $3_1 = $9_1 + $3_1 | 0;
    $10_1 = $8_1 + $10_1 | 0;
    $4_1 = $10_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $10_1;
    $3_1 = $4_1 << 4 | $10_1 >>> 28;
    $36_1 = $7_1;
    $69($23_1, $7_1 >>> 16 & 15 | $10_1 << 4 & -16, $3_1 & 16777215, 0, 0, 977, 1, 0, 0);
    $17_1 = HEAP32[$5_1 + 756 >> 2];
    $3_1 = $17_1 + HEAP32[$5_1 + 996 >> 2] | 0;
    $21_1 = HEAP32[$5_1 + 752 >> 2];
    $7_1 = HEAP32[$5_1 + 992 >> 2];
    $10_1 = $21_1 + $7_1 | 0;
    $22_1 = $10_1;
    HEAP32[$5_1 + 1464 >> 2] = $10_1;
    $7_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $23_1 = $7_1 & 1048575;
    HEAP32[$5_1 + 1468 >> 2] = $23_1;
    $34_1 = $5_1 + 976 | 0;
    $69($34_1, $25_1, $24_1, 0, 0, $28_1, $33_1, 0, 0);
    $31_1 = $5_1 + 720 | 0;
    $69($31_1, $16_1, $45_1, 0, 0, $54_1, $38_1, 0, 0);
    $32_1 = $5_1 + 848 | 0;
    $69($32_1, $41_1, $40_1, 0, 0, $41_1, $40_1, 0, 0);
    $57_1 = $5_1 + 704 | 0;
    $12_1 = ($4_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 > $12_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
    $8_1 = ($9_1 | 0) == ($14_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $9_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $14_1 = HEAP32[$3_1 >> 2];
    $18_1 = $35_1 + 8 | 0;
    $9_1 = $14_1 + HEAP32[$18_1 >> 2] | 0;
    $3_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $9_1;
    $9_1 = $8_1 + $9_1 | 0;
    $3_1 = $14_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $8_1 = $6_1;
    $6_1 = $6_1 + $9_1 | 0;
    $3_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $6_1;
    $6_1 = $6_1 + $12_1 | 0;
    $9_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $9_1 << 12 | $6_1 >>> 20;
    $4_1 = $6_1 << 12 | $4_1 >>> 20;
    $6_1 = $8_1;
    $37_1 = HEAP32[$5_1 + 720 >> 2];
    $8_1 = HEAP32[$5_1 + 848 >> 2];
    $18_1 = $37_1 + $8_1 | 0;
    $35_1 = HEAP32[$5_1 + 724 >> 2];
    $3_1 = $35_1 + HEAP32[$5_1 + 852 >> 2] | 0;
    $8_1 = $8_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $8_1 + $6_1 | 0;
    $4_1 = $4_1 + $18_1 | 0;
    $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $26_1 = $4_1;
    $6_1 = $3_1;
    $69($57_1, $4_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $10_1 = ($7_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $21_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
    $3_1 = $39_1 + 8 | 0;
    $12_1 = HEAP32[$3_1 >> 2];
    $14_1 = $30_1 + 8 | 0;
    $4_1 = $12_1 + HEAP32[$14_1 >> 2] | 0;
    $3_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $10_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $10_1 << 12 | $4_1 >>> 20;
    $7_1 = $4_1 << 12 | $7_1 >>> 20;
    $3_1 = $12_1;
    $30_1 = HEAP32[$5_1 + 704 >> 2];
    $12_1 = HEAP32[$5_1 + 976 >> 2];
    $21_1 = $30_1 + $12_1 | 0;
    $39_1 = HEAP32[$5_1 + 708 >> 2];
    $4_1 = $39_1 + HEAP32[$5_1 + 980 >> 2] | 0;
    $12_1 = $12_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $3_1 = $12_1 + $3_1 | 0;
    $4_1 = $7_1 + $21_1 | 0;
    $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $4_1;
    HEAP32[$5_1 + 1472 >> 2] = $4_1;
    $7_1 = $3_1;
    $17_1 = $3_1 & 1048575;
    HEAP32[$5_1 + 1476 >> 2] = $17_1;
    $48_1 = $5_1 + 912 | 0;
    $69($48_1, $25_1, $24_1, 0, 0, $54_1, $38_1, 0, 0);
    $54_1 = $5_1 + 960 | 0;
    $69($54_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
    $33_1 = $5_1 + 656 | 0;
    $69($33_1, $16_1, $45_1, 0, 0, $41_1, $40_1, 0, 0);
    $45_1 = $5_1 + 640 | 0;
    $16_1 = $45_1;
    $24_1 = ($6_1 | 0) == ($8_1 | 0) & $18_1 >>> 0 > $26_1 >>> 0 | $6_1 >>> 0 < $8_1 >>> 0;
    $8_1 = ($8_1 | 0) == ($35_1 | 0) & $18_1 >>> 0 < $37_1 >>> 0 | $8_1 >>> 0 < $35_1 >>> 0;
    $3_1 = $32_1 + 8 | 0;
    $18_1 = HEAP32[$3_1 >> 2];
    $25_1 = $31_1 + 8 | 0;
    $4_1 = $18_1 + HEAP32[$25_1 >> 2] | 0;
    $3_1 = HEAP32[$25_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $18_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $18_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $9_1 = $9_1 >>> 20 | 0;
    $4_1 = $9_1;
    $9_1 = $8_1 + $9_1 | 0;
    $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $9_1 + $24_1 | 0;
    $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1 << 12 | $4_1 >>> 20;
    $38_1 = $4_1 << 12 | $6_1 >>> 20;
    $8_1 = HEAP32[$5_1 + 656 >> 2];
    $6_1 = $38_1 + $8_1 | 0;
    $25_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 660 >> 2] | 0;
    $24_1 = $6_1;
    $18_1 = $6_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($16_1, $6_1, $18_1, 0, 0, 15632, 16, 0, 0);
    $16_1 = ($7_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $7_1 >>> 0 < $12_1 >>> 0;
    $6_1 = ($12_1 | 0) == ($39_1 | 0) & $21_1 >>> 0 < $30_1 >>> 0 | $12_1 >>> 0 < $39_1 >>> 0;
    $3_1 = $34_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $12_1 = $57_1 + 8 | 0;
    $4_1 = $8_1 + HEAP32[$12_1 >> 2] | 0;
    $3_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = $4_1 + $6_1 | 0;
    $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $8_1 = $10_1 >>> 20 | 0;
    $6_1 = $6_1 + $8_1 | 0;
    $3_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $6_1 + $16_1 | 0;
    $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 << 12 | $4_1 >>> 20;
    $7_1 = $4_1 << 12 | $7_1 >>> 20;
    $10_1 = $3_1;
    $26_1 = HEAP32[$5_1 + 912 >> 2];
    $8_1 = HEAP32[$5_1 + 960 >> 2];
    $4_1 = $26_1 + $8_1 | 0;
    $28_1 = HEAP32[$5_1 + 916 >> 2];
    $3_1 = $28_1 + HEAP32[$5_1 + 964 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $21_1 = $4_1;
    $4_1 = HEAP32[$5_1 + 640 >> 2];
    $16_1 = $21_1 + $4_1 | 0;
    $12_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 644 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $10_1 | 0;
    $8_1 = $7_1 + $16_1 | 0;
    $3_1 = $8_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 1480 >> 2] = $8_1;
    $7_1 = $3_1;
    $10_1 = $3_1 & 1048575;
    HEAP32[$5_1 + 1484 >> 2] = $10_1;
    $41_1 = $5_1 + 576 | 0;
    $18_1 = ($18_1 | 0) == ($25_1 | 0) & $24_1 >>> 0 < $38_1 >>> 0 | $18_1 >>> 0 < $25_1 >>> 0;
    $3_1 = $33_1 + 8 | 0;
    $24_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $9_1 = $9_1 >>> 20 | 0;
    $25_1 = $9_1;
    $9_1 = $9_1 + $24_1 | 0;
    $3_1 = $25_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $24_1 = $9_1;
    $9_1 = $9_1 + $18_1 | 0;
    $3_1 = $24_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($41_1, $9_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $18_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
    $16_1 = ($4_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $45_1 + 8 | 0;
    $24_1 = HEAP32[$3_1 >> 2];
    $25_1 = HEAP32[$3_1 + 4 >> 2];
    $12_1 = ($12_1 | 0) == ($28_1 | 0) & $21_1 >>> 0 < $26_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
    $3_1 = $54_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $21_1 = $48_1 + 8 | 0;
    $9_1 = $4_1 + HEAP32[$21_1 >> 2] | 0;
    $3_1 = HEAP32[$21_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1;
    $9_1 = $9_1 + $12_1 | 0;
    $3_1 = ($3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $25_1 | 0;
    $4_1 = $9_1 + $24_1 | 0;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $4_1;
    $4_1 = $4_1 + $16_1 | 0;
    $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $6_1 + $4_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $18_1 | 0;
    $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1;
    $4_1 = $6_1 << 12 | $3_1 >>> 20;
    $7_1 = $3_1 << 12 | $7_1 >>> 20;
    $9_1 = $4_1;
    $18_1 = HEAP32[$5_1 + 576 >> 2];
    $16_1 = $18_1 + ($42_1 & -2) | 0;
    $21_1 = HEAP32[$5_1 + 580 >> 2];
    $3_1 = $21_1 + ($44_1 & 1048575) | 0;
    $4_1 = $16_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $9_1 | 0;
    $7_1 = $7_1 + $16_1 | 0;
    $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 1488 >> 2] = $7_1;
    $9_1 = $3_1;
    $12_1 = $3_1 & 1048575;
    HEAP32[$5_1 + 1492 >> 2] = $12_1;
    $24_1 = $36_1 & 65535;
    $25_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $16_1 = ($4_1 | 0) == ($21_1 | 0) & $16_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
    $4_1 = $41_1 + 8 | 0;
    $3_1 = $16_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2];
    $4_1 = $3_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = $3_1;
    $3_1 = $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $6_1 + $16_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $25_1 | 0;
    $3_1 = $24_1 + (($6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) << 12 | $4_1 >>> 20) | 0;
    $4_1 = $4_1 << 12 | $9_1 >>> 20;
    $6_1 = $4_1 + $13_1 | 0;
    HEAP32[$5_1 + 1496 >> 2] = $6_1;
    $4_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 1500 >> 2] = $4_1;
    $3_1 = HEAP32[$5_1 + 1544 >> 2];
    $9_1 = -5862 - $3_1 | 0;
    $3_1 = 6291449 - (HEAP32[$5_1 + 1548 >> 2] + ($3_1 >>> 0 > 4294961434) | 0) | 0;
    HEAP32[$5_1 + 1424 >> 2] = $9_1;
    HEAP32[$5_1 + 1428 >> 2] = $3_1;
    $3_1 = HEAP32[$65_1 >> 2];
    $9_1 = -6 - $3_1 | 0;
    $3_1 = 6291455 - (HEAP32[$65_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
    HEAP32[$5_1 + 1432 >> 2] = $9_1;
    HEAP32[$5_1 + 1436 >> 2] = $3_1;
    $3_1 = HEAP32[$66_1 >> 2];
    $9_1 = -6 - $3_1 | 0;
    $3_1 = 6291455 - (HEAP32[$66_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
    HEAP32[$5_1 + 1440 >> 2] = $9_1;
    HEAP32[$5_1 + 1444 >> 2] = $3_1;
    $3_1 = HEAP32[$67_1 >> 2];
    $9_1 = -6 - $3_1 | 0;
    $3_1 = 6291455 - (HEAP32[$67_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
    HEAP32[$5_1 + 1448 >> 2] = $9_1;
    HEAP32[$5_1 + 1452 >> 2] = $3_1;
    $3_1 = HEAP32[$61_1 >> 2];
    $9_1 = -6 - $3_1 | 0;
    $3_1 = 393215 - (HEAP32[$61_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
    HEAP32[$5_1 + 1456 >> 2] = $9_1;
    HEAP32[$5_1 + 1460 >> 2] = $3_1;
    $16_1 = $23_1;
    $3_1 = $16_1 << 1 | $22_1 >>> 31;
    $54_1 = $5_1 + 528 | 0;
    $9_1 = $12_1;
    $23_1 = $22_1 << 1;
    $12_1 = $3_1;
    $69($54_1, $7_1, $9_1, 0, 0, $23_1, $3_1, 0, 0);
    $33_1 = $5_1 + 592 | 0;
    $13_1 = $8_1;
    $8_1 = $10_1;
    $24_1 = $14_1 << 1;
    $21_1 = $17_1;
    $18_1 = $17_1 << 1 | $14_1 >>> 31;
    $69($33_1, $13_1, $8_1, 0, 0, $24_1, $18_1, 0, 0);
    $25_1 = $5_1 + 496 | 0;
    $69($25_1, $6_1, $4_1, 0, 0, $6_1, $4_1, 0, 0);
    $38_1 = $5_1 + 480 | 0;
    $69($38_1, HEAP32[$5_1 + 496 >> 2], HEAP32[$5_1 + 500 >> 2], 0, 0, 15632, 16, 0, 0);
    $42_1 = $5_1 + 448 | 0;
    $10_1 = $6_1 << 1;
    $17_1 = $4_1 << 1 | $6_1 >>> 31;
    $69($42_1, $10_1, $17_1, 0, 0, $22_1, $16_1, 0, 0);
    $44_1 = $5_1 + 544 | 0;
    $69($44_1, $7_1, $9_1, 0, 0, $24_1, $18_1, 0, 0);
    $36_1 = $5_1 + 608 | 0;
    $69($36_1, $13_1, $8_1, 0, 0, $13_1, $8_1, 0, 0);
    $26_1 = $5_1 + 464 | 0;
    $3_1 = $25_1 + 8 | 0;
    $69($26_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $41_1 = $5_1 + 736 | 0;
    $69($41_1, $22_1, $16_1, 0, 0, $22_1, $16_1, 0, 0);
    $40_1 = $5_1 + 432 | 0;
    $69($40_1, $10_1, $17_1, 0, 0, $14_1, $21_1, 0, 0);
    $35_1 = $5_1 + 512 | 0;
    $24_1 = $7_1;
    $25_1 = $9_1;
    $28_1 = $8_1;
    $22_1 = $13_1;
    $69($35_1, $7_1, $9_1, 0, 0, $13_1 << 1, $8_1 << 1 | $13_1 >>> 31, 0, 0);
    $13_1 = HEAP32[$5_1 + 528 >> 2];
    $7_1 = HEAP32[$5_1 + 592 >> 2];
    $4_1 = $13_1 + $7_1 | 0;
    $9_1 = HEAP32[$5_1 + 532 >> 2];
    $3_1 = $9_1 + HEAP32[$5_1 + 596 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $8_1 = HEAP32[$5_1 + 480 >> 2];
    $7_1 = $4_1 + $8_1 | 0;
    $4_1 = $3_1 + HEAP32[$5_1 + 484 >> 2] | 0;
    $45_1 = $7_1;
    $7_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = ($3_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $45_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
    $4_1 = $38_1 + 8 | 0;
    $16_1 = HEAP32[$4_1 >> 2];
    $18_1 = HEAP32[$4_1 + 4 >> 2];
    $6_1 = ($3_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
    $3_1 = $33_1 + 8 | 0;
    $9_1 = HEAP32[$3_1 >> 2];
    $13_1 = $54_1 + 8 | 0;
    $4_1 = $9_1 + HEAP32[$13_1 >> 2] | 0;
    $3_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1 + $6_1 | 0;
    $4_1 = ($6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $3_1 = $6_1;
    $6_1 = $6_1 + $16_1 | 0;
    $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $6_1 + $8_1 | 0;
    $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 << 12 | $4_1 >>> 20;
    $54_1 = $7_1;
    $33_1 = $4_1 << 12 | $7_1 >>> 20;
    $39_1 = $3_1;
    $37_1 = HEAP32[$5_1 + 544 >> 2];
    $7_1 = HEAP32[$5_1 + 608 >> 2];
    $4_1 = $37_1 + $7_1 | 0;
    $38_1 = HEAP32[$5_1 + 548 >> 2];
    $3_1 = $38_1 + HEAP32[$5_1 + 612 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = HEAP32[$5_1 + 448 >> 2];
    $7_1 = $8_1 + $4_1 | 0;
    $13_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 452 >> 2] | 0;
    $3_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $7_1;
    $9_1 = HEAP32[$5_1 + 464 >> 2];
    $7_1 = $7_1 + $9_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 468 >> 2] | 0;
    $9_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1 + $39_1 | 0;
    $39_1 = $5_1 + 416 | 0;
    $18_1 = $7_1;
    $33_1 = $7_1 + $33_1 | 0;
    $7_1 = $7_1 >>> 0 > $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $9_1;
    $9_1 = $33_1;
    $33_1 = ($7_1 | 0) == ($3_1 | 0) & $18_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
    $18_1 = ($3_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $3_1 = $26_1 + 8 | 0;
    $26_1 = HEAP32[$3_1 >> 2];
    $30_1 = HEAP32[$3_1 + 4 >> 2];
    $16_1 = ($4_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 < $13_1 >>> 0;
    $3_1 = $42_1 + 8 | 0;
    $42_1 = HEAP32[$3_1 >> 2];
    $34_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($13_1 | 0) == ($38_1 | 0) & $8_1 >>> 0 < $37_1 >>> 0 | $13_1 >>> 0 < $38_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $38_1 = $44_1 + 8 | 0;
    $13_1 = $4_1 + HEAP32[$38_1 >> 2] | 0;
    $3_1 = HEAP32[$38_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $13_1;
    $13_1 = $8_1 + $13_1 | 0;
    $3_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $34_1 | 0;
    $4_1 = $13_1 + $42_1 | 0;
    $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = $4_1 + $16_1 | 0;
    $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $30_1 | 0;
    $8_1 = $4_1;
    $4_1 = $4_1 + $26_1 | 0;
    $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = $4_1 + $18_1 | 0;
    $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $6_1;
    $6_1 = $6_1 + $13_1 | 0;
    $3_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $6_1 + $33_1 | 0;
    $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 << 12 | $4_1 >>> 20;
    $13_1 = $7_1;
    $7_1 = $4_1 << 12 | $7_1 >>> 20;
    $33_1 = $3_1;
    $38_1 = HEAP32[$5_1 + 432 >> 2];
    $4_1 = HEAP32[$5_1 + 512 >> 2];
    $8_1 = $38_1 + $4_1 | 0;
    $18_1 = HEAP32[$5_1 + 436 >> 2];
    $3_1 = $18_1 + HEAP32[$5_1 + 516 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $33_1 | 0;
    $16_1 = $7_1 + $8_1 | 0;
    $3_1 = $16_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $42_1 = $16_1 << 4 & -16;
    $33_1 = $13_1;
    $7_1 = $3_1;
    $69($39_1, $42_1 | $13_1 >>> 16 & 15, ($3_1 << 4 | $16_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
    $37_1 = $5_1 + 672 | 0;
    $69($37_1, $14_1, $21_1, 0, 0, $23_1, $12_1, 0, 0);
    $42_1 = $5_1 + 400 | 0;
    $69($42_1, $10_1, $17_1, 0, 0, $22_1, $28_1, 0, 0);
    $44_1 = $5_1 + 560 | 0;
    $69($44_1, $24_1, $25_1, 0, 0, $24_1, $25_1, 0, 0);
    $57_1 = $5_1 + 384 | 0;
    $36_1 = $57_1;
    $16_1 = ($4_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 > $3_1 >>> 0;
    $8_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $38_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
    $3_1 = $35_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $18_1 = $40_1 + 8 | 0;
    $13_1 = $4_1 + HEAP32[$18_1 >> 2] | 0;
    $3_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $8_1 + $13_1 | 0;
    $4_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $3_1;
    $3_1 = $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $6_1 + $13_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $16_1 | 0;
    $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $6_1 << 12 | $4_1 >>> 20;
    $7_1 = $4_1 << 12 | $7_1 >>> 20;
    $8_1 = $13_1;
    $18_1 = HEAP32[$5_1 + 400 >> 2];
    $13_1 = HEAP32[$5_1 + 560 >> 2];
    $4_1 = $18_1 + $13_1 | 0;
    $16_1 = HEAP32[$5_1 + 404 >> 2];
    $3_1 = $16_1 + HEAP32[$5_1 + 564 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $4_1;
    $4_1 = $3_1 + $8_1 | 0;
    $7_1 = $7_1 + $13_1 | 0;
    $4_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $7_1;
    $7_1 = $4_1;
    $69($36_1, $8_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $40_1 = $5_1 + 624 | 0;
    $69($40_1, $22_1, $28_1, 0, 0, $23_1, $12_1, 0, 0);
    $35_1 = $5_1 + 688 | 0;
    $69($35_1, $14_1, $21_1, 0, 0, $14_1, $21_1, 0, 0);
    $12_1 = $5_1 + 368 | 0;
    $69($12_1, $10_1, $17_1, 0, 0, $24_1, $25_1, 0, 0);
    $48_1 = $5_1 + 352 | 0;
    $10_1 = $48_1;
    $8_1 = ($3_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
    $13_1 = ($3_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $16_1 >>> 0;
    $3_1 = $44_1 + 8 | 0;
    $14_1 = HEAP32[$3_1 >> 2];
    $17_1 = $42_1 + 8 | 0;
    $4_1 = $14_1 + HEAP32[$17_1 >> 2] | 0;
    $3_1 = HEAP32[$17_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $4_1;
    $4_1 = $4_1 + $13_1 | 0;
    $3_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $6_1;
    $6_1 = $6_1 + $13_1 | 0;
    $3_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $6_1 + $8_1 | 0;
    $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 << 12 | $4_1 >>> 20;
    $13_1 = $4_1 << 12 | $7_1 >>> 20;
    $8_1 = HEAP32[$5_1 + 368 >> 2];
    $7_1 = $13_1 + $8_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 372 >> 2] | 0;
    $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($10_1, $7_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $50_1 = $5_1 + 336 | 0;
    $8_1 = $50_1;
    $13_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $3_1 = $12_1 + 8 | 0;
    $10_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $7_1 = $6_1 >>> 20 | 0;
    $4_1 = $7_1 + $10_1 | 0;
    $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $13_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($8_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
    $3_1 = $5_1 + 1424 | 0;
    $34($3_1, $3_1, $5_1 + 1464 | 0);
    $3_1 = HEAP32[$5_1 + 1348 >> 2];
    $16_1 = $3_1;
    $18_1 = HEAP32[$5_1 + 1344 >> 2];
    $6_1 = $18_1;
    $3_1 = $3_1 << 1 | $6_1 >>> 31;
    $21_1 = $5_1 - -64 | 0;
    $4_1 = HEAP32[$5_1 + 1368 >> 2];
    $7_1 = HEAP32[$5_1 + 1372 >> 2];
    $17_1 = $6_1 << 1;
    $14_1 = $3_1;
    $69($21_1, $4_1, $7_1, 0, 0, $17_1, $3_1, 0, 0);
    $3_1 = HEAP32[$5_1 + 1356 >> 2];
    $44_1 = $3_1;
    $36_1 = HEAP32[$5_1 + 1352 >> 2];
    $8_1 = $36_1;
    $3_1 = $3_1 << 1 | $8_1 >>> 31;
    $42_1 = $5_1 + 272 | 0;
    $6_1 = HEAP32[$5_1 + 1360 >> 2];
    $13_1 = HEAP32[$5_1 + 1364 >> 2];
    $23_1 = $8_1 << 1;
    $10_1 = $3_1;
    $69($42_1, $6_1, $13_1, 0, 0, $23_1, $3_1, 0, 0);
    $24_1 = $5_1 + 224 | 0;
    $3_1 = HEAP32[$5_1 + 1376 >> 2];
    $8_1 = HEAP32[$5_1 + 1380 >> 2];
    $69($24_1, $3_1, $8_1, 0, 0, $3_1, $8_1, 0, 0);
    $26_1 = $5_1 + 208 | 0;
    $69($26_1, HEAP32[$5_1 + 224 >> 2], HEAP32[$5_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
    $12_1 = $8_1 << 1;
    $8_1 = $3_1;
    $3_1 = $12_1 | $3_1 >>> 31;
    $30_1 = $5_1 + 176 | 0;
    $12_1 = $8_1 << 1;
    $22_1 = $3_1;
    $69($30_1, $12_1, $3_1, 0, 0, $18_1, $16_1, 0, 0);
    $34_1 = $5_1 + 80 | 0;
    $69($34_1, $4_1, $7_1, 0, 0, $23_1, $10_1, 0, 0);
    $31_1 = $5_1 + 256 | 0;
    $69($31_1, $6_1, $13_1, 0, 0, $6_1, $13_1, 0, 0);
    $32_1 = $5_1 + 192 | 0;
    $3_1 = $24_1 + 8 | 0;
    $69($32_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $51_1 = $5_1 + 320 | 0;
    $69($51_1, $18_1, $16_1, 0, 0, $18_1, $16_1, 0, 0);
    $43_1 = $5_1 + 160 | 0;
    $69($43_1, $12_1, $22_1, 0, 0, $36_1, $44_1, 0, 0);
    $46_1 = $5_1 + 96 | 0;
    $24_1 = $4_1;
    $25_1 = $7_1;
    $28_1 = $13_1;
    $23_1 = $6_1;
    $69($46_1, $4_1, $7_1, 0, 0, $6_1 << 1, $13_1 << 1 | $6_1 >>> 31, 0, 0);
    $10_1 = HEAP32[$5_1 + 64 >> 2];
    $7_1 = HEAP32[$5_1 + 272 >> 2];
    $4_1 = $10_1 + $7_1 | 0;
    $8_1 = HEAP32[$5_1 + 68 >> 2];
    $3_1 = $8_1 + HEAP32[$5_1 + 276 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = HEAP32[$5_1 + 208 >> 2];
    $13_1 = $6_1 + $4_1 | 0;
    $7_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 212 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $38_1 = $13_1;
    $13_1 = ($7_1 | 0) == ($4_1 | 0) & $13_1 >>> 0 < $6_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
    $3_1 = $26_1 + 8 | 0;
    $16_1 = HEAP32[$3_1 >> 2];
    $18_1 = HEAP32[$3_1 + 4 >> 2];
    $6_1 = ($7_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $10_1 >>> 0 | $7_1 >>> 0 < $8_1 >>> 0;
    $3_1 = $42_1 + 8 | 0;
    $8_1 = HEAP32[$3_1 >> 2];
    $10_1 = $21_1 + 8 | 0;
    $7_1 = $8_1 + HEAP32[$10_1 >> 2] | 0;
    $3_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $7_1;
    $7_1 = $6_1 + $7_1 | 0;
    $3_1 = ($8_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
    $6_1 = $7_1;
    $7_1 = $7_1 + $16_1 | 0;
    $3_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $7_1;
    $7_1 = $7_1 + $13_1 | 0;
    $6_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $6_1 << 12 | $7_1 >>> 20;
    $42_1 = $4_1;
    $7_1 = $7_1 << 12 | $4_1 >>> 20;
    $53_1 = HEAP32[$5_1 + 80 >> 2];
    $8_1 = HEAP32[$5_1 + 256 >> 2];
    $4_1 = $53_1 + $8_1 | 0;
    $26_1 = HEAP32[$5_1 + 84 >> 2];
    $3_1 = $26_1 + HEAP32[$5_1 + 260 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $4_1;
    $10_1 = HEAP32[$5_1 + 176 >> 2];
    $4_1 = $4_1 + $10_1 | 0;
    $8_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 180 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $18_1 = $4_1;
    $21_1 = HEAP32[$5_1 + 192 >> 2];
    $4_1 = $4_1 + $21_1 | 0;
    $10_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 196 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $21_1 = $4_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $13_1 | 0;
    $13_1 = $7_1 + $21_1 | 0;
    $7_1 = $13_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $49_1 = ($4_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
    $21_1 = ($4_1 | 0) == ($10_1 | 0) & $18_1 >>> 0 > $21_1 >>> 0 | $4_1 >>> 0 < $10_1 >>> 0;
    $3_1 = $32_1 + 8 | 0;
    $32_1 = HEAP32[$3_1 >> 2];
    $55_1 = HEAP32[$3_1 + 4 >> 2];
    $10_1 = ($8_1 | 0) == ($10_1 | 0) & $16_1 >>> 0 > $18_1 >>> 0 | $8_1 >>> 0 > $10_1 >>> 0;
    $3_1 = $30_1 + 8 | 0;
    $18_1 = HEAP32[$3_1 >> 2];
    $30_1 = HEAP32[$3_1 + 4 >> 2];
    $8_1 = ($8_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $53_1 >>> 0 | $8_1 >>> 0 < $26_1 >>> 0;
    $3_1 = $31_1 + 8 | 0;
    $16_1 = HEAP32[$3_1 >> 2];
    $26_1 = $34_1 + 8 | 0;
    $4_1 = $16_1 + HEAP32[$26_1 >> 2] | 0;
    $3_1 = HEAP32[$26_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = ($16_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $30_1 | 0;
    $8_1 = $4_1 + $18_1 | 0;
    $4_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $8_1;
    $8_1 = $8_1 + $10_1 | 0;
    $3_1 = ($3_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $55_1 | 0;
    $4_1 = $8_1 + $32_1 | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $4_1;
    $4_1 = $4_1 + $21_1 | 0;
    $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $6_1 + $4_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $49_1 | 0;
    $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1;
    $10_1 = $6_1 << 12 | $3_1 >>> 20;
    $4_1 = $7_1;
    $16_1 = $3_1 << 12 | $4_1 >>> 20;
    $26_1 = HEAP32[$5_1 + 160 >> 2];
    $8_1 = HEAP32[$5_1 + 96 >> 2];
    $7_1 = $26_1 + $8_1 | 0;
    $21_1 = HEAP32[$5_1 + 164 >> 2];
    $3_1 = $21_1 + HEAP32[$5_1 + 100 >> 2] | 0;
    $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $8_1 + $10_1 | 0;
    $10_1 = $7_1;
    $16_1 = $7_1 + $16_1 | 0;
    $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $30_1 = $16_1 << 4 & -16;
    $18_1 = $4_1;
    $7_1 = $3_1;
    $69($5_1, $30_1 | $4_1 >>> 16 & 15, ($3_1 << 4 | $16_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
    $31_1 = $5_1 + 304 | 0;
    $69($31_1, $36_1, $44_1, 0, 0, $17_1, $14_1, 0, 0);
    $30_1 = $5_1 + 144 | 0;
    $69($30_1, $12_1, $22_1, 0, 0, $23_1, $28_1, 0, 0);
    $34_1 = $5_1 + 112 | 0;
    $69($34_1, $24_1, $25_1, 0, 0, $24_1, $25_1, 0, 0);
    $32_1 = $5_1 + 48 | 0;
    $16_1 = ($3_1 | 0) == ($8_1 | 0) & $10_1 >>> 0 > $16_1 >>> 0 | $3_1 >>> 0 < $8_1 >>> 0;
    $10_1 = ($8_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $26_1 >>> 0 | $8_1 >>> 0 < $21_1 >>> 0;
    $3_1 = $46_1 + 8 | 0;
    $21_1 = HEAP32[$3_1 >> 2];
    $4_1 = $43_1 + 8 | 0;
    $8_1 = $21_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $8_1 + $10_1 | 0;
    $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $4_1 = $4_1 + $6_1 | 0;
    $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $4_1;
    $4_1 = $4_1 + $16_1 | 0;
    $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $8_1 = $6_1 << 12 | $4_1 >>> 20;
    $7_1 = $4_1 << 12 | $7_1 >>> 20;
    $3_1 = $8_1;
    $21_1 = HEAP32[$5_1 + 144 >> 2];
    $10_1 = HEAP32[$5_1 + 112 >> 2];
    $8_1 = $21_1 + $10_1 | 0;
    $16_1 = HEAP32[$5_1 + 148 >> 2];
    $4_1 = $16_1 + HEAP32[$5_1 + 116 >> 2] | 0;
    $4_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $3_1 = $4_1 + $3_1 | 0;
    $7_1 = $7_1 + $8_1 | 0;
    $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $7_1;
    $7_1 = $3_1;
    $69($32_1, $10_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $26_1 = $5_1 + 240 | 0;
    $69($26_1, $23_1, $28_1, 0, 0, $17_1, $14_1, 0, 0);
    $43_1 = $5_1 + 288 | 0;
    $69($43_1, $36_1, $44_1, 0, 0, $36_1, $44_1, 0, 0);
    $14_1 = $5_1 + 128 | 0;
    $69($14_1, $12_1, $22_1, 0, 0, $24_1, $25_1, 0, 0);
    $36_1 = $5_1 + 32 | 0;
    $12_1 = $36_1;
    $10_1 = ($3_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $8_1 = ($4_1 | 0) == ($16_1 | 0) & $8_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
    $3_1 = $34_1 + 8 | 0;
    $17_1 = HEAP32[$3_1 >> 2];
    $22_1 = $30_1 + 8 | 0;
    $4_1 = $17_1 + HEAP32[$22_1 >> 2] | 0;
    $3_1 = HEAP32[$22_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $16_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $8_1 = $6_1;
    $6_1 = $4_1 + $6_1 | 0;
    $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 + $10_1 | 0;
    $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $4_1 << 12 | $3_1 >>> 20;
    $10_1 = $3_1 << 12 | $7_1 >>> 20;
    $17_1 = HEAP32[$5_1 + 128 >> 2];
    $7_1 = $10_1 + $17_1 | 0;
    $6_1 = $8_1;
    $3_1 = $6_1 + HEAP32[$5_1 + 132 >> 2] | 0;
    $3_1 = $7_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($12_1, $7_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $46_1 = $5_1 + 16 | 0;
    $8_1 = $46_1;
    $6_1 = ($3_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
    $3_1 = $14_1 + 8 | 0;
    $7_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $7_1 = $4_1 + $7_1 | 0;
    $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 + $7_1 | 0;
    $4_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($8_1, $3_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
    $34($0_1 + 80 | 0, $69_1, $79);
    $69_1 = HEAP32[$1_1 + 120 >> 2];
    $7_1 = $0_1;
    $0_1 = HEAP32[$5_1 + 1424 >> 2];
    $16_1 = $0_1;
    $3_1 = HEAP32[$5_1 + 1428 >> 2];
    $21_1 = $3_1;
    $6_1 = $0_1;
    $8_1 = $3_1;
    $14_1 = HEAP32[$5_1 >> 2];
    $0_1 = HEAP32[$5_1 + 320 >> 2];
    $4_1 = $14_1 + $0_1 | 0;
    $12_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $12_1 + HEAP32[$5_1 + 324 >> 2] | 0;
    $0_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $8_1 + ($0_1 & 1048575) | 0;
    $6_1 = $4_1 + $6_1 | 0;
    $3_1 = $6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$7_1 >> 2] = $6_1;
    $8_1 = $3_1;
    HEAP32[$7_1 + 4 >> 2] = $3_1;
    $30_1 = $7_1 + 8 | 0;
    $24_1 = $30_1;
    $3_1 = HEAP32[$5_1 + 1432 >> 2];
    $22_1 = $3_1;
    $10_1 = HEAP32[$5_1 + 1436 >> 2];
    $23_1 = $10_1;
    $10_1 = ($0_1 | 0) == ($12_1 | 0) & $4_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $51_1 + 8 | 0;
    $12_1 = HEAP32[$3_1 >> 2];
    $14_1 = $5_1 + 8 | 0;
    $4_1 = $12_1 + HEAP32[$14_1 >> 2] | 0;
    $3_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $10_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $10_1 << 12 | $4_1 >>> 20;
    $0_1 = $4_1 << 12 | $0_1 >>> 20;
    $4_1 = $12_1;
    $51_1 = HEAP32[$5_1 + 48 >> 2];
    $12_1 = HEAP32[$5_1 + 304 >> 2];
    $14_1 = $51_1 + $12_1 | 0;
    $28_1 = HEAP32[$5_1 + 52 >> 2];
    $3_1 = $28_1 + HEAP32[$5_1 + 308 >> 2] | 0;
    $12_1 = $12_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $12_1 + $4_1 | 0;
    $3_1 = $0_1 + $14_1 | 0;
    $0_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $17_1 = $3_1;
    $4_1 = $22_1 + $3_1 | 0;
    $3_1 = $23_1 + ($0_1 & 1048575) | 0;
    HEAP32[$24_1 >> 2] = $4_1;
    $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$24_1 + 4 >> 2] = $3_1;
    $24_1 = $3_1 << 1;
    $3_1 = $4_1;
    $4_1 = $24_1 | $3_1 >>> 31;
    $24_1 = $3_1 << 1;
    $3_1 = $4_1 + $23_1 | 0;
    $4_1 = $22_1 + $24_1 | 0;
    $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$65_1 >> 2] = $4_1;
    HEAP32[$65_1 + 4 >> 2] = $3_1;
    $34_1 = $7_1 + 16 | 0;
    $3_1 = HEAP32[$5_1 + 1440 >> 2];
    $24_1 = $3_1;
    $4_1 = HEAP32[$5_1 + 1444 >> 2];
    $25_1 = $4_1;
    $17_1 = ($0_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $17_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
    $12_1 = ($12_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $51_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
    $3_1 = $31_1 + 8 | 0;
    $14_1 = HEAP32[$3_1 >> 2];
    $22_1 = $32_1 + 8 | 0;
    $4_1 = $14_1 + HEAP32[$22_1 >> 2] | 0;
    $3_1 = HEAP32[$22_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $4_1;
    $4_1 = $4_1 + $12_1 | 0;
    $3_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $10_1 = $10_1 >>> 20 | 0;
    $4_1 = $10_1;
    $10_1 = $10_1 + $12_1 | 0;
    $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $10_1 + $17_1 | 0;
    $10_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $10_1 << 12 | $4_1 >>> 20;
    $14_1 = $4_1 << 12 | $0_1 >>> 20;
    $31_1 = $3_1;
    $32_1 = HEAP32[$5_1 + 240 >> 2];
    $4_1 = HEAP32[$5_1 + 288 >> 2];
    $0_1 = $32_1 + $4_1 | 0;
    $28_1 = HEAP32[$5_1 + 244 >> 2];
    $3_1 = $28_1 + HEAP32[$5_1 + 292 >> 2] | 0;
    $3_1 = $0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $17_1 = $0_1;
    $4_1 = HEAP32[$5_1 + 32 >> 2];
    $0_1 = $0_1 + $4_1 | 0;
    $12_1 = $3_1;
    $3_1 = $3_1 + HEAP32[$5_1 + 36 >> 2] | 0;
    $4_1 = $0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 + $31_1 | 0;
    $22_1 = $0_1;
    $14_1 = $0_1 + $14_1 | 0;
    $0_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $25_1 + ($0_1 & 1048575) | 0;
    $23_1 = $14_1;
    $14_1 = $24_1 + $14_1 | 0;
    HEAP32[$34_1 >> 2] = $14_1;
    $3_1 = $14_1 >>> 0 < $23_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$34_1 + 4 >> 2] = $3_1;
    $3_1 = ($3_1 << 1 | $14_1 >>> 31) + $25_1 | 0;
    $14_1 = $14_1 << 1;
    $25_1 = $14_1;
    $14_1 = $14_1 + $24_1 | 0;
    $3_1 = $25_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$66_1 >> 2] = $14_1;
    HEAP32[$66_1 + 4 >> 2] = $3_1;
    $31_1 = $7_1 + 24 | 0;
    $3_1 = HEAP32[$5_1 + 1448 >> 2];
    $14_1 = HEAP32[$5_1 + 1452 >> 2];
    $24_1 = $3_1;
    $25_1 = $14_1;
    $14_1 = ($0_1 | 0) == ($4_1 | 0) & $22_1 >>> 0 > $23_1 >>> 0 | $0_1 >>> 0 < $4_1 >>> 0;
    $22_1 = ($4_1 | 0) == ($12_1 | 0) & $17_1 >>> 0 > $22_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
    $3_1 = $36_1 + 8 | 0;
    $23_1 = HEAP32[$3_1 >> 2];
    $36_1 = HEAP32[$3_1 + 4 >> 2];
    $17_1 = ($12_1 | 0) == ($28_1 | 0) & $17_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
    $3_1 = $43_1 + 8 | 0;
    $4_1 = HEAP32[$3_1 >> 2];
    $28_1 = $26_1 + 8 | 0;
    $12_1 = $4_1 + HEAP32[$28_1 >> 2] | 0;
    $3_1 = HEAP32[$28_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $12_1;
    $12_1 = $12_1 + $17_1 | 0;
    $3_1 = ($3_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $36_1 | 0;
    $4_1 = $12_1 + $23_1 | 0;
    $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $4_1 = $4_1 + $22_1 | 0;
    $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $10_1 >>> 20 | 0;
    $4_1 = $10_1 + $4_1 | 0;
    $3_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $4_1;
    $4_1 = $4_1 + $14_1 | 0;
    $10_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1;
    $4_1 = $10_1 << 12 | $3_1 >>> 20;
    $17_1 = $3_1 << 12 | $0_1 >>> 20;
    $36_1 = HEAP32[$5_1 + 16 >> 2];
    $12_1 = $38_1 & -2;
    $0_1 = $36_1 + $12_1 | 0;
    $28_1 = HEAP32[$5_1 + 20 >> 2];
    $3_1 = $28_1 + ($42_1 & 1048575) | 0;
    $12_1 = $0_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $12_1 + $4_1 | 0;
    $14_1 = $0_1;
    $17_1 = $0_1 + $17_1 | 0;
    $0_1 = $0_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $25_1 + ($0_1 & 1048575) | 0;
    $4_1 = $17_1 + $24_1 | 0;
    $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$31_1 >> 2] = $4_1;
    HEAP32[$31_1 + 4 >> 2] = $3_1;
    $22_1 = $4_1 << 1;
    $4_1 = ($3_1 << 1 | $4_1 >>> 31) + $25_1 | 0;
    $3_1 = $22_1 + $24_1 | 0;
    $4_1 = $3_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$67_1 >> 2] = $3_1;
    HEAP32[$67_1 + 4 >> 2] = $4_1;
    $32_1 = $7_1 + 32 | 0;
    $25_1 = $32_1;
    $3_1 = HEAP32[$5_1 + 1456 >> 2];
    $4_1 = HEAP32[$5_1 + 1460 >> 2];
    $22_1 = $3_1;
    $23_1 = $4_1;
    $24_1 = $13_1;
    $18_1 = $18_1 & 65535;
    $17_1 = ($0_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $17_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
    $13_1 = ($12_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $36_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
    $3_1 = $46_1 + 8 | 0;
    $4_1 = $13_1 + HEAP32[$3_1 >> 2] | 0;
    $3_1 = HEAP32[$3_1 + 4 >> 2];
    $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $10_1 = $10_1 >>> 20 | 0;
    $13_1 = $4_1 + $10_1 | 0;
    $4_1 = $10_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $13_1;
    $13_1 = $13_1 + $17_1 | 0;
    $3_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $13_1 >>> 20;
    $4_1 = $13_1 << 12 | $0_1 >>> 20;
    $0_1 = $4_1 + $24_1 | 0;
    $3_1 = $3_1 + $18_1 | 0;
    $3_1 = ($0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $23_1 | 0;
    $4_1 = $0_1;
    $0_1 = $0_1 + $22_1 | 0;
    $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$25_1 >> 2] = $0_1;
    HEAP32[$25_1 + 4 >> 2] = $3_1;
    $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $23_1 | 0;
    $0_1 = $0_1 << 1;
    $4_1 = $0_1;
    $0_1 = $0_1 + $22_1 | 0;
    $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$61_1 >> 2] = $0_1;
    HEAP32[$61_1 + 4 >> 2] = $3_1;
    $13_1 = $5_1;
    $3_1 = ($8_1 << 1 | $6_1 >>> 31) + $21_1 | 0;
    $0_1 = $6_1 << 1;
    $4_1 = $0_1;
    $0_1 = $0_1 + $16_1 | 0;
    $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$5_1 + 1544 >> 2] = $0_1;
    HEAP32[$5_1 + 1548 >> 2] = $3_1;
    $0_1 = $41_1 + 8 | 0;
    $12_1 = HEAP32[$0_1 >> 2];
    $62_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = $39_1 + 8 | 0;
    $71 = HEAP32[$0_1 >> 2];
    $72 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = HEAP32[$5_1 + 736 >> 2];
    $3_1 = HEAP32[$5_1 + 740 >> 2];
    $14_1 = HEAP32[$5_1 + 416 >> 2];
    $6_1 = HEAP32[$5_1 + 420 >> 2];
    $4_1 = $37_1 + 8 | 0;
    $73 = HEAP32[$4_1 >> 2];
    $74 = HEAP32[$4_1 + 4 >> 2];
    $4_1 = $57_1 + 8 | 0;
    $17_1 = HEAP32[$4_1 >> 2];
    $60_1 = HEAP32[$4_1 + 4 >> 2];
    $26_1 = HEAP32[$5_1 + 672 >> 2];
    $68_1 = HEAP32[$5_1 + 676 >> 2];
    $41_1 = HEAP32[$5_1 + 384 >> 2];
    $5_1 = HEAP32[$5_1 + 388 >> 2];
    $4_1 = $35_1 + 8 | 0;
    $64_1 = HEAP32[$4_1 >> 2];
    $70_1 = HEAP32[$4_1 + 4 >> 2];
    $4_1 = $40_1 + 8 | 0;
    $51_1 = HEAP32[$4_1 >> 2];
    $75 = HEAP32[$4_1 + 4 >> 2];
    $43_1 = HEAP32[$13_1 + 688 >> 2];
    $76 = HEAP32[$13_1 + 692 >> 2];
    $46_1 = HEAP32[$13_1 + 624 >> 2];
    $57_1 = HEAP32[$13_1 + 628 >> 2];
    $4_1 = $48_1 + 8 | 0;
    $22_1 = HEAP32[$4_1 >> 2];
    $23_1 = HEAP32[$4_1 + 4 >> 2];
    $53_1 = HEAP32[$13_1 + 352 >> 2];
    $77 = HEAP32[$13_1 + 356 >> 2];
    $49_1 = HEAP32[$13_1 + 336 >> 2];
    $48_1 = HEAP32[$13_1 + 340 >> 2];
    $4_1 = $50_1 + 8 | 0;
    $78 = HEAP32[$4_1 >> 2];
    $16_1 = HEAP32[$4_1 + 4 >> 2];
    $40_1 = $7_1 + 104 | 0;
    $18_1 = HEAP32[$40_1 >> 2];
    $21_1 = HEAP32[$40_1 + 4 >> 2];
    $35_1 = $7_1 + 96 | 0;
    $24_1 = HEAP32[$35_1 >> 2];
    $25_1 = HEAP32[$35_1 + 4 >> 2];
    $39_1 = $7_1 + 88 | 0;
    $28_1 = HEAP32[$39_1 >> 2];
    $38_1 = HEAP32[$39_1 + 4 >> 2];
    $37_1 = $7_1 + 112 | 0;
    $42_1 = HEAP32[$37_1 >> 2];
    $8_1 = HEAP32[$37_1 + 4 >> 2];
    $44_1 = HEAP32[$7_1 + 80 >> 2];
    $36_1 = HEAP32[$7_1 + 84 >> 2];
    $34($63_1, $63_1, $13_1 + 1344 | 0);
    $10_1 = HEAP32[$13_1 + 1544 >> 2];
    $50_1 = HEAP32[$13_1 + 1548 >> 2];
    $3_1 = $3_1 + $6_1 | 0;
    $4_1 = $0_1 + $14_1 | 0;
    $0_1 = $4_1 >>> 0 < $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $55_1 = $10_1;
    $3_1 = $4_1;
    $10_1 = $29_1 ? $19_1 : $3_1;
    $19_1 = $55_1 + $10_1 | 0;
    $4_1 = $50_1 + ($29_1 ? $11_1 : $0_1 & 1048575) | 0;
    $63_1 = 8388599 - (($19_1 >>> 0 > 4294959480) + ($10_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0) | 0;
    $50_1 = -7816 - $19_1 | 0;
    $4_1 = $50_1 & 1;
    $55_1 = 0 - $4_1 | 0;
    $10_1 = 0 - $4_1 | 0;
    $6_1 = ($0_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
    $3_1 = $62_1 + $72 | 0;
    $11_1 = $12_1 + $71 | 0;
    $4_1 = $11_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 + $11_1 | 0;
    $4_1 = $3_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $4_1 << 12 | $3_1 >>> 20;
    $0_1 = $3_1 << 12 | $0_1 >>> 20;
    $19_1 = $6_1;
    $3_1 = $5_1 + $68_1 | 0;
    $6_1 = $26_1 + $41_1 | 0;
    $11_1 = $6_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $11_1 + $19_1 | 0;
    $19_1 = $0_1 + $6_1 | 0;
    $0_1 = $19_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $26_1 = $19_1;
    $19_1 = ($11_1 | 0) == ($0_1 | 0) & $19_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $11_1 >>> 0;
    $6_1 = ($5_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 < $41_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
    $3_1 = $60_1 + $74 | 0;
    $11_1 = $17_1 + $73 | 0;
    $3_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $11_1;
    $11_1 = $6_1 + $11_1 | 0;
    $3_1 = $12_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $11_1 = $4_1 + $11_1 | 0;
    $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $11_1 + $19_1 | 0;
    $6_1 = $3_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $11_1 = $6_1 << 12 | $3_1 >>> 20;
    $41_1 = $0_1;
    $0_1 = $3_1 << 12 | $0_1 >>> 20;
    $3_1 = $57_1 + $76 | 0;
    $12_1 = $43_1 + $46_1 | 0;
    $4_1 = $12_1 >>> 0 < $43_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $77 + $4_1 | 0;
    $5_1 = $12_1 + $53_1 | 0;
    $19_1 = $5_1 >>> 0 < $53_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $19_1 + $11_1 | 0;
    $14_1 = $0_1 + $5_1 | 0;
    $11_1 = $14_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $0_1 = $45_1 & -2;
    $17_1 = $0_1 + $49_1 | 0;
    $3_1 = $48_1 + ($54_1 & 1048575) | 0;
    $0_1 = $0_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $45_1 = ($11_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 > $14_1 >>> 0 | $11_1 >>> 0 < $19_1 >>> 0;
    $5_1 = ($4_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $4_1 >>> 0 > $19_1 >>> 0;
    $12_1 = ($4_1 | 0) == ($57_1 | 0) & $12_1 >>> 0 < $46_1 >>> 0 | $4_1 >>> 0 < $57_1 >>> 0;
    $4_1 = $70_1 + $75 | 0;
    $19_1 = $51_1 + $64_1 | 0;
    $3_1 = $19_1 >>> 0 < $51_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $12_1 + $19_1 | 0;
    $3_1 = ($4_1 >>> 0 < $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $23_1 | 0;
    $12_1 = $4_1;
    $4_1 = $4_1 + $22_1 | 0;
    $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $4_1;
    $4_1 = $4_1 + $5_1 | 0;
    $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $6_1 >>> 20 | 0;
    $12_1 = $6_1;
    $6_1 = $4_1 + $6_1 | 0;
    $4_1 = $12_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $6_1 + $45_1 | 0;
    $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $3_1;
    $3_1 = $0_1 + ($4_1 << 12 | $3_1 >>> 20) | 0;
    $12_1 = $11_1;
    $6_1 = $6_1 << 12 | $11_1 >>> 20;
    $11_1 = $6_1 + $17_1 | 0;
    $19_1 = $11_1;
    $11_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $22_1 = $7_1 + 72 | 0;
    $6_1 = $10_1;
    $3_1 = $6_1 >>> 16 | 0;
    $5_1 = ($6_1 & 65535) << 16 | $55_1 >>> 16;
    $10_1 = $3_1;
    $23_1 = HEAP32[$61_1 >> 2];
    $61_1 = HEAP32[$61_1 + 4 >> 2];
    $45_1 = $33_1 & 65535;
    $54_1 = ($0_1 | 0) == ($11_1 | 0) & $17_1 >>> 0 > $19_1 >>> 0 | $0_1 >>> 0 > $11_1 >>> 0;
    $17_1 = ($0_1 | 0) == ($48_1 | 0) & $17_1 >>> 0 < $49_1 >>> 0 | $0_1 >>> 0 < $48_1 >>> 0;
    $0_1 = $78 + $17_1 | 0;
    $3_1 = $16_1;
    $3_1 = $0_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $4_1 >>> 20 | 0;
    $0_1 = $0_1 + $4_1 | 0;
    $4_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $0_1;
    $0_1 = $0_1 + $54_1 | 0;
    $4_1 = ($3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $0_1 >>> 20;
    $17_1 = $11_1;
    $11_1 = $0_1 << 12 | $11_1 >>> 20;
    $0_1 = $11_1 + $9_1 | 0;
    $3_1 = $4_1 + $45_1 | 0;
    $3_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $29_1 ? $47_1 : $0_1;
    $0_1 = $4_1 + $23_1 | 0;
    $3_1 = $61_1 + ($29_1 ? $56_1 : $3_1) | 0;
    $3_1 = ($10_1 - (($0_1 >>> 0 > $5_1 >>> 0) + ($0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 524287 | 0;
    $0_1 = ($5_1 - $0_1 | 0) - 8 | 0;
    $4_1 = $0_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $4_1 >>> 1 | 0;
    $5_1 = ($4_1 & 1) << 31 | $0_1 >>> 1;
    HEAP32[$22_1 >> 2] = $5_1;
    $9_1 = $3_1;
    HEAP32[$22_1 + 4 >> 2] = $3_1;
    $23_1 = $7_1 - -64 | 0;
    $10_1 = $23_1;
    $47_1 = $0_1 << 19 & 524288;
    $11_1 = ($6_1 & 4095) << 20 | $55_1 >>> 12;
    $0_1 = $6_1 >>> 12 | 0;
    $6_1 = $29_1 ? $52_1 : $19_1;
    $4_1 = $6_1 + HEAP32[$67_1 >> 2] | 0;
    $3_1 = HEAP32[$67_1 + 4 >> 2] + ($29_1 ? $15_1 : $17_1 & 1048575) | 0;
    $3_1 = ($0_1 - (($4_1 >>> 0 > $11_1 >>> 0) + ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 8388607 | 0;
    $6_1 = ($11_1 - $4_1 | 0) - 8 | 0;
    $15_1 = $6_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = ($15_1 >>> 1 | 0) + $47_1 | 0;
    $19_1 = ($15_1 & 1) << 31 | $6_1 >>> 1;
    $3_1 = $19_1;
    $4_1 = $3_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$10_1 >> 2] = $3_1;
    $47_1 = $4_1;
    HEAP32[$10_1 + 4 >> 2] = $4_1;
    $17_1 = $7_1 + 56 | 0;
    $10_1 = $17_1;
    $16_1 = $6_1 << 19 & 524288;
    $6_1 = $29_1 ? $58_1 : $14_1;
    $4_1 = $6_1 + HEAP32[$66_1 >> 2] | 0;
    $3_1 = HEAP32[$66_1 + 4 >> 2] + ($29_1 ? $20_1 : $12_1 & 1048575) | 0;
    $3_1 = ($0_1 - (($4_1 >>> 0 > $11_1 >>> 0) + ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 8388607 | 0;
    $4_1 = ($11_1 - $4_1 | 0) - 8 | 0;
    $6_1 = $4_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = ($6_1 >>> 1 | 0) + $16_1 | 0;
    $15_1 = ($6_1 & 1) << 31 | $4_1 >>> 1;
    $3_1 = $15_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$10_1 >> 2] = $15_1;
    $20_1 = $3_1;
    HEAP32[$10_1 + 4 >> 2] = $3_1;
    $14_1 = $7_1 + 48 | 0;
    $12_1 = $4_1 << 19 & 524288;
    $6_1 = $11_1;
    $10_1 = $0_1;
    $3_1 = $29_1 ? $59_1 : $26_1;
    $0_1 = $3_1 + HEAP32[$65_1 >> 2] | 0;
    $4_1 = HEAP32[$65_1 + 4 >> 2] + ($29_1 ? $27_1 : $41_1 & 1048575) | 0;
    $3_1 = ($10_1 - (($0_1 >>> 0 > $6_1 >>> 0) + ($0_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0) | 0) + 8388607 | 0;
    $0_1 = ($6_1 - $0_1 | 0) - 8 | 0;
    $11_1 = $0_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = ($11_1 >>> 1 | 0) + $12_1 | 0;
    $27_1 = ($11_1 & 1) << 31 | $0_1 >>> 1;
    $4_1 = $27_1;
    $3_1 = $4_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$14_1 >> 2] = $4_1;
    $12_1 = $3_1;
    HEAP32[$14_1 + 4 >> 2] = $3_1;
    $11_1 = $0_1 << 19 & 524288;
    $3_1 = ($10_1 & 1048574) + $63_1 | 0;
    $0_1 = ($6_1 & -977) + $50_1 | 0;
    $3_1 = $0_1 >>> 0 < $50_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $0_1 = ($3_1 & 1) << 31 | $0_1 >>> 1;
    $3_1 = ($3_1 >>> 1 | 0) + $11_1 | 0;
    $11_1 = $0_1;
    $3_1 = $0_1 >>> 0 < $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$7_1 + 40 >> 2] = $0_1;
    HEAP32[$7_1 + 44 >> 2] = $3_1;
    $1_1 = HEAP32[$1_1 + 120 >> 2];
    $6_1 = $1_1 >> 31;
    $0_1 = $1_1 - 1 | 0;
    $16_1 = $0_1;
    $4_1 = 0 - ((($1_1 | 0) != 0) + $6_1 | 0) | 0;
    $10_1 = $6_1 - !$1_1 | 0;
    $6_1 = $4_1 & HEAP32[$2_1 + 4 >> 2] | $10_1 & HEAP32[$7_1 + 4 >> 2];
    $1_1 = 0 - $1_1 | 0;
    HEAP32[$7_1 >> 2] = $1_1 & HEAP32[$2_1 >> 2] | $0_1 & HEAP32[$7_1 >> 2];
    HEAP32[$7_1 + 4 >> 2] = $6_1;
    $6_1 = HEAP32[$2_1 + 12 >> 2] & $4_1 | HEAP32[$30_1 + 4 >> 2] & $10_1;
    HEAP32[$30_1 >> 2] = HEAP32[$2_1 + 8 >> 2] & $1_1 | HEAP32[$30_1 >> 2] & $0_1;
    HEAP32[$30_1 + 4 >> 2] = $6_1;
    $6_1 = HEAP32[$2_1 + 20 >> 2] & $4_1 | HEAP32[$34_1 + 4 >> 2] & $10_1;
    HEAP32[$34_1 >> 2] = HEAP32[$2_1 + 16 >> 2] & $1_1 | HEAP32[$34_1 >> 2] & $0_1;
    HEAP32[$34_1 + 4 >> 2] = $6_1;
    $6_1 = HEAP32[$2_1 + 28 >> 2] & $4_1 | HEAP32[$31_1 + 4 >> 2] & $10_1;
    HEAP32[$31_1 >> 2] = HEAP32[$2_1 + 24 >> 2] & $1_1 | HEAP32[$31_1 >> 2] & $0_1;
    HEAP32[$31_1 + 4 >> 2] = $6_1;
    $6_1 = HEAP32[$2_1 + 36 >> 2] & $4_1 | HEAP32[$32_1 + 4 >> 2] & $10_1;
    HEAP32[$32_1 >> 2] = HEAP32[$2_1 + 32 >> 2] & $1_1 | HEAP32[$32_1 >> 2] & $0_1;
    HEAP32[$32_1 + 4 >> 2] = $6_1;
    $3_1 = HEAP32[$2_1 + 44 >> 2] & $4_1 | $3_1 & $10_1;
    HEAP32[$7_1 + 40 >> 2] = HEAP32[$2_1 + 40 >> 2] & $1_1 | $0_1 & $11_1;
    HEAP32[$7_1 + 44 >> 2] = $3_1;
    $3_1 = $2_1 + 48 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $12_1;
    HEAP32[$14_1 >> 2] = $1_1 & $11_1 | $0_1 & $27_1;
    HEAP32[$14_1 + 4 >> 2] = $3_1;
    $3_1 = $2_1 + 56 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $20_1;
    HEAP32[$17_1 >> 2] = $1_1 & $11_1 | $0_1 & $15_1;
    HEAP32[$17_1 + 4 >> 2] = $3_1;
    $3_1 = $2_1 - -64 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $47_1;
    HEAP32[$23_1 >> 2] = $1_1 & $11_1 | $0_1 & $19_1;
    HEAP32[$23_1 + 4 >> 2] = $3_1;
    $2_1 = $2_1 + 72 | 0;
    $3_1 = HEAP32[$2_1 >> 2];
    $2_1 = HEAP32[$2_1 + 4 >> 2] & $4_1 | $9_1 & $10_1;
    HEAP32[$22_1 >> 2] = $1_1 & $3_1 | $0_1 & $5_1;
    HEAP32[$22_1 + 4 >> 2] = $2_1;
    $2_1 = $10_1 & HEAP32[$7_1 + 84 >> 2];
    HEAP32[$7_1 + 80 >> 2] = HEAP32[$7_1 + 80 >> 2] & $0_1 | $1_1 & 1;
    HEAP32[$7_1 + 84 >> 2] = $2_1;
    $1_1 = HEAP32[$39_1 + 4 >> 2] & $10_1;
    HEAP32[$39_1 >> 2] = HEAP32[$39_1 >> 2] & $0_1;
    HEAP32[$39_1 + 4 >> 2] = $1_1;
    $1_1 = HEAP32[$35_1 + 4 >> 2] & $10_1;
    HEAP32[$35_1 >> 2] = HEAP32[$35_1 >> 2] & $0_1;
    HEAP32[$35_1 + 4 >> 2] = $1_1;
    $1_1 = HEAP32[$40_1 + 4 >> 2] & $10_1;
    HEAP32[$40_1 >> 2] = HEAP32[$40_1 >> 2] & $0_1;
    HEAP32[$40_1 + 4 >> 2] = $1_1;
    $19_1 = HEAP32[$37_1 >> 2];
    $5_1 = HEAP32[$37_1 + 4 >> 2];
    $20_1 = $7_1;
    $12_1 = $8_1 & 65535;
    $1_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
    $0_1 = $1_1 + $44_1 | 0;
    $3_1 = $36_1 + i64toi32_i32$HIGH_BITS | 0;
    $1_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $2_1 = $1_1 >>> 20 | 0;
    $3_1 = $38_1;
    $4_1 = $2_1;
    $2_1 = $2_1 + $28_1 | 0;
    $11_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $25_1;
    $4_1 = $11_1 >>> 20 | 0;
    $7_1 = $4_1 + $24_1 | 0;
    $6_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $21_1;
    $4_1 = $6_1 >>> 20 | 0;
    $15_1 = $4_1 + $18_1 | 0;
    $9_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $4_1 = $12_1;
    $27_1 = $9_1 >>> 20 | 0;
    $3_1 = $27_1 + $42_1 | 0;
    $4_1 = $27_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    if ($3_1 | ($15_1 | ($0_1 | $2_1 | $7_1)) | ($4_1 | ($1_1 | $11_1 | $6_1 | $9_1) & 1048575)) {
      if (($2_1 & ($0_1 ^ 976) & $7_1 & $15_1 & $3_1) == -1) {
        $0_1 = ($11_1 & ($1_1 ^ 1) & $6_1 & $9_1 & ($4_1 ^ 983040)) == 1048575;
      } else {
        $0_1 = 0;
      }
    } else {
      $0_1 = 1;
    }
    HEAP32[$20_1 + 120 >> 2] = $0_1 & ($69_1 ^ -1);
    HEAP32[$37_1 >> 2] = $16_1 & $19_1;
    HEAP32[$37_1 + 4 >> 2] = $5_1 & $10_1;
    global$0 = $13_1 + 1744 | 0;
  }
  function $54($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
    $4_1 = global$0 - 336 | 0;
    global$0 = $4_1;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $19_1 = $2_1;
    $15_1 = HEAP32[$1_1 >> 2];
    $3_1 = $15_1;
    $2_1 = $2_1 << 1 | $3_1 >>> 31;
    $10_1 = $4_1 - -64 | 0;
    $14_1 = HEAP32[$1_1 + 24 >> 2];
    $13_1 = HEAP32[$1_1 + 28 >> 2];
    $25_1 = $3_1 << 1;
    $29_1 = $2_1;
    $69($10_1, $14_1, $13_1, 0, 0, $25_1, $2_1, 0, 0);
    $2_1 = HEAP32[$1_1 + 12 >> 2];
    $35_1 = $2_1;
    $30_1 = HEAP32[$1_1 + 8 >> 2];
    $3_1 = $30_1;
    $2_1 = $2_1 << 1 | $3_1 >>> 31;
    $8_1 = $4_1 + 272 | 0;
    $18_1 = HEAP32[$1_1 + 16 >> 2];
    $12_1 = HEAP32[$1_1 + 20 >> 2];
    $3_1 = $3_1 << 1;
    $5_1 = $2_1;
    $69($8_1, $18_1, $12_1, 0, 0, $3_1, $2_1, 0, 0);
    $7_1 = $4_1 + 224 | 0;
    $6_1 = HEAP32[$1_1 + 32 >> 2];
    $1_1 = HEAP32[$1_1 + 36 >> 2];
    $69($7_1, $6_1, $1_1, 0, 0, $6_1, $1_1, 0, 0);
    $9_1 = $4_1 + 208 | 0;
    $69($9_1, HEAP32[$4_1 + 224 >> 2], HEAP32[$4_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
    $2_1 = $1_1 << 1 | $6_1 >>> 31;
    $31_1 = $4_1 + 176 | 0;
    $21_1 = $6_1 << 1;
    $32_1 = $2_1;
    $69($31_1, $21_1, $2_1, 0, 0, $15_1, $19_1, 0, 0);
    $33_1 = $4_1 + 80 | 0;
    $69($33_1, $14_1, $13_1, 0, 0, $3_1, $5_1, 0, 0);
    $34_1 = $4_1 + 256 | 0;
    $69($34_1, $18_1, $12_1, 0, 0, $18_1, $12_1, 0, 0);
    $11_1 = $4_1 + 192 | 0;
    $1_1 = $7_1 + 8 | 0;
    $69($11_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $37_1 = $4_1 + 320 | 0;
    $69($37_1, $15_1, $19_1, 0, 0, $15_1, $19_1, 0, 0);
    $26_1 = $4_1 + 160 | 0;
    $69($26_1, $21_1, $2_1, 0, 0, $30_1, $35_1, 0, 0);
    $27_1 = $4_1 + 96 | 0;
    $69($27_1, $14_1, $13_1, 0, 0, $18_1 << 1, $12_1 << 1 | $18_1 >>> 31, 0, 0);
    $15_1 = HEAP32[$4_1 + 68 >> 2];
    $2_1 = $15_1 + HEAP32[$4_1 + 276 >> 2] | 0;
    $6_1 = HEAP32[$4_1 + 64 >> 2];
    $1_1 = HEAP32[$4_1 + 272 >> 2];
    $3_1 = $6_1 + $1_1 | 0;
    $5_1 = HEAP32[$4_1 + 208 >> 2];
    $36_1 = $3_1 + $5_1 | 0;
    $1_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $1_1 + HEAP32[$4_1 + 212 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $36_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = ($1_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $36_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $2_1 = $9_1 + 8 | 0;
    $9_1 = HEAP32[$2_1 >> 2];
    $23_1 = HEAP32[$2_1 + 4 >> 2];
    $6_1 = ($1_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
    $2_1 = $8_1 + 8 | 0;
    $3_1 = HEAP32[$2_1 >> 2];
    $1_1 = $10_1 + 8 | 0;
    $8_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $6_1 + $8_1 | 0;
    $2_1 = ($1_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $23_1 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $19_1 = $5_1;
    $23_1 = $1_1 << 12 | $5_1 >>> 20;
    $3_1 = $2_1;
    $6_1 = $2_1 << 12 | $1_1 >>> 20;
    $20_1 = HEAP32[$4_1 + 80 >> 2];
    $1_1 = HEAP32[$4_1 + 256 >> 2];
    $7_1 = $20_1 + $1_1 | 0;
    $28_1 = HEAP32[$4_1 + 84 >> 2];
    $2_1 = $28_1 + HEAP32[$4_1 + 260 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = HEAP32[$4_1 + 176 >> 2];
    $9_1 = $1_1 + $7_1 | 0;
    $10_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$4_1 + 180 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = HEAP32[$4_1 + 192 >> 2];
    $5_1 = $1_1 + $9_1 | 0;
    $8_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$4_1 + 196 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $1_1 + $6_1 | 0;
    $23_1 = $5_1 + $23_1 | 0;
    $6_1 = $23_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $22_1 = ($1_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 > $23_1 >>> 0 | $1_1 >>> 0 > $6_1 >>> 0;
    $24_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
    $1_1 = $11_1 + 8 | 0;
    $17_1 = HEAP32[$1_1 >> 2];
    $16_1 = HEAP32[$1_1 + 4 >> 2];
    $15_1 = ($8_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
    $1_1 = $31_1 + 8 | 0;
    $11_1 = HEAP32[$1_1 >> 2];
    $8_1 = HEAP32[$1_1 + 4 >> 2];
    $9_1 = ($10_1 | 0) == ($28_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $10_1 >>> 0 < $28_1 >>> 0;
    $2_1 = $34_1 + 8 | 0;
    $5_1 = HEAP32[$2_1 >> 2];
    $1_1 = $33_1 + 8 | 0;
    $7_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $7_1 + $9_1 | 0;
    $2_1 = ($1_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $8_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $2_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $15_1 | 0;
    $2_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $16_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $2_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $1_1 + $24_1 | 0;
    $2_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $3_1 >>> 20 | 0;
    $1_1 = $3_1 + $5_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $6_1;
    $7_1 = $1_1 << 12 | $3_1 >>> 20;
    $5_1 = $2_1;
    $9_1 = $2_1 << 12 | $1_1 >>> 20;
    $17_1 = HEAP32[$4_1 + 160 >> 2];
    $1_1 = HEAP32[$4_1 + 96 >> 2];
    $6_1 = $17_1 + $1_1 | 0;
    $20_1 = HEAP32[$4_1 + 164 >> 2];
    $2_1 = $20_1 + HEAP32[$4_1 + 100 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $1_1 + $9_1 | 0;
    $11_1 = $6_1;
    $6_1 = $6_1 + $7_1 | 0;
    $7_1 = $6_1 << 4 & -16;
    $8_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $9_1 = ($8_1 << 4 | $6_1 >>> 28) & 16777215;
    $15_1 = $3_1;
    $69($4_1, $7_1 | $3_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
    $22_1 = HEAP32[$4_1 + 4 >> 2];
    $2_1 = $22_1 + HEAP32[$4_1 + 324 >> 2] | 0;
    $9_1 = $0_1;
    $24_1 = HEAP32[$4_1 >> 2];
    $0_1 = HEAP32[$4_1 + 320 >> 2];
    $10_1 = $24_1 + $0_1 | 0;
    HEAP32[$9_1 >> 2] = $10_1;
    $7_1 = $0_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$9_1 + 4 >> 2] = $7_1 & 1048575;
    $28_1 = $4_1 + 304 | 0;
    $69($28_1, $30_1, $35_1, 0, 0, $25_1, $29_1, 0, 0);
    $31_1 = $4_1 + 144 | 0;
    $69($31_1, $21_1, $32_1, 0, 0, $18_1, $12_1, 0, 0);
    $33_1 = $4_1 + 112 | 0;
    $69($33_1, $14_1, $13_1, 0, 0, $14_1, $13_1, 0, 0);
    $34_1 = $4_1 + 48 | 0;
    $16_1 = $34_1;
    $6_1 = ($1_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $3_1 = ($1_1 | 0) == ($20_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
    $2_1 = $27_1 + 8 | 0;
    $1_1 = HEAP32[$2_1 >> 2];
    $0_1 = $26_1 + 8 | 0;
    $11_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $3_1 + $11_1 | 0;
    $2_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $5_1 >>> 20 | 0;
    $0_1 = $1_1 + $3_1 | 0;
    $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $6_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $0_1 << 12 | $8_1 >>> 20;
    $6_1 = $2_1;
    $5_1 = $2_1 << 12 | $0_1 >>> 20;
    $26_1 = HEAP32[$4_1 + 148 >> 2];
    $2_1 = $26_1 + HEAP32[$4_1 + 116 >> 2] | 0;
    $20_1 = HEAP32[$4_1 + 144 >> 2];
    $1_1 = HEAP32[$4_1 + 112 >> 2];
    $0_1 = $20_1 + $1_1 | 0;
    $17_1 = $0_1;
    $11_1 = $0_1 + $8_1 | 0;
    $3_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $5_1 | 0;
    $8_1 = $11_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($16_1, $11_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $5_1 = ($7_1 | 0) == ($22_1 | 0) & $10_1 >>> 0 < $24_1 >>> 0 | $7_1 >>> 0 < $22_1 >>> 0;
    $2_1 = $37_1 + 8 | 0;
    $1_1 = HEAP32[$2_1 >> 2];
    $0_1 = $4_1 + 8 | 0;
    $10_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $5_1 + $10_1 | 0;
    $2_1 = $0_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $10_1 = $0_1 << 12 | $7_1 >>> 20;
    $5_1 = $2_1;
    $7_1 = $2_1 << 12 | $0_1 >>> 20;
    $22_1 = HEAP32[$4_1 + 48 >> 2];
    $0_1 = HEAP32[$4_1 + 304 >> 2];
    $16_1 = $22_1 + $0_1 | 0;
    $27_1 = HEAP32[$4_1 + 52 >> 2];
    $2_1 = $27_1 + HEAP32[$4_1 + 308 >> 2] | 0;
    $1_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $1_1 + $7_1 | 0;
    $10_1 = $10_1 + $16_1 | 0;
    $2_1 = $10_1 >>> 0 < $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$9_1 + 8 >> 2] = $10_1;
    $7_1 = $2_1;
    HEAP32[$9_1 + 12 >> 2] = $2_1 & 1048575;
    $24_1 = $4_1 + 240 | 0;
    $69($24_1, $18_1, $12_1, 0, 0, $25_1, $29_1, 0, 0);
    $29_1 = $4_1 + 288 | 0;
    $69($29_1, $30_1, $35_1, 0, 0, $30_1, $35_1, 0, 0);
    $25_1 = $4_1 + 128 | 0;
    $69($25_1, $21_1, $32_1, 0, 0, $14_1, $13_1, 0, 0);
    $32_1 = $4_1 + 32 | 0;
    $13_1 = $32_1;
    $12_1 = ($3_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $11_1 = ($3_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 < $26_1 >>> 0;
    $2_1 = $33_1 + 8 | 0;
    $3_1 = HEAP32[$2_1 >> 2];
    $0_1 = $31_1 + 8 | 0;
    $14_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $11_1 + $14_1 | 0;
    $2_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $6_1 = $6_1 >>> 20 | 0;
    $0_1 = $3_1 + $6_1 | 0;
    $2_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $0_1;
    $0_1 = $0_1 + $12_1 | 0;
    $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $18_1 = $0_1 << 12 | $8_1 >>> 20;
    $6_1 = HEAP32[$4_1 + 128 >> 2];
    $8_1 = $18_1 + $6_1 | 0;
    $3_1 = $2_1;
    $21_1 = $2_1 << 12 | $0_1 >>> 20;
    $2_1 = $21_1 + HEAP32[$4_1 + 132 >> 2] | 0;
    $11_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($13_1, $8_1, $11_1, 0, 0, 15632, 16, 0, 0);
    $6_1 = $9_1;
    $10_1 = ($1_1 | 0) == ($7_1 | 0) & $10_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $9_1 = ($1_1 | 0) == ($27_1 | 0) & $16_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
    $2_1 = $28_1 + 8 | 0;
    $1_1 = HEAP32[$2_1 >> 2];
    $0_1 = $34_1 + 8 | 0;
    $12_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $9_1 + $12_1 | 0;
    $2_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $5_1 >>> 20 | 0;
    $0_1 = $1_1 + $5_1 | 0;
    $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $10_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $9_1 = $0_1 << 12 | $7_1 >>> 20;
    $1_1 = $2_1;
    $13_1 = $2_1 << 12 | $0_1 >>> 20;
    $16_1 = HEAP32[$4_1 + 240 >> 2];
    $0_1 = HEAP32[$4_1 + 288 >> 2];
    $7_1 = $16_1 + $0_1 | 0;
    $17_1 = HEAP32[$4_1 + 244 >> 2];
    $2_1 = $17_1 + HEAP32[$4_1 + 292 >> 2] | 0;
    $12_1 = $0_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $12_1 + HEAP32[$4_1 + 36 >> 2] | 0;
    $0_1 = HEAP32[$4_1 + 32 >> 2];
    $5_1 = $0_1 + $7_1 | 0;
    $10_1 = $5_1;
    $9_1 = $5_1 + $9_1 | 0;
    $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 + $13_1 | 0;
    HEAP32[$6_1 + 16 >> 2] = $9_1;
    $5_1 = $9_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 20 >> 2] = $5_1 & 1048575;
    $14_1 = $4_1 + 16 | 0;
    $13_1 = ($11_1 | 0) == ($21_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $11_1 >>> 0 < $21_1 >>> 0;
    $2_1 = $25_1 + 8 | 0;
    $11_1 = HEAP32[$2_1 >> 2];
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $3_1 = $3_1 >>> 20 | 0;
    $8_1 = $3_1;
    $3_1 = $3_1 + $11_1 | 0;
    $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $3_1;
    $3_1 = $3_1 + $13_1 | 0;
    $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($14_1, $3_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
    $3_1 = $6_1;
    $13_1 = ($0_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
    $11_1 = ($0_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
    $0_1 = $32_1 + 8 | 0;
    $10_1 = HEAP32[$0_1 >> 2];
    $8_1 = HEAP32[$0_1 + 4 >> 2];
    $9_1 = ($12_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $12_1 >>> 0 < $17_1 >>> 0;
    $2_1 = $29_1 + 8 | 0;
    $6_1 = HEAP32[$2_1 >> 2];
    $0_1 = $24_1 + 8 | 0;
    $7_1 = $6_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $7_1 + $9_1 | 0;
    $2_1 = ($0_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $8_1 | 0;
    $6_1 = $0_1;
    $0_1 = $0_1 + $10_1 | 0;
    $2_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $6_1 = $0_1 + $11_1 | 0;
    $2_1 = $6_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $1_1 >>> 20 | 0;
    $0_1 = $1_1 + $6_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $13_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $6_1 = $0_1 << 12 | $5_1 >>> 20;
    $1_1 = $2_1;
    $5_1 = $2_1 << 12 | $0_1 >>> 20;
    $11_1 = HEAP32[$4_1 + 16 >> 2];
    $0_1 = $36_1 & -2;
    $9_1 = $11_1 + $0_1 | 0;
    $2_1 = $19_1 & 1048575;
    $19_1 = HEAP32[$4_1 + 20 >> 2];
    $2_1 = $2_1 + $19_1 | 0;
    $7_1 = $0_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $7_1 + $5_1 | 0;
    $5_1 = $6_1 + $9_1 | 0;
    $2_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$3_1 + 24 >> 2] = $5_1;
    $0_1 = $2_1;
    HEAP32[$3_1 + 28 >> 2] = $2_1 & 1048575;
    $6_1 = $3_1;
    $10_1 = $15_1 & 65535;
    $8_1 = ($2_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
    $3_1 = ($7_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $7_1 >>> 0 < $19_1 >>> 0;
    $2_1 = $14_1 + 8 | 0;
    $5_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $1_1 >>> 20 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + $5_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $1_1 << 12 | $0_1 >>> 20;
    $3_1 = $0_1 + $23_1 | 0;
    $2_1 = $10_1 + ($2_1 << 12 | $1_1 >>> 20) | 0;
    HEAP32[$6_1 + 32 >> 2] = $3_1;
    HEAP32[$6_1 + 36 >> 2] = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    global$0 = $4_1 + 336 | 0;
  }
  function $55($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0;
    $4_1 = global$0 - 464 | 0;
    global$0 = $4_1;
    HEAP32[$0_1 + 120 >> 2] = HEAP32[$1_1 + 120 >> 2];
    $2_1 = $1_1 + 40 | 0;
    $34($0_1 + 80 | 0, $1_1 + 80 | 0, $2_1);
    $54($4_1 + 384 | 0, $2_1);
    $33_1 = $4_1 + 424 | 0;
    $54($33_1, $1_1);
    $15_1 = HEAP32[$4_1 + 388 >> 2];
    $16_1 = HEAP32[$4_1 + 384 >> 2];
    HEAP32[$4_1 + 344 >> 2] = -3908 - $16_1;
    HEAP32[$4_1 + 348 >> 2] = 4194299 - (($16_1 >>> 0 > 4294963388) + $15_1 | 0);
    $13_1 = HEAP32[$4_1 + 396 >> 2];
    $19_1 = HEAP32[$4_1 + 392 >> 2];
    HEAP32[$4_1 + 352 >> 2] = -4 - $19_1;
    HEAP32[$4_1 + 356 >> 2] = 4194303 - (($19_1 >>> 0 > 4294967292) + $13_1 | 0);
    $21_1 = HEAP32[$4_1 + 404 >> 2];
    $18_1 = HEAP32[$4_1 + 400 >> 2];
    HEAP32[$4_1 + 360 >> 2] = -4 - $18_1;
    HEAP32[$4_1 + 364 >> 2] = 4194303 - (($18_1 >>> 0 > 4294967292) + $21_1 | 0);
    $10_1 = HEAP32[$4_1 + 412 >> 2];
    $7_1 = HEAP32[$4_1 + 408 >> 2];
    HEAP32[$4_1 + 368 >> 2] = -4 - $7_1;
    HEAP32[$4_1 + 372 >> 2] = 4194303 - (($7_1 >>> 0 > 4294967292) + $10_1 | 0);
    $6_1 = __wasm_i64_mul(HEAP32[$4_1 + 456 >> 2], HEAP32[$4_1 + 460 >> 2], 3, 0);
    $5_1 = i64toi32_i32$HIGH_BITS;
    $20_1 = __wasm_i64_mul(HEAP32[$4_1 + 424 >> 2], HEAP32[$4_1 + 428 >> 2], 3, 0);
    $9_1 = i64toi32_i32$HIGH_BITS;
    $2_1 = $20_1 & 1;
    $3_1 = 0 - $2_1 | 0;
    $12_1 = $3_1;
    $11_1 = 0 - $2_1 | 0;
    $2_1 = ($11_1 >>> 16 | 0) + $5_1 | 0;
    $3_1 = ($11_1 & 65535) << 16 | $3_1 >>> 16;
    $5_1 = $3_1 + $6_1 | 0;
    $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$4_1 + 456 >> 2] = ($2_1 & 1) << 31 | $5_1 >>> 1;
    HEAP32[$4_1 + 460 >> 2] = $2_1 >>> 1;
    $8_1 = $5_1 << 19 & 524288;
    $6_1 = $11_1 >>> 12 | 0;
    $12_1 = ($11_1 & 4095) << 20 | $12_1 >>> 12;
    $3_1 = __wasm_i64_mul(HEAP32[$4_1 + 448 >> 2], HEAP32[$4_1 + 452 >> 2], 3, 0);
    $5_1 = $12_1 + $3_1 | 0;
    $2_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
    $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = ($3_1 >>> 1 | 0) + $8_1 | 0;
    $11_1 = ($3_1 & 1) << 31 | $5_1 >>> 1;
    $2_1 = $11_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$4_1 + 448 >> 2] = $11_1;
    HEAP32[$4_1 + 452 >> 2] = $2_1;
    $11_1 = $5_1 << 19 & 524288;
    $5_1 = __wasm_i64_mul(HEAP32[$4_1 + 440 >> 2], HEAP32[$4_1 + 444 >> 2], 3, 0) + $12_1 | 0;
    $3_1 = i64toi32_i32$HIGH_BITS + $6_1 | 0;
    $3_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $2_1 = ($3_1 >>> 1 | 0) + $11_1 | 0;
    $8_1 = ($3_1 & 1) << 31 | $5_1 >>> 1;
    $2_1 = $8_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$4_1 + 440 >> 2] = $8_1;
    HEAP32[$4_1 + 444 >> 2] = $2_1;
    $8_1 = $5_1 << 19 & 524288;
    $3_1 = __wasm_i64_mul(HEAP32[$4_1 + 432 >> 2], HEAP32[$4_1 + 436 >> 2], 3, 0);
    $11_1 = $3_1 + $12_1 | 0;
    $2_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
    $5_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = ($5_1 >>> 1 | 0) + $8_1 | 0;
    $22_1 = ($5_1 & 1) << 31 | $11_1 >>> 1;
    $3_1 = $22_1;
    $2_1 = $3_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$4_1 + 432 >> 2] = $3_1;
    HEAP32[$4_1 + 436 >> 2] = $2_1;
    $11_1 = $11_1 << 19 & 524288;
    $2_1 = ($6_1 & 1048574) + $9_1 | 0;
    $5_1 = ($12_1 & -977) + $20_1 | 0;
    $2_1 = $5_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = ($2_1 & 1) << 31 | $5_1 >>> 1;
    $2_1 = ($2_1 >>> 1 | 0) + $11_1 | 0;
    $3_1 = $5_1;
    $2_1 = $3_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$4_1 + 424 >> 2] = $3_1;
    HEAP32[$4_1 + 428 >> 2] = $2_1;
    $9_1 = HEAP32[$4_1 + 420 >> 2];
    $8_1 = HEAP32[$4_1 + 416 >> 2];
    HEAP32[$4_1 + 376 >> 2] = -4 - $8_1;
    HEAP32[$4_1 + 380 >> 2] = 262143 - (($8_1 >>> 0 > 4294967292) + $9_1 | 0);
    $34_1 = $4_1 + 344 | 0;
    $34($34_1, $34_1, $1_1);
    $54($0_1, $33_1);
    $1_1 = HEAP32[$4_1 + 376 >> 2];
    $51_1 = $1_1;
    $2_1 = HEAP32[$4_1 + 380 >> 2];
    $52_1 = $2_1;
    $2_1 = HEAP32[$0_1 + 36 >> 2] + ($2_1 << 1 | $1_1 >>> 31) | 0;
    $1_1 = $1_1 << 1;
    $3_1 = $1_1;
    $1_1 = $1_1 + HEAP32[$0_1 + 32 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $38_1 = $1_1;
    HEAP32[$0_1 + 32 >> 2] = $1_1;
    $29_1 = $2_1;
    HEAP32[$0_1 + 36 >> 2] = $2_1;
    $6_1 = $0_1;
    $5_1 = HEAP32[$0_1 + 24 >> 2];
    $0_1 = HEAP32[$4_1 + 368 >> 2];
    $53_1 = $0_1;
    $1_1 = HEAP32[$4_1 + 372 >> 2];
    $54_1 = $1_1;
    $2_1 = HEAP32[$6_1 + 28 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
    $0_1 = $0_1 << 1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $5_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $39_1 = $0_1;
    HEAP32[$6_1 + 24 >> 2] = $0_1;
    $35_1 = $2_1;
    HEAP32[$6_1 + 28 >> 2] = $2_1;
    $0_1 = HEAP32[$4_1 + 360 >> 2];
    $55_1 = $0_1;
    $1_1 = HEAP32[$4_1 + 364 >> 2];
    $56_1 = $1_1;
    $2_1 = HEAP32[$6_1 + 20 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
    $0_1 = $0_1 << 1;
    $1_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 16 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $40_1 = $0_1;
    HEAP32[$6_1 + 16 >> 2] = $0_1;
    $36_1 = $2_1;
    HEAP32[$6_1 + 20 >> 2] = $2_1;
    $0_1 = HEAP32[$4_1 + 352 >> 2];
    $57_1 = $0_1;
    $1_1 = HEAP32[$4_1 + 356 >> 2];
    $58_1 = $1_1;
    $3_1 = HEAP32[$6_1 + 12 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
    $0_1 = $0_1 << 1;
    $1_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 8 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $41_1 = $0_1;
    HEAP32[$6_1 + 8 >> 2] = $0_1;
    $20_1 = $3_1;
    HEAP32[$6_1 + 12 >> 2] = $3_1;
    $0_1 = HEAP32[$4_1 + 344 >> 2];
    $59_1 = $0_1;
    $1_1 = HEAP32[$4_1 + 348 >> 2];
    $60_1 = $1_1;
    $2_1 = HEAP32[$6_1 + 4 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
    $0_1 = $0_1 << 1;
    $1_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $42_1 = $0_1;
    HEAP32[$6_1 >> 2] = $0_1;
    $22_1 = $2_1;
    HEAP32[$6_1 + 4 >> 2] = $2_1;
    $24_1 = $4_1 + 104 | 0;
    $11_1 = $7_1;
    $5_1 = $10_1;
    $27_1 = $16_1 << 1;
    $25_1 = $15_1 << 1 | $16_1 >>> 31;
    $69($24_1, $7_1, $5_1, 0, 0, $27_1, $25_1, 0, 0);
    $17_1 = $4_1 + 168 | 0;
    $1_1 = $18_1;
    $0_1 = $21_1;
    $12_1 = $19_1 << 1;
    $7_1 = $13_1 << 1 | $19_1 >>> 31;
    $69($17_1, $1_1, $0_1, 0, 0, $12_1, $7_1, 0, 0);
    $18_1 = $4_1 + 328 | 0;
    $69($18_1, $8_1, $9_1, 0, 0, $8_1, $9_1, 0, 0);
    $14_1 = $4_1 + 312 | 0;
    $69($14_1, HEAP32[$4_1 + 328 >> 2], HEAP32[$4_1 + 332 >> 2], 0, 0, 15632, 16, 0, 0);
    $3_1 = $8_1;
    $2_1 = $9_1 << 1 | $3_1 >>> 31;
    $43_1 = $4_1 + 136 | 0;
    $30_1 = $3_1 << 1;
    $21_1 = $2_1;
    $69($43_1, $30_1, $2_1, 0, 0, $16_1, $15_1, 0, 0);
    $44_1 = $4_1 + 152 | 0;
    $69($44_1, $11_1, $5_1, 0, 0, $12_1, $7_1, 0, 0);
    $45_1 = $4_1 + 232 | 0;
    $69($45_1, $1_1, $0_1, 0, 0, $1_1, $0_1, 0, 0);
    $26_1 = $4_1 + 296 | 0;
    $2_1 = $18_1 + 8 | 0;
    $69($26_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $46_1 = $4_1 + 120 | 0;
    $69($46_1, $16_1, $15_1, 0, 0, $16_1, $15_1, 0, 0);
    $47_1 = $4_1 + 200 | 0;
    $69($47_1, $30_1, $21_1, 0, 0, $19_1, $13_1, 0, 0);
    $8_1 = $0_1;
    $18_1 = $1_1;
    $2_1 = $0_1 << 1 | $1_1 >>> 31;
    $48_1 = $4_1 + 248 | 0;
    $10_1 = $11_1;
    $9_1 = $5_1;
    $69($48_1, $10_1, $5_1, 0, 0, $1_1 << 1, $2_1, 0, 0);
    $15_1 = HEAP32[$4_1 + 108 >> 2];
    $2_1 = $15_1 + HEAP32[$4_1 + 172 >> 2] | 0;
    $5_1 = HEAP32[$4_1 + 104 >> 2];
    $0_1 = HEAP32[$4_1 + 168 >> 2];
    $3_1 = $5_1 + $0_1 | 0;
    $1_1 = HEAP32[$4_1 + 312 >> 2];
    $16_1 = $3_1 + $1_1 | 0;
    $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 + HEAP32[$4_1 + 316 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = ($0_1 | 0) == ($1_1 | 0) & $3_1 >>> 0 > $16_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
    $2_1 = $14_1 + 8 | 0;
    $12_1 = HEAP32[$2_1 >> 2];
    $11_1 = HEAP32[$2_1 + 4 >> 2];
    $5_1 = ($0_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $15_1 >>> 0;
    $2_1 = $17_1 + 8 | 0;
    $3_1 = HEAP32[$2_1 >> 2];
    $0_1 = $24_1 + 8 | 0;
    $15_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $5_1 + $15_1 | 0;
    $2_1 = ($0_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $11_1 | 0;
    $3_1 = $0_1;
    $0_1 = $0_1 + $12_1 | 0;
    $3_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $7_1 | 0;
    $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $15_1 = $1_1;
    $11_1 = $0_1 << 12 | $1_1 >>> 20;
    $1_1 = $3_1 << 12 | $0_1 >>> 20;
    $49_1 = HEAP32[$4_1 + 152 >> 2];
    $0_1 = HEAP32[$4_1 + 232 >> 2];
    $7_1 = $49_1 + $0_1 | 0;
    $37_1 = HEAP32[$4_1 + 156 >> 2];
    $2_1 = $37_1 + HEAP32[$4_1 + 236 >> 2] | 0;
    $2_1 = $0_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = HEAP32[$4_1 + 136 >> 2];
    $12_1 = $0_1 + $7_1 | 0;
    $17_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$4_1 + 140 >> 2] | 0;
    $2_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = HEAP32[$4_1 + 296 >> 2];
    $5_1 = $0_1 + $12_1 | 0;
    $14_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$4_1 + 300 >> 2] | 0;
    $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 + $1_1 | 0;
    $50_1 = $4_1 + 40 | 0;
    $11_1 = $5_1 + $11_1 | 0;
    $1_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $28_1 = ($0_1 | 0) == ($1_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
    $23_1 = ($0_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 < $14_1 >>> 0;
    $0_1 = $26_1 + 8 | 0;
    $31_1 = HEAP32[$0_1 >> 2];
    $32_1 = HEAP32[$0_1 + 4 >> 2];
    $24_1 = ($14_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 > $12_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
    $0_1 = $43_1 + 8 | 0;
    $26_1 = HEAP32[$0_1 >> 2];
    $14_1 = HEAP32[$0_1 + 4 >> 2];
    $12_1 = ($17_1 | 0) == ($37_1 | 0) & $7_1 >>> 0 < $49_1 >>> 0 | $17_1 >>> 0 < $37_1 >>> 0;
    $2_1 = $45_1 + 8 | 0;
    $5_1 = HEAP32[$2_1 >> 2];
    $0_1 = $44_1 + 8 | 0;
    $7_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $7_1 + $12_1 | 0;
    $2_1 = ($0_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $14_1 | 0;
    $5_1 = $0_1;
    $0_1 = $0_1 + $26_1 | 0;
    $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $0_1;
    $0_1 = $0_1 + $24_1 | 0;
    $2_1 = ($5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $32_1 | 0;
    $5_1 = $0_1;
    $0_1 = $0_1 + $31_1 | 0;
    $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $0_1 + $23_1 | 0;
    $2_1 = $5_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $3_1 >>> 20 | 0;
    $0_1 = $3_1 + $5_1 | 0;
    $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $0_1;
    $0_1 = $0_1 + $28_1 | 0;
    $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $0_1 << 12 | $1_1 >>> 20;
    $3_1 = $2_1;
    $12_1 = $2_1 << 12 | $0_1 >>> 20;
    $28_1 = HEAP32[$4_1 + 204 >> 2];
    $2_1 = $28_1 + HEAP32[$4_1 + 252 >> 2] | 0;
    $23_1 = HEAP32[$4_1 + 200 >> 2];
    $0_1 = HEAP32[$4_1 + 248 >> 2];
    $5_1 = $23_1 + $0_1 | 0;
    $14_1 = $5_1;
    $7_1 = $5_1 + $7_1 | 0;
    $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 + $12_1 | 0;
    $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $5_1 << 4 | $7_1 >>> 28;
    $17_1 = $7_1 << 4 & -16;
    $12_1 = $1_1;
    $69($50_1, $17_1 | $1_1 >>> 16 & 15, $2_1 & 16777215, 0, 0, 977, 1, 0, 0);
    $31_1 = $4_1 + 24 | 0;
    $69($31_1, $19_1, $13_1, 0, 0, $27_1, $25_1, 0, 0);
    $32_1 = $4_1 + 216 | 0;
    $69($32_1, $30_1, $21_1, 0, 0, $18_1, $8_1, 0, 0);
    $24_1 = $4_1 + 280 | 0;
    $69($24_1, $10_1, $9_1, 0, 0, $10_1, $9_1, 0, 0);
    $26_1 = $4_1 + 88 | 0;
    $17_1 = ($0_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
    $7_1 = ($0_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $0_1 >>> 0 < $28_1 >>> 0;
    $2_1 = $48_1 + 8 | 0;
    $1_1 = HEAP32[$2_1 >> 2];
    $0_1 = $47_1 + 8 | 0;
    $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $3_1;
    $1_1 = $7_1 + $14_1 | 0;
    $2_1 = $1_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $0_1 >>> 20 | 0;
    $3_1 = $0_1;
    $0_1 = $0_1 + $1_1 | 0;
    $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $17_1 | 0;
    $1_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $1_1 << 12 | $0_1 >>> 20;
    $7_1 = $0_1 << 12 | $5_1 >>> 20;
    $5_1 = $3_1;
    $17_1 = HEAP32[$4_1 + 216 >> 2];
    $0_1 = HEAP32[$4_1 + 280 >> 2];
    $3_1 = $17_1 + $0_1 | 0;
    $23_1 = HEAP32[$4_1 + 220 >> 2];
    $2_1 = $23_1 + HEAP32[$4_1 + 284 >> 2] | 0;
    $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 + $5_1 | 0;
    $5_1 = $7_1;
    $7_1 = $3_1;
    $3_1 = $5_1 + $3_1 | 0;
    $5_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($26_1, $3_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $14_1 = $4_1 + 8 | 0;
    $69($14_1, $18_1, $8_1, 0, 0, $27_1, $25_1, 0, 0);
    $27_1 = $4_1 + 184 | 0;
    $69($27_1, $19_1, $13_1, 0, 0, $19_1, $13_1, 0, 0);
    $13_1 = $4_1 + 264 | 0;
    $69($13_1, $30_1, $21_1, 0, 0, $10_1, $9_1, 0, 0);
    $21_1 = $4_1 + 72 | 0;
    $9_1 = $21_1;
    $8_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
    $7_1 = ($0_1 | 0) == ($23_1 | 0) & $7_1 >>> 0 < $17_1 >>> 0 | $0_1 >>> 0 < $23_1 >>> 0;
    $3_1 = $24_1 + 8 | 0;
    $2_1 = HEAP32[$3_1 >> 2];
    $0_1 = $32_1 + 8 | 0;
    $10_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
    $3_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $3_1 = $7_1 + $10_1 | 0;
    $2_1 = $3_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $1_1 >>> 20 | 0;
    $0_1 = $1_1 + $3_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $8_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $0_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$4_1 + 264 >> 2];
    $10_1 = $8_1 + $5_1 | 0;
    $1_1 = $2_1;
    $0_1 = $2_1 << 12 | $0_1 >>> 20;
    $3_1 = $0_1 + HEAP32[$4_1 + 268 >> 2] | 0;
    $3_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $69($9_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
    $18_1 = $4_1 + 56 | 0;
    $7_1 = $18_1;
    $5_1 = ($0_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $10_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
    $0_1 = $13_1 + 8 | 0;
    $3_1 = HEAP32[$0_1 >> 2];
    $2_1 = HEAP32[$0_1 + 4 >> 2];
    $1_1 = $1_1 >>> 20 | 0;
    $0_1 = $1_1 + $3_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $5_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($7_1, $0_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
    $0_1 = $4_1;
    $3_1 = $29_1 + $52_1 | 0;
    $1_1 = $38_1 + $51_1 | 0;
    $3_1 = $1_1 >>> 0 < $38_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    HEAP32[$0_1 + 376 >> 2] = $1_1;
    HEAP32[$0_1 + 380 >> 2] = $3_1;
    $2_1 = $35_1 + $54_1 | 0;
    $1_1 = $39_1 + $53_1 | 0;
    $2_1 = $1_1 >>> 0 < $39_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$0_1 + 368 >> 2] = $1_1;
    HEAP32[$0_1 + 372 >> 2] = $2_1;
    $2_1 = $36_1 + $56_1 | 0;
    $1_1 = $40_1 + $55_1 | 0;
    $2_1 = $1_1 >>> 0 < $40_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$0_1 + 360 >> 2] = $1_1;
    HEAP32[$0_1 + 364 >> 2] = $2_1;
    $2_1 = $20_1 + $58_1 | 0;
    $1_1 = $41_1 + $57_1 | 0;
    $2_1 = $1_1 >>> 0 < $41_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$0_1 + 352 >> 2] = $1_1;
    HEAP32[$0_1 + 356 >> 2] = $2_1;
    $8_1 = $0_1;
    $2_1 = $22_1 + $60_1 | 0;
    $0_1 = $42_1 + $59_1 | 0;
    $2_1 = $0_1 >>> 0 < $42_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$4_1 + 344 >> 2] = $0_1;
    HEAP32[$4_1 + 348 >> 2] = $2_1;
    $34($6_1 + 40 | 0, $34_1, $33_1);
    $7_1 = $6_1;
    $6_1 = HEAP32[$6_1 + 40 >> 2];
    $2_1 = HEAP32[$7_1 + 44 >> 2];
    $5_1 = HEAP32[$4_1 + 40 >> 2];
    $1_1 = HEAP32[$4_1 + 120 >> 2];
    $0_1 = $5_1 + $1_1 | 0;
    $9_1 = HEAP32[$4_1 + 44 >> 2];
    $3_1 = $9_1 + HEAP32[$4_1 + 124 >> 2] | 0;
    $1_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $2_1 = $2_1 + ($1_1 & 1048575) | 0;
    $3_1 = $0_1 + $6_1 | 0;
    $2_1 = $3_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$7_1 + 40 >> 2] = -5862 - $3_1;
    HEAP32[$7_1 + 44 >> 2] = 6291449 - (($3_1 >>> 0 > 4294961434) + $2_1 | 0);
    $2_1 = $7_1 + 48 | 0;
    $13_1 = $2_1;
    $10_1 = HEAP32[$2_1 >> 2];
    $4_1 = HEAP32[$2_1 + 4 >> 2];
    $5_1 = ($1_1 | 0) == ($9_1 | 0) & $0_1 >>> 0 < $5_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
    $2_1 = $46_1 + 8 | 0;
    $3_1 = HEAP32[$2_1 >> 2];
    $0_1 = $50_1 + 8 | 0;
    $6_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $5_1 + $6_1 | 0;
    $3_1 = $0_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $6_1 = $0_1 << 12 | $1_1 >>> 20;
    $5_1 = $3_1 << 12 | $0_1 >>> 20;
    $9_1 = HEAP32[$8_1 + 88 >> 2];
    $0_1 = HEAP32[$8_1 + 24 >> 2];
    $1_1 = $9_1 + $0_1 | 0;
    $20_1 = HEAP32[$8_1 + 92 >> 2];
    $2_1 = $20_1 + HEAP32[$8_1 + 28 >> 2] | 0;
    $2_1 = $0_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $6_1;
    $6_1 = $1_1;
    $1_1 = $0_1 + $1_1 | 0;
    $0_1 = $2_1;
    $2_1 = $2_1 + $5_1 | 0;
    $5_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $4_1 + ($5_1 & 1048575) | 0;
    $10_1 = $1_1 + $10_1 | 0;
    $2_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$13_1 >> 2] = -6 - $10_1;
    HEAP32[$13_1 + 4 >> 2] = 6291455 - (($10_1 >>> 0 > 4294967290) + $2_1 | 0);
    $2_1 = $7_1 + 56 | 0;
    $22_1 = $2_1;
    $13_1 = HEAP32[$2_1 >> 2];
    $10_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = ($0_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
    $6_1 = ($0_1 | 0) == ($20_1 | 0) & $6_1 >>> 0 < $9_1 >>> 0 | $0_1 >>> 0 < $20_1 >>> 0;
    $2_1 = $31_1 + 8 | 0;
    $1_1 = HEAP32[$2_1 >> 2];
    $0_1 = $26_1 + 8 | 0;
    $9_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $6_1 + $9_1 | 0;
    $2_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $3_1 >>> 20 | 0;
    $0_1 = $1_1 + $3_1 | 0;
    $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $4_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $0_1 << 12 | $5_1 >>> 20;
    $1_1 = $2_1;
    $3_1 = $2_1 << 12 | $0_1 >>> 20;
    $29_1 = HEAP32[$8_1 + 8 >> 2];
    $0_1 = HEAP32[$8_1 + 184 >> 2];
    $4_1 = $29_1 + $0_1 | 0;
    $25_1 = HEAP32[$8_1 + 12 >> 2];
    $2_1 = $25_1 + HEAP32[$8_1 + 188 >> 2] | 0;
    $2_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = HEAP32[$8_1 + 72 >> 2];
    $6_1 = $0_1 + $4_1 | 0;
    $9_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$8_1 + 76 >> 2] | 0;
    $0_1 = $0_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $0_1 + $3_1 | 0;
    $5_1 = $5_1 + $6_1 | 0;
    $3_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $10_1 + ($3_1 & 1048575) | 0;
    $13_1 = $5_1 + $13_1 | 0;
    $2_1 = $13_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$22_1 >> 2] = -6 - $13_1;
    HEAP32[$22_1 + 4 >> 2] = 6291455 - (($13_1 >>> 0 > 4294967290) + $2_1 | 0);
    $2_1 = $7_1 - -64 | 0;
    $19_1 = $2_1;
    $35_1 = HEAP32[$2_1 >> 2];
    $36_1 = HEAP32[$2_1 + 4 >> 2];
    $20_1 = ($0_1 | 0) == ($3_1 | 0) & $5_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
    $22_1 = ($0_1 | 0) == ($9_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $0_1 >>> 0 < $9_1 >>> 0;
    $0_1 = $21_1 + 8 | 0;
    $13_1 = HEAP32[$0_1 >> 2];
    $10_1 = HEAP32[$0_1 + 4 >> 2];
    $6_1 = ($9_1 | 0) == ($25_1 | 0) & $4_1 >>> 0 < $29_1 >>> 0 | $9_1 >>> 0 < $25_1 >>> 0;
    $2_1 = $27_1 + 8 | 0;
    $5_1 = HEAP32[$2_1 >> 2];
    $0_1 = $14_1 + 8 | 0;
    $4_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
    $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
    $2_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $4_1 + $6_1 | 0;
    $2_1 = ($0_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
    $5_1 = $0_1;
    $0_1 = $0_1 + $13_1 | 0;
    $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $0_1 + $22_1 | 0;
    $2_1 = $5_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $1_1 >>> 20 | 0;
    $0_1 = $1_1 + $5_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $0_1;
    $0_1 = $0_1 + $20_1 | 0;
    $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $0_1 << 12 | $3_1 >>> 20;
    $1_1 = $2_1;
    $4_1 = $2_1 << 12 | $0_1 >>> 20;
    $9_1 = HEAP32[$8_1 + 56 >> 2];
    $3_1 = $16_1 & -2;
    $0_1 = $9_1 + $3_1 | 0;
    $10_1 = HEAP32[$8_1 + 60 >> 2];
    $2_1 = $10_1 + ($15_1 & 1048575) | 0;
    $6_1 = $0_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $6_1 + $4_1 | 0;
    $3_1 = $5_1;
    $5_1 = $0_1;
    $3_1 = $3_1 + $0_1 | 0;
    $0_1 = $3_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $36_1 + ($0_1 & 1048575) | 0;
    $4_1 = $3_1 + $35_1 | 0;
    $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$19_1 >> 2] = -6 - $4_1;
    HEAP32[$19_1 + 4 >> 2] = 6291455 - (($4_1 >>> 0 > 4294967290) + $2_1 | 0);
    $2_1 = $7_1 + 72 | 0;
    $16_1 = $2_1;
    $15_1 = HEAP32[$2_1 >> 2];
    $7_1 = HEAP32[$2_1 + 4 >> 2];
    $12_1 = $12_1 & 65535;
    $4_1 = ($0_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
    $3_1 = ($6_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $6_1 >>> 0 < $10_1 >>> 0;
    $2_1 = $18_1 + 8 | 0;
    $5_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $1_1 = $1_1 >>> 20 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + $5_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $4_1 | 0;
    $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $0_1 = $1_1 << 12 | $0_1 >>> 20;
    $5_1 = $0_1 + $11_1 | 0;
    $3_1 = $12_1 + ($2_1 << 12 | $1_1 >>> 20) | 0;
    $2_1 = ($0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
    $0_1 = $5_1 + $15_1 | 0;
    $2_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$16_1 >> 2] = -6 - $0_1;
    HEAP32[$16_1 + 4 >> 2] = 393215 - (($0_1 >>> 0 > 4294967290) + $2_1 | 0);
    global$0 = $8_1 + 464 | 0;
  }
  function $56($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0;
    $7_1 = global$0 - 80 | 0;
    global$0 = $7_1;
    label$1: {
      if (HEAP32[$1_1 + 120 >> 2]) {
        HEAP32[$0_1 + 80 >> 2] = 1;
        $68($0_1, 80);
        break label$1;
      }
      $11_1 = $1_1 + 88 | 0;
      $4_1 = HEAP32[$11_1 >> 2];
      $6_1 = HEAP32[$11_1 + 4 >> 2];
      $5_1 = HEAP32[$1_1 + 84 >> 2];
      $3_1 = $1_1 + 112 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $8_1 = HEAP32[$3_1 + 4 >> 2];
      $15_1 = $8_1;
      $3_1 = HEAP32[$1_1 + 80 >> 2];
      $2_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
      $10_1 = $3_1 + $2_1 | 0;
      $5_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      $3_1 = $6_1;
      $9_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $5_1 + 1 | 0 : $5_1;
      $2_1 = $9_1 >>> 20 | 0;
      $6_1 = $2_1;
      $2_1 = $2_1 + $4_1 | 0;
      $6_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $16_1 = $6_1 & 1048575;
      $5_1 = $1_1 + 104 | 0;
      $13_1 = HEAP32[$5_1 >> 2];
      $17_1 = HEAP32[$5_1 + 4 >> 2];
      $5_1 = $1_1 + 96 | 0;
      $8_1 = HEAP32[$5_1 >> 2];
      $4_1 = HEAP32[$5_1 + 4 >> 2];
      $5_1 = $6_1 >>> 20 | 0;
      $8_1 = $5_1 + $8_1 | 0;
      $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $17_1;
      $12_1 = $4_1;
      $4_1 = $4_1 >>> 20 | 0;
      $5_1 = $4_1 + $13_1 | 0;
      $3_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $3_1 & 1048575;
      $17_1 = $1_1 + 80 | 0;
      $4_1 = $8_1;
      $12_1 = $12_1 & 1048575;
      $18_1 = ($2_1 & $4_1 & $5_1) == -1 & ($6_1 & $12_1 & $3_1) == 1048575;
      $6_1 = $3_1 >>> 20 | 0;
      $3_1 = $15_1 & 65535;
      $8_1 = $6_1 + $14_1 | 0;
      $6_1 = $8_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1 & 1048575;
      $14_1 = $3_1;
      if ($18_1 & (($8_1 | 0) == -1 & ($6_1 | 0) == 65535) & (($3_1 | 0) == 1048574 & $10_1 >>> 0 > 4294966318 | $3_1 >>> 0 > 1048574) | $6_1 >>> 16) {
        $3_1 = $14_1 + 1 | 0;
        $10_1 = $10_1 + 977 | 0;
        $3_1 = $10_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
        $14_1 = $3_1 & 1048575;
        $9_1 = $3_1;
        $3_1 = $16_1;
        $9_1 = $9_1 >>> 20 | 0;
        $2_1 = $2_1 + $9_1 | 0;
        $3_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $16_1 = $3_1 & 1048575;
        $9_1 = $4_1;
        $15_1 = $3_1 >>> 20 | 0;
        $4_1 = $12_1;
        $3_1 = $9_1 + $15_1 | 0;
        $4_1 = $3_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $12_1 = $4_1 & 1048575;
        $9_1 = $4_1;
        $4_1 = $3_1;
        $3_1 = $13_1;
        $9_1 = $9_1 >>> 20 | 0;
        $5_1 = $5_1 + $9_1 | 0;
        $3_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $13_1 = $3_1 & 1048575;
        $9_1 = $3_1;
        $3_1 = $6_1;
        $6_1 = $8_1;
        $8_1 = ($9_1 >>> 20 | 0) + $8_1 | 0;
        $6_1 = ($6_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) & 65535;
      }
      HEAP32[$7_1 + 72 >> 2] = $6_1 >>> 8;
      HEAP32[$7_1 + 76 >> 2] = 0;
      $3_1 = $6_1 << 22 | $8_1 >>> 10;
      HEAP32[$7_1 + 64 >> 2] = $8_1 << 22 & -4194304 | (($13_1 & 1073741823) << 2 | $5_1 >>> 30);
      HEAP32[$7_1 + 68 >> 2] = $3_1 & 1073741823 | $13_1 >>> 30;
      HEAP32[$7_1 + 56 >> 2] = ($12_1 & 1048575) << 12 | $4_1 >>> 20;
      HEAP32[$7_1 + 60 >> 2] = $5_1 & 1073741823 | $12_1 >>> 20;
      $4_1 = $4_1 << 10 & 1073740800;
      HEAP32[$7_1 + 48 >> 2] = ($16_1 & 1023) << 22 | $2_1 >>> 10;
      HEAP32[$7_1 + 52 >> 2] = $16_1 >>> 10 | $4_1;
      HEAP32[$7_1 + 40 >> 2] = $10_1;
      HEAP32[$7_1 + 44 >> 2] = $14_1 | $2_1 << 20 & 1072693248;
      $10_1 = $7_1 + 40 | 0;
      $40($10_1, 690464);
      $5_1 = HEAP32[$7_1 + 44 >> 2];
      $4_1 = $5_1;
      HEAP32[$1_1 + 80 >> 2] = HEAP32[$7_1 + 40 >> 2];
      HEAP32[$1_1 + 84 >> 2] = $4_1 & 1048575;
      $5_1 = HEAP32[$7_1 + 72 >> 2] << 8;
      $8_1 = HEAP32[$7_1 + 68 >> 2];
      $3_1 = $8_1 >>> 22 | 0;
      $6_1 = HEAP32[$7_1 + 64 >> 2];
      HEAP32[$1_1 + 112 >> 2] = ($8_1 & 4194303) << 10 | $6_1 >>> 22;
      HEAP32[$1_1 + 116 >> 2] = $3_1 | $5_1;
      $2_1 = $6_1;
      $3_1 = $8_1 << 30 | $2_1 >>> 2;
      $6_1 = $2_1 << 30 & -1073741824;
      $2_1 = HEAP32[$7_1 + 56 >> 2];
      $5_1 = HEAP32[$7_1 + 60 >> 2];
      HEAP32[$1_1 + 104 >> 2] = $5_1 | $6_1;
      HEAP32[$1_1 + 108 >> 2] = $3_1 & 1048575;
      $5_1 = $5_1 << 20 | $2_1 >>> 12;
      $6_1 = $2_1 << 20 & -1048576;
      $8_1 = $5_1 & 1048575;
      $2_1 = HEAP32[$7_1 + 48 >> 2];
      $5_1 = HEAP32[$7_1 + 52 >> 2];
      HEAP32[$1_1 + 96 >> 2] = $5_1 >>> 10 | $6_1;
      HEAP32[$1_1 + 100 >> 2] = $8_1;
      $3_1 = $5_1 << 10 | $2_1 >>> 22;
      HEAP32[$1_1 + 88 >> 2] = $2_1 << 10 & -1024 | $4_1 >>> 20;
      HEAP32[$1_1 + 92 >> 2] = $3_1 & 1048575;
      $54($10_1, $17_1);
      $34($7_1, $17_1, $10_1);
      $34($1_1, $1_1, $10_1);
      $2_1 = $1_1 + 40 | 0;
      $34($2_1, $2_1, $7_1);
      HEAP32[$11_1 >> 2] = 0;
      HEAP32[$11_1 + 4 >> 2] = 0;
      $2_1 = $11_1 + 8 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $11_1 + 16 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $11_1 + 24 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      HEAP32[$0_1 + 80 >> 2] = 0;
      HEAP32[$1_1 + 80 >> 2] = 1;
      HEAP32[$1_1 + 84 >> 2] = 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $2_1 = $1_1 + 8 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 8 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 16 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 24 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 32 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 32 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 72 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 72 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 - -64 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 - -64 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 56 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 56 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = $1_1 + 48 | 0;
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      $4_1 = $0_1 + 48 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $2_1 = HEAP32[$1_1 + 44 >> 2];
      HEAP32[$0_1 + 40 >> 2] = HEAP32[$1_1 + 40 >> 2];
      HEAP32[$0_1 + 44 >> 2] = $2_1;
    }
    global$0 = $7_1 + 80 | 0;
  }
  function $57($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0;
    $4_1 = global$0 - 128 | 0;
    global$0 = $4_1;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 56 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 48 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 40 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 32 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 24 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 16 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $3_1 = $1_1 + 8 | 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      if (!$2_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689936, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      $0_1 = 0;
      if (!$32($4_1, $2_1)) {
        break label$1;
      }
      $0_1 = 0;
      if (!$33($4_1 + 40 | 0, $4_1, 0)) {
        break label$1;
      }
      $35($1_1, $4_1 + 40 | 0);
      $0_1 = 1;
    }
    global$0 = $4_1 + 128 | 0;
    return $0_1;
  }
  function $58($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
    $3_1 = global$0 - 96 | 0;
    global$0 = $3_1;
    HEAP8[690885] = 0;
    HEAP8[690886] = 0;
    HEAP8[690887] = 0;
    HEAP8[690888] = 0;
    HEAP8[690889] = 0;
    HEAP8[690890] = 0;
    HEAP8[690891] = 0;
    HEAP8[690892] = 0;
    HEAP8[690909] = 0;
    HEAP8[690910] = 0;
    HEAP8[690911] = 0;
    HEAP8[690912] = 0;
    HEAP8[690913] = 0;
    HEAP8[690914] = 0;
    HEAP8[690915] = 0;
    HEAP8[690916] = 0;
    HEAP8[690901] = 0;
    HEAP8[690902] = 0;
    HEAP8[690903] = 0;
    HEAP8[690904] = 0;
    HEAP8[690905] = 0;
    HEAP8[690906] = 0;
    HEAP8[690907] = 0;
    HEAP8[690908] = 0;
    HEAP8[690893] = 0;
    HEAP8[690894] = 0;
    HEAP8[690895] = 0;
    HEAP8[690896] = 0;
    HEAP8[690897] = 0;
    HEAP8[690898] = 0;
    HEAP8[690899] = 0;
    HEAP8[690900] = 0;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      $5_1 = HEAPU8[$1_1 + 60 | 0] | HEAPU8[$1_1 + 61 | 0] << 8 | (HEAPU8[$1_1 + 62 | 0] << 16 | HEAPU8[$1_1 + 63 | 0] << 24);
      $8_1 = $5_1 >>> 16 | 0;
      $4_1 = $3_1 + 80 | 0;
      $2_1 = HEAPU8[$1_1 + 56 | 0] | HEAPU8[$1_1 + 57 | 0] << 8 | (HEAPU8[$1_1 + 58 | 0] << 16 | HEAPU8[$1_1 + 59 | 0] << 24);
      HEAP32[$4_1 >> 2] = ($5_1 & 65535) << 16 | $2_1 >>> 16;
      HEAP32[$4_1 + 4 >> 2] = $8_1;
      $7_1 = $2_1 << 4 & 1048560;
      $4_1 = HEAPU8[$1_1 + 52 | 0] | HEAPU8[$1_1 + 53 | 0] << 8 | (HEAPU8[$1_1 + 54 | 0] << 16 | HEAPU8[$1_1 + 55 | 0] << 24);
      $2_1 = $4_1 >>> 28 | 0;
      $6_1 = $3_1 + 72 | 0;
      $5_1 = HEAPU8[$1_1 + 48 | 0] | HEAPU8[$1_1 + 49 | 0] << 8 | (HEAPU8[$1_1 + 50 | 0] << 16 | HEAPU8[$1_1 + 51 | 0] << 24);
      HEAP32[$6_1 >> 2] = ($4_1 & 268435455) << 4 | $5_1 >>> 28;
      HEAP32[$6_1 + 4 >> 2] = $2_1 | $7_1;
      $2_1 = $5_1;
      $8_1 = $4_1 << 24 | $2_1 >>> 8;
      $5_1 = HEAPU8[$1_1 + 40 | 0] | HEAPU8[$1_1 + 41 | 0] << 8 | (HEAPU8[$1_1 + 42 | 0] << 16 | HEAPU8[$1_1 + 43 | 0] << 24);
      $7_1 = $3_1 - -64 | 0;
      $4_1 = HEAPU8[$1_1 + 44 | 0] | HEAPU8[$1_1 + 45 | 0] << 8 | (HEAPU8[$1_1 + 46 | 0] << 16 | HEAPU8[$1_1 + 47 | 0] << 24);
      HEAP32[$7_1 >> 2] = $2_1 << 24 & -16777216 | $4_1 >>> 8;
      HEAP32[$7_1 + 4 >> 2] = $8_1 & 1048575;
      $2_1 = $5_1;
      $4_1 = ($4_1 << 12 | $2_1 >>> 20) & 1048575;
      $7_1 = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
      $6_1 = $3_1 + 56 | 0;
      $9_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
      HEAP32[$6_1 >> 2] = $2_1 << 12 & -4096 | $9_1 >>> 20;
      HEAP32[$6_1 + 4 >> 2] = $4_1;
      HEAP32[$3_1 + 88 >> 2] = 0;
      HEAP32[$3_1 + 48 >> 2] = $7_1;
      HEAP32[$3_1 + 52 >> 2] = $9_1 & 1048575;
      $5_1 = HEAPU8[$1_1 + 12 | 0] | HEAPU8[$1_1 + 13 | 0] << 8 | (HEAPU8[$1_1 + 14 | 0] << 16 | HEAPU8[$1_1 + 15 | 0] << 24);
      $2_1 = HEAPU8[$1_1 + 8 | 0] | HEAPU8[$1_1 + 9 | 0] << 8 | (HEAPU8[$1_1 + 10 | 0] << 16 | HEAPU8[$1_1 + 11 | 0] << 24);
      $8_1 = $5_1 << 12 | $2_1 >>> 20;
      $4_1 = $2_1 << 12 & -4096;
      $2_1 = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      $9_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $10_1 = $9_1 >>> 20 | $4_1;
      HEAP32[$3_1 + 16 >> 2] = $10_1;
      $11_1 = $8_1 & 1048575;
      HEAP32[$3_1 + 20 >> 2] = $11_1;
      $4_1 = $2_1;
      HEAP32[$3_1 + 8 >> 2] = $2_1;
      $12_1 = $9_1 & 1048575;
      HEAP32[$3_1 + 12 >> 2] = $12_1;
      $6_1 = HEAPU8[$1_1 + 28 | 0] | HEAPU8[$1_1 + 29 | 0] << 8 | (HEAPU8[$1_1 + 30 | 0] << 16 | HEAPU8[$1_1 + 31 | 0] << 24);
      $2_1 = $6_1 >>> 16 | 0;
      $7_1 = HEAPU8[$1_1 + 24 | 0] | HEAPU8[$1_1 + 25 | 0] << 8 | (HEAPU8[$1_1 + 26 | 0] << 16 | HEAPU8[$1_1 + 27 | 0] << 24);
      $9_1 = ($6_1 & 65535) << 16 | $7_1 >>> 16;
      HEAP32[$3_1 + 40 >> 2] = $9_1;
      $6_1 = $2_1;
      HEAP32[$3_1 + 44 >> 2] = $2_1;
      $2_1 = HEAPU8[$1_1 + 16 | 0] | HEAPU8[$1_1 + 17 | 0] << 8 | (HEAPU8[$1_1 + 18 | 0] << 16 | HEAPU8[$1_1 + 19 | 0] << 24);
      $14_1 = $2_1;
      $13_1 = HEAPU8[$1_1 + 20 | 0] | HEAPU8[$1_1 + 21 | 0] << 8 | (HEAPU8[$1_1 + 22 | 0] << 16 | HEAPU8[$1_1 + 23 | 0] << 24);
      $1_1 = $2_1;
      $2_1 = $13_1 << 24 | $1_1 >>> 8;
      $5_1 = $1_1 << 24 & -16777216 | $5_1 >>> 8;
      HEAP32[$3_1 + 24 >> 2] = $5_1;
      $8_1 = $2_1 & 1048575;
      HEAP32[$3_1 + 28 >> 2] = $8_1;
      $1_1 = $13_1;
      $2_1 = $1_1 >>> 28 | 0;
      $1_1 = ($1_1 & 268435455) << 4 | $14_1 >>> 28;
      HEAP32[$3_1 + 32 >> 2] = $1_1;
      $2_1 = $2_1 | $7_1 << 4 & 1048560;
      HEAP32[$3_1 + 36 >> 2] = $2_1;
      if (!($4_1 | $10_1 | $9_1 | $5_1 | $1_1 | ($11_1 | $12_1 | $6_1 | $8_1 | $2_1))) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      $37(690885, $3_1 + 8 | 0);
      $15_1 = 1;
    }
    global$0 = $3_1 + 96 | 0;
    return $15_1;
  }
  function $59($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
    $4_1 = global$0 - 96 | 0;
    global$0 = $4_1;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689586, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      if (!$3_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      $11_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
      $5_1 = $11_1 >>> 16 | 0;
      $6_1 = $4_1 + 80 | 0;
      $7_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
      $11_1 = ($11_1 & 65535) << 16 | $7_1 >>> 16;
      HEAP32[$6_1 >> 2] = $11_1;
      $24_1 = $5_1;
      HEAP32[$6_1 + 4 >> 2] = $5_1;
      $10_1 = $7_1 << 4 & 1048560;
      $8_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
      $5_1 = $8_1 >>> 28 | 0;
      $6_1 = $4_1 + 72 | 0;
      $7_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
      $13_1 = ($8_1 & 268435455) << 4 | $7_1 >>> 28;
      HEAP32[$6_1 >> 2] = $13_1;
      $16_1 = $5_1 | $10_1;
      HEAP32[$6_1 + 4 >> 2] = $16_1;
      $5_1 = $8_1 << 24 | $7_1 >>> 8;
      $10_1 = $7_1 << 24 & -16777216;
      $7_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
      $6_1 = $4_1 - -64 | 0;
      $8_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
      $14_1 = $8_1 >>> 8 | $10_1;
      HEAP32[$6_1 >> 2] = $14_1;
      $17_1 = $5_1 & 1048575;
      HEAP32[$6_1 + 4 >> 2] = $17_1;
      $5_1 = $7_1;
      $10_1 = $8_1 << 12 | $5_1 >>> 20;
      $7_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
      $6_1 = $4_1 + 56 | 0;
      $9_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
      $15_1 = $5_1 << 12 & -4096 | $9_1 >>> 20;
      HEAP32[$6_1 >> 2] = $15_1;
      $18_1 = $10_1 & 1048575;
      HEAP32[$6_1 + 4 >> 2] = $18_1;
      HEAP32[$4_1 + 88 >> 2] = 0;
      HEAP32[$4_1 + 48 >> 2] = $7_1;
      $19_1 = $9_1 & 1048575;
      HEAP32[$4_1 + 52 >> 2] = $19_1;
      $5_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
      $6_1 = $5_1;
      $8_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
      $9_1 = ($5_1 << 12 | $8_1 >>> 20) & 1048575;
      $5_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      $12_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $20_1 = $8_1 << 12 & -4096 | $12_1 >>> 20;
      HEAP32[$4_1 + 16 >> 2] = $20_1;
      $25_1 = $9_1;
      HEAP32[$4_1 + 20 >> 2] = $9_1;
      $8_1 = $5_1;
      HEAP32[$4_1 + 8 >> 2] = $5_1;
      $21_1 = $12_1 & 1048575;
      HEAP32[$4_1 + 12 >> 2] = $21_1;
      $9_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
      $5_1 = $9_1 >>> 16 | 0;
      $10_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
      $12_1 = ($9_1 & 65535) << 16 | $10_1 >>> 16;
      HEAP32[$4_1 + 40 >> 2] = $12_1;
      $9_1 = $5_1;
      HEAP32[$4_1 + 44 >> 2] = $5_1;
      $5_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
      $26_1 = $5_1;
      $22_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
      $3_1 = $5_1;
      $23_1 = ($22_1 << 24 | $3_1 >>> 8) & 1048575;
      $6_1 = $3_1 << 24 & -16777216 | $6_1 >>> 8;
      HEAP32[$4_1 + 24 >> 2] = $6_1;
      HEAP32[$4_1 + 28 >> 2] = $23_1;
      $3_1 = $22_1;
      $5_1 = $3_1 >>> 28 | 0;
      $3_1 = ($3_1 & 268435455) << 4 | $26_1 >>> 28;
      HEAP32[$4_1 + 32 >> 2] = $3_1;
      $5_1 = $5_1 | $10_1 << 4 & 1048560;
      HEAP32[$4_1 + 36 >> 2] = $5_1;
      if (!($8_1 | $20_1 | $12_1 | $6_1 | $3_1 | ($25_1 | $21_1 | $9_1 | $23_1 | $5_1))) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
        $0_1 = 0;
        break label$1;
      }
      if ($7_1 & 1) {
        HEAP32[$4_1 + 80 >> 2] = -4 - $11_1;
        HEAP32[$4_1 + 84 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $24_1 | 0);
        HEAP32[$4_1 + 72 >> 2] = -4 - $13_1;
        HEAP32[$4_1 + 76 >> 2] = 4194303 - (($13_1 >>> 0 > 4294967292) + $16_1 | 0);
        HEAP32[$4_1 + 64 >> 2] = -4 - $14_1;
        HEAP32[$4_1 + 68 >> 2] = 4194303 - (($14_1 >>> 0 > 4294967292) + $17_1 | 0);
        HEAP32[$4_1 + 56 >> 2] = -4 - $15_1;
        HEAP32[$4_1 + 60 >> 2] = 4194303 - (($15_1 >>> 0 > 4294967292) + $18_1 | 0);
        HEAP32[$4_1 + 48 >> 2] = -3908 - $7_1;
        HEAP32[$4_1 + 52 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $19_1 | 0);
        $27_1 = 1;
      }
      if ($2_1) {
        HEAP32[$2_1 >> 2] = $27_1;
      }
      $35($1_1, $4_1 + 8 | 0);
      $0_1 = 1;
    }
    global$0 = $4_1 + 96 | 0;
    return $0_1;
  }
  function $60($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
    $2_1 = global$0 - 256 | 0;
    global$0 = $2_1;
    label$1: {
      if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689700, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      $6_1 = $68($1_1, 96);
      if (!HEAP32[$0_1 >> 2]) {
        FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690045, HEAP32[$0_1 + 172 >> 2]);
        break label$1;
      }
      $3_1 = $2_1 + 96 | 0;
      $7_1 = $2_1 + 128 | 0;
      $38($3_1, 690788, $7_1);
      $9_1 = HEAP32[$2_1 + 120 >> 2];
      $10_1 = HEAP32[$2_1 + 112 >> 2];
      $4_1 = HEAP32[$2_1 + 104 >> 2];
      $11_1 = HEAP32[$2_1 + 96 >> 2];
      $12_1 = HEAP32[$2_1 + 124 >> 2];
      $13_1 = HEAP32[$2_1 + 116 >> 2];
      $14_1 = HEAP32[$2_1 + 108 >> 2];
      $15_1 = HEAP32[$2_1 + 100 >> 2];
      $8_1 = HEAP32[$2_1 + 128 >> 2] | !($9_1 | ($10_1 | ($4_1 | $11_1)) | ($12_1 | ($13_1 | ($14_1 | $15_1))));
      $1_1 = $8_1 ? 0 : -1;
      HEAP32[$2_1 + 120 >> 2] = $1_1 & $9_1;
      HEAP32[$2_1 + 124 >> 2] = $1_1 & $12_1;
      HEAP32[$2_1 + 112 >> 2] = $1_1 & $10_1;
      HEAP32[$2_1 + 116 >> 2] = $1_1 & $13_1;
      HEAP32[$2_1 + 104 >> 2] = $1_1 & $4_1;
      HEAP32[$2_1 + 108 >> 2] = $1_1 & $14_1;
      $4_1 = ($8_1 | 0) != 0;
      HEAP32[$2_1 + 96 >> 2] = $4_1 | $1_1 & $11_1;
      HEAP32[$2_1 + 100 >> 2] = $1_1 & $15_1;
      $48($0_1, $7_1, $3_1);
      $0_1 = $2_1 + 8 | 0;
      $49($0_1, $7_1);
      $39($6_1, $3_1);
      $35($6_1 + 32 | 0, $0_1);
      HEAP32[$2_1 + 128 >> 2] = $4_1;
      $0_1 = HEAP32[$2_1 + 128 >> 2] - 1 | 0;
      while (1) {
        $1_1 = $5_1 + $6_1 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] & $0_1;
        $3_1 = $1_1 + 1 | 0;
        HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
        $3_1 = $1_1 + 2 | 0;
        HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
        $3_1 = $1_1 + 3 | 0;
        HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
        $3_1 = $1_1 + 4 | 0;
        HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
        $1_1 = $1_1 + 5 | 0;
        HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] & $0_1;
        $5_1 = $5_1 + 6 | 0;
        if (($5_1 | 0) != 96) {
          continue;
        }
        break;
      }
      ;
      $5_1 = !$8_1;
    }
    global$0 = $2_1 + 256 | 0;
    return $5_1;
  }
  function $61($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1, $7_1) {
    $0_1 = $0_1 | 0;
    $1_1 = $1_1 | 0;
    $2_1 = $2_1 | 0;
    $3_1 = $3_1 | 0;
    $4_1 = $4_1 | 0;
    $5_1 = $5_1 | 0;
    $6_1 = $6_1 | 0;
    $7_1 = $7_1 | 0;
    var $8_1 = 0, $9_1 = 0;
    $8_1 = global$0 - 176 | 0;
    global$0 = $8_1;
    if ($5_1) {
      label$2: {
        if (!$7_1) {
          HEAP8[$8_1 | 0] = HEAPU8[$3_1 | 0] ^ 84;
          HEAP8[$8_1 + 1 | 0] = HEAPU8[$3_1 + 1 | 0] ^ 241;
          HEAP8[$8_1 + 2 | 0] = HEAPU8[$3_1 + 2 | 0] ^ 105;
          HEAP8[$8_1 + 3 | 0] = HEAPU8[$3_1 + 3 | 0] ^ 207;
          HEAP8[$8_1 + 4 | 0] = HEAPU8[$3_1 + 4 | 0] ^ 201;
          HEAP8[$8_1 + 5 | 0] = HEAPU8[$3_1 + 5 | 0] ^ 226;
          HEAP8[$8_1 + 6 | 0] = HEAPU8[$3_1 + 6 | 0] ^ 229;
          HEAP8[$8_1 + 7 | 0] = HEAPU8[$3_1 + 7 | 0] ^ 114;
          HEAP8[$8_1 + 8 | 0] = HEAPU8[$3_1 + 8 | 0] ^ 116;
          HEAP8[$8_1 + 9 | 0] = HEAPU8[$3_1 + 9 | 0] ^ 128;
          HEAP8[$8_1 + 10 | 0] = HEAPU8[$3_1 + 10 | 0] ^ 68;
          HEAP8[$8_1 + 11 | 0] = HEAPU8[$3_1 + 11 | 0] ^ 31;
          HEAP8[$8_1 + 12 | 0] = HEAPU8[$3_1 + 12 | 0] ^ 144;
          HEAP8[$8_1 + 13 | 0] = HEAPU8[$3_1 + 13 | 0] ^ 186;
          HEAP8[$8_1 + 14 | 0] = HEAPU8[$3_1 + 14 | 0] ^ 37;
          HEAP8[$8_1 + 15 | 0] = HEAPU8[$3_1 + 15 | 0] ^ 196;
          HEAP8[$8_1 + 16 | 0] = HEAPU8[$3_1 + 16 | 0] ^ 136;
          HEAP8[$8_1 + 17 | 0] = HEAPU8[$3_1 + 17 | 0] ^ 244;
          HEAP8[$8_1 + 18 | 0] = HEAPU8[$3_1 + 18 | 0] ^ 97;
          HEAP8[$8_1 + 19 | 0] = HEAPU8[$3_1 + 19 | 0] ^ 199;
          HEAP8[$8_1 + 20 | 0] = HEAPU8[$3_1 + 20 | 0] ^ 11;
          HEAP8[$8_1 + 21 | 0] = HEAPU8[$3_1 + 21 | 0] ^ 94;
          HEAP8[$8_1 + 22 | 0] = HEAPU8[$3_1 + 22 | 0] ^ 165;
          HEAP8[$8_1 + 23 | 0] = HEAPU8[$3_1 + 23 | 0] ^ 220;
          HEAP8[$8_1 + 24 | 0] = HEAPU8[$3_1 + 24 | 0] ^ 170;
          HEAP8[$8_1 + 25 | 0] = HEAPU8[$3_1 + 25 | 0] ^ 247;
          HEAP8[$8_1 + 26 | 0] = HEAPU8[$3_1 + 26 | 0] ^ 175;
          HEAP8[$8_1 + 27 | 0] = HEAPU8[$3_1 + 27 | 0] ^ 105;
          HEAP8[$8_1 + 28 | 0] = HEAPU8[$3_1 + 28 | 0] ^ 39;
          HEAP8[$8_1 + 29 | 0] = HEAPU8[$3_1 + 29 | 0] ^ 10;
          HEAP8[$8_1 + 30 | 0] = HEAPU8[$3_1 + 30 | 0] ^ 165;
          HEAP8[$8_1 + 31 | 0] = HEAPU8[$3_1 + 31 | 0] ^ 20;
          break label$2;
        }
        HEAP32[$8_1 + 136 >> 2] = 64;
        HEAP32[$8_1 + 140 >> 2] = 0;
        HEAP32[$8_1 + 64 >> 2] = 1252796217;
        HEAP32[$8_1 + 68 >> 2] = 614368522;
        HEAP32[$8_1 + 56 >> 2] = 989586609;
        HEAP32[$8_1 + 60 >> 2] = 1279582103;
        HEAP32[$8_1 + 48 >> 2] = -904942663;
        HEAP32[$8_1 + 52 >> 2] = 262346349;
        HEAP32[$8_1 + 40 >> 2] = 618476057;
        HEAP32[$8_1 + 44 >> 2] = 1320844912;
        $9_1 = $8_1 + 40 | 0;
        $29($9_1, $7_1, 32);
        $30($9_1, $8_1);
        HEAP8[$8_1 | 0] = HEAPU8[$8_1 | 0] ^ HEAPU8[$3_1 | 0];
        HEAP8[$8_1 + 1 | 0] = HEAPU8[$8_1 + 1 | 0] ^ HEAPU8[$3_1 + 1 | 0];
        HEAP8[$8_1 + 2 | 0] = HEAPU8[$8_1 + 2 | 0] ^ HEAPU8[$3_1 + 2 | 0];
        HEAP8[$8_1 + 3 | 0] = HEAPU8[$8_1 + 3 | 0] ^ HEAPU8[$3_1 + 3 | 0];
        HEAP8[$8_1 + 4 | 0] = HEAPU8[$8_1 + 4 | 0] ^ HEAPU8[$3_1 + 4 | 0];
        HEAP8[$8_1 + 5 | 0] = HEAPU8[$8_1 + 5 | 0] ^ HEAPU8[$3_1 + 5 | 0];
        HEAP8[$8_1 + 6 | 0] = HEAPU8[$8_1 + 6 | 0] ^ HEAPU8[$3_1 + 6 | 0];
        HEAP8[$8_1 + 7 | 0] = HEAPU8[$8_1 + 7 | 0] ^ HEAPU8[$3_1 + 7 | 0];
        HEAP8[$8_1 + 8 | 0] = HEAPU8[$8_1 + 8 | 0] ^ HEAPU8[$3_1 + 8 | 0];
        HEAP8[$8_1 + 9 | 0] = HEAPU8[$8_1 + 9 | 0] ^ HEAPU8[$3_1 + 9 | 0];
        HEAP8[$8_1 + 10 | 0] = HEAPU8[$8_1 + 10 | 0] ^ HEAPU8[$3_1 + 10 | 0];
        HEAP8[$8_1 + 11 | 0] = HEAPU8[$8_1 + 11 | 0] ^ HEAPU8[$3_1 + 11 | 0];
        HEAP8[$8_1 + 12 | 0] = HEAPU8[$8_1 + 12 | 0] ^ HEAPU8[$3_1 + 12 | 0];
        HEAP8[$8_1 + 13 | 0] = HEAPU8[$8_1 + 13 | 0] ^ HEAPU8[$3_1 + 13 | 0];
        HEAP8[$8_1 + 14 | 0] = HEAPU8[$8_1 + 14 | 0] ^ HEAPU8[$3_1 + 14 | 0];
        HEAP8[$8_1 + 15 | 0] = HEAPU8[$8_1 + 15 | 0] ^ HEAPU8[$3_1 + 15 | 0];
        HEAP8[$8_1 + 16 | 0] = HEAPU8[$8_1 + 16 | 0] ^ HEAPU8[$3_1 + 16 | 0];
        HEAP8[$8_1 + 17 | 0] = HEAPU8[$8_1 + 17 | 0] ^ HEAPU8[$3_1 + 17 | 0];
        HEAP8[$8_1 + 18 | 0] = HEAPU8[$8_1 + 18 | 0] ^ HEAPU8[$3_1 + 18 | 0];
        HEAP8[$8_1 + 19 | 0] = HEAPU8[$8_1 + 19 | 0] ^ HEAPU8[$3_1 + 19 | 0];
        HEAP8[$8_1 + 20 | 0] = HEAPU8[$8_1 + 20 | 0] ^ HEAPU8[$3_1 + 20 | 0];
        HEAP8[$8_1 + 21 | 0] = HEAPU8[$8_1 + 21 | 0] ^ HEAPU8[$3_1 + 21 | 0];
        HEAP8[$8_1 + 22 | 0] = HEAPU8[$8_1 + 22 | 0] ^ HEAPU8[$3_1 + 22 | 0];
        HEAP8[$8_1 + 23 | 0] = HEAPU8[$8_1 + 23 | 0] ^ HEAPU8[$3_1 + 23 | 0];
        HEAP8[$8_1 + 24 | 0] = HEAPU8[$8_1 + 24 | 0] ^ HEAPU8[$3_1 + 24 | 0];
        HEAP8[$8_1 + 25 | 0] = HEAPU8[$8_1 + 25 | 0] ^ HEAPU8[$3_1 + 25 | 0];
        HEAP8[$8_1 + 26 | 0] = HEAPU8[$8_1 + 26 | 0] ^ HEAPU8[$3_1 + 26 | 0];
        HEAP8[$8_1 + 27 | 0] = HEAPU8[$8_1 + 27 | 0] ^ HEAPU8[$3_1 + 27 | 0];
        HEAP8[$8_1 + 28 | 0] = HEAPU8[$8_1 + 28 | 0] ^ HEAPU8[$3_1 + 28 | 0];
        HEAP8[$8_1 + 29 | 0] = HEAPU8[$8_1 + 29 | 0] ^ HEAPU8[$3_1 + 29 | 0];
        HEAP8[$8_1 + 30 | 0] = HEAPU8[$8_1 + 30 | 0] ^ HEAPU8[$3_1 + 30 | 0];
        HEAP8[$8_1 + 31 | 0] = HEAPU8[$8_1 + 31 | 0] ^ HEAPU8[$3_1 + 31 | 0];
      }
      label$4: {
        if (($6_1 | 0) == 13) {
          label$6: {
            if (HEAPU8[$5_1 | 0] != 66) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 1 | 0] != 73) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 2 | 0] != 80) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 3 | 0] != 48) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 4 | 0] != 51) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 5 | 0] != 52) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 6 | 0] != 48) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 7 | 0] != 47) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 8 | 0] != 110) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 9 | 0] != 111) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 10 | 0] != 110) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 11 | 0] != 99) {
              break label$6;
            }
            if (HEAPU8[$5_1 + 12 | 0] != 101) {
              break label$6;
            }
            HEAP32[$8_1 + 136 >> 2] = 64;
            HEAP32[$8_1 + 140 >> 2] = 0;
            HEAP32[$8_1 + 64 >> 2] = 564305492;
            HEAP32[$8_1 + 68 >> 2] = 1756396364;
            HEAP32[$8_1 + 56 >> 2] = 1612804480;
            HEAP32[$8_1 + 60 >> 2] = 1463125601;
            HEAP32[$8_1 + 48 >> 2] = -1618098575;
            HEAP32[$8_1 + 52 >> 2] = -2090698061;
            HEAP32[$8_1 + 40 >> 2] = 1180785461;
            HEAP32[$8_1 + 44 >> 2] = -188760073;
            break label$4;
          }
          HEAP32[$8_1 + 136 >> 2] = 0;
          HEAP32[$8_1 + 140 >> 2] = 0;
          HEAP32[$8_1 + 64 >> 2] = 528734635;
          HEAP32[$8_1 + 68 >> 2] = 1541459225;
          HEAP32[$8_1 + 56 >> 2] = 1359893119;
          HEAP32[$8_1 + 60 >> 2] = -1694144372;
          HEAP32[$8_1 + 48 >> 2] = 1013904242;
          HEAP32[$8_1 + 52 >> 2] = -1521486534;
          HEAP32[$8_1 + 40 >> 2] = 1779033703;
          HEAP32[$8_1 + 44 >> 2] = -1150833019;
          $3_1 = $8_1 + 40 | 0;
          $29($3_1, $5_1, 13);
          $5_1 = $8_1 + 144 | 0;
          $30($3_1, $5_1);
          HEAP32[$8_1 + 136 >> 2] = 0;
          HEAP32[$8_1 + 140 >> 2] = 0;
          HEAP32[$8_1 + 64 >> 2] = 528734635;
          HEAP32[$8_1 + 68 >> 2] = 1541459225;
          HEAP32[$8_1 + 56 >> 2] = 1359893119;
          HEAP32[$8_1 + 60 >> 2] = -1694144372;
          HEAP32[$8_1 + 48 >> 2] = 1013904242;
          HEAP32[$8_1 + 52 >> 2] = -1521486534;
          HEAP32[$8_1 + 40 >> 2] = 1779033703;
          HEAP32[$8_1 + 44 >> 2] = -1150833019;
          $29($3_1, $5_1, 32);
          $29($3_1, $5_1, 32);
          break label$4;
        }
        HEAP32[$8_1 + 136 >> 2] = 0;
        HEAP32[$8_1 + 140 >> 2] = 0;
        HEAP32[$8_1 + 64 >> 2] = 528734635;
        HEAP32[$8_1 + 68 >> 2] = 1541459225;
        HEAP32[$8_1 + 56 >> 2] = 1359893119;
        HEAP32[$8_1 + 60 >> 2] = -1694144372;
        HEAP32[$8_1 + 48 >> 2] = 1013904242;
        HEAP32[$8_1 + 52 >> 2] = -1521486534;
        HEAP32[$8_1 + 40 >> 2] = 1779033703;
        HEAP32[$8_1 + 44 >> 2] = -1150833019;
        $3_1 = $8_1 + 40 | 0;
        $29($3_1, $5_1, $6_1);
        $5_1 = $8_1 + 144 | 0;
        $30($3_1, $5_1);
        HEAP32[$8_1 + 136 >> 2] = 0;
        HEAP32[$8_1 + 140 >> 2] = 0;
        HEAP32[$8_1 + 64 >> 2] = 528734635;
        HEAP32[$8_1 + 68 >> 2] = 1541459225;
        HEAP32[$8_1 + 56 >> 2] = 1359893119;
        HEAP32[$8_1 + 60 >> 2] = -1694144372;
        HEAP32[$8_1 + 48 >> 2] = 1013904242;
        HEAP32[$8_1 + 52 >> 2] = -1521486534;
        HEAP32[$8_1 + 40 >> 2] = 1779033703;
        HEAP32[$8_1 + 44 >> 2] = -1150833019;
        $29($3_1, $5_1, 32);
        $29($3_1, $5_1, 32);
      }
      $3_1 = $8_1 + 40 | 0;
      $29($3_1, $8_1, 32);
      $29($3_1, $4_1, 32);
      $29($3_1, $1_1, $2_1);
      $30($3_1, $0_1);
      $0_1 = 1;
    } else {
      $0_1 = 0;
    }
    global$0 = $8_1 + 176 | 0;
    return $0_1 | 0;
  }
  function $62($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
    $7_1 = global$0 - 32 | 0;
    global$0 = $7_1;
    $13_1 = $68($0_1, 516);
    $0_1 = $1_1 + 24 | 0;
    $10_1 = HEAP32[$0_1 >> 2];
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $4_1 = $7_1 + 24 | 0;
    HEAP32[$4_1 >> 2] = $10_1;
    HEAP32[$4_1 + 4 >> 2] = $0_1;
    $4_1 = $1_1 + 16 | 0;
    $3_1 = HEAP32[$4_1 + 4 >> 2];
    $5_1 = $7_1 + 16 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $3_1;
    $4_1 = $1_1 + 8 | 0;
    $3_1 = HEAP32[$4_1 + 4 >> 2];
    $5_1 = $7_1 + 8 | 0;
    HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$5_1 + 4 >> 2] = $3_1;
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    HEAP32[$7_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$7_1 + 4 >> 2] = $4_1;
    $8_1 = 1;
    $4_1 = $0_1;
    if (($0_1 | 0) < 0) {
      $3_1 = HEAP32[$7_1 >> 2] ^ -1;
      $5_1 = $3_1 - 801750718 | 0;
      $6_1 = HEAP32[$7_1 + 4 >> 2] ^ -1;
      $1_1 = $6_1 - (($3_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
      HEAP32[$7_1 >> 2] = $5_1;
      HEAP32[$7_1 + 4 >> 2] = $1_1;
      $1_1 = ($1_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 < $6_1 >>> 0;
      $0_1 = $7_1;
      $5_1 = HEAP32[$0_1 + 8 >> 2] ^ -1;
      $1_1 = $1_1 + $5_1 | 0;
      $6_1 = HEAP32[$0_1 + 12 >> 2] ^ -1;
      $3_1 = $6_1;
      $9_1 = $1_1 - 1354194885 | 0;
      HEAP32[$0_1 + 8 >> 2] = $9_1;
      $3_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $3_1 - (($1_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
      HEAP32[$0_1 + 12 >> 2] = $8_1;
      $6_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
      $5_1 = ($3_1 | 0) == ($8_1 | 0) & $1_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
      $1_1 = $6_1 + $5_1 | 0;
      $6_1 = HEAP32[$0_1 + 20 >> 2] ^ -1;
      $3_1 = $6_1 + ($1_1 >>> 0 < $5_1 >>> 0) | 0;
      $5_1 = HEAP32[$0_1 + 16 >> 2] ^ -1;
      $1_1 = $5_1 + $1_1 | 0;
      $9_1 = $1_1 - 2 | 0;
      HEAP32[$0_1 + 16 >> 2] = $9_1;
      $3_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $3_1 - ($1_1 >>> 0 < 2) | 0;
      HEAP32[$0_1 + 20 >> 2] = $8_1;
      $0_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
      $3_1 = ($3_1 | 0) == ($8_1 | 0) & $1_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
      $0_1 = $0_1 + $3_1 | 0;
      $1_1 = $0_1 >>> 0 < $3_1 >>> 0;
      $3_1 = $0_1 - $10_1 | 0;
      HEAP32[$7_1 + 24 >> 2] = $3_1 - 2;
      HEAP32[$7_1 + 28 >> 2] = ($1_1 - (($0_1 >>> 0 < $10_1 >>> 0) + $4_1 | 0) | 0) - ($3_1 >>> 0 < 2);
      $8_1 = -1;
    }
    $14_1 = $2_1 - 1 | 0;
    $10_1 = -1;
    $1_1 = 0;
    while (1) {
      $3_1 = $1_1 >>> 6 | 0;
      $12_1 = $3_1 << 3;
      $4_1 = $12_1 + $7_1 | 0;
      $0_1 = HEAP32[$4_1 >> 2];
      $5_1 = HEAP32[$4_1 + 4 >> 2];
      $6_1 = $1_1 & 63;
      $4_1 = $6_1 & 31;
      if ($6_1 >>> 0 >= 32) {
        $4_1 = $5_1 >>> $4_1 | 0;
      } else {
        $4_1 = ((1 << $4_1) - 1 & $5_1) << 32 - $4_1 | $0_1 >>> $4_1;
      }
      label$3: {
        if (($11_1 | 0) == ($4_1 & 1)) {
          $0_1 = $1_1 + 1 | 0;
          break label$3;
        }
        $0_1 = 129 - $1_1 | 0;
        $9_1 = ($0_1 | 0) < ($2_1 | 0) ? $0_1 : $2_1;
        $0_1 = $9_1 + $1_1 | 0;
        if (($3_1 | 0) != ($0_1 - 1 >>> 6 | 0)) {
          $3_1 = ($7_1 + $12_1 | 0) + 8 | 0;
          $10_1 = HEAP32[$3_1 >> 2];
          $3_1 = 64 - $6_1 | 0;
          $6_1 = $3_1 & 31;
          $4_1 = (($3_1 & 63) >>> 0 < 32 ? $10_1 << $6_1 : 0) | $4_1;
        }
        $3_1 = $9_1 & 31;
        $4_1 = $11_1 + ($4_1 & ((($9_1 & 63) >>> 0 < 32 ? -1 << $3_1 : 0) ^ -1)) | 0;
        $11_1 = $4_1 >>> $14_1 & 1;
        HEAP32[$13_1 + ($1_1 << 2) >> 2] = Math_imul($4_1 - ($11_1 << $2_1) | 0, $8_1);
        $10_1 = $1_1;
      }
      $1_1 = $0_1;
      if (($1_1 | 0) < 129) {
        continue;
      }
      break;
    }
    ;
    global$0 = $7_1 + 32 | 0;
    return $10_1 + 1 | 0;
  }
  function $63($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
    label$1: {
      if (($2_1 | 0) > 0) {
        $3_1 = $1_1 + (($2_1 << 5) - 32 & -64) | 0;
        $1_1 = HEAP32[$3_1 >> 2];
        $2_1 = HEAP32[$3_1 + 4 >> 2] & 1048575;
        HEAP32[$0_1 >> 2] = $1_1;
        HEAP32[$0_1 + 4 >> 2] = $2_1;
        $1_1 = HEAP32[$3_1 + 8 >> 2];
        $2_1 = HEAP32[$3_1 + 12 >> 2] << 12 | $1_1 >>> 20;
        HEAP32[$0_1 + 8 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 4 >> 2] >>> 20;
        HEAP32[$0_1 + 12 >> 2] = $2_1 & 1048575;
        $1_1 = HEAP32[$3_1 + 16 >> 2];
        $2_1 = HEAP32[$3_1 + 20 >> 2] << 24 | $1_1 >>> 8;
        HEAP32[$0_1 + 16 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$3_1 + 12 >> 2] >>> 8;
        HEAP32[$0_1 + 20 >> 2] = $2_1 & 1048575;
        $4_1 = HEAP32[$3_1 + 24 >> 2] << 4 & 1048560;
        $2_1 = HEAP32[$3_1 + 20 >> 2];
        $1_1 = $2_1 >>> 28 | 0;
        HEAP32[$0_1 + 24 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$3_1 + 16 >> 2] >>> 28;
        HEAP32[$0_1 + 28 >> 2] = $1_1 | $4_1;
        $1_1 = HEAP32[$3_1 + 28 >> 2];
        $2_1 = $1_1 >>> 16 | 0;
        HEAP32[$0_1 + 32 >> 2] = ($1_1 & 65535) << 16 | HEAP32[$3_1 + 24 >> 2] >>> 16;
        HEAP32[$0_1 + 36 >> 2] = $2_1;
        $1_1 = HEAP32[$3_1 + 36 >> 2] & 1048575;
        HEAP32[$0_1 + 40 >> 2] = HEAP32[$3_1 + 32 >> 2];
        HEAP32[$0_1 + 44 >> 2] = $1_1;
        $4_1 = $3_1 + 40 | 0;
        $1_1 = HEAP32[$4_1 >> 2];
        $2_1 = HEAP32[$4_1 + 4 >> 2] << 12 | $1_1 >>> 20;
        $5_1 = $0_1 + 48 | 0;
        HEAP32[$5_1 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 36 >> 2] >>> 20;
        HEAP32[$5_1 + 4 >> 2] = $2_1 & 1048575;
        $5_1 = $3_1 + 48 | 0;
        $1_1 = HEAP32[$5_1 >> 2];
        $2_1 = HEAP32[$5_1 + 4 >> 2] << 24 | $1_1 >>> 8;
        $6_1 = $0_1 + 56 | 0;
        HEAP32[$6_1 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$4_1 + 4 >> 2] >>> 8;
        HEAP32[$6_1 + 4 >> 2] = $2_1 & 1048575;
        $3_1 = $3_1 + 56 | 0;
        $1_1 = HEAP32[$3_1 >> 2];
        $6_1 = $1_1 << 4 & 1048560;
        $2_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $2_1 >>> 28 | 0;
        $4_1 = $0_1 - -64 | 0;
        HEAP32[$4_1 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$5_1 >> 2] >>> 28;
        HEAP32[$4_1 + 4 >> 2] = $1_1 | $6_1;
        $1_1 = $0_1 + 72 | 0;
        $4_1 = HEAP32[$3_1 + 4 >> 2];
        HEAP32[$1_1 >> 2] = ($4_1 & 65535) << 16 | HEAP32[$3_1 >> 2] >>> 16;
        HEAP32[$1_1 + 4 >> 2] = $4_1 >>> 16;
        break label$1;
      }
      $3_1 = $1_1 + (($2_1 ^ -1) / 2 << 6) | 0;
      $1_1 = HEAP32[$3_1 >> 2];
      $2_1 = HEAP32[$3_1 + 4 >> 2] & 1048575;
      HEAP32[$0_1 >> 2] = $1_1;
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = HEAP32[$3_1 + 8 >> 2];
      $2_1 = HEAP32[$3_1 + 12 >> 2] << 12 | $1_1 >>> 20;
      HEAP32[$0_1 + 8 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 4 >> 2] >>> 20;
      HEAP32[$0_1 + 12 >> 2] = $2_1 & 1048575;
      $1_1 = HEAP32[$3_1 + 16 >> 2];
      $2_1 = HEAP32[$3_1 + 20 >> 2] << 24 | $1_1 >>> 8;
      HEAP32[$0_1 + 16 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$3_1 + 12 >> 2] >>> 8;
      HEAP32[$0_1 + 20 >> 2] = $2_1 & 1048575;
      $4_1 = HEAP32[$3_1 + 24 >> 2] << 4 & 1048560;
      $2_1 = HEAP32[$3_1 + 20 >> 2];
      $1_1 = $2_1 >>> 28 | 0;
      HEAP32[$0_1 + 24 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$3_1 + 16 >> 2] >>> 28;
      HEAP32[$0_1 + 28 >> 2] = $1_1 | $4_1;
      $1_1 = HEAP32[$3_1 + 28 >> 2];
      $2_1 = $1_1 >>> 16 | 0;
      HEAP32[$0_1 + 32 >> 2] = ($1_1 & 65535) << 16 | HEAP32[$3_1 + 24 >> 2] >>> 16;
      HEAP32[$0_1 + 36 >> 2] = $2_1;
      $6_1 = HEAP32[$3_1 + 36 >> 2] & 1048575;
      $9_1 = HEAP32[$3_1 + 32 >> 2];
      HEAP32[$0_1 + 40 >> 2] = $9_1;
      HEAP32[$0_1 + 44 >> 2] = $6_1;
      $4_1 = $3_1 + 40 | 0;
      $1_1 = HEAP32[$4_1 >> 2];
      $2_1 = HEAP32[$4_1 + 4 >> 2] << 12 | $1_1 >>> 20;
      $10_1 = $0_1 + 48 | 0;
      $5_1 = $10_1;
      $11_1 = $1_1 << 12 & -4096 | HEAP32[$3_1 + 36 >> 2] >>> 20;
      HEAP32[$5_1 >> 2] = $11_1;
      $13_1 = $2_1 & 1048575;
      HEAP32[$5_1 + 4 >> 2] = $13_1;
      $5_1 = $3_1 + 48 | 0;
      $1_1 = HEAP32[$5_1 >> 2];
      $2_1 = HEAP32[$5_1 + 4 >> 2] << 24 | $1_1 >>> 8;
      $7_1 = $0_1 + 56 | 0;
      $4_1 = $1_1 << 24 & -16777216 | HEAP32[$4_1 + 4 >> 2] >>> 8;
      HEAP32[$7_1 >> 2] = $4_1;
      $14_1 = $2_1 & 1048575;
      HEAP32[$7_1 + 4 >> 2] = $14_1;
      $3_1 = $3_1 + 56 | 0;
      $1_1 = HEAP32[$3_1 >> 2];
      $12_1 = $1_1 << 4 & 1048560;
      $2_1 = HEAP32[$5_1 + 4 >> 2];
      $1_1 = $2_1 >>> 28 | 0;
      $8_1 = $0_1 - -64 | 0;
      $2_1 = ($2_1 & 268435455) << 4 | HEAP32[$5_1 >> 2] >>> 28;
      HEAP32[$8_1 >> 2] = $2_1;
      $5_1 = $1_1 | $12_1;
      HEAP32[$8_1 + 4 >> 2] = $5_1;
      $12_1 = HEAP32[$3_1 >> 2];
      $1_1 = HEAP32[$3_1 + 4 >> 2];
      HEAP32[$8_1 >> 2] = -4 - $2_1;
      HEAP32[$8_1 + 4 >> 2] = 4194303 - (($2_1 >>> 0 > 4294967292) + $5_1 | 0);
      HEAP32[$7_1 >> 2] = -4 - $4_1;
      HEAP32[$7_1 + 4 >> 2] = 4194303 - (($4_1 >>> 0 > 4294967292) + $14_1 | 0);
      HEAP32[$10_1 >> 2] = -4 - $11_1;
      HEAP32[$10_1 + 4 >> 2] = 4194303 - (($11_1 >>> 0 > 4294967292) + $13_1 | 0);
      HEAP32[$0_1 + 40 >> 2] = -3908 - $9_1;
      HEAP32[$0_1 + 44 >> 2] = 4194299 - (($9_1 >>> 0 > 4294963388) + $6_1 | 0);
      $3_1 = $1_1 >>> 16 | 0;
      $2_1 = $0_1 + 72 | 0;
      $1_1 = ($1_1 & 65535) << 16 | $12_1 >>> 16;
      HEAP32[$2_1 >> 2] = -4 - $1_1;
      HEAP32[$2_1 + 4 >> 2] = 262143 - (($1_1 >>> 0 > 4294967292) + $3_1 | 0);
    }
    HEAP32[$0_1 + 80 >> 2] = 0;
  }
  function $64($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0;
    $6_1 = global$0 - 1120 | 0;
    global$0 = $6_1;
    label$1: {
      if (HEAP32[$1_1 + 120 >> 2]) {
        HEAP32[$0_1 + 120 >> 2] = HEAP32[$2_1 + 80 >> 2];
        $4_1 = $6_1 + 1080 | 0;
        $54($4_1, $3_1);
        $1_1 = $6_1 + 1040 | 0;
        $34($1_1, $4_1, $3_1);
        $34($0_1, $2_1, $4_1);
        $34($0_1 + 40 | 0, $2_1 + 40 | 0, $1_1);
        $1_1 = $0_1 + 88 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        HEAP32[$0_1 + 80 >> 2] = 1;
        HEAP32[$0_1 + 84 >> 2] = 0;
        $1_1 = $0_1 + 96 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $0_1 + 104 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $0_1 = $0_1 + 112 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        break label$1;
      }
      if (HEAP32[$2_1 + 80 >> 2]) {
        $70($0_1, $1_1, 128);
        break label$1;
      }
      $44_1 = $6_1 + 1080 | 0;
      $45_1 = $1_1 + 80 | 0;
      $34($44_1, $45_1, $3_1);
      $3_1 = HEAP32[$6_1 + 1084 >> 2];
      $15_1 = $3_1;
      $12_1 = HEAP32[$6_1 + 1080 >> 2];
      $4_1 = $12_1;
      $3_1 = $3_1 << 1 | $4_1 >>> 31;
      $13_1 = $6_1 + 408 | 0;
      $21_1 = HEAP32[$6_1 + 1104 >> 2];
      $19_1 = HEAP32[$6_1 + 1108 >> 2];
      $22_1 = $4_1 << 1;
      $27_1 = $3_1;
      $69($13_1, $21_1, $19_1, 0, 0, $22_1, $3_1, 0, 0);
      $3_1 = HEAP32[$6_1 + 1092 >> 2];
      $42_1 = $3_1;
      $41_1 = HEAP32[$6_1 + 1088 >> 2];
      $5_1 = $41_1;
      $3_1 = $3_1 << 1 | $5_1 >>> 31;
      $9_1 = $6_1 + 616 | 0;
      $18_1 = HEAP32[$6_1 + 1096 >> 2];
      $17_1 = HEAP32[$6_1 + 1100 >> 2];
      $5_1 = $5_1 << 1;
      $8_1 = $3_1;
      $69($9_1, $18_1, $17_1, 0, 0, $5_1, $3_1, 0, 0);
      $14_1 = $6_1 + 568 | 0;
      $4_1 = HEAP32[$6_1 + 1112 >> 2];
      $3_1 = HEAP32[$6_1 + 1116 >> 2];
      $69($14_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
      $10_1 = $6_1 + 552 | 0;
      $69($10_1, HEAP32[$6_1 + 568 >> 2], HEAP32[$6_1 + 572 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $3_1 << 1 | $4_1 >>> 31;
      $37_1 = $6_1 + 520 | 0;
      $28_1 = $4_1 << 1;
      $20_1 = $3_1;
      $69($37_1, $28_1, $3_1, 0, 0, $12_1, $15_1, 0, 0);
      $32_1 = $6_1 + 424 | 0;
      $69($32_1, $21_1, $19_1, 0, 0, $5_1, $8_1, 0, 0);
      $30_1 = $6_1 + 600 | 0;
      $69($30_1, $18_1, $17_1, 0, 0, $18_1, $17_1, 0, 0);
      $11_1 = $6_1 + 536 | 0;
      $3_1 = $14_1 + 8 | 0;
      $69($11_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $39_1 = $6_1 + 664 | 0;
      $69($39_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
      $38_1 = $6_1 + 504 | 0;
      $69($38_1, $28_1, $20_1, 0, 0, $41_1, $42_1, 0, 0);
      $35_1 = $6_1 + 440 | 0;
      $69($35_1, $21_1, $19_1, 0, 0, $18_1 << 1, $17_1 << 1 | $18_1 >>> 31, 0, 0);
      $15_1 = HEAP32[$6_1 + 412 >> 2];
      $3_1 = $15_1 + HEAP32[$6_1 + 620 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 408 >> 2];
      $5_1 = HEAP32[$6_1 + 616 >> 2];
      $4_1 = $7_1 + $5_1 | 0;
      $8_1 = HEAP32[$6_1 + 552 >> 2];
      $25_1 = $4_1 + $8_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + HEAP32[$6_1 + 556 >> 2] | 0;
      $8_1 = $8_1 >>> 0 > $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $25_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
      $3_1 = $10_1 + 8 | 0;
      $14_1 = HEAP32[$3_1 >> 2];
      $10_1 = HEAP32[$3_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
      $5_1 = $9_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $13_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $7_1 + $9_1 | 0;
      $3_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + $14_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $12_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $33_1 = $8_1;
      $14_1 = $4_1 << 12 | $8_1 >>> 20;
      $5_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 424 >> 2];
      $4_1 = HEAP32[$6_1 + 600 >> 2];
      $12_1 = $29_1 + $4_1 | 0;
      $36_1 = HEAP32[$6_1 + 428 >> 2];
      $3_1 = $36_1 + HEAP32[$6_1 + 604 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 520 >> 2];
      $10_1 = $4_1 + $12_1 | 0;
      $13_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 524 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = HEAP32[$6_1 + 536 >> 2];
      $8_1 = $4_1 + $10_1 | 0;
      $9_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 540 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $34_1 = $6_1 + 344 | 0;
      $31_1 = $34_1;
      $14_1 = $8_1 + $14_1 | 0;
      $7_1 = $14_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $26_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $23_1 = ($4_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
      $3_1 = $11_1 + 8 | 0;
      $24_1 = HEAP32[$3_1 >> 2];
      $16_1 = HEAP32[$3_1 + 4 >> 2];
      $15_1 = ($9_1 | 0) == ($13_1 | 0) & $12_1 >>> 0 > $10_1 >>> 0 | $9_1 >>> 0 < $13_1 >>> 0;
      $3_1 = $37_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $9_1 = HEAP32[$3_1 + 4 >> 2];
      $10_1 = ($13_1 | 0) == ($36_1 | 0) & $12_1 >>> 0 < $29_1 >>> 0 | $13_1 >>> 0 < $36_1 >>> 0;
      $8_1 = $30_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $32_1 + 8 | 0;
      $12_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $12_1 + $10_1 | 0;
      $3_1 = ($4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $9_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $15_1 | 0;
      $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $24_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1 + $23_1 | 0;
      $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $26_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $7_1;
      $10_1 = $4_1 << 12 | $5_1 >>> 20;
      $8_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $15_1 = HEAP32[$6_1 + 504 >> 2];
      $4_1 = HEAP32[$6_1 + 440 >> 2];
      $13_1 = $15_1 + $4_1 | 0;
      $23_1 = HEAP32[$6_1 + 508 >> 2];
      $3_1 = $23_1 + HEAP32[$6_1 + 444 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $7_1 | 0;
      $10_1 = $10_1 + $13_1 | 0;
      $3_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $10_1 << 4 & -16;
      $7_1 = $3_1;
      $12_1 = ($3_1 << 4 | $10_1 >>> 28) & 16777215;
      $16_1 = $5_1;
      $69($31_1, $9_1 | $5_1 >>> 16 & 15, $12_1, 0, 0, 977, 1, 0, 0);
      $5_1 = $1_1 + 8 | 0;
      $3_1 = HEAP32[$5_1 + 4 >> 2];
      $12_1 = $6_1 + 1e3 | 0;
      $30_1 = $12_1 + 8 | 0;
      HEAP32[$30_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$30_1 + 4 >> 2] = $3_1;
      $5_1 = $1_1 + 16 | 0;
      $3_1 = HEAP32[$5_1 + 4 >> 2];
      $29_1 = $12_1 + 16 | 0;
      HEAP32[$29_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$29_1 + 4 >> 2] = $3_1;
      $5_1 = $1_1 + 24 | 0;
      $3_1 = HEAP32[$5_1 + 4 >> 2];
      $31_1 = $12_1 + 24 | 0;
      HEAP32[$31_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$31_1 + 4 >> 2] = $3_1;
      $5_1 = $1_1 + 32 | 0;
      $3_1 = HEAP32[$5_1 + 4 >> 2];
      $26_1 = $12_1 + 32 | 0;
      HEAP32[$26_1 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$26_1 + 4 >> 2] = $3_1;
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      HEAP32[$6_1 + 1e3 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$6_1 + 1004 >> 2] = $3_1;
      $43_1 = HEAP32[$6_1 + 348 >> 2];
      $3_1 = $43_1 + HEAP32[$6_1 + 668 >> 2] | 0;
      $32_1 = HEAP32[$6_1 + 344 >> 2];
      $5_1 = HEAP32[$6_1 + 664 >> 2];
      $9_1 = $32_1 + $5_1 | 0;
      HEAP32[$6_1 + 1040 >> 2] = $9_1;
      $5_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 1044 >> 2] = $5_1 & 1048575;
      $46_1 = $6_1 + 648 | 0;
      $69($46_1, $41_1, $42_1, 0, 0, $22_1, $27_1, 0, 0);
      $40_1 = $6_1 + 488 | 0;
      $69($40_1, $28_1, $20_1, 0, 0, $18_1, $17_1, 0, 0);
      $36_1 = $6_1 + 456 | 0;
      $69($36_1, $21_1, $19_1, 0, 0, $21_1, $19_1, 0, 0);
      $37_1 = $6_1 + 392 | 0;
      $24_1 = $37_1;
      $11_1 = ($4_1 | 0) == ($7_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $13_1 = ($4_1 | 0) == ($23_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $23_1 >>> 0;
      $10_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $38_1 + 8 | 0;
      $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $13_1 + $15_1 | 0;
      $3_1 = $10_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $8_1 + $10_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $4_1 << 12 | $7_1 >>> 20;
      $10_1 = $3_1;
      $7_1 = $3_1 << 12 | $4_1 >>> 20;
      $12_1 = HEAP32[$6_1 + 492 >> 2];
      $3_1 = $12_1 + HEAP32[$6_1 + 460 >> 2] | 0;
      $38_1 = HEAP32[$6_1 + 488 >> 2];
      $8_1 = HEAP32[$6_1 + 456 >> 2];
      $4_1 = $38_1 + $8_1 | 0;
      $23_1 = $4_1;
      $15_1 = $4_1 + $13_1 | 0;
      $8_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $8_1 + $7_1 | 0;
      $13_1 = $15_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($24_1, $15_1, $13_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $9_1 = ($5_1 | 0) == ($43_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $5_1 >>> 0 < $43_1 >>> 0;
      $7_1 = $39_1 + 8 | 0;
      $4_1 = HEAP32[$7_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $11_1 | 0;
      $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $4_1 << 12 | $5_1 >>> 20;
      $7_1 = $3_1;
      $9_1 = $3_1 << 12 | $4_1 >>> 20;
      $39_1 = HEAP32[$6_1 + 396 >> 2];
      $3_1 = $39_1 + HEAP32[$6_1 + 652 >> 2] | 0;
      $35_1 = HEAP32[$6_1 + 392 >> 2];
      $5_1 = HEAP32[$6_1 + 648 >> 2];
      $4_1 = $35_1 + $5_1 | 0;
      $24_1 = $4_1;
      $11_1 = $4_1 + $11_1 | 0;
      $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $5_1 + $9_1 | 0;
      HEAP32[$6_1 + 1048 >> 2] = $11_1;
      $9_1 = $11_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 1052 >> 2] = $9_1 & 1048575;
      $34_1 = $6_1 + 584 | 0;
      $69($34_1, $18_1, $17_1, 0, 0, $22_1, $27_1, 0, 0);
      $32_1 = $6_1 + 632 | 0;
      $69($32_1, $41_1, $42_1, 0, 0, $41_1, $42_1, 0, 0);
      $27_1 = $6_1 + 472 | 0;
      $69($27_1, $28_1, $20_1, 0, 0, $21_1, $19_1, 0, 0);
      $22_1 = $6_1 + 376 | 0;
      $19_1 = $22_1;
      $17_1 = ($8_1 | 0) == ($13_1 | 0) & $15_1 >>> 0 < $23_1 >>> 0 | $8_1 >>> 0 > $13_1 >>> 0;
      $15_1 = ($8_1 | 0) == ($12_1 | 0) & $23_1 >>> 0 < $38_1 >>> 0 | $8_1 >>> 0 < $12_1 >>> 0;
      $8_1 = $36_1 + 8 | 0;
      $4_1 = HEAP32[$8_1 >> 2];
      $3_1 = $40_1 + 8 | 0;
      $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $15_1 + $21_1 | 0;
      $3_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $10_1 >>> 20 | 0;
      $4_1 = $8_1 + $10_1 | 0;
      $3_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $4_1;
      $4_1 = $4_1 + $17_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $4_1 << 12 | $13_1 >>> 20;
      $10_1 = HEAP32[$6_1 + 472 >> 2];
      $13_1 = $20_1 + $10_1 | 0;
      $8_1 = $3_1;
      $23_1 = $3_1 << 12 | $4_1 >>> 20;
      $3_1 = $23_1 + HEAP32[$6_1 + 476 >> 2] | 0;
      $15_1 = $10_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($19_1, $13_1, $15_1, 0, 0, 15632, 16, 0, 0);
      $11_1 = ($5_1 | 0) == ($9_1 | 0) & $11_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 > $9_1 >>> 0;
      $12_1 = ($5_1 | 0) == ($39_1 | 0) & $24_1 >>> 0 < $35_1 >>> 0 | $5_1 >>> 0 < $39_1 >>> 0;
      $5_1 = $46_1 + 8 | 0;
      $4_1 = HEAP32[$5_1 >> 2];
      $3_1 = $37_1 + 8 | 0;
      $17_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $12_1 + $17_1 | 0;
      $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $7_1 >>> 20 | 0;
      $4_1 = $5_1 + $7_1 | 0;
      $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $11_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $12_1 = $4_1 << 12 | $9_1 >>> 20;
      $5_1 = $3_1;
      $19_1 = $3_1 << 12 | $4_1 >>> 20;
      $18_1 = HEAP32[$6_1 + 584 >> 2];
      $4_1 = HEAP32[$6_1 + 632 >> 2];
      $9_1 = $18_1 + $4_1 | 0;
      $24_1 = HEAP32[$6_1 + 588 >> 2];
      $3_1 = $24_1 + HEAP32[$6_1 + 636 >> 2] | 0;
      $17_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $17_1 + HEAP32[$6_1 + 380 >> 2] | 0;
      $4_1 = HEAP32[$6_1 + 376 >> 2];
      $7_1 = $4_1 + $9_1 | 0;
      $11_1 = $7_1;
      $12_1 = $7_1 + $12_1 | 0;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $4_1 + $19_1 | 0;
      HEAP32[$6_1 + 1056 >> 2] = $12_1;
      $7_1 = $12_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 1060 >> 2] = $7_1 & 1048575;
      $21_1 = $6_1 + 360 | 0;
      $19_1 = ($15_1 | 0) == ($23_1 | 0) & $13_1 >>> 0 < $20_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
      $3_1 = $27_1 + 8 | 0;
      $15_1 = HEAP32[$3_1 >> 2];
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $8_1 = $8_1 >>> 20 | 0;
      $10_1 = $8_1;
      $8_1 = $8_1 + $15_1 | 0;
      $3_1 = $10_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $8_1;
      $8_1 = $8_1 + $19_1 | 0;
      $3_1 = $10_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($21_1, $8_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $19_1 = ($4_1 | 0) == ($7_1 | 0) & $12_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
      $15_1 = ($4_1 | 0) == ($17_1 | 0) & $9_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
      $3_1 = $22_1 + 8 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $13_1 = HEAP32[$3_1 + 4 >> 2];
      $12_1 = ($17_1 | 0) == ($24_1 | 0) & $9_1 >>> 0 < $18_1 >>> 0 | $17_1 >>> 0 < $24_1 >>> 0;
      $10_1 = $32_1 + 8 | 0;
      $4_1 = HEAP32[$10_1 >> 2];
      $3_1 = $34_1 + 8 | 0;
      $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $9_1 + $12_1 | 0;
      $3_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $13_1 | 0;
      $8_1 = $4_1;
      $4_1 = $4_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 + $15_1 | 0;
      $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $4_1 = $5_1 + $10_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $4_1;
      $4_1 = $4_1 + $19_1 | 0;
      $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1 << 12 | $7_1 >>> 20;
      $5_1 = $3_1;
      $9_1 = $3_1 << 12 | $4_1 >>> 20;
      $11_1 = HEAP32[$6_1 + 360 >> 2];
      $7_1 = $25_1 & -2;
      $4_1 = $11_1 + $7_1 | 0;
      $15_1 = HEAP32[$6_1 + 364 >> 2];
      $3_1 = $15_1 + ($33_1 & 1048575) | 0;
      $12_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $12_1 + $9_1 | 0;
      $8_1 = $10_1;
      $10_1 = $4_1;
      $7_1 = $8_1 + $4_1 | 0;
      HEAP32[$6_1 + 1064 >> 2] = $7_1;
      $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 1068 >> 2] = $4_1 & 1048575;
      $13_1 = $16_1 & 65535;
      $9_1 = ($4_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
      $7_1 = ($12_1 | 0) == ($15_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $12_1 >>> 0 < $15_1 >>> 0;
      $3_1 = $21_1 + 8 | 0;
      $10_1 = $7_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $5_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $10_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $5_1;
      $5_1 = $5_1 + $9_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $5_1 << 12 | $4_1 >>> 20;
      $7_1 = $4_1 + $14_1 | 0;
      $3_1 = $13_1 + ($3_1 << 12 | $5_1 >>> 20) | 0;
      HEAP32[$6_1 + 1072 >> 2] = $7_1;
      HEAP32[$6_1 + 1076 >> 2] = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $14_1 = $30_1;
      $9_1 = HEAP32[$14_1 >> 2];
      $12_1 = HEAP32[$14_1 + 4 >> 2];
      $10_1 = HEAP32[$6_1 + 1004 >> 2];
      $7_1 = HEAP32[$26_1 >> 2];
      $4_1 = HEAP32[$26_1 + 4 >> 2];
      $11_1 = $4_1;
      $3_1 = HEAP32[$6_1 + 1e3 >> 2];
      $5_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $3_1 + $5_1 | 0;
      $3_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
      $10_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $12_1;
      $5_1 = $10_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $9_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $15_1 = $5_1;
      HEAP32[$14_1 >> 2] = $5_1;
      $30_1 = $3_1 & 1048575;
      HEAP32[$14_1 + 4 >> 2] = $30_1;
      $14_1 = $29_1;
      $9_1 = HEAP32[$14_1 >> 2];
      $5_1 = $3_1;
      $3_1 = HEAP32[$14_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $9_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $5_1;
      HEAP32[$14_1 >> 2] = $5_1;
      $29_1 = $3_1 & 1048575;
      HEAP32[$14_1 + 4 >> 2] = $29_1;
      $14_1 = $31_1;
      $9_1 = HEAP32[$14_1 >> 2];
      $5_1 = $3_1;
      $3_1 = HEAP32[$14_1 + 4 >> 2];
      $5_1 = $5_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $9_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $5_1;
      HEAP32[$14_1 >> 2] = $5_1;
      $31_1 = $3_1 & 1048575;
      HEAP32[$14_1 + 4 >> 2] = $31_1;
      $14_1 = $26_1;
      $5_1 = $3_1;
      $3_1 = $11_1 & 65535;
      $5_1 = $5_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $7_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $21_1 = $5_1;
      HEAP32[$14_1 >> 2] = $5_1;
      $33_1 = $3_1;
      HEAP32[$14_1 + 4 >> 2] = $3_1;
      $14_1 = $4_1;
      HEAP32[$6_1 + 1e3 >> 2] = $4_1;
      $26_1 = $10_1 & 1048575;
      HEAP32[$6_1 + 1004 >> 2] = $26_1;
      $28_1 = $6_1 + 1040 | 0;
      $34($6_1 + 960 | 0, $2_1, $28_1);
      $17_1 = $6_1 + 920 | 0;
      $25_1 = $17_1 + 8 | 0;
      $3_1 = $1_1 + 48 | 0;
      $11_1 = HEAP32[$3_1 >> 2];
      $12_1 = HEAP32[$3_1 + 4 >> 2];
      $10_1 = HEAP32[$1_1 + 44 >> 2];
      $3_1 = $1_1 + 72 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $4_1 = HEAP32[$3_1 + 4 >> 2];
      $16_1 = $4_1;
      $3_1 = HEAP32[$1_1 + 40 >> 2];
      $5_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
      $4_1 = $3_1 + $5_1 | 0;
      $3_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
      $10_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $12_1;
      $5_1 = $10_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $5_1;
      HEAP32[$25_1 >> 2] = $5_1;
      $23_1 = $3_1 & 1048575;
      HEAP32[$25_1 + 4 >> 2] = $23_1;
      $25_1 = $17_1 + 16 | 0;
      $5_1 = $1_1 + 56 | 0;
      $11_1 = HEAP32[$5_1 >> 2];
      $12_1 = HEAP32[$5_1 + 4 >> 2];
      $5_1 = $3_1;
      $3_1 = $12_1;
      $5_1 = $5_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = $5_1;
      HEAP32[$25_1 >> 2] = $5_1;
      $24_1 = $3_1 & 1048575;
      HEAP32[$25_1 + 4 >> 2] = $24_1;
      $25_1 = $17_1 + 24 | 0;
      $5_1 = $1_1 - -64 | 0;
      $11_1 = HEAP32[$5_1 >> 2];
      $12_1 = HEAP32[$5_1 + 4 >> 2];
      $5_1 = $3_1;
      $3_1 = $12_1;
      $5_1 = $5_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $19_1 = $5_1;
      HEAP32[$25_1 >> 2] = $5_1;
      $27_1 = $3_1 & 1048575;
      HEAP32[$25_1 + 4 >> 2] = $27_1;
      $11_1 = $17_1 + 32 | 0;
      $5_1 = $3_1;
      $3_1 = $16_1 & 65535;
      $5_1 = $5_1 >>> 20 | 0;
      $7_1 = $5_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $17_1 = $7_1;
      HEAP32[$11_1 >> 2] = $7_1;
      $5_1 = $3_1;
      HEAP32[$11_1 + 4 >> 2] = $3_1;
      $25_1 = $4_1;
      HEAP32[$6_1 + 920 >> 2] = $4_1;
      $22_1 = $10_1 & 1048575;
      HEAP32[$6_1 + 924 >> 2] = $22_1;
      $3_1 = $6_1 + 880 | 0;
      $34($3_1, $2_1 + 40 | 0, $28_1);
      $34($3_1, $3_1, $44_1);
      $4_1 = $6_1;
      $2_1 = HEAP32[$4_1 + 960 >> 2];
      $12_1 = ($2_1 - $14_1 | 0) - 3908 | 0;
      $3_1 = (HEAP32[$4_1 + 964 >> 2] - (($2_1 >>> 0 < $14_1 >>> 0) + $26_1 | 0) | 0) + 4194299 | 0;
      HEAP32[$4_1 + 840 >> 2] = $12_1;
      $10_1 = $12_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 844 >> 2] = $10_1;
      $2_1 = HEAP32[$4_1 + 968 >> 2];
      $11_1 = ($2_1 - $15_1 | 0) - 4 | 0;
      $3_1 = (HEAP32[$4_1 + 972 >> 2] - (($2_1 >>> 0 < $15_1 >>> 0) + $30_1 | 0) | 0) + 4194303 | 0;
      HEAP32[$4_1 + 848 >> 2] = $11_1;
      $14_1 = $11_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 852 >> 2] = $14_1;
      $2_1 = HEAP32[$4_1 + 976 >> 2];
      $16_1 = ($2_1 - $13_1 | 0) - 4 | 0;
      $3_1 = (HEAP32[$4_1 + 980 >> 2] - (($2_1 >>> 0 < $13_1 >>> 0) + $29_1 | 0) | 0) + 4194303 | 0;
      HEAP32[$4_1 + 856 >> 2] = $16_1;
      $13_1 = $16_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 860 >> 2] = $13_1;
      $2_1 = HEAP32[$4_1 + 984 >> 2];
      $15_1 = ($2_1 - $9_1 | 0) - 4 | 0;
      $3_1 = (HEAP32[$4_1 + 988 >> 2] - (($2_1 >>> 0 < $9_1 >>> 0) + $31_1 | 0) | 0) + 4194303 | 0;
      HEAP32[$4_1 + 864 >> 2] = $15_1;
      $9_1 = $15_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 868 >> 2] = $9_1;
      $3_1 = HEAP32[$4_1 + 992 >> 2];
      $2_1 = ($3_1 - $21_1 | 0) - 4 | 0;
      $3_1 = (HEAP32[$4_1 + 996 >> 2] - (($3_1 >>> 0 < $21_1 >>> 0) + $33_1 | 0) | 0) + 262143 | 0;
      HEAP32[$4_1 + 872 >> 2] = $2_1;
      $7_1 = $2_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 876 >> 2] = $7_1;
      $3_1 = HEAP32[$4_1 + 912 >> 2];
      $33_1 = ($17_1 - $3_1 | 0) - 4 | 0;
      $3_1 = ($5_1 - (HEAP32[$4_1 + 916 >> 2] + ($3_1 >>> 0 > $17_1 >>> 0) | 0) | 0) + 262143 | 0;
      $5_1 = $33_1;
      HEAP32[$4_1 + 832 >> 2] = $5_1;
      $8_1 = $5_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 836 >> 2] = $8_1;
      $3_1 = HEAP32[$4_1 + 904 >> 2];
      $29_1 = ($19_1 - $3_1 | 0) - 4 | 0;
      $3_1 = ($27_1 - (HEAP32[$4_1 + 908 >> 2] + ($3_1 >>> 0 > $19_1 >>> 0) | 0) | 0) + 4194303 | 0;
      HEAP32[$4_1 + 824 >> 2] = $29_1;
      $21_1 = $29_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 828 >> 2] = $21_1;
      $3_1 = HEAP32[$4_1 + 896 >> 2];
      $31_1 = ($18_1 - $3_1 | 0) - 4 | 0;
      $3_1 = ($24_1 - (HEAP32[$4_1 + 900 >> 2] + ($3_1 >>> 0 > $18_1 >>> 0) | 0) | 0) + 4194303 | 0;
      HEAP32[$4_1 + 816 >> 2] = $31_1;
      $19_1 = $31_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 820 >> 2] = $19_1;
      $3_1 = HEAP32[$4_1 + 888 >> 2];
      $26_1 = ($20_1 - $3_1 | 0) - 4 | 0;
      $3_1 = ($23_1 - (HEAP32[$4_1 + 892 >> 2] + ($3_1 >>> 0 > $20_1 >>> 0) | 0) | 0) + 4194303 | 0;
      HEAP32[$4_1 + 808 >> 2] = $26_1;
      $17_1 = $26_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 812 >> 2] = $17_1;
      $3_1 = HEAP32[$4_1 + 880 >> 2];
      $28_1 = ($25_1 - $3_1 | 0) - 3908 | 0;
      $3_1 = ($22_1 - (HEAP32[$4_1 + 884 >> 2] + ($3_1 >>> 0 > $25_1 >>> 0) | 0) | 0) + 4194299 | 0;
      HEAP32[$4_1 + 800 >> 2] = $28_1;
      $25_1 = $28_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$4_1 + 804 >> 2] = $25_1;
      $4_1 = __wasm_i64_mul($7_1 >>> 16 | 0, 0, 977, 1) + $12_1 | 0;
      $3_1 = i64toi32_i32$HIGH_BITS + $10_1 | 0;
      $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $18_1 = $3_1 & 1048575;
      $35_1 = $18_1;
      label$4: {
        $33_1 = $4_1;
        $34_1 = $4_1 ^ 976;
        $32_1 = $18_1 ^ 1;
        if ((($34_1 | 0) != -1 | ($32_1 | 0) != 1048575) & ($4_1 | $18_1) != 0) {
          break label$4;
        }
        $30_1 = $7_1 & 65535;
        $4_1 = $3_1;
        $3_1 = $14_1;
        $4_1 = ($4_1 >>> 20 | 0) + $11_1 | 0;
        $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $23_1 = $4_1;
        $24_1 = $3_1;
        $3_1 = $13_1;
        $4_1 = ($24_1 >>> 20 | 0) + $16_1 | 0;
        $3_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $27_1 = $4_1;
        $22_1 = $3_1;
        $3_1 = $9_1;
        $4_1 = ($22_1 >>> 20 | 0) + $15_1 | 0;
        $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $20_1 = $4_1;
        $18_1 = $3_1;
        $3_1 = $30_1;
        $4_1 = $18_1 >>> 20 | 0;
        $30_1 = $4_1;
        $4_1 = $2_1 + $4_1 | 0;
        $3_1 = $30_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        if ($4_1 | ($20_1 | ($27_1 | ($23_1 | $33_1))) | ($3_1 | ($18_1 & 1048575 | ($22_1 & 1048575 | ($24_1 & 1048575 | $35_1))))) {
          if (($23_1 & $34_1 & $27_1 & $20_1 & $4_1) != -1) {
            $3_1 = 1;
          } else {
            $3_1 = ($24_1 & $32_1 & $22_1 & $18_1 & ($3_1 ^ 983040)) != 1048575;
          }
          if ($3_1) {
            break label$4;
          }
        }
        $2_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1) + $28_1 | 0;
        $3_1 = i64toi32_i32$HIGH_BITS + $25_1 | 0;
        $3_1 = $2_1 >>> 0 < $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $7_1 = $3_1 & 1048575;
        $16_1 = $7_1;
        label$6: {
          $4_1 = $2_1;
          $15_1 = $4_1 ^ 976;
          $11_1 = $7_1 ^ 1;
          if ((($15_1 | 0) != -1 | ($11_1 | 0) != 1048575) & ($4_1 | $7_1) != 0) {
            break label$6;
          }
          $13_1 = $8_1 & 65535;
          $2_1 = $3_1;
          $3_1 = $17_1;
          $2_1 = ($2_1 >>> 20 | 0) + $26_1 | 0;
          $3_1 = $2_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $9_1 = $2_1;
          $12_1 = $3_1;
          $3_1 = $19_1;
          $2_1 = ($12_1 >>> 20 | 0) + $31_1 | 0;
          $3_1 = $2_1 >>> 0 < $31_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $14_1 = $2_1;
          $10_1 = $3_1;
          $3_1 = $21_1;
          $2_1 = ($10_1 >>> 20 | 0) + $29_1 | 0;
          $3_1 = $2_1 >>> 0 < $29_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          $7_1 = $2_1;
          $8_1 = $3_1;
          $3_1 = $13_1;
          $2_1 = $8_1 >>> 20 | 0;
          $13_1 = $2_1;
          $2_1 = $2_1 + $5_1 | 0;
          $3_1 = $13_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
          if ($2_1 | ($7_1 | ($14_1 | ($4_1 | $9_1))) | ($3_1 | ($8_1 & 1048575 | ($10_1 & 1048575 | ($12_1 & 1048575 | $16_1))))) {
            if (($9_1 & $15_1 & $14_1 & $7_1 & $2_1) != -1) {
              $2_1 = 1;
            } else {
              $2_1 = ($12_1 & $11_1 & $10_1 & $8_1 & ($3_1 ^ 983040)) != 1048575;
            }
            if ($2_1) {
              break label$6;
            }
          }
          if (HEAP32[$1_1 + 120 >> 2]) {
            HEAP32[$0_1 + 120 >> 2] = 1;
            $68($0_1, 120);
            break label$1;
          }
          $55($0_1, $1_1);
          break label$1;
        }
        HEAP32[$0_1 + 120 >> 2] = 1;
        $68($0_1, 120);
        break label$1;
      }
      HEAP32[$0_1 + 120 >> 2] = 0;
      $36_1 = $6_1 + 840 | 0;
      $34($0_1 + 80 | 0, $45_1, $36_1);
      $27_1 = $6_1 + 312 | 0;
      $8_1 = $15_1;
      $5_1 = $9_1;
      $19_1 = $12_1 << 1;
      $9_1 = $10_1;
      $21_1 = $9_1 << 1 | $12_1 >>> 31;
      $69($27_1, $8_1, $5_1, 0, 0, $19_1, $21_1, 0, 0);
      $20_1 = $6_1 + 232 | 0;
      $4_1 = $16_1;
      $1_1 = $13_1;
      $10_1 = $11_1 << 1;
      $15_1 = $14_1;
      $17_1 = $11_1;
      $14_1 = $14_1 << 1 | $11_1 >>> 31;
      $69($20_1, $4_1, $1_1, 0, 0, $10_1, $14_1, 0, 0);
      $11_1 = $6_1 + 168 | 0;
      $69($11_1, $2_1, $7_1, 0, 0, $2_1, $7_1, 0, 0);
      $16_1 = $6_1 + 152 | 0;
      $69($16_1, HEAP32[$6_1 + 168 >> 2], HEAP32[$6_1 + 172 >> 2], 0, 0, 15632, 16, 0, 0);
      $3_1 = $7_1 << 1 | $2_1 >>> 31;
      $37_1 = $6_1 + 120 | 0;
      $18_1 = $2_1 << 1;
      $25_1 = $3_1;
      $69($37_1, $18_1, $3_1, 0, 0, $12_1, $9_1, 0, 0);
      $38_1 = $6_1 + 280 | 0;
      $69($38_1, $8_1, $5_1, 0, 0, $10_1, $14_1, 0, 0);
      $35_1 = $6_1 + 216 | 0;
      $69($35_1, $4_1, $1_1, 0, 0, $4_1, $1_1, 0, 0);
      $22_1 = $6_1 + 136 | 0;
      $2_1 = $11_1 + 8 | 0;
      $69($22_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $34_1 = $6_1 + 328 | 0;
      $69($34_1, $12_1, $9_1, 0, 0, $12_1, $9_1, 0, 0);
      $32_1 = $6_1 + 104 | 0;
      $69($32_1, $18_1, $3_1, 0, 0, $17_1, $15_1, 0, 0);
      $9_1 = $1_1;
      $33_1 = $4_1;
      $3_1 = $1_1 << 1 | $4_1 >>> 31;
      $30_1 = $6_1 + 184 | 0;
      $11_1 = $8_1;
      $13_1 = $5_1;
      $69($30_1, $8_1, $5_1, 0, 0, $4_1 << 1, $3_1, 0, 0);
      $14_1 = HEAP32[$6_1 + 316 >> 2];
      $3_1 = $14_1 + HEAP32[$6_1 + 236 >> 2] | 0;
      $5_1 = HEAP32[$6_1 + 312 >> 2];
      $2_1 = HEAP32[$6_1 + 232 >> 2];
      $1_1 = $5_1 + $2_1 | 0;
      $4_1 = HEAP32[$6_1 + 152 >> 2];
      $12_1 = $1_1 + $4_1 | 0;
      $2_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $2_1 + HEAP32[$6_1 + 156 >> 2] | 0;
      $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = ($2_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
      $3_1 = $16_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $8_1 = HEAP32[$3_1 + 4 >> 2];
      $5_1 = ($2_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
      $3_1 = $20_1 + 8 | 0;
      $2_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $14_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $2_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $5_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $8_1 | 0;
      $2_1 = $1_1;
      $1_1 = $1_1 + $7_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $10_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $10_1 = $4_1;
      $8_1 = $1_1 << 12 | $4_1 >>> 20;
      $2_1 = $3_1;
      $5_1 = $3_1 << 12 | $1_1 >>> 20;
      $29_1 = HEAP32[$6_1 + 280 >> 2];
      $1_1 = HEAP32[$6_1 + 216 >> 2];
      $14_1 = $29_1 + $1_1 | 0;
      $40_1 = HEAP32[$6_1 + 284 >> 2];
      $3_1 = $40_1 + HEAP32[$6_1 + 220 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 120 >> 2];
      $7_1 = $1_1 + $14_1 | 0;
      $20_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 124 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 136 >> 2];
      $4_1 = $1_1 + $7_1 | 0;
      $16_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 140 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $5_1 | 0;
      $31_1 = $6_1 + 88 | 0;
      $5_1 = $4_1 + $8_1 | 0;
      $8_1 = $5_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $26_1 = ($1_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
      $28_1 = ($1_1 | 0) == ($16_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $1_1 = $22_1 + 8 | 0;
      $23_1 = HEAP32[$1_1 >> 2];
      $24_1 = HEAP32[$1_1 + 4 >> 2];
      $27_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
      $1_1 = $37_1 + 8 | 0;
      $22_1 = HEAP32[$1_1 >> 2];
      $16_1 = HEAP32[$1_1 + 4 >> 2];
      $7_1 = ($20_1 | 0) == ($40_1 | 0) & $14_1 >>> 0 < $29_1 >>> 0 | $20_1 >>> 0 < $40_1 >>> 0;
      $3_1 = $35_1 + 8 | 0;
      $4_1 = HEAP32[$3_1 >> 2];
      $1_1 = $38_1 + 8 | 0;
      $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $14_1 | 0;
      $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $22_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1;
      $1_1 = $1_1 + $27_1 | 0;
      $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $24_1 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $23_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $1_1 + $28_1 | 0;
      $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $2_1 >>> 20 | 0;
      $1_1 = $2_1 + $4_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $26_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $8_1;
      $7_1 = $1_1 << 12 | $2_1 >>> 20;
      $4_1 = $3_1;
      $8_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 104 >> 2];
      $1_1 = HEAP32[$6_1 + 184 >> 2];
      $16_1 = $22_1 + $1_1 | 0;
      $26_1 = HEAP32[$6_1 + 108 >> 2];
      $3_1 = $26_1 + HEAP32[$6_1 + 188 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $8_1 | 0;
      $7_1 = $7_1 + $16_1 | 0;
      $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $20_1 = $7_1 << 4 & -16;
      $14_1 = $2_1;
      $8_1 = $3_1;
      $69($31_1, $20_1 | $2_1 >>> 16 & 15, ($3_1 << 4 | $7_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
      $28_1 = $6_1 + 264 | 0;
      $69($28_1, $17_1, $15_1, 0, 0, $19_1, $21_1, 0, 0);
      $23_1 = $6_1 + 72 | 0;
      $69($23_1, $18_1, $25_1, 0, 0, $33_1, $9_1, 0, 0);
      $24_1 = $6_1 + 296 | 0;
      $69($24_1, $11_1, $13_1, 0, 0, $11_1, $13_1, 0, 0);
      $27_1 = $6_1 + 56 | 0;
      $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $30_1 + 8 | 0;
      $2_1 = HEAP32[$3_1 >> 2];
      $1_1 = $32_1 + 8 | 0;
      $16_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $2_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $7_1 + $16_1 | 0;
      $3_1 = $2_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $4_1 >>> 20 | 0;
      $1_1 = $2_1 + $4_1 | 0;
      $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $20_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $8_1 >>> 20;
      $2_1 = $3_1;
      $4_1 = $3_1 << 12 | $1_1 >>> 20;
      $22_1 = HEAP32[$6_1 + 72 >> 2];
      $1_1 = HEAP32[$6_1 + 296 >> 2];
      $7_1 = $22_1 + $1_1 | 0;
      $26_1 = HEAP32[$6_1 + 76 >> 2];
      $3_1 = $26_1 + HEAP32[$6_1 + 300 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $4_1 | 0;
      $8_1 = $8_1 + $7_1 | 0;
      $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $4_1 = $3_1;
      $69($27_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $20_1 = $6_1 + 200 | 0;
      $69($20_1, $33_1, $9_1, 0, 0, $19_1, $21_1, 0, 0);
      $21_1 = $6_1 + 248 | 0;
      $69($21_1, $17_1, $15_1, 0, 0, $17_1, $15_1, 0, 0);
      $16_1 = $6_1 + 40 | 0;
      $69($16_1, $18_1, $25_1, 0, 0, $11_1, $13_1, 0, 0);
      $15_1 = $6_1 + 24 | 0;
      $13_1 = $15_1;
      $9_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $7_1 = ($1_1 | 0) == ($26_1 | 0) & $7_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $26_1 >>> 0;
      $3_1 = $24_1 + 8 | 0;
      $8_1 = HEAP32[$3_1 >> 2];
      $1_1 = $23_1 + 8 | 0;
      $11_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $7_1 + $11_1 | 0;
      $3_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $2_1 >>> 20 | 0;
      $1_1 = $2_1 + $8_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $9_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $8_1 = $1_1 << 12 | $4_1 >>> 20;
      $4_1 = HEAP32[$6_1 + 40 >> 2];
      $9_1 = $8_1 + $4_1 | 0;
      $2_1 = $3_1;
      $1_1 = $3_1 << 12 | $1_1 >>> 20;
      $3_1 = $1_1 + HEAP32[$6_1 + 44 >> 2] | 0;
      $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
      $19_1 = $6_1 + 8 | 0;
      $7_1 = $19_1;
      $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $1_1 = $16_1 + 8 | 0;
      $4_1 = HEAP32[$1_1 >> 2];
      $3_1 = HEAP32[$1_1 + 4 >> 2];
      $2_1 = $2_1 >>> 20 | 0;
      $1_1 = $2_1 + $4_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $8_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
      $9_1 = HEAP32[$6_1 + 92 >> 2];
      $3_1 = $9_1 + HEAP32[$6_1 + 332 >> 2] | 0;
      $7_1 = HEAP32[$6_1 + 88 >> 2];
      $2_1 = HEAP32[$6_1 + 328 >> 2];
      $1_1 = $7_1 + $2_1 | 0;
      HEAP32[$6_1 + 760 >> 2] = -3908 - $1_1;
      $4_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 764 >> 2] = 4194299 - (($4_1 & 1048575) + ($1_1 >>> 0 > 4294963388) | 0);
      $7_1 = ($4_1 | 0) == ($9_1 | 0) & $1_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
      $3_1 = $34_1 + 8 | 0;
      $2_1 = HEAP32[$3_1 >> 2];
      $1_1 = $31_1 + 8 | 0;
      $9_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $7_1 + $9_1 | 0;
      $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $2_1 = $3_1;
      $13_1 = $3_1 << 12 | $1_1 >>> 20;
      $16_1 = HEAP32[$6_1 + 60 >> 2];
      $3_1 = $16_1 + HEAP32[$6_1 + 268 >> 2] | 0;
      $11_1 = HEAP32[$6_1 + 56 >> 2];
      $1_1 = HEAP32[$6_1 + 264 >> 2];
      $4_1 = $11_1 + $1_1 | 0;
      $9_1 = $4_1;
      $7_1 = $4_1 + $7_1 | 0;
      $1_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $13_1 | 0;
      $4_1 = $7_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $7_1;
      HEAP32[$6_1 + 768 >> 2] = -4 - $3_1;
      HEAP32[$6_1 + 772 >> 2] = 4194303 - (($4_1 & 1048575) + ($3_1 >>> 0 > 4294967292) | 0);
      $13_1 = ($1_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $4_1 >>> 0;
      $9_1 = ($1_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
      $3_1 = $28_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $27_1 + 8 | 0;
      $11_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $9_1 + $11_1 | 0;
      $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $2_1 >>> 20 | 0;
      $1_1 = $2_1 + $7_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $13_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $2_1 = $3_1;
      $4_1 = $3_1 << 12 | $1_1 >>> 20;
      $17_1 = HEAP32[$6_1 + 200 >> 2];
      $1_1 = HEAP32[$6_1 + 248 >> 2];
      $13_1 = $17_1 + $1_1 | 0;
      $18_1 = HEAP32[$6_1 + 204 >> 2];
      $3_1 = $18_1 + HEAP32[$6_1 + 252 >> 2] | 0;
      $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$6_1 + 24 >> 2];
      $9_1 = $1_1 + $13_1 | 0;
      $11_1 = $3_1;
      $3_1 = $3_1 + HEAP32[$6_1 + 28 >> 2] | 0;
      $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + $4_1 | 0;
      $7_1 = $7_1 + $9_1 | 0;
      $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 776 >> 2] = -4 - $7_1;
      $4_1 = $3_1;
      HEAP32[$6_1 + 780 >> 2] = 4194303 - (($3_1 & 1048575) + ($7_1 >>> 0 > 4294967292) | 0);
      $25_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
      $33_1 = ($1_1 | 0) == ($11_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $11_1 >>> 0;
      $1_1 = $15_1 + 8 | 0;
      $16_1 = HEAP32[$1_1 >> 2];
      $15_1 = HEAP32[$1_1 + 4 >> 2];
      $9_1 = ($11_1 | 0) == ($18_1 | 0) & $13_1 >>> 0 < $17_1 >>> 0 | $11_1 >>> 0 < $18_1 >>> 0;
      $3_1 = $21_1 + 8 | 0;
      $7_1 = HEAP32[$3_1 >> 2];
      $1_1 = $20_1 + 8 | 0;
      $13_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
      $3_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $9_1 + $13_1 | 0;
      $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $15_1 | 0;
      $8_1 = $1_1;
      $1_1 = $1_1 + $16_1 | 0;
      $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 + $33_1 | 0;
      $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $2_1 >>> 20 | 0;
      $1_1 = $2_1 + $7_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $25_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $7_1 = $1_1 << 12 | $4_1 >>> 20;
      $2_1 = $3_1;
      $11_1 = $3_1 << 12 | $1_1 >>> 20;
      $15_1 = HEAP32[$6_1 + 12 >> 2];
      $3_1 = $15_1 + ($10_1 & 1048575) | 0;
      $13_1 = HEAP32[$6_1 + 8 >> 2];
      $4_1 = $12_1 & -2;
      $1_1 = $13_1 + $4_1 | 0;
      $12_1 = $1_1;
      $7_1 = $1_1 + $7_1 | 0;
      $9_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $9_1 + $11_1 | 0;
      HEAP32[$6_1 + 784 >> 2] = -4 - $7_1;
      $1_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 788 >> 2] = 4194303 - (($1_1 & 1048575) + ($7_1 >>> 0 > 4294967292) | 0);
      $4_1 = $6_1;
      $10_1 = $5_1;
      $14_1 = $14_1 & 65535;
      $7_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
      $5_1 = ($9_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $9_1 >>> 0 < $15_1 >>> 0;
      $3_1 = $19_1 + 8 | 0;
      $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2];
      $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $2_1 = $2_1 >>> 20 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $8_1 | 0;
      $3_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $3_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = $2_1 << 12 | $1_1 >>> 20;
      $5_1 = $1_1 + $10_1 | 0;
      $3_1 = $14_1 + ($3_1 << 12 | $2_1 >>> 20) | 0;
      HEAP32[$4_1 + 792 >> 2] = -4 - $5_1;
      HEAP32[$4_1 + 796 >> 2] = 262143 - (($5_1 >>> 0 > 4294967292) + ($1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0);
      $23_1 = $4_1 + 720 | 0;
      $1_1 = $4_1 + 760 | 0;
      $34($23_1, $1_1, $36_1);
      $27_1 = $4_1 + 680 | 0;
      $34($27_1, $4_1 + 1e3 | 0, $1_1);
      $22_1 = $4_1 + 800 | 0;
      $54($0_1, $22_1);
      $1_1 = HEAP32[$4_1 + 752 >> 2];
      $5_1 = $1_1 + HEAP32[$0_1 + 32 >> 2] | 0;
      $3_1 = HEAP32[$0_1 + 36 >> 2] + HEAP32[$4_1 + 756 >> 2] | 0;
      $2_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $1_1 = HEAP32[$4_1 + 712 >> 2];
      $20_1 = $1_1;
      $3_1 = HEAP32[$4_1 + 716 >> 2];
      $18_1 = $3_1;
      $3_1 = ($3_1 << 1 | $1_1 >>> 31) + $2_1 | 0;
      $1_1 = $1_1 << 1;
      $2_1 = $1_1;
      $1_1 = $1_1 + $5_1 | 0;
      $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $11_1 = $1_1;
      HEAP32[$0_1 + 32 >> 2] = $1_1;
      $12_1 = $3_1;
      HEAP32[$0_1 + 36 >> 2] = $3_1;
      $1_1 = $0_1;
      $0_1 = HEAP32[$4_1 + 744 >> 2];
      $5_1 = $0_1 + HEAP32[$1_1 + 24 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 28 >> 2] + HEAP32[$4_1 + 748 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = HEAP32[$4_1 + 704 >> 2];
      $21_1 = $0_1;
      $3_1 = HEAP32[$4_1 + 708 >> 2];
      $19_1 = $3_1;
      $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
      $0_1 = $0_1 << 1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $5_1 | 0;
      $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $13_1 = $0_1;
      HEAP32[$1_1 + 24 >> 2] = $0_1;
      $14_1 = $3_1;
      HEAP32[$1_1 + 28 >> 2] = $3_1;
      $0_1 = HEAP32[$4_1 + 736 >> 2];
      $5_1 = $0_1 + HEAP32[$1_1 + 16 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 20 >> 2] + HEAP32[$4_1 + 740 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = HEAP32[$4_1 + 696 >> 2];
      $17_1 = $0_1;
      $3_1 = HEAP32[$4_1 + 700 >> 2];
      $25_1 = $3_1;
      $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
      $0_1 = $0_1 << 1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $5_1 | 0;
      $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $9_1 = $0_1;
      HEAP32[$1_1 + 16 >> 2] = $0_1;
      $10_1 = $3_1;
      HEAP32[$1_1 + 20 >> 2] = $3_1;
      $0_1 = HEAP32[$4_1 + 728 >> 2];
      $2_1 = $0_1 + HEAP32[$1_1 + 8 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 12 >> 2] + HEAP32[$4_1 + 732 >> 2] | 0;
      $0_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = HEAP32[$4_1 + 692 >> 2];
      $33_1 = $3_1;
      $24_1 = HEAP32[$4_1 + 688 >> 2];
      $5_1 = $24_1;
      $3_1 = ($3_1 << 1 | $5_1 >>> 31) + $0_1 | 0;
      $5_1 = $5_1 << 1;
      $7_1 = $2_1 + $5_1 | 0;
      $3_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$1_1 + 8 >> 2] = $7_1;
      $8_1 = $3_1;
      HEAP32[$1_1 + 12 >> 2] = $3_1;
      $0_1 = HEAP32[$4_1 + 720 >> 2];
      $5_1 = $0_1 + HEAP32[$1_1 >> 2] | 0;
      $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 724 >> 2] | 0;
      $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = HEAP32[$4_1 + 680 >> 2];
      $16_1 = $0_1;
      $3_1 = HEAP32[$4_1 + 684 >> 2];
      $15_1 = $3_1;
      $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
      $0_1 = $0_1 << 1;
      $2_1 = $0_1;
      $0_1 = $0_1 + $5_1 | 0;
      $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $5_1 = $0_1;
      HEAP32[$1_1 >> 2] = $5_1;
      $2_1 = $3_1;
      HEAP32[$1_1 + 4 >> 2] = $3_1;
      $3_1 = $12_1 + $18_1 | 0;
      $4_1 = $11_1 + $20_1 | 0;
      $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 712 >> 2] = $4_1;
      HEAP32[$6_1 + 716 >> 2] = $3_1;
      $3_1 = $14_1 + $19_1 | 0;
      $4_1 = $13_1 + $21_1 | 0;
      $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 704 >> 2] = $4_1;
      HEAP32[$6_1 + 708 >> 2] = $3_1;
      $3_1 = $10_1 + $25_1 | 0;
      $4_1 = $9_1 + $17_1 | 0;
      $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 696 >> 2] = $4_1;
      HEAP32[$6_1 + 700 >> 2] = $3_1;
      $3_1 = $8_1 + $33_1 | 0;
      $4_1 = $7_1 + $24_1 | 0;
      $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 688 >> 2] = $4_1;
      HEAP32[$6_1 + 692 >> 2] = $3_1;
      $3_1 = $2_1 + $15_1 | 0;
      $0_1 = $5_1 + $16_1 | 0;
      $3_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      HEAP32[$6_1 + 680 >> 2] = $0_1;
      HEAP32[$6_1 + 684 >> 2] = $3_1;
      $34($1_1 + 40 | 0, $27_1, $22_1);
      $34($23_1, $23_1, $6_1 + 920 | 0);
      $3_1 = HEAP32[$1_1 + 44 >> 2] + HEAP32[$6_1 + 724 >> 2] | 0;
      $0_1 = HEAP32[$6_1 + 720 >> 2];
      $2_1 = $0_1 + HEAP32[$1_1 + 40 >> 2] | 0;
      HEAP32[$1_1 + 40 >> 2] = $2_1;
      HEAP32[$1_1 + 44 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + 48 | 0;
      $4_1 = $3_1;
      $0_1 = HEAP32[$6_1 + 728 >> 2];
      $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 732 >> 2] | 0;
      HEAP32[$4_1 >> 2] = $2_1;
      HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 + 56 | 0;
      $4_1 = $3_1;
      $0_1 = HEAP32[$6_1 + 736 >> 2];
      $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 740 >> 2] | 0;
      HEAP32[$4_1 >> 2] = $2_1;
      HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $3_1 = $1_1 - -64 | 0;
      $4_1 = $3_1;
      $0_1 = HEAP32[$6_1 + 744 >> 2];
      $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
      $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 748 >> 2] | 0;
      HEAP32[$4_1 >> 2] = $2_1;
      HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
      $0_1 = HEAP32[$6_1 + 752 >> 2];
      $2_1 = $1_1 + 72 | 0;
      $1_1 = $0_1 + HEAP32[$2_1 >> 2] | 0;
      $3_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$6_1 + 756 >> 2] | 0;
      HEAP32[$2_1 >> 2] = $1_1;
      HEAP32[$2_1 + 4 >> 2] = $0_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    }
    global$0 = $6_1 + 1120 | 0;
  }
  function $65($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
    $8_1 = global$0 - 736 | 0;
    global$0 = $8_1;
    $4_1 = HEAP32[$2_1 + 80 >> 2];
    label$1: {
      if (HEAP32[$1_1 + 120 >> 2]) {
        HEAP32[$0_1 + 120 >> 2] = $4_1;
        $1_1 = HEAP32[$2_1 + 4 >> 2];
        HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
        HEAP32[$0_1 + 4 >> 2] = $1_1;
        $1_1 = $2_1 + 8 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 + 8 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = $2_1 + 16 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 + 16 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = $2_1 + 24 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 + 24 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = $2_1 + 32 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 + 32 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = HEAP32[$2_1 + 44 >> 2];
        HEAP32[$0_1 + 40 >> 2] = HEAP32[$2_1 + 40 >> 2];
        HEAP32[$0_1 + 44 >> 2] = $1_1;
        $1_1 = $2_1 + 48 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 + 48 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = $2_1 + 56 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 + 56 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = $2_1 - -64 | 0;
        $3_1 = HEAP32[$1_1 + 4 >> 2];
        $4_1 = $0_1 - -64 | 0;
        HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$4_1 + 4 >> 2] = $3_1;
        $1_1 = $2_1 + 72 | 0;
        $2_1 = HEAP32[$1_1 + 4 >> 2];
        $3_1 = $0_1 + 72 | 0;
        HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $2_1;
        $1_1 = $0_1 + 88 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        HEAP32[$0_1 + 80 >> 2] = 1;
        HEAP32[$0_1 + 84 >> 2] = 0;
        $1_1 = $0_1 + 96 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $1_1 = $0_1 + 104 | 0;
        HEAP32[$1_1 >> 2] = 0;
        HEAP32[$1_1 + 4 >> 2] = 0;
        $0_1 = $0_1 + 112 | 0;
        HEAP32[$0_1 >> 2] = 0;
        HEAP32[$0_1 + 4 >> 2] = 0;
        break label$1;
      }
      if ($4_1) {
        if ($3_1) {
          HEAP32[$3_1 + 8 >> 2] = 0;
          HEAP32[$3_1 + 12 >> 2] = 0;
          HEAP32[$3_1 >> 2] = 1;
          HEAP32[$3_1 + 4 >> 2] = 0;
          $2_1 = $3_1 + 16 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $3_1 + 24 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
          $2_1 = $3_1 + 32 | 0;
          HEAP32[$2_1 >> 2] = 0;
          HEAP32[$2_1 + 4 >> 2] = 0;
        }
        $70($0_1, $1_1, 128);
        break label$1;
      }
      $18_1 = $8_1 + 696 | 0;
      $30_1 = $1_1 + 80 | 0;
      $54($18_1, $30_1);
      $14_1 = $8_1 + 656 | 0;
      $10_1 = $14_1 + 8 | 0;
      $4_1 = $1_1 + 8 | 0;
      $7_1 = HEAP32[$4_1 >> 2];
      $12_1 = HEAP32[$4_1 + 4 >> 2];
      $6_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $1_1 + 32 | 0;
      $11_1 = HEAP32[$4_1 >> 2];
      $9_1 = HEAP32[$4_1 + 4 >> 2];
      $17_1 = $9_1;
      $4_1 = HEAP32[$1_1 >> 2];
      $9_1 = __wasm_i64_mul($9_1 >>> 16 | 0, 0, 977, 1);
      $5_1 = $4_1 + $9_1 | 0;
      $4_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
      $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $12_1;
      $6_1 = $9_1 >>> 20 | 0;
      $12_1 = $6_1;
      $6_1 = $6_1 + $7_1 | 0;
      $4_1 = $12_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$10_1 >> 2] = $6_1;
      $19_1 = $4_1 & 1048575;
      HEAP32[$10_1 + 4 >> 2] = $19_1;
      $7_1 = $14_1 + 16 | 0;
      $10_1 = $1_1 + 16 | 0;
      $12_1 = HEAP32[$10_1 >> 2];
      $15_1 = HEAP32[$10_1 + 4 >> 2];
      $10_1 = $4_1;
      $4_1 = $15_1;
      $10_1 = $10_1 >>> 20 | 0;
      $13_1 = $10_1;
      $10_1 = $10_1 + $12_1 | 0;
      $4_1 = $13_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$7_1 >> 2] = $10_1;
      $28_1 = $4_1 & 1048575;
      HEAP32[$7_1 + 4 >> 2] = $28_1;
      $12_1 = $14_1 + 24 | 0;
      $7_1 = $1_1 + 24 | 0;
      $15_1 = HEAP32[$7_1 >> 2];
      $13_1 = HEAP32[$7_1 + 4 >> 2];
      $7_1 = $4_1;
      $4_1 = $13_1;
      $7_1 = $7_1 >>> 20 | 0;
      $13_1 = $7_1;
      $7_1 = $7_1 + $15_1 | 0;
      $4_1 = $13_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$12_1 >> 2] = $7_1;
      $24_1 = $4_1 & 1048575;
      HEAP32[$12_1 + 4 >> 2] = $24_1;
      $12_1 = $14_1 + 32 | 0;
      $14_1 = $4_1;
      $4_1 = $17_1 & 65535;
      $14_1 = $14_1 >>> 20 | 0;
      $17_1 = $11_1 + $14_1 | 0;
      $4_1 = $14_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$12_1 >> 2] = $17_1;
      $21_1 = $4_1;
      HEAP32[$12_1 + 4 >> 2] = $4_1;
      $11_1 = $5_1;
      HEAP32[$8_1 + 656 >> 2] = $5_1;
      $20_1 = $9_1 & 1048575;
      HEAP32[$8_1 + 660 >> 2] = $20_1;
      $34($8_1 + 616 | 0, $2_1, $18_1);
      $15_1 = $8_1 + 576 | 0;
      $12_1 = $15_1 + 8 | 0;
      $4_1 = $1_1 + 48 | 0;
      $16_1 = HEAP32[$4_1 >> 2];
      $22_1 = HEAP32[$4_1 + 4 >> 2];
      $14_1 = HEAP32[$1_1 + 44 >> 2];
      $4_1 = $1_1 + 72 | 0;
      $9_1 = HEAP32[$4_1 >> 2];
      $13_1 = HEAP32[$4_1 + 4 >> 2];
      $23_1 = $13_1;
      $4_1 = HEAP32[$1_1 + 40 >> 2];
      $13_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1);
      $5_1 = $4_1 + $13_1 | 0;
      $4_1 = $14_1 + i64toi32_i32$HIGH_BITS | 0;
      $14_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $22_1;
      $13_1 = $14_1 >>> 20 | 0;
      $22_1 = $13_1 + $16_1 | 0;
      $4_1 = $13_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$12_1 >> 2] = $22_1;
      $31_1 = $4_1 & 1048575;
      HEAP32[$12_1 + 4 >> 2] = $31_1;
      $13_1 = $15_1 + 16 | 0;
      $12_1 = $1_1 + 56 | 0;
      $16_1 = HEAP32[$12_1 >> 2];
      $25_1 = HEAP32[$12_1 + 4 >> 2];
      $12_1 = $4_1;
      $4_1 = $25_1;
      $12_1 = $12_1 >>> 20 | 0;
      $25_1 = $12_1 + $16_1 | 0;
      $4_1 = $12_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$13_1 >> 2] = $25_1;
      $27_1 = $4_1 & 1048575;
      HEAP32[$13_1 + 4 >> 2] = $27_1;
      $13_1 = $15_1 + 24 | 0;
      $12_1 = $1_1 - -64 | 0;
      $16_1 = HEAP32[$12_1 >> 2];
      $26_1 = HEAP32[$12_1 + 4 >> 2];
      $12_1 = $4_1;
      $4_1 = $26_1;
      $12_1 = $12_1 >>> 20 | 0;
      $26_1 = $12_1 + $16_1 | 0;
      $4_1 = $12_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$13_1 >> 2] = $26_1;
      $29_1 = $4_1 & 1048575;
      HEAP32[$13_1 + 4 >> 2] = $29_1;
      $15_1 = $15_1 + 32 | 0;
      $12_1 = $4_1;
      $4_1 = $23_1 & 65535;
      $12_1 = $12_1 >>> 20 | 0;
      $13_1 = $9_1 + $12_1 | 0;
      $4_1 = $12_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$15_1 >> 2] = $13_1;
      $16_1 = $4_1;
      HEAP32[$15_1 + 4 >> 2] = $4_1;
      $23_1 = $5_1;
      HEAP32[$8_1 + 576 >> 2] = $5_1;
      $32_1 = $14_1 & 1048575;
      HEAP32[$8_1 + 580 >> 2] = $32_1;
      $4_1 = $8_1 + 536 | 0;
      $34($4_1, $2_1 + 40 | 0, $18_1);
      $34($4_1, $4_1, $30_1);
      $2_1 = HEAP32[$8_1 + 616 >> 2];
      $9_1 = ($2_1 - $11_1 | 0) - 3908 | 0;
      $4_1 = (HEAP32[$8_1 + 620 >> 2] - (($2_1 >>> 0 < $11_1 >>> 0) + $20_1 | 0) | 0) + 4194299 | 0;
      HEAP32[$8_1 + 496 >> 2] = $9_1;
      $12_1 = $9_1 >>> 0 < 4294963388 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 500 >> 2] = $12_1;
      $2_1 = $8_1;
      $4_1 = HEAP32[$2_1 + 624 >> 2];
      $11_1 = ($4_1 - $6_1 | 0) - 4 | 0;
      $4_1 = (HEAP32[$2_1 + 628 >> 2] - (($4_1 >>> 0 < $6_1 >>> 0) + $19_1 | 0) | 0) + 4194303 | 0;
      HEAP32[$2_1 + 504 >> 2] = $11_1;
      $14_1 = $11_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$2_1 + 508 >> 2] = $14_1;
      $4_1 = HEAP32[$2_1 + 632 >> 2];
      $5_1 = ($4_1 - $10_1 | 0) - 4 | 0;
      $4_1 = (HEAP32[$2_1 + 636 >> 2] - (($4_1 >>> 0 < $10_1 >>> 0) + $28_1 | 0) | 0) + 4194303 | 0;
      HEAP32[$2_1 + 512 >> 2] = $5_1;
      $10_1 = $5_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$2_1 + 516 >> 2] = $10_1;
      $4_1 = HEAP32[$2_1 + 640 >> 2];
      $6_1 = ($4_1 - $7_1 | 0) - 4 | 0;
      $4_1 = (HEAP32[$2_1 + 644 >> 2] - (($4_1 >>> 0 < $7_1 >>> 0) + $24_1 | 0) | 0) + 4194303 | 0;
      HEAP32[$2_1 + 520 >> 2] = $6_1;
      $7_1 = $6_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$2_1 + 524 >> 2] = $7_1;
      $4_1 = HEAP32[$2_1 + 648 >> 2];
      $2_1 = ($4_1 - $17_1 | 0) - 4 | 0;
      $4_1 = (HEAP32[$8_1 + 652 >> 2] - (($4_1 >>> 0 < $17_1 >>> 0) + $21_1 | 0) | 0) + 262143 | 0;
      HEAP32[$8_1 + 528 >> 2] = $2_1;
      $17_1 = $2_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 532 >> 2] = $17_1;
      $4_1 = HEAP32[$8_1 + 568 >> 2];
      $21_1 = ($13_1 - $4_1 | 0) - 4 | 0;
      $4_1 = ($16_1 - (HEAP32[$8_1 + 572 >> 2] + ($4_1 >>> 0 > $13_1 >>> 0) | 0) | 0) + 262143 | 0;
      HEAP32[$8_1 + 488 >> 2] = $21_1;
      $13_1 = $21_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 492 >> 2] = $13_1;
      $4_1 = HEAP32[$8_1 + 560 >> 2];
      $16_1 = ($26_1 - $4_1 | 0) - 4 | 0;
      $4_1 = ($29_1 - (HEAP32[$8_1 + 564 >> 2] + ($4_1 >>> 0 > $26_1 >>> 0) | 0) | 0) + 4194303 | 0;
      $26_1 = $16_1;
      HEAP32[$8_1 + 480 >> 2] = $16_1;
      $29_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 484 >> 2] = $29_1;
      $4_1 = HEAP32[$8_1 + 552 >> 2];
      $16_1 = ($25_1 - $4_1 | 0) - 4 | 0;
      $4_1 = ($27_1 - (HEAP32[$8_1 + 556 >> 2] + ($4_1 >>> 0 > $25_1 >>> 0) | 0) | 0) + 4194303 | 0;
      $25_1 = $16_1;
      HEAP32[$8_1 + 472 >> 2] = $16_1;
      $27_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 476 >> 2] = $27_1;
      $4_1 = HEAP32[$8_1 + 544 >> 2];
      $16_1 = ($22_1 - $4_1 | 0) - 4 | 0;
      $4_1 = ($31_1 - (HEAP32[$8_1 + 548 >> 2] + ($4_1 >>> 0 > $22_1 >>> 0) | 0) | 0) + 4194303 | 0;
      HEAP32[$8_1 + 464 >> 2] = $16_1;
      $31_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 468 >> 2] = $31_1;
      $4_1 = HEAP32[$8_1 + 536 >> 2];
      $15_1 = ($23_1 - $4_1 | 0) - 3908 | 0;
      $4_1 = ($32_1 - (HEAP32[$8_1 + 540 >> 2] + ($4_1 >>> 0 > $23_1 >>> 0) | 0) | 0) + 4194299 | 0;
      $22_1 = $15_1;
      HEAP32[$8_1 + 456 >> 2] = $15_1;
      $32_1 = $15_1 >>> 0 < 4294963388 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 460 >> 2] = $32_1;
      $15_1 = __wasm_i64_mul($17_1 >>> 16 | 0, 0, 977, 1) + $9_1 | 0;
      $4_1 = i64toi32_i32$HIGH_BITS + $12_1 | 0;
      $4_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $23_1 = $4_1 & 1048575;
      $33_1 = $23_1;
      label$5: {
        $34_1 = $15_1;
        $35_1 = $15_1 ^ 976;
        $36_1 = $23_1 ^ 1;
        if ((($35_1 | 0) != -1 | ($36_1 | 0) != 1048575) & ($15_1 | $23_1) != 0) {
          break label$5;
        }
        $20_1 = $17_1 & 65535;
        $15_1 = $4_1;
        $4_1 = $14_1;
        $15_1 = ($15_1 >>> 20 | 0) + $11_1 | 0;
        $23_1 = $15_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $10_1;
        $18_1 = ($23_1 >>> 20 | 0) + $5_1 | 0;
        $19_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $7_1;
        $28_1 = ($19_1 >>> 20 | 0) + $6_1 | 0;
        $24_1 = $28_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $4_1 = $20_1;
        $20_1 = $24_1 >>> 20 | 0;
        $37_1 = $20_1;
        $20_1 = $2_1 + $20_1 | 0;
        $4_1 = $37_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        if ($20_1 | ($28_1 | ($18_1 | ($15_1 | $34_1))) | ($4_1 | ($24_1 & 1048575 | ($19_1 & 1048575 | ($23_1 & 1048575 | $33_1))))) {
          if (($15_1 & $35_1 & $18_1 & $28_1 & $20_1) != -1) {
            $4_1 = 1;
          } else {
            $4_1 = ($23_1 & $36_1 & $19_1 & $24_1 & ($4_1 ^ 983040)) != 1048575;
          }
          if ($4_1) {
            break label$5;
          }
        }
        $2_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1) + $22_1 | 0;
        $4_1 = i64toi32_i32$HIGH_BITS + $32_1 | 0;
        $4_1 = $2_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
        $5_1 = $4_1 & 1048575;
        $12_1 = $5_1;
        label$7: {
          $14_1 = $2_1;
          $17_1 = $2_1 ^ 976;
          $15_1 = $5_1 ^ 1;
          if ((($17_1 | 0) != -1 | ($15_1 | 0) != 1048575) & ($2_1 | $5_1) != 0) {
            break label$7;
          }
          $13_1 = $13_1 & 65535;
          $2_1 = $4_1;
          $4_1 = $31_1;
          $2_1 = ($2_1 >>> 20 | 0) + $16_1 | 0;
          $5_1 = $2_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $27_1;
          $6_1 = ($5_1 >>> 20 | 0) + $25_1 | 0;
          $11_1 = $6_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $29_1;
          $10_1 = ($11_1 >>> 20 | 0) + $26_1 | 0;
          $7_1 = $10_1 >>> 0 < $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          $4_1 = $13_1;
          $9_1 = $7_1 >>> 20 | 0;
          $13_1 = $9_1;
          $9_1 = $9_1 + $21_1 | 0;
          $4_1 = $13_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
          if ($9_1 | ($10_1 | ($6_1 | ($2_1 | $14_1))) | ($4_1 | ($7_1 & 1048575 | ($11_1 & 1048575 | ($5_1 & 1048575 | $12_1))))) {
            if (($2_1 & $17_1 & $6_1 & $10_1 & $9_1) != -1) {
              $2_1 = 1;
            } else {
              $2_1 = ($5_1 & $15_1 & $11_1 & $7_1 & ($4_1 ^ 983040)) != 1048575;
            }
            if ($2_1) {
              break label$7;
            }
          }
          if (HEAP32[$1_1 + 120 >> 2]) {
            HEAP32[$0_1 + 120 >> 2] = 1;
            $68($0_1, 120);
            if (!$3_1) {
              break label$1;
            }
            HEAP32[$3_1 + 8 >> 2] = 0;
            HEAP32[$3_1 + 12 >> 2] = 0;
            HEAP32[$3_1 >> 2] = 1;
            HEAP32[$3_1 + 4 >> 2] = 0;
            $0_1 = $3_1 + 16 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $3_1 + 24 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            $0_1 = $3_1 + 32 | 0;
            HEAP32[$0_1 >> 2] = 0;
            HEAP32[$0_1 + 4 >> 2] = 0;
            break label$1;
          }
          if ($3_1) {
            $2_1 = $1_1 + 40 | 0;
            $4_1 = HEAP32[$2_1 >> 2];
            $5_1 = HEAP32[$2_1 + 4 >> 2];
            HEAP32[$3_1 >> 2] = $4_1;
            HEAP32[$3_1 + 4 >> 2] = $5_1;
            $6_1 = $2_1 + 8 | 0;
            $11_1 = HEAP32[$6_1 >> 2];
            $14_1 = $11_1;
            $10_1 = HEAP32[$6_1 + 4 >> 2];
            $12_1 = $10_1;
            $6_1 = $3_1 + 8 | 0;
            HEAP32[$6_1 >> 2] = $11_1;
            HEAP32[$6_1 + 4 >> 2] = $10_1;
            $11_1 = $2_1 + 16 | 0;
            $10_1 = HEAP32[$11_1 >> 2];
            $17_1 = $10_1;
            $7_1 = HEAP32[$11_1 + 4 >> 2];
            $15_1 = $7_1;
            $11_1 = $3_1 + 16 | 0;
            HEAP32[$11_1 >> 2] = $10_1;
            HEAP32[$11_1 + 4 >> 2] = $7_1;
            $10_1 = $2_1 + 24 | 0;
            $7_1 = HEAP32[$10_1 >> 2];
            $13_1 = $7_1;
            $9_1 = HEAP32[$10_1 + 4 >> 2];
            $21_1 = $9_1;
            $10_1 = $3_1 + 24 | 0;
            HEAP32[$10_1 >> 2] = $7_1;
            HEAP32[$10_1 + 4 >> 2] = $9_1;
            $2_1 = $2_1 + 32 | 0;
            $7_1 = HEAP32[$2_1 >> 2];
            $2_1 = HEAP32[$2_1 + 4 >> 2];
            $9_1 = $3_1 + 32 | 0;
            HEAP32[$9_1 >> 2] = $7_1;
            HEAP32[$9_1 + 4 >> 2] = $2_1;
            $22_1 = __wasm_i64_mul($2_1 >>> 16 | 0, 0, 977, 1);
            $16_1 = $22_1 + $4_1 | 0;
            $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
            HEAP32[$3_1 >> 2] = $16_1;
            $4_1 = $16_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$3_1 + 4 >> 2] = $4_1 & 1048575;
            $3_1 = $4_1;
            $4_1 = $12_1;
            $3_1 = $3_1 >>> 20 | 0;
            $5_1 = $3_1;
            $3_1 = $3_1 + $14_1 | 0;
            $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$6_1 >> 2] = $3_1;
            HEAP32[$6_1 + 4 >> 2] = $4_1 & 1048575;
            $3_1 = $4_1;
            $4_1 = $15_1;
            $3_1 = $3_1 >>> 20 | 0;
            $5_1 = $3_1;
            $3_1 = $3_1 + $17_1 | 0;
            $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$11_1 >> 2] = $3_1;
            HEAP32[$11_1 + 4 >> 2] = $4_1 & 1048575;
            $3_1 = $4_1;
            $4_1 = $21_1;
            $3_1 = $3_1 >>> 20 | 0;
            $5_1 = $3_1;
            $3_1 = $3_1 + $13_1 | 0;
            $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$10_1 >> 2] = $3_1;
            HEAP32[$10_1 + 4 >> 2] = $4_1 & 1048575;
            $3_1 = $2_1 & 65535;
            $2_1 = $4_1;
            $4_1 = $3_1;
            $2_1 = $2_1 >>> 20 | 0;
            $3_1 = $2_1;
            $2_1 = $2_1 + $7_1 | 0;
            $4_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
            HEAP32[$9_1 >> 2] = $2_1;
            HEAP32[$9_1 + 4 >> 2] = $4_1;
          }
          $55($0_1, $1_1);
          break label$1;
        }
        if ($3_1) {
          HEAP32[$3_1 >> 2] = 0;
          HEAP32[$3_1 + 4 >> 2] = 0;
          $1_1 = $3_1 + 32 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $3_1 + 24 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $3_1 + 16 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
          $1_1 = $3_1 + 8 | 0;
          HEAP32[$1_1 >> 2] = 0;
          HEAP32[$1_1 + 4 >> 2] = 0;
        }
        HEAP32[$0_1 + 120 >> 2] = 1;
        $68($0_1, 120);
        break label$1;
      }
      HEAP32[$0_1 + 120 >> 2] = 0;
      if ($3_1) {
        $1_1 = HEAP32[$8_1 + 500 >> 2];
        HEAP32[$3_1 >> 2] = HEAP32[$8_1 + 496 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $1_1;
        $1_1 = $8_1 + 496 | 0;
        $4_1 = $1_1 + 32 | 0;
        $15_1 = HEAP32[$4_1 + 4 >> 2];
        $13_1 = $3_1 + 32 | 0;
        HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$13_1 + 4 >> 2] = $15_1;
        $4_1 = $1_1 + 24 | 0;
        $15_1 = HEAP32[$4_1 + 4 >> 2];
        $13_1 = $3_1 + 24 | 0;
        HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$13_1 + 4 >> 2] = $15_1;
        $4_1 = $1_1 + 16 | 0;
        $15_1 = HEAP32[$4_1 + 4 >> 2];
        $13_1 = $3_1 + 16 | 0;
        HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
        HEAP32[$13_1 + 4 >> 2] = $15_1;
        $1_1 = $1_1 + 8 | 0;
        $4_1 = HEAP32[$1_1 + 4 >> 2];
        $3_1 = $3_1 + 8 | 0;
        HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2];
        HEAP32[$3_1 + 4 >> 2] = $4_1;
      }
      $28_1 = $8_1 + 496 | 0;
      $34($0_1 + 80 | 0, $30_1, $28_1);
      $23_1 = $8_1 + 304 | 0;
      $15_1 = $9_1 << 1;
      $1_1 = $12_1;
      $12_1 = $1_1 << 1 | $9_1 >>> 31;
      $69($23_1, $6_1, $7_1, 0, 0, $15_1, $12_1, 0, 0);
      $18_1 = $8_1 + 224 | 0;
      $3_1 = $11_1 << 1;
      $21_1 = $14_1;
      $14_1 = $11_1;
      $13_1 = $21_1 << 1 | $11_1 >>> 31;
      $69($18_1, $5_1, $10_1, 0, 0, $3_1, $13_1, 0, 0);
      $16_1 = $8_1 + 160 | 0;
      $69($16_1, $2_1, $17_1, 0, 0, $2_1, $17_1, 0, 0);
      $19_1 = $8_1 + 144 | 0;
      $69($19_1, HEAP32[$8_1 + 160 >> 2], HEAP32[$8_1 + 164 >> 2], 0, 0, 15632, 16, 0, 0);
      $24_1 = $8_1 + 112 | 0;
      $11_1 = $2_1 << 1;
      $17_1 = $17_1 << 1 | $2_1 >>> 31;
      $69($24_1, $11_1, $17_1, 0, 0, $9_1, $1_1, 0, 0);
      $20_1 = $8_1 + 272 | 0;
      $69($20_1, $6_1, $7_1, 0, 0, $3_1, $13_1, 0, 0);
      $29_1 = $8_1 + 208 | 0;
      $69($29_1, $5_1, $10_1, 0, 0, $5_1, $10_1, 0, 0);
      $27_1 = $8_1 + 128 | 0;
      $2_1 = $16_1 + 8 | 0;
      $69($27_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
      $31_1 = $8_1 + 320 | 0;
      $69($31_1, $9_1, $1_1, 0, 0, $9_1, $1_1, 0, 0);
      $32_1 = $8_1 + 96 | 0;
      $69($32_1, $11_1, $17_1, 0, 0, $14_1, $21_1, 0, 0);
      $34_1 = $8_1 + 176 | 0;
      $16_1 = $6_1;
      $22_1 = $7_1;
      $25_1 = $10_1;
      $10_1 = $5_1;
      $69($34_1, $6_1, $7_1, 0, 0, $5_1 << 1, $25_1 << 1 | $5_1 >>> 31, 0, 0);
      $6_1 = HEAP32[$8_1 + 304 >> 2];
      $2_1 = HEAP32[$8_1 + 224 >> 2];
      $1_1 = $6_1 + $2_1 | 0;
      $5_1 = HEAP32[$8_1 + 308 >> 2];
      $4_1 = $5_1 + HEAP32[$8_1 + 228 >> 2] | 0;
      $2_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $2_1 + HEAP32[$8_1 + 148 >> 2] | 0;
      $3_1 = $1_1;
      $7_1 = HEAP32[$8_1 + 144 >> 2];
      $1_1 = $1_1 + $7_1 | 0;
      $26_1 = $1_1;
      $1_1 = $1_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = ($2_1 | 0) == ($1_1 | 0) & $3_1 >>> 0 > $26_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
      $4_1 = $19_1 + 8 | 0;
      $9_1 = HEAP32[$4_1 >> 2];
      $13_1 = HEAP32[$4_1 + 4 >> 2];
      $3_1 = ($2_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 < $5_1 >>> 0;
      $4_1 = $18_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 >> 2];
      $6_1 = $23_1 + 8 | 0;
      $2_1 = $5_1 + HEAP32[$6_1 >> 2] | 0;
      $4_1 = HEAP32[$6_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1;
      $2_1 = $2_1 + $3_1 | 0;
      $4_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $13_1 | 0;
      $3_1 = $2_1;
      $2_1 = $2_1 + $9_1 | 0;
      $4_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $2_1 + $7_1 | 0;
      $2_1 = $3_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1 << 12 | $3_1 >>> 20;
      $23_1 = $1_1;
      $18_1 = $3_1 << 12 | $1_1 >>> 20;
      $30_1 = $5_1;
      $33_1 = HEAP32[$8_1 + 272 >> 2];
      $3_1 = HEAP32[$8_1 + 208 >> 2];
      $1_1 = $33_1 + $3_1 | 0;
      $19_1 = HEAP32[$8_1 + 276 >> 2];
      $4_1 = $19_1 + HEAP32[$8_1 + 212 >> 2] | 0;
      $4_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $1_1;
      $3_1 = HEAP32[$8_1 + 112 >> 2];
      $1_1 = $1_1 + $3_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$8_1 + 116 >> 2] | 0;
      $4_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = $1_1;
      $3_1 = HEAP32[$8_1 + 128 >> 2];
      $1_1 = $1_1 + $3_1 | 0;
      $6_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$8_1 + 132 >> 2] | 0;
      $3_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $3_1 + $30_1 | 0;
      $30_1 = $8_1 + 80 | 0;
      $13_1 = $1_1;
      $18_1 = $1_1 + $18_1 | 0;
      $1_1 = $1_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $3_1;
      $3_1 = $18_1;
      $18_1 = ($1_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $4_1 >>> 0;
      $13_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
      $4_1 = $27_1 + 8 | 0;
      $27_1 = HEAP32[$4_1 >> 2];
      $35_1 = HEAP32[$4_1 + 4 >> 2];
      $6_1 = ($5_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
      $4_1 = $24_1 + 8 | 0;
      $9_1 = HEAP32[$4_1 >> 2];
      $24_1 = HEAP32[$4_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($19_1 | 0) & $7_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $19_1 >>> 0;
      $4_1 = $29_1 + 8 | 0;
      $19_1 = HEAP32[$4_1 >> 2];
      $20_1 = $20_1 + 8 | 0;
      $5_1 = $19_1 + HEAP32[$20_1 >> 2] | 0;
      $4_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $20_1 = $5_1;
      $5_1 = $5_1 + $7_1 | 0;
      $4_1 = ($20_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $24_1 | 0;
      $7_1 = $5_1;
      $5_1 = $5_1 + $9_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $5_1;
      $5_1 = $5_1 + $6_1 | 0;
      $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $35_1 | 0;
      $7_1 = $5_1;
      $5_1 = $5_1 + $27_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $5_1;
      $5_1 = $5_1 + $13_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $2_1 >>> 20 | 0;
      $7_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1 + $18_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $2_1 << 12 | $5_1 >>> 20;
      $7_1 = $5_1 << 12;
      $5_1 = $1_1;
      $9_1 = $7_1 | $1_1 >>> 20;
      $13_1 = $4_1;
      $19_1 = HEAP32[$8_1 + 96 >> 2];
      $6_1 = HEAP32[$8_1 + 176 >> 2];
      $1_1 = $19_1 + $6_1 | 0;
      $18_1 = HEAP32[$8_1 + 100 >> 2];
      $4_1 = $18_1 + HEAP32[$8_1 + 180 >> 2] | 0;
      $6_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + $13_1 | 0;
      $7_1 = $1_1;
      $9_1 = $1_1 + $9_1 | 0;
      $4_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $24_1 = $9_1 << 4 & -16;
      $13_1 = $5_1;
      $1_1 = $4_1;
      $69($30_1, $24_1 | $5_1 >>> 16 & 15, ($4_1 << 4 | $9_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
      $24_1 = $8_1 + 256 | 0;
      $69($24_1, $14_1, $21_1, 0, 0, $15_1, $12_1, 0, 0);
      $20_1 = $8_1 - -64 | 0;
      $69($20_1, $11_1, $17_1, 0, 0, $10_1, $25_1, 0, 0);
      $29_1 = $8_1 + 288 | 0;
      $69($29_1, $16_1, $22_1, 0, 0, $16_1, $22_1, 0, 0);
      $27_1 = $8_1 + 48 | 0;
      $9_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
      $6_1 = ($6_1 | 0) == ($18_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $6_1 >>> 0 < $18_1 >>> 0;
      $4_1 = $34_1 + 8 | 0;
      $7_1 = HEAP32[$4_1 >> 2];
      $18_1 = $32_1 + 8 | 0;
      $5_1 = $7_1 + HEAP32[$18_1 >> 2] | 0;
      $4_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $5_1;
      $5_1 = $5_1 + $6_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $2_1 >>> 20 | 0;
      $7_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1 + $9_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $2_1 << 12 | $5_1 >>> 20;
      $5_1 = $5_1 << 12 | $1_1 >>> 20;
      $7_1 = $6_1;
      $18_1 = HEAP32[$8_1 + 64 >> 2];
      $6_1 = HEAP32[$8_1 + 288 >> 2];
      $1_1 = $18_1 + $6_1 | 0;
      $9_1 = HEAP32[$8_1 + 68 >> 2];
      $4_1 = $9_1 + HEAP32[$8_1 + 292 >> 2] | 0;
      $4_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1;
      $1_1 = $4_1;
      $4_1 = $4_1 + $7_1 | 0;
      $5_1 = $5_1 + $6_1 | 0;
      $4_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $5_1;
      $5_1 = $4_1;
      $69($27_1, $7_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
      $19_1 = $8_1 + 192 | 0;
      $69($19_1, $10_1, $25_1, 0, 0, $15_1, $12_1, 0, 0);
      $12_1 = $8_1 + 240 | 0;
      $69($12_1, $14_1, $21_1, 0, 0, $14_1, $21_1, 0, 0);
      $10_1 = $8_1 + 32 | 0;
      $69($10_1, $11_1, $17_1, 0, 0, $16_1, $22_1, 0, 0);
      $17_1 = $8_1 + 16 | 0;
      $11_1 = $17_1;
      $7_1 = ($1_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 > $4_1 >>> 0;
      $6_1 = ($1_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
      $4_1 = $29_1 + 8 | 0;
      $9_1 = HEAP32[$4_1 >> 2];
      $14_1 = $20_1 + 8 | 0;
      $1_1 = $9_1 + HEAP32[$14_1 >> 2] | 0;
      $4_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = $1_1;
      $1_1 = $1_1 + $6_1 | 0;
      $4_1 = $14_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $2_1 >>> 20 | 0;
      $1_1 = $1_1 + $2_1 | 0;
      $4_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $1_1 + $7_1 | 0;
      $1_1 = $2_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $1_1 << 12 | $2_1 >>> 20;
      $7_1 = $2_1 << 12 | $5_1 >>> 20;
      $9_1 = HEAP32[$8_1 + 32 >> 2];
      $2_1 = $7_1 + $9_1 | 0;
      $5_1 = $6_1;
      $4_1 = $5_1 + HEAP32[$8_1 + 36 >> 2] | 0;
      $4_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($11_1, $2_1, $4_1, 0, 0, 15632, 16, 0, 0);
      $2_1 = ($4_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $4_1 = $10_1 + 8 | 0;
      $5_1 = HEAP32[$4_1 >> 2];
      $4_1 = HEAP32[$4_1 + 4 >> 2];
      $1_1 = $1_1 >>> 20 | 0;
      $7_1 = $1_1;
      $1_1 = $1_1 + $5_1 | 0;
      $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $1_1;
      $1_1 = $1_1 + $2_1 | 0;
      $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $69($8_1, $1_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
      $1_1 = $8_1;
      $11_1 = HEAP32[$1_1 + 80 >> 2];
      $2_1 = HEAP32[$1_1 + 320 >> 2];
      $5_1 = $11_1 + $2_1 | 0;
      $6_1 = HEAP32[$1_1 + 84 >> 2];
      $4_1 = $6_1 + HEAP32[$1_1 + 324 >> 2] | 0;
      HEAP32[$1_1 + 416 >> 2] = -3908 - $5_1;
      $2_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$1_1 + 420 >> 2] = 4194299 - (($2_1 & 1048575) + ($5_1 >>> 0 > 4294963388) | 0);
      $6_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
      $4_1 = $31_1 + 8 | 0;
      $11_1 = HEAP32[$4_1 >> 2];
      $10_1 = $30_1 + 8 | 0;
      $5_1 = $11_1 + HEAP32[$10_1 >> 2] | 0;
      $4_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $5_1 + $6_1 | 0;
      $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $5_1 << 12 | $6_1 >>> 20;
      $6_1 = $6_1 << 12 | $2_1 >>> 20;
      $10_1 = $11_1;
      $9_1 = HEAP32[$1_1 + 48 >> 2];
      $11_1 = HEAP32[$1_1 + 256 >> 2];
      $2_1 = $9_1 + $11_1 | 0;
      $7_1 = HEAP32[$1_1 + 52 >> 2];
      $4_1 = $7_1 + HEAP32[$1_1 + 260 >> 2] | 0;
      $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $2_1;
      $2_1 = $4_1;
      $4_1 = $4_1 + $10_1 | 0;
      $6_1 = $6_1 + $11_1 | 0;
      $4_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $10_1 = $6_1;
      HEAP32[$1_1 + 424 >> 2] = -4 - $6_1;
      $6_1 = $4_1;
      HEAP32[$1_1 + 428 >> 2] = 4194303 - (($4_1 & 1048575) + ($10_1 >>> 0 > 4294967292) | 0);
      $10_1 = ($2_1 | 0) == ($4_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
      $11_1 = ($2_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $11_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
      $4_1 = $24_1 + 8 | 0;
      $7_1 = HEAP32[$4_1 >> 2];
      $9_1 = $27_1 + 8 | 0;
      $2_1 = $7_1 + HEAP32[$9_1 >> 2] | 0;
      $4_1 = HEAP32[$9_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $2_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $2_1;
      $2_1 = $2_1 + $11_1 | 0;
      $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $5_1 >>> 20 | 0;
      $2_1 = $2_1 + $5_1 | 0;
      $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1 + $10_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $2_1 << 12 | $5_1 >>> 20;
      $9_1 = $5_1 << 12 | $6_1 >>> 20;
      $21_1 = HEAP32[$1_1 + 192 >> 2];
      $5_1 = HEAP32[$1_1 + 240 >> 2];
      $6_1 = $21_1 + $5_1 | 0;
      $14_1 = HEAP32[$1_1 + 196 >> 2];
      $4_1 = $14_1 + HEAP32[$1_1 + 244 >> 2] | 0;
      $4_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $6_1;
      $6_1 = HEAP32[$1_1 + 16 >> 2];
      $10_1 = $7_1 + $6_1 | 0;
      $5_1 = $4_1;
      $4_1 = $4_1 + HEAP32[$1_1 + 20 >> 2] | 0;
      $6_1 = $6_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $6_1 + $11_1 | 0;
      $11_1 = $9_1 + $10_1 | 0;
      $4_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = $11_1;
      HEAP32[$1_1 + 432 >> 2] = -4 - $9_1;
      $11_1 = $4_1;
      HEAP32[$1_1 + 436 >> 2] = 4194303 - (($4_1 & 1048575) + ($9_1 >>> 0 > 4294967292) | 0);
      $9_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
      $6_1 = ($5_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
      $4_1 = $17_1 + 8 | 0;
      $10_1 = HEAP32[$4_1 >> 2];
      $17_1 = HEAP32[$4_1 + 4 >> 2];
      $7_1 = ($5_1 | 0) == ($14_1 | 0) & $7_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 < $14_1 >>> 0;
      $4_1 = $12_1 + 8 | 0;
      $14_1 = HEAP32[$4_1 >> 2];
      $12_1 = $19_1 + 8 | 0;
      $5_1 = $14_1 + HEAP32[$12_1 >> 2] | 0;
      $4_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $5_1;
      $5_1 = $5_1 + $7_1 | 0;
      $4_1 = ($12_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $17_1 | 0;
      $7_1 = $5_1;
      $5_1 = $5_1 + $10_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $7_1 = $5_1;
      $5_1 = $5_1 + $6_1 | 0;
      $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $2_1 >>> 20 | 0;
      $7_1 = $2_1;
      $2_1 = $2_1 + $5_1 | 0;
      $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $2_1 + $9_1 | 0;
      $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $2_1 << 12 | $5_1 >>> 20;
      $10_1 = $5_1 << 12 | $11_1 >>> 20;
      $14_1 = HEAP32[$1_1 >> 2];
      $5_1 = $26_1 & -2;
      $11_1 = $14_1 + $5_1 | 0;
      $9_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $9_1 + ($23_1 & 1048575) | 0;
      $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = $5_1 + $6_1 | 0;
      $10_1 = $10_1 + $11_1 | 0;
      $4_1 = $10_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$1_1 + 440 >> 2] = -4 - $10_1;
      $6_1 = $4_1;
      HEAP32[$1_1 + 444 >> 2] = 4194303 - (($4_1 & 1048575) + ($10_1 >>> 0 > 4294967292) | 0);
      $7_1 = $3_1;
      $12_1 = $13_1 & 65535;
      $10_1 = ($4_1 | 0) == ($5_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
      $5_1 = ($5_1 | 0) == ($9_1 | 0) & $11_1 >>> 0 < $14_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
      $4_1 = $1_1 + 8 | 0;
      $3_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2];
      $4_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $2_1 >>> 20 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $3_1 | 0;
      $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $2_1;
      $2_1 = $2_1 + $10_1 | 0;
      $4_1 = $12_1 + (($3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $2_1 >>> 20) | 0;
      $5_1 = $2_1 << 12 | $6_1 >>> 20;
      $2_1 = $5_1 + $7_1 | 0;
      HEAP32[$1_1 + 448 >> 2] = -4 - $2_1;
      HEAP32[$1_1 + 452 >> 2] = 262143 - (($2_1 >>> 0 > 4294967292) + ($2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0);
      $15_1 = $1_1 + 376 | 0;
      $2_1 = $1_1 + 416 | 0;
      $34($15_1, $2_1, $28_1);
      $16_1 = $1_1 + 336 | 0;
      $34($16_1, $1_1 + 656 | 0, $2_1);
      $22_1 = $1_1 + 456 | 0;
      $54($0_1, $22_1);
      $3_1 = HEAP32[$1_1 + 408 >> 2];
      $2_1 = $3_1 + HEAP32[$0_1 + 32 >> 2] | 0;
      $4_1 = HEAP32[$0_1 + 36 >> 2] + HEAP32[$1_1 + 412 >> 2] | 0;
      $3_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = HEAP32[$1_1 + 372 >> 2];
      $25_1 = $4_1;
      $13_1 = HEAP32[$1_1 + 368 >> 2];
      $5_1 = $13_1;
      $4_1 = ($4_1 << 1 | $5_1 >>> 31) + $3_1 | 0;
      $5_1 = $5_1 << 1;
      $2_1 = $2_1 + $5_1 | 0;
      $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $6_1 = $2_1;
      HEAP32[$0_1 + 32 >> 2] = $2_1;
      $11_1 = $4_1;
      HEAP32[$0_1 + 36 >> 2] = $4_1;
      $3_1 = HEAP32[$1_1 + 400 >> 2];
      $2_1 = $3_1 + HEAP32[$0_1 + 24 >> 2] | 0;
      $4_1 = HEAP32[$0_1 + 28 >> 2] + HEAP32[$1_1 + 404 >> 2] | 0;
      $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = $2_1;
      $5_1 = $4_1;
      $2_1 = HEAP32[$1_1 + 360 >> 2];
      $26_1 = $2_1;
      $4_1 = HEAP32[$1_1 + 364 >> 2];
      $23_1 = $4_1;
      $4_1 = ($4_1 << 1 | $2_1 >>> 31) + $5_1 | 0;
      $2_1 = $2_1 << 1;
      $5_1 = $2_1;
      $2_1 = $2_1 + $3_1 | 0;
      $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$0_1 + 24 >> 2] = $2_1;
      $10_1 = $4_1;
      HEAP32[$0_1 + 28 >> 2] = $4_1;
      $5_1 = HEAP32[$1_1 + 392 >> 2];
      $3_1 = $5_1 + HEAP32[$0_1 + 16 >> 2] | 0;
      $4_1 = HEAP32[$0_1 + 20 >> 2] + HEAP32[$1_1 + 396 >> 2] | 0;
      $4_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $3_1;
      $7_1 = $4_1;
      $3_1 = HEAP32[$1_1 + 352 >> 2];
      $18_1 = $3_1;
      $4_1 = HEAP32[$1_1 + 356 >> 2];
      $19_1 = $4_1;
      $4_1 = ($4_1 << 1 | $3_1 >>> 31) + $7_1 | 0;
      $3_1 = $3_1 << 1;
      $7_1 = $3_1;
      $3_1 = $3_1 + $5_1 | 0;
      $4_1 = $7_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$0_1 + 16 >> 2] = $3_1;
      $7_1 = $4_1;
      HEAP32[$0_1 + 20 >> 2] = $4_1;
      $9_1 = HEAP32[$1_1 + 384 >> 2];
      $5_1 = $9_1 + HEAP32[$0_1 + 8 >> 2] | 0;
      $4_1 = HEAP32[$0_1 + 12 >> 2] + HEAP32[$1_1 + 388 >> 2] | 0;
      $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $4_1 = HEAP32[$1_1 + 348 >> 2];
      $28_1 = $4_1;
      $21_1 = HEAP32[$1_1 + 344 >> 2];
      $14_1 = $21_1;
      $4_1 = ($4_1 << 1 | $14_1 >>> 31) + $9_1 | 0;
      $14_1 = $14_1 << 1;
      $5_1 = $5_1 + $14_1 | 0;
      $4_1 = $14_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $9_1 = $5_1;
      HEAP32[$0_1 + 8 >> 2] = $5_1;
      $14_1 = $4_1;
      HEAP32[$0_1 + 12 >> 2] = $4_1;
      $12_1 = HEAP32[$1_1 + 376 >> 2];
      $5_1 = $12_1 + HEAP32[$0_1 >> 2] | 0;
      $4_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 380 >> 2] | 0;
      $4_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $5_1;
      $17_1 = $4_1;
      $5_1 = HEAP32[$1_1 + 336 >> 2];
      $24_1 = $5_1;
      $4_1 = HEAP32[$1_1 + 340 >> 2];
      $20_1 = $4_1;
      $4_1 = ($4_1 << 1 | $5_1 >>> 31) + $17_1 | 0;
      $5_1 = $5_1 << 1;
      $17_1 = $5_1;
      $5_1 = $5_1 + $12_1 | 0;
      $4_1 = $17_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$0_1 >> 2] = $5_1;
      $12_1 = $4_1;
      HEAP32[$0_1 + 4 >> 2] = $4_1;
      $4_1 = $11_1 + $25_1 | 0;
      $6_1 = $6_1 + $13_1 | 0;
      $4_1 = $6_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$1_1 + 368 >> 2] = $6_1;
      HEAP32[$1_1 + 372 >> 2] = $4_1;
      $4_1 = $10_1 + $23_1 | 0;
      $6_1 = $2_1;
      $2_1 = $2_1 + $26_1 | 0;
      $4_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$1_1 + 360 >> 2] = $2_1;
      HEAP32[$1_1 + 364 >> 2] = $4_1;
      $4_1 = $7_1 + $19_1 | 0;
      $2_1 = $3_1 + $18_1 | 0;
      $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$1_1 + 352 >> 2] = $2_1;
      HEAP32[$1_1 + 356 >> 2] = $4_1;
      $4_1 = $14_1 + $28_1 | 0;
      $2_1 = $9_1 + $21_1 | 0;
      $4_1 = $2_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$1_1 + 344 >> 2] = $2_1;
      HEAP32[$1_1 + 348 >> 2] = $4_1;
      $4_1 = $12_1 + $20_1 | 0;
      $1_1 = $5_1 + $24_1 | 0;
      $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$8_1 + 336 >> 2] = $1_1;
      HEAP32[$8_1 + 340 >> 2] = $4_1;
      $34($0_1 + 40 | 0, $16_1, $22_1);
      $34($15_1, $15_1, $8_1 + 576 | 0);
      $4_1 = HEAP32[$0_1 + 44 >> 2] + HEAP32[$8_1 + 380 >> 2] | 0;
      $2_1 = HEAP32[$8_1 + 376 >> 2];
      $1_1 = $2_1 + HEAP32[$0_1 + 40 >> 2] | 0;
      HEAP32[$0_1 + 40 >> 2] = $1_1;
      HEAP32[$0_1 + 44 >> 2] = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = HEAP32[$8_1 + 384 >> 2];
      $1_1 = $0_1 + 48 | 0;
      $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 388 >> 2] | 0;
      HEAP32[$1_1 >> 2] = $2_1;
      HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = HEAP32[$8_1 + 392 >> 2];
      $1_1 = $0_1 + 56 | 0;
      $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 396 >> 2] | 0;
      HEAP32[$1_1 >> 2] = $2_1;
      HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $3_1 = HEAP32[$8_1 + 400 >> 2];
      $1_1 = $0_1 - -64 | 0;
      $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
      $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 404 >> 2] | 0;
      HEAP32[$1_1 >> 2] = $2_1;
      HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = HEAP32[$8_1 + 408 >> 2];
      $0_1 = $0_1 + 72 | 0;
      $1_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
      $4_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$8_1 + 412 >> 2] | 0;
      HEAP32[$0_1 >> 2] = $1_1;
      HEAP32[$0_1 + 4 >> 2] = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    }
    global$0 = $8_1 + 736 | 0;
  }
  function $66($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0;
    $6_1 = global$0 - 256 | 0;
    global$0 = $6_1;
    $8_1 = $6_1 + 240 | 0;
    $69($8_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
    $3_1 = HEAP32[$6_1 + 244 >> 2];
    HEAP32[$0_1 >> 2] = HEAP32[$6_1 + 240 >> 2];
    HEAP32[$0_1 + 4 >> 2] = $3_1;
    $10_1 = $6_1 + 208 | 0;
    $69($10_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
    $7_1 = $6_1 + 224 | 0;
    $69($7_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
    $14_1 = $0_1;
    $4_1 = HEAP32[$6_1 + 208 >> 2];
    $0_1 = $8_1 + 8 | 0;
    $3_1 = HEAP32[$0_1 >> 2];
    $13_1 = $4_1 + $3_1 | 0;
    $11_1 = HEAP32[$6_1 + 212 >> 2];
    $0_1 = $11_1 + HEAP32[$0_1 + 4 >> 2] | 0;
    $9_1 = $3_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $9_1 + HEAP32[$6_1 + 228 >> 2] | 0;
    $3_1 = HEAP32[$6_1 + 224 >> 2];
    $8_1 = $3_1 + $13_1 | 0;
    HEAP32[$14_1 + 8 >> 2] = $8_1;
    $5_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$14_1 + 12 >> 2] = $5_1;
    $17_1 = $6_1 + 160 | 0;
    $69($17_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
    $20_1 = $6_1 + 176 | 0;
    $69($20_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
    $18_1 = $6_1 + 192 | 0;
    $69($18_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
    $4_1 = ($9_1 | 0) == ($11_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $9_1 >>> 0 < $11_1 >>> 0;
    $0_1 = $10_1 + 8 | 0;
    $3_1 = $4_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = ($5_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
    $0_1 = $7_1 + 8 | 0;
    $5_1 = $8_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($5_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $4_1 | 0;
    $8_1 = $3_1 + $5_1 | 0;
    $0_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $11_1 = $8_1;
    $8_1 = HEAP32[$6_1 + 160 >> 2];
    $5_1 = $11_1 + $8_1 | 0;
    $15_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 164 >> 2] | 0;
    $0_1 = $5_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = HEAP32[$6_1 + 176 >> 2];
    $10_1 = $8_1 + $5_1 | 0;
    $16_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 180 >> 2] | 0;
    $12_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $12_1 + HEAP32[$6_1 + 196 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 192 >> 2];
    $9_1 = $8_1 + $10_1 | 0;
    HEAP32[$14_1 + 16 >> 2] = $9_1;
    $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$14_1 + 20 >> 2] = $7_1;
    $25_1 = $6_1 + 96 | 0;
    $69($25_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
    $23_1 = $6_1 + 112 | 0;
    $69($23_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
    $24_1 = $6_1 + 128 | 0;
    $69($24_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
    $22_1 = $6_1 + 144 | 0;
    $69($22_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
    $8_1 = ($15_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $11_1 >>> 0 | $15_1 >>> 0 > $16_1 >>> 0;
    $0_1 = $17_1 + 8 | 0;
    $13_1 = $8_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $3_1 = ($4_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $15_1 >>> 0;
    $17_1 = $13_1 + $3_1 | 0;
    $0_1 = $8_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = $0_1;
    $4_1 = $3_1 >>> 0 > $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $11_1 = $17_1;
    $3_1 = ($12_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 > $10_1 >>> 0 | $12_1 >>> 0 < $16_1 >>> 0;
    $0_1 = $20_1 + 8 | 0;
    $5_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $4_1 | 0;
    $21_1 = $5_1;
    $5_1 = $5_1 + $11_1 | 0;
    $3_1 = $21_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $20_1 = $5_1;
    $11_1 = $5_1;
    $5_1 = ($7_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $7_1 >>> 0 < $12_1 >>> 0;
    $0_1 = $18_1 + 8 | 0;
    $9_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($5_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
    $5_1 = $9_1 + $11_1 | 0;
    $0_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $15_1 = $5_1;
    $5_1 = HEAP32[$6_1 + 96 >> 2];
    $16_1 = $15_1 + $5_1 | 0;
    $18_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 100 >> 2] | 0;
    $0_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = HEAP32[$6_1 + 112 >> 2];
    $12_1 = $5_1 + $16_1 | 0;
    $19_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 116 >> 2] | 0;
    $0_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = HEAP32[$6_1 + 128 >> 2];
    $7_1 = $5_1 + $12_1 | 0;
    $21_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 132 >> 2] | 0;
    $10_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $10_1 + HEAP32[$6_1 + 148 >> 2] | 0;
    $5_1 = HEAP32[$6_1 + 144 >> 2];
    $9_1 = $5_1 + $7_1 | 0;
    HEAP32[$14_1 + 24 >> 2] = $9_1;
    $0_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$14_1 + 28 >> 2] = $0_1;
    $26_1 = $6_1 + 48 | 0;
    $69($26_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
    $27_1 = $6_1 - -64 | 0;
    $69($27_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
    $28_1 = $6_1 + 80 | 0;
    $69($28_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
    $9_1 = ($0_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
    $0_1 = $22_1 + 8 | 0;
    $5_1 = $9_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $7_1 = ($10_1 | 0) == ($21_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $10_1 >>> 0 < $21_1 >>> 0;
    $0_1 = $24_1 + 8 | 0;
    $11_1 = $7_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $10_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $7_1 = ($3_1 | 0) == ($18_1 | 0) & $15_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 > $18_1 >>> 0;
    $0_1 = ($3_1 | 0) == ($4_1 | 0) & $17_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $3_1 = ($4_1 | 0) == ($8_1 | 0) & $13_1 >>> 0 > $17_1 >>> 0 | $4_1 >>> 0 < $8_1 >>> 0;
    $4_1 = $0_1 + $3_1 | 0;
    $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
    $8_1 = $4_1 + $7_1 | 0;
    $13_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = ($18_1 | 0) == ($19_1 | 0) & $15_1 >>> 0 > $16_1 >>> 0 | $18_1 >>> 0 > $19_1 >>> 0;
    $0_1 = $25_1 + 8 | 0;
    $4_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $13_1 | 0;
    $7_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $18_1 = $4_1;
    $7_1 = $4_1;
    $4_1 = ($19_1 | 0) == ($21_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $19_1 >>> 0 > $21_1 >>> 0;
    $0_1 = $23_1 + 8 | 0;
    $12_1 = $4_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($4_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
    $7_1 = $7_1 + $12_1 | 0;
    $4_1 = $7_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $4_1 + $10_1 | 0;
    $21_1 = $7_1;
    $16_1 = $7_1 + $11_1 | 0;
    $17_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $17_1 + $9_1 | 0;
    $7_1 = $5_1 + $16_1 | 0;
    $0_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $20_1 = $7_1;
    $7_1 = HEAP32[$6_1 + 48 >> 2];
    $15_1 = $20_1 + $7_1 | 0;
    $22_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 52 >> 2] | 0;
    $19_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $19_1 + HEAP32[$6_1 + 68 >> 2] | 0;
    $10_1 = HEAP32[$6_1 + 64 >> 2];
    $7_1 = $10_1 + $15_1 | 0;
    $11_1 = HEAP32[$6_1 + 80 >> 2];
    $12_1 = $7_1 + $11_1 | 0;
    $10_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $10_1 + HEAP32[$6_1 + 84 >> 2] | 0;
    HEAP32[$14_1 + 32 >> 2] = $12_1;
    $0_1 = $12_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$14_1 + 36 >> 2] = $0_1;
    $23_1 = $6_1 + 16 | 0;
    $69($23_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
    $24_1 = $6_1 + 32 | 0;
    $69($24_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
    $11_1 = ($0_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $12_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
    $0_1 = $28_1 + 8 | 0;
    $12_1 = $11_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $11_1 = $12_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $7_1 = ($10_1 | 0) == ($19_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $10_1 >>> 0 < $19_1 >>> 0;
    $0_1 = $27_1 + 8 | 0;
    $10_1 = $7_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $7_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $9_1 = ($9_1 | 0) == ($22_1 | 0) & $5_1 >>> 0 > $20_1 >>> 0 | $9_1 >>> 0 > $22_1 >>> 0;
    $5_1 = ($4_1 | 0) == ($17_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $17_1 >>> 0;
    $0_1 = ($3_1 | 0) == ($4_1 | 0) & $18_1 >>> 0 > $21_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
    $3_1 = ($3_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0;
    $4_1 = $0_1 + $3_1 | 0;
    $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
    $3_1 = $4_1 + $5_1 | 0;
    $0_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = $3_1 + $9_1 | 0;
    $5_1 = $8_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = ($19_1 | 0) == ($22_1 | 0) & $15_1 >>> 0 < $20_1 >>> 0 | $19_1 >>> 0 < $22_1 >>> 0;
    $0_1 = $26_1 + 8 | 0;
    $4_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $5_1 | 0;
    $3_1 = $4_1 + $8_1 | 0;
    $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $4_1 + $7_1 | 0;
    $7_1 = $12_1;
    $16_1 = $3_1;
    $13_1 = $3_1 + $10_1 | 0;
    $12_1 = $13_1;
    $9_1 = $7_1 + $12_1 | 0;
    $3_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $3_1 + $11_1 | 0;
    $13_1 = HEAP32[$6_1 + 16 >> 2];
    $10_1 = $13_1 + $9_1 | 0;
    $15_1 = $9_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $15_1 + HEAP32[$6_1 + 20 >> 2] | 0;
    $11_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $11_1 + HEAP32[$6_1 + 36 >> 2] | 0;
    $7_1 = HEAP32[$6_1 + 32 >> 2];
    $13_1 = $7_1 + $10_1 | 0;
    HEAP32[$14_1 + 40 >> 2] = $13_1;
    $7_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$14_1 + 44 >> 2] = $7_1;
    $69($6_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
    $2_1 = $14_1;
    $1_1 = ($11_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 > $10_1 >>> 0 | $11_1 >>> 0 < $15_1 >>> 0;
    $0_1 = $23_1 + 8 | 0;
    $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $9_1 = ($3_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 > $15_1 >>> 0;
    $0_1 = ($3_1 | 0) == ($4_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $3_1 = ($4_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $4_1 = $0_1 + $3_1 | 0;
    $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
    $8_1 = $4_1 + $9_1 | 0;
    $9_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $9_1 + $1_1 | 0;
    $1_1 = $8_1 + $14_1 | 0;
    $3_1 = $1_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = $1_1;
    $4_1 = $1_1;
    $1_1 = ($7_1 | 0) == ($11_1 | 0) & $10_1 >>> 0 > $13_1 >>> 0 | $7_1 >>> 0 < $11_1 >>> 0;
    $0_1 = $24_1 + 8 | 0;
    $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = ($1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
    $4_1 = $4_1 + $14_1 | 0;
    $1_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $1_1 + HEAP32[$6_1 + 4 >> 2] | 0;
    $14_1 = HEAP32[$6_1 >> 2];
    $13_1 = $14_1 + $4_1 | 0;
    HEAP32[$2_1 + 48 >> 2] = $13_1;
    $0_1 = $14_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$2_1 + 52 >> 2] = $0_1;
    $14_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 < $1_1 >>> 0;
    $4_1 = ($1_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $5_1 >>> 0 | $1_1 >>> 0 < $3_1 >>> 0;
    $1_1 = ($3_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
    $0_1 = $6_1 + 8 | 0;
    $3_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $3_1 + $4_1 | 0;
    $0_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $14_1 | 0;
    $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$2_1 + 56 >> 2] = $1_1;
    HEAP32[$2_1 + 60 >> 2] = $0_1;
    global$0 = $6_1 + 256 | 0;
  }
  function $67($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0;
    $7_1 = global$0 - 480 | 0;
    global$0 = $7_1;
    $4_1 = HEAP32[$2_1 + 4 >> 2];
    $30_1 = $4_1;
    $10_1 = $4_1 >> 31;
    $4_1 = HEAP32[$0_1 + 4 >> 2];
    $12_1 = $4_1;
    $4_1 = $4_1 >> 31;
    $35_1 = $7_1 + 352 | 0;
    $28_1 = HEAP32[$2_1 >> 2];
    $6_1 = HEAP32[$0_1 >> 2];
    $5_1 = $4_1;
    $69($35_1, $28_1, $30_1, $10_1, $10_1, $6_1, $12_1, $4_1, $4_1);
    $4_1 = HEAP32[$2_1 + 12 >> 2];
    $31_1 = $4_1;
    $13_1 = $4_1 >> 31;
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = $4_1;
    $4_1 = $4_1 >> 31;
    $38_1 = $7_1 + 384 | 0;
    $16_1 = HEAP32[$2_1 + 8 >> 2];
    $15_1 = HEAP32[$1_1 >> 2];
    $9_1 = $4_1;
    $69($38_1, $16_1, $31_1, $13_1, $13_1, $15_1, $11_1, $4_1, $4_1);
    $4_1 = HEAP32[$2_1 + 20 >> 2];
    $17_1 = $4_1;
    $4_1 = $4_1 >> 31;
    $36_1 = $7_1 + 368 | 0;
    $32_1 = HEAP32[$2_1 + 16 >> 2];
    $23_1 = $4_1;
    $69($36_1, $32_1, $17_1, $4_1, $4_1, $6_1, $12_1, $5_1, $5_1);
    $37_1 = HEAP32[$2_1 + 24 >> 2];
    $2_1 = HEAP32[$2_1 + 28 >> 2];
    $18_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $33_1 = $7_1 + 400 | 0;
    $27_1 = $2_1;
    $69($33_1, $37_1, $18_1, $2_1, $2_1, $15_1, $11_1, $9_1, $9_1);
    $43_1 = HEAP32[$1_1 + 32 >> 2];
    $2_1 = HEAP32[$1_1 + 36 >> 2];
    $50_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $9_1 = $2_1;
    $5_1 = $2_1 & $16_1;
    $44_1 = HEAP32[$0_1 + 32 >> 2];
    $2_1 = HEAP32[$0_1 + 36 >> 2];
    $45_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $4_1 = $5_1;
    $12_1 = $2_1;
    $5_1 = $2_1 & $28_1;
    $2_1 = $4_1 + $5_1 | 0;
    $4_1 = ($12_1 & $30_1) + ($9_1 & $31_1) | 0;
    $5_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = HEAP32[$3_1 + 40 >> 2];
    $8_1 = $4_1;
    $21_1 = HEAP32[$7_1 + 388 >> 2];
    $4_1 = $21_1 + HEAP32[$7_1 + 356 >> 2] | 0;
    $24_1 = HEAP32[$3_1 + 44 >> 2];
    $22_1 = HEAP32[$7_1 + 384 >> 2];
    $6_1 = HEAP32[$7_1 + 352 >> 2];
    $11_1 = $22_1 + $6_1 | 0;
    $6_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $25_1 = __wasm_i64_mul($8_1, $24_1, $11_1, $6_1);
    $15_1 = $25_1 + $2_1 | 0;
    $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
    $29_1 = $2_1 - $15_1 | 0;
    $2_1 = $5_1 - ((($15_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) & 1073741823) + ($2_1 >>> 0 < $15_1 >>> 0) | 0) | 0;
    $25_1 = $2_1;
    $14_1 = $2_1 >> 31;
    $2_1 = HEAP32[$3_1 + 4 >> 2];
    $19_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $39_1 = $7_1 + 320 | 0;
    $20_1 = HEAP32[$3_1 >> 2];
    $15_1 = $2_1;
    $69($39_1, $29_1, $25_1, $14_1, $14_1, $20_1, $19_1, $2_1, $2_1);
    $5_1 = $12_1 & $32_1;
    $2_1 = $5_1 + ($9_1 & $37_1) | 0;
    $4_1 = ($9_1 & $18_1) + ($12_1 & $17_1) | 0;
    $5_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $26_1 = HEAP32[$7_1 + 404 >> 2];
    $4_1 = $26_1 + HEAP32[$7_1 + 372 >> 2] | 0;
    $40_1 = HEAP32[$7_1 + 400 >> 2];
    $9_1 = HEAP32[$7_1 + 368 >> 2];
    $12_1 = $40_1 + $9_1 | 0;
    $9_1 = $9_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $24_1 = __wasm_i64_mul($12_1, $9_1, $8_1, $24_1);
    $8_1 = $24_1 + $2_1 | 0;
    $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
    $34_1 = $2_1 - $8_1 | 0;
    $2_1 = $5_1 - ((($8_1 >>> 0 < $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) & 1073741823) + ($2_1 >>> 0 < $8_1 >>> 0) | 0) | 0;
    $24_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $41_1 = $7_1 + 336 | 0;
    $42_1 = $2_1;
    $69($41_1, $34_1, $24_1, $2_1, $2_1, $20_1, $19_1, $15_1, $15_1);
    $2_1 = HEAP32[$0_1 + 12 >> 2];
    $8_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $46_1 = $7_1 + 416 | 0;
    $15_1 = HEAP32[$0_1 + 8 >> 2];
    $5_1 = $2_1;
    $69($46_1, $28_1, $30_1, $10_1, $10_1, $15_1, $8_1, $2_1, $2_1);
    $2_1 = HEAP32[$1_1 + 12 >> 2];
    $19_1 = $2_1;
    $2_1 = $2_1 >> 31;
    $4_1 = $2_1;
    $47_1 = $7_1 + 448 | 0;
    $20_1 = HEAP32[$1_1 + 8 >> 2];
    $69($47_1, $16_1, $31_1, $13_1, $13_1, $20_1, $19_1, $4_1, $4_1);
    $48_1 = $7_1 + 432 | 0;
    $69($48_1, $32_1, $17_1, $23_1, $23_1, $15_1, $8_1, $5_1, $5_1);
    $49_1 = $7_1 + 464 | 0;
    $69($49_1, $37_1, $18_1, $27_1, $27_1, $20_1, $19_1, $4_1, $4_1);
    $2_1 = HEAP32[$7_1 + 336 >> 2];
    $8_1 = $2_1;
    $15_1 = HEAP32[$7_1 + 340 >> 2];
    $4_1 = $15_1 + $9_1 | 0;
    $2_1 = $2_1 + $12_1 | 0;
    $4_1 = $2_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $2_1;
    $2_1 = $4_1;
    $15_1 = ($15_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
    $4_1 = $41_1 + 8 | 0;
    $8_1 = HEAP32[$4_1 >> 2];
    $20_1 = HEAP32[$4_1 + 4 >> 2];
    $9_1 = ($9_1 | 0) == ($26_1 | 0) & $12_1 >>> 0 < $40_1 >>> 0 | $9_1 >>> 0 < $26_1 >>> 0;
    $4_1 = $36_1 + 8 | 0;
    $12_1 = HEAP32[$4_1 >> 2];
    $19_1 = $33_1 + 8 | 0;
    $5_1 = $12_1 + HEAP32[$19_1 >> 2] | 0;
    $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = $5_1;
    $5_1 = $5_1 + $9_1 | 0;
    $4_1 = ($12_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $20_1 | 0;
    $9_1 = $5_1;
    $5_1 = $5_1 + $8_1 | 0;
    $4_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $5_1 + $15_1 | 0;
    $5_1 = $9_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = $5_1 << 2 | $9_1 >>> 30;
    $15_1 = $9_1 << 2 | $2_1 >>> 30;
    $19_1 = HEAP32[$7_1 + 464 >> 2];
    $2_1 = HEAP32[$7_1 + 432 >> 2];
    $9_1 = $19_1 + $2_1 | 0;
    $8_1 = HEAP32[$7_1 + 468 >> 2];
    $4_1 = $8_1 + HEAP32[$7_1 + 436 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $2_1 + $12_1 | 0;
    $12_1 = $9_1 + $15_1 | 0;
    $15_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $20_1 = ($2_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
    $9_1 = ($2_1 | 0) == ($8_1 | 0) & $9_1 >>> 0 < $19_1 >>> 0 | $2_1 >>> 0 < $8_1 >>> 0;
    $4_1 = $48_1 + 8 | 0;
    $8_1 = HEAP32[$4_1 >> 2];
    $19_1 = $49_1 + 8 | 0;
    $2_1 = $8_1 + HEAP32[$19_1 >> 2] | 0;
    $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $2_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $2_1;
    $2_1 = $2_1 + $9_1 | 0;
    $4_1 = ($5_1 >> 31) + ($8_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $5_1 = $5_1 >> 30;
    $2_1 = $2_1 + $5_1 | 0;
    $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $2_1 + $20_1 | 0;
    $2_1 = $9_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$7_1 + 320 >> 2];
    $19_1 = $5_1;
    $20_1 = HEAP32[$7_1 + 324 >> 2];
    $4_1 = $20_1 + $6_1 | 0;
    $5_1 = $5_1 + $11_1 | 0;
    $4_1 = $5_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $5_1;
    $5_1 = $4_1;
    $8_1 = ($20_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
    $4_1 = $39_1 + 8 | 0;
    $20_1 = HEAP32[$4_1 >> 2];
    $19_1 = HEAP32[$4_1 + 4 >> 2];
    $11_1 = ($6_1 | 0) == ($21_1 | 0) & $11_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $21_1 >>> 0;
    $4_1 = $35_1 + 8 | 0;
    $21_1 = HEAP32[$4_1 >> 2];
    $26_1 = $38_1 + 8 | 0;
    $6_1 = $21_1 + HEAP32[$26_1 >> 2] | 0;
    $4_1 = HEAP32[$26_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $22_1 = $6_1;
    $6_1 = $6_1 + $11_1 | 0;
    $4_1 = ($22_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $19_1 | 0;
    $11_1 = $6_1;
    $6_1 = $6_1 + $20_1 | 0;
    $4_1 = $11_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $11_1 = $6_1 + $8_1 | 0;
    $6_1 = $11_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $6_1 << 2 | $11_1 >>> 30;
    $11_1 = $11_1 << 2 | $5_1 >>> 30;
    $19_1 = HEAP32[$7_1 + 448 >> 2];
    $21_1 = HEAP32[$7_1 + 416 >> 2];
    $5_1 = $19_1 + $21_1 | 0;
    $20_1 = HEAP32[$7_1 + 452 >> 2];
    $4_1 = $20_1 + HEAP32[$7_1 + 420 >> 2] | 0;
    $4_1 = $5_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $21_1 = $5_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $8_1 = $11_1 + $21_1 | 0;
    $11_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $26_1 = ($5_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
    $21_1 = ($5_1 | 0) == ($20_1 | 0) & $19_1 >>> 0 > $21_1 >>> 0 | $5_1 >>> 0 < $20_1 >>> 0;
    $4_1 = $46_1 + 8 | 0;
    $20_1 = HEAP32[$4_1 >> 2];
    $19_1 = $47_1 + 8 | 0;
    $5_1 = $20_1 + HEAP32[$19_1 >> 2] | 0;
    $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $19_1 = $5_1;
    $5_1 = $5_1 + $21_1 | 0;
    $4_1 = ($6_1 >> 31) + ($19_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $6_1 = $6_1 >> 30;
    $5_1 = $5_1 + $6_1 | 0;
    $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $5_1 + $26_1 | 0;
    $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $21_1 = HEAP32[$1_1 + 24 >> 2];
    $20_1 = HEAP32[$1_1 + 28 >> 2];
    $19_1 = HEAP32[$1_1 + 16 >> 2];
    $26_1 = HEAP32[$1_1 + 20 >> 2];
    $35_1 = HEAP32[$0_1 + 24 >> 2];
    $38_1 = HEAP32[$0_1 + 28 >> 2];
    $36_1 = HEAP32[$0_1 + 16 >> 2];
    $33_1 = HEAP32[$0_1 + 20 >> 2];
    $4_1 = HEAP32[$3_1 + 8 >> 2];
    $22_1 = HEAP32[$3_1 + 12 >> 2];
    if ($4_1 | $22_1) {
      $41_1 = $7_1 + 304 | 0;
      $40_1 = $4_1;
      $4_1 = $22_1 >> 31;
      $69($41_1, $29_1, $25_1, $14_1, $14_1, $40_1, $22_1, $4_1, $4_1);
      $39_1 = $7_1 + 288 | 0;
      $69($39_1, $34_1, $24_1, $42_1, $42_1, $40_1, $22_1, $4_1, $4_1);
      $14_1 = $15_1;
      $22_1 = $12_1;
      $15_1 = HEAP32[$7_1 + 288 >> 2];
      $12_1 = $12_1 + $15_1 | 0;
      $4_1 = $14_1 + HEAP32[$7_1 + 292 >> 2] | 0;
      $15_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = ($14_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $14_1 >>> 0 > $15_1 >>> 0;
      $4_1 = $39_1 + 8 | 0;
      $22_1 = HEAP32[$4_1 >> 2];
      $9_1 = $22_1 + $9_1 | 0;
      $4_1 = $2_1 + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $9_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $2_1 = $9_1;
      $9_1 = $9_1 + $14_1 | 0;
      $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = $11_1;
      $22_1 = $8_1;
      $11_1 = HEAP32[$7_1 + 304 >> 2];
      $8_1 = $8_1 + $11_1 | 0;
      $4_1 = $14_1 + HEAP32[$7_1 + 308 >> 2] | 0;
      $11_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = ($14_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $22_1 >>> 0 | $11_1 >>> 0 < $14_1 >>> 0;
      $4_1 = $41_1 + 8 | 0;
      $22_1 = HEAP32[$4_1 >> 2];
      $6_1 = $22_1 + $6_1 | 0;
      $4_1 = $5_1 + HEAP32[$4_1 + 4 >> 2] | 0;
      $4_1 = $6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $5_1 = $6_1;
      $6_1 = $6_1 + $14_1 | 0;
      $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    }
    HEAP32[$0_1 >> 2] = $8_1;
    HEAP32[$0_1 + 4 >> 2] = $11_1 & 1073741823;
    HEAP32[$1_1 >> 2] = $12_1;
    HEAP32[$1_1 + 4 >> 2] = $15_1 & 1073741823;
    $4_1 = $33_1 >> 31;
    $8_1 = $4_1;
    $22_1 = $7_1 + 272 | 0;
    $14_1 = $28_1;
    $69($22_1, $14_1, $30_1, $10_1, $10_1, $36_1, $33_1, $4_1, $4_1);
    $42_1 = $7_1 + 240 | 0;
    $28_1 = $16_1;
    $10_1 = $13_1;
    $16_1 = $26_1;
    $4_1 = $16_1 >> 31;
    $69($42_1, $28_1, $31_1, $10_1, $10_1, $19_1, $16_1, $4_1, $4_1);
    $13_1 = $7_1 + 256 | 0;
    $69($13_1, $32_1, $17_1, $23_1, $23_1, $36_1, $33_1, $8_1, $8_1);
    $16_1 = $7_1 + 224 | 0;
    $69($16_1, $37_1, $18_1, $27_1, $27_1, $19_1, $26_1, $4_1, $4_1);
    $23_1 = HEAP32[$7_1 + 224 >> 2];
    $8_1 = HEAP32[$7_1 + 256 >> 2];
    $12_1 = $23_1 + $8_1 | 0;
    $10_1 = HEAP32[$7_1 + 228 >> 2];
    $4_1 = $10_1 + HEAP32[$7_1 + 260 >> 2] | 0;
    $8_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $23_1 = ($10_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $23_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
    $4_1 = $13_1 + 8 | 0;
    $13_1 = HEAP32[$4_1 >> 2];
    $16_1 = $16_1 + 8 | 0;
    $10_1 = $13_1 + HEAP32[$16_1 >> 2] | 0;
    $4_1 = HEAP32[$16_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $10_1;
    $10_1 = $10_1 + $23_1 | 0;
    $4_1 = ($2_1 >> 31) + ($13_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $16_1 = $2_1 >> 30;
    $10_1 = $10_1 + $16_1 | 0;
    $4_1 = $16_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $10_1;
    $10_1 = $4_1;
    $4_1 = $2_1 << 2 | $9_1 >>> 30;
    $2_1 = $9_1 << 2 | $15_1 >>> 30;
    $9_1 = $2_1 + $12_1 | 0;
    $4_1 = $4_1 + $8_1 | 0;
    $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $15_1 = ($8_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $2_1 >>> 0 < $8_1 >>> 0;
    $12_1 = $15_1 + $13_1 | 0;
    $4_1 = $10_1;
    $15_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = HEAP32[$7_1 + 240 >> 2];
    $10_1 = HEAP32[$7_1 + 272 >> 2];
    $8_1 = $16_1 + $10_1 | 0;
    $13_1 = HEAP32[$7_1 + 244 >> 2];
    $4_1 = $13_1 + HEAP32[$7_1 + 276 >> 2] | 0;
    $10_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = ($13_1 | 0) == ($10_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $10_1 >>> 0 < $13_1 >>> 0;
    $4_1 = $22_1 + 8 | 0;
    $23_1 = HEAP32[$4_1 >> 2];
    $27_1 = $42_1 + 8 | 0;
    $13_1 = $23_1 + HEAP32[$27_1 >> 2] | 0;
    $4_1 = HEAP32[$27_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $13_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $19_1 = $13_1;
    $13_1 = $13_1 + $16_1 | 0;
    $4_1 = ($5_1 >> 31) + ($19_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $23_1 = $5_1 >> 30;
    $13_1 = $13_1 + $23_1 | 0;
    $4_1 = $23_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = $13_1;
    $13_1 = $4_1;
    $4_1 = $5_1 << 2 | $6_1 >>> 30;
    $5_1 = $6_1 << 2 | $11_1 >>> 30;
    $6_1 = $5_1 + $8_1 | 0;
    $4_1 = $4_1 + $10_1 | 0;
    $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = ($10_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $10_1 >>> 0;
    $11_1 = $8_1 + $16_1 | 0;
    $4_1 = $13_1;
    $8_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = HEAP32[$3_1 + 16 >> 2];
    $16_1 = HEAP32[$3_1 + 20 >> 2];
    if ($13_1 | $16_1) {
      $4_1 = $16_1 >> 31;
      $23_1 = $7_1 + 208 | 0;
      $10_1 = $4_1;
      $4_1 = $25_1 >> 31;
      $69($23_1, $13_1, $16_1, $10_1, $10_1, $29_1, $25_1, $4_1, $4_1);
      $27_1 = $7_1 + 192 | 0;
      $4_1 = $24_1 >> 31;
      $69($27_1, $13_1, $16_1, $10_1, $10_1, $34_1, $24_1, $4_1, $4_1);
      $10_1 = HEAP32[$7_1 + 196 >> 2];
      $4_1 = $10_1 + $2_1 | 0;
      $2_1 = $9_1;
      $13_1 = HEAP32[$7_1 + 192 >> 2];
      $9_1 = $13_1 + $9_1 | 0;
      $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = ($10_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
      $4_1 = $27_1 + 8 | 0;
      $10_1 = HEAP32[$4_1 >> 2] + $12_1 | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + $15_1 | 0;
      $4_1 = $12_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $10_1 + $13_1 | 0;
      $15_1 = $12_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $10_1 = HEAP32[$7_1 + 212 >> 2];
      $4_1 = $10_1 + $5_1 | 0;
      $5_1 = $6_1;
      $13_1 = HEAP32[$7_1 + 208 >> 2];
      $6_1 = $13_1 + $6_1 | 0;
      $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $13_1 = ($10_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $10_1 >>> 0;
      $4_1 = $23_1 + 8 | 0;
      $10_1 = HEAP32[$4_1 >> 2] + $11_1 | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + $8_1 | 0;
      $4_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $10_1 + $13_1 | 0;
      $8_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    }
    HEAP32[$0_1 + 8 >> 2] = $6_1;
    HEAP32[$0_1 + 12 >> 2] = $5_1 & 1073741823;
    HEAP32[$1_1 + 8 >> 2] = $9_1;
    HEAP32[$1_1 + 12 >> 2] = $2_1 & 1073741823;
    $4_1 = $30_1 >> 31;
    $10_1 = $4_1;
    $4_1 = $38_1 >> 31;
    $36_1 = $7_1 + 176 | 0;
    $16_1 = $14_1;
    $9_1 = $4_1;
    $69($36_1, $14_1, $30_1, $10_1, $10_1, $35_1, $38_1, $4_1, $4_1);
    $4_1 = $31_1 >> 31;
    $13_1 = $4_1;
    $4_1 = $20_1 >> 31;
    $33_1 = $7_1 + 144 | 0;
    $6_1 = $4_1;
    $69($33_1, $28_1, $31_1, $13_1, $13_1, $21_1, $20_1, $4_1, $4_1);
    $4_1 = $17_1;
    $23_1 = $4_1;
    $4_1 = $4_1 >> 31;
    $22_1 = $7_1 + 160 | 0;
    $27_1 = $4_1;
    $69($22_1, $32_1, $17_1, $4_1, $4_1, $35_1, $38_1, $9_1, $9_1);
    $4_1 = $18_1;
    $19_1 = $4_1;
    $4_1 = $4_1 >> 31;
    $35_1 = $7_1 + 128 | 0;
    $26_1 = $4_1;
    $69($35_1, $37_1, $18_1, $4_1, $4_1, $21_1, $20_1, $6_1, $6_1);
    $18_1 = HEAP32[$7_1 + 128 >> 2];
    $9_1 = HEAP32[$7_1 + 160 >> 2];
    $6_1 = $18_1 + $9_1 | 0;
    $17_1 = HEAP32[$7_1 + 132 >> 2];
    $4_1 = $17_1 + HEAP32[$7_1 + 164 >> 2] | 0;
    $9_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $14_1 = $15_1 << 2 | $12_1 >>> 30;
    $2_1 = $12_1 << 2 | $2_1 >>> 30;
    $12_1 = $2_1 + $6_1 | 0;
    $4_1 = $9_1 + $14_1 | 0;
    $2_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $9_1;
    $9_1 = $12_1;
    $14_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $9_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
    $12_1 = ($4_1 | 0) == ($17_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
    $4_1 = $22_1 + 8 | 0;
    $17_1 = HEAP32[$4_1 >> 2];
    $18_1 = $35_1 + 8 | 0;
    $6_1 = $17_1 + HEAP32[$18_1 >> 2] | 0;
    $4_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $18_1 = $6_1;
    $6_1 = $6_1 + $12_1 | 0;
    $4_1 = ($15_1 >> 31) + ($18_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $15_1 = $15_1 >> 30;
    $6_1 = $6_1 + $15_1 | 0;
    $4_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = $6_1 + $14_1 | 0;
    $15_1 = $12_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $21_1 = HEAP32[$7_1 + 144 >> 2];
    $6_1 = HEAP32[$7_1 + 176 >> 2];
    $14_1 = $21_1 + $6_1 | 0;
    $18_1 = HEAP32[$7_1 + 148 >> 2];
    $4_1 = $18_1 + HEAP32[$7_1 + 180 >> 2] | 0;
    $6_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $17_1 = $8_1 << 2 | $11_1 >>> 30;
    $5_1 = $11_1 << 2 | $5_1 >>> 30;
    $11_1 = $5_1 + $14_1 | 0;
    $4_1 = $6_1 + $17_1 | 0;
    $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $6_1;
    $6_1 = $11_1;
    $17_1 = ($5_1 | 0) == ($4_1 | 0) & $14_1 >>> 0 > $6_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
    $14_1 = ($4_1 | 0) == ($18_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
    $4_1 = $36_1 + 8 | 0;
    $18_1 = HEAP32[$4_1 >> 2];
    $21_1 = $33_1 + 8 | 0;
    $11_1 = $18_1 + HEAP32[$21_1 >> 2] | 0;
    $4_1 = HEAP32[$21_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $11_1 >>> 0 < $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $18_1 = $11_1;
    $11_1 = $11_1 + $14_1 | 0;
    $4_1 = ($8_1 >> 31) + ($18_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $8_1 = $8_1 >> 30;
    $11_1 = $8_1 + $11_1 | 0;
    $4_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $11_1;
    $11_1 = $11_1 + $17_1 | 0;
    $8_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $17_1 = HEAP32[$3_1 + 24 >> 2];
    $18_1 = HEAP32[$3_1 + 28 >> 2];
    if ($17_1 | $18_1) {
      $4_1 = $18_1 >> 31;
      $21_1 = $7_1 + 112 | 0;
      $14_1 = $4_1;
      $4_1 = $25_1 >> 31;
      $69($21_1, $17_1, $18_1, $14_1, $14_1, $29_1, $25_1, $4_1, $4_1);
      $20_1 = $7_1 + 96 | 0;
      $4_1 = $24_1 >> 31;
      $69($20_1, $17_1, $18_1, $14_1, $14_1, $34_1, $24_1, $4_1, $4_1);
      $14_1 = HEAP32[$7_1 + 100 >> 2];
      $4_1 = $14_1 + $2_1 | 0;
      $2_1 = $9_1;
      $17_1 = HEAP32[$7_1 + 96 >> 2];
      $9_1 = $17_1 + $9_1 | 0;
      $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $17_1 = ($14_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $17_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
      $4_1 = $20_1 + 8 | 0;
      $14_1 = HEAP32[$4_1 >> 2] + $12_1 | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + $15_1 | 0;
      $4_1 = $12_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $12_1 = $14_1 + $17_1 | 0;
      $15_1 = $12_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $14_1 = HEAP32[$7_1 + 116 >> 2];
      $4_1 = $14_1 + $5_1 | 0;
      $5_1 = $6_1;
      $17_1 = HEAP32[$7_1 + 112 >> 2];
      $6_1 = $17_1 + $6_1 | 0;
      $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $17_1 = ($14_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $14_1 >>> 0;
      $4_1 = $21_1 + 8 | 0;
      $14_1 = HEAP32[$4_1 >> 2] + $11_1 | 0;
      $4_1 = HEAP32[$4_1 + 4 >> 2] + $8_1 | 0;
      $4_1 = $11_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      $11_1 = $14_1 + $17_1 | 0;
      $8_1 = $11_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    }
    HEAP32[$0_1 + 16 >> 2] = $6_1;
    HEAP32[$0_1 + 20 >> 2] = $5_1 & 1073741823;
    HEAP32[$1_1 + 16 >> 2] = $9_1;
    HEAP32[$1_1 + 20 >> 2] = $2_1 & 1073741823;
    $4_1 = $45_1 >> 31;
    $6_1 = $4_1;
    $17_1 = $7_1 + 80 | 0;
    $18_1 = $45_1;
    $69($17_1, $16_1, $30_1, $10_1, $10_1, $44_1, $18_1, $4_1, $4_1);
    $30_1 = $7_1 + 48 | 0;
    $10_1 = $13_1;
    $16_1 = $50_1;
    $4_1 = $16_1 >> 31;
    $69($30_1, $28_1, $31_1, $10_1, $10_1, $43_1, $16_1, $4_1, $4_1);
    $28_1 = $7_1 - -64 | 0;
    $69($28_1, $32_1, $23_1, $27_1, $27_1, $44_1, $18_1, $6_1, $6_1);
    $31_1 = $7_1 + 32 | 0;
    $69($31_1, $37_1, $19_1, $26_1, $26_1, $43_1, $16_1, $4_1, $4_1);
    $9_1 = HEAP32[$3_1 + 32 >> 2];
    $3_1 = HEAP32[$3_1 + 36 >> 2];
    $6_1 = $3_1;
    $3_1 = $6_1 >> 31;
    $4_1 = $25_1 >> 31;
    $69($7_1, $9_1, $6_1, $3_1, $3_1, $29_1, $25_1, $4_1, $4_1);
    $16_1 = $7_1 + 16 | 0;
    $4_1 = $24_1 >> 31;
    $69($16_1, $9_1, $6_1, $3_1, $3_1, $34_1, $24_1, $4_1, $4_1);
    $9_1 = $0_1;
    $18_1 = HEAP32[$7_1 + 48 >> 2];
    $0_1 = HEAP32[$7_1 + 80 >> 2];
    $3_1 = $18_1 + $0_1 | 0;
    $13_1 = HEAP32[$7_1 + 52 >> 2];
    $4_1 = $13_1 + HEAP32[$7_1 + 84 >> 2] | 0;
    $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $25_1 = $3_1;
    $5_1 = $11_1 << 2 | $5_1 >>> 30;
    $3_1 = $3_1 + $5_1 | 0;
    $4_1 = $0_1 + ($8_1 << 2 | $11_1 >>> 30) | 0;
    $6_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $6_1 + HEAP32[$7_1 + 4 >> 2] | 0;
    $29_1 = $3_1;
    $3_1 = HEAP32[$7_1 >> 2];
    $5_1 = $29_1 + $3_1 | 0;
    $10_1 = $5_1;
    HEAP32[$9_1 + 24 >> 2] = $5_1;
    $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$9_1 + 28 >> 2] = $3_1 & 1073741823;
    $5_1 = $1_1;
    $1_1 = $12_1 << 2 | $2_1 >>> 30;
    $12_1 = $15_1 << 2 | $12_1 >>> 30;
    $32_1 = HEAP32[$7_1 + 32 >> 2];
    $2_1 = HEAP32[$7_1 + 64 >> 2];
    $11_1 = $32_1 + $2_1 | 0;
    $14_1 = HEAP32[$7_1 + 36 >> 2];
    $4_1 = $14_1 + HEAP32[$7_1 + 68 >> 2] | 0;
    $2_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $2_1 + $12_1 | 0;
    $1_1 = $1_1 + $11_1 | 0;
    $12_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $12_1 + HEAP32[$7_1 + 20 >> 2] | 0;
    $24_1 = $1_1;
    $1_1 = HEAP32[$7_1 + 16 >> 2];
    $34_1 = $24_1 + $1_1 | 0;
    HEAP32[$5_1 + 24 >> 2] = $34_1;
    $1_1 = $1_1 >>> 0 > $34_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$5_1 + 28 >> 2] = $1_1 & 1073741823;
    $10_1 = ($3_1 | 0) == ($6_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
    $4_1 = $7_1 + 8 | 0;
    $37_1 = HEAP32[$4_1 >> 2];
    $23_1 = HEAP32[$4_1 + 4 >> 2];
    $29_1 = ($0_1 | 0) == ($6_1 | 0) & $25_1 >>> 0 > $29_1 >>> 0 | $0_1 >>> 0 > $6_1 >>> 0;
    $6_1 = ($0_1 | 0) == ($13_1 | 0) & $18_1 >>> 0 > $25_1 >>> 0 | $0_1 >>> 0 < $13_1 >>> 0;
    $4_1 = $17_1 + 8 | 0;
    $25_1 = HEAP32[$4_1 >> 2];
    $13_1 = $30_1 + 8 | 0;
    $0_1 = $25_1 + HEAP32[$13_1 >> 2] | 0;
    $4_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $0_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $0_1;
    $0_1 = $0_1 + $6_1 | 0;
    $4_1 = ($8_1 >> 31) + ($13_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $8_1 = $8_1 >> 30;
    $0_1 = $0_1 + $8_1 | 0;
    $4_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $0_1;
    $0_1 = $0_1 + $29_1 | 0;
    $4_1 = ($6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $23_1 | 0;
    $6_1 = $0_1;
    $0_1 = $0_1 + $37_1 | 0;
    $4_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $0_1;
    $0_1 = $0_1 + $10_1 | 0;
    $6_1 = ($6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 2 | $0_1 >>> 30;
    HEAP32[$9_1 + 32 >> 2] = $0_1 << 2 | $3_1 >>> 30;
    HEAP32[$9_1 + 36 >> 2] = $6_1;
    $9_1 = ($1_1 | 0) == ($12_1 | 0) & $24_1 >>> 0 > $34_1 >>> 0 | $1_1 >>> 0 < $12_1 >>> 0;
    $0_1 = $16_1 + 8 | 0;
    $6_1 = HEAP32[$0_1 >> 2];
    $8_1 = HEAP32[$0_1 + 4 >> 2];
    $12_1 = ($2_1 | 0) == ($12_1 | 0) & $11_1 >>> 0 > $24_1 >>> 0 | $2_1 >>> 0 > $12_1 >>> 0;
    $2_1 = ($2_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 < $32_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
    $3_1 = $28_1 + 8 | 0;
    $11_1 = HEAP32[$3_1 >> 2];
    $4_1 = $31_1 + 8 | 0;
    $0_1 = $11_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $4_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $3_1 = $0_1;
    $0_1 = $0_1 + $2_1 | 0;
    $4_1 = ($15_1 >> 31) + ($3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
    $3_1 = $15_1 >> 30;
    $0_1 = $0_1 + $3_1 | 0;
    $4_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $12_1 | 0;
    $4_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $8_1 | 0;
    $2_1 = $0_1;
    $0_1 = $0_1 + $6_1 | 0;
    $4_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $2_1 = $0_1;
    $0_1 = $0_1 + $9_1 | 0;
    $2_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 2 | $0_1 >>> 30;
    HEAP32[$5_1 + 32 >> 2] = $0_1 << 2 | $1_1 >>> 30;
    HEAP32[$5_1 + 36 >> 2] = $2_1;
    global$0 = $7_1 + 480 | 0;
  }
  function $68($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0, $4_1 = 0;
    $2_1 = $1_1;
    label$1: {
      if ($1_1 >>> 0 <= 15) {
        $1_1 = $0_1;
        break label$1;
      }
      $3_1 = 0 - $0_1 & 3;
      $4_1 = $3_1 + $0_1 | 0;
      if ($3_1) {
        $1_1 = $0_1;
        while (1) {
          HEAP8[$1_1 | 0] = 0;
          $1_1 = $1_1 + 1 | 0;
          if ($4_1 >>> 0 > $1_1 >>> 0) {
            continue;
          }
          break;
        }
        ;
      }
      $2_1 = $2_1 - $3_1 | 0;
      $3_1 = $2_1 & -4;
      $1_1 = $3_1 + $4_1 | 0;
      if (($3_1 | 0) > 0) {
        while (1) {
          HEAP32[$4_1 >> 2] = 0;
          $4_1 = $4_1 + 4 | 0;
          if ($4_1 >>> 0 < $1_1 >>> 0) {
            continue;
          }
          break;
        }
      }
      $2_1 = $2_1 & 3;
    }
    if ($2_1) {
      $2_1 = $1_1 + $2_1 | 0;
      while (1) {
        HEAP8[$1_1 | 0] = 0;
        $1_1 = $1_1 + 1 | 0;
        if ($2_1 >>> 0 > $1_1 >>> 0) {
          continue;
        }
        break;
      }
      ;
    }
    return $0_1;
  }
  function $69($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1, $7_1, $8_1) {
    var $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
    $9_1 = __wasm_i64_mul($5_1, 0, $1_1, 0);
    $12_1 = $0_1;
    $10_1 = i64toi32_i32$HIGH_BITS;
    $15_1 = $1_1;
    $1_1 = __wasm_i64_mul($1_1, 0, $6_1, 0);
    $11_1 = i64toi32_i32$HIGH_BITS;
    $13_1 = __wasm_i64_mul($5_1, 0, $2_1, 0);
    $14_1 = i64toi32_i32$HIGH_BITS;
    $0_1 = $11_1 + $14_1 | 0;
    $11_1 = $1_1 + $13_1 | 0;
    $1_1 = $11_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $10_1 + $11_1 | 0;
    $0_1 = 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$12_1 >> 2] = $9_1;
    HEAP32[$12_1 + 4 >> 2] = $0_1;
    $10_1 = ($0_1 | 0) == ($10_1 | 0) & $9_1 >>> 0 < $9_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
    $0_1 = ($1_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
    $9_1 = $1_1;
    $1_1 = $1_1 + __wasm_i64_mul($2_1, 0, $6_1, 0) | 0;
    $0_1 = i64toi32_i32$HIGH_BITS + $0_1 | 0;
    $0_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $9_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $9_1 = $9_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = __wasm_i64_mul($15_1, $2_1, $7_1, $8_1);
    $7_1 = i64toi32_i32$HIGH_BITS;
    $3_1 = __wasm_i64_mul($3_1, $4_1, $5_1, $6_1);
    $2_1 = $3_1 + $0_1 | 0;
    $0_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
    $0_1 = ($2_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $9_1 | 0;
    $1_1 = $1_1 + $2_1 | 0;
    $0_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$12_1 + 8 >> 2] = $1_1;
    HEAP32[$12_1 + 12 >> 2] = $0_1;
  }
  function $70($0_1, $1_1, $2_1) {
    var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0;
    $6_1 = $2_1;
    label$1: {
      if ($2_1 >>> 0 <= 15) {
        $2_1 = $0_1;
        break label$1;
      }
      $5_1 = 0 - $0_1 & 3;
      $4_1 = $5_1 + $0_1 | 0;
      if ($5_1) {
        $2_1 = $0_1;
        $3_1 = $1_1;
        while (1) {
          HEAP8[$2_1 | 0] = HEAPU8[$3_1 | 0];
          $3_1 = $3_1 + 1 | 0;
          $2_1 = $2_1 + 1 | 0;
          if ($4_1 >>> 0 > $2_1 >>> 0) {
            continue;
          }
          break;
        }
        ;
      }
      $6_1 = $6_1 - $5_1 | 0;
      $7_1 = $6_1 & -4;
      $2_1 = $7_1 + $4_1 | 0;
      $5_1 = $1_1 + $5_1 | 0;
      $3_1 = $5_1 & 3;
      label$5: {
        if ($3_1) {
          if (($7_1 | 0) <= 0) {
            break label$5;
          }
          $8_1 = $5_1 & -4;
          $1_1 = $8_1 + 4 | 0;
          $9_1 = $3_1 << 3;
          $10_1 = 0 - $9_1 & 24;
          $3_1 = HEAP32[$8_1 >> 2];
          while (1) {
            $8_1 = $3_1 >>> $9_1 | 0;
            $3_1 = HEAP32[$1_1 >> 2];
            HEAP32[$4_1 >> 2] = $8_1 | $3_1 << $10_1;
            $1_1 = $1_1 + 4 | 0;
            $4_1 = $4_1 + 4 | 0;
            if ($4_1 >>> 0 < $2_1 >>> 0) {
              continue;
            }
            break;
          }
          ;
          break label$5;
        }
        if (($7_1 | 0) <= 0) {
          break label$5;
        }
        $1_1 = $5_1;
        while (1) {
          HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
          $1_1 = $1_1 + 4 | 0;
          $4_1 = $4_1 + 4 | 0;
          if ($4_1 >>> 0 < $2_1 >>> 0) {
            continue;
          }
          break;
        }
        ;
      }
      $6_1 = $6_1 & 3;
      $1_1 = $5_1 + $7_1 | 0;
    }
    if ($6_1) {
      $3_1 = $2_1 + $6_1 | 0;
      while (1) {
        HEAP8[$2_1 | 0] = HEAPU8[$1_1 | 0];
        $1_1 = $1_1 + 1 | 0;
        $2_1 = $2_1 + 1 | 0;
        if ($3_1 >>> 0 > $2_1 >>> 0) {
          continue;
        }
        break;
      }
      ;
    }
    return $0_1;
  }
  function __wasm_ctz_i64($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0;
    if ($0_1 | $1_1) {
      $2_1 = $1_1 - 1 | 0;
      $3_1 = $0_1 - 1 | 0;
      $2_1 = ($3_1 | 0) != -1 ? $2_1 + 1 | 0 : $2_1;
      $3_1 = $0_1 ^ $3_1;
      $0_1 = Math_clz32($1_1 ^ $2_1);
      if (($0_1 | 0) == 32) {
        $0_1 = Math_clz32($3_1) + 32 | 0;
      }
      i64toi32_i32$HIGH_BITS = 0 - ($0_1 >>> 0 > 63) | 0;
      return 63 - $0_1 | 0;
    }
    i64toi32_i32$HIGH_BITS = 0;
    return 64;
  }
  function __wasm_i64_mul($0_1, $1_1, $2_1, $3_1) {
    var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0;
    $4_1 = $2_1 & 65535;
    $5_1 = $0_1 & 65535;
    $6_1 = Math_imul($4_1, $5_1);
    $7_1 = $2_1 >>> 16 | 0;
    $9_1 = Math_imul($5_1, $7_1);
    $8_1 = $0_1 >>> 16 | 0;
    $5_1 = Math_imul($4_1, $8_1) + ($6_1 >>> 16 | 0) | 0;
    $4_1 = $9_1 + ($5_1 & 65535) | 0;
    i64toi32_i32$HIGH_BITS = (Math_imul($1_1, $2_1) + Math_imul($7_1, $8_1) | 0) + Math_imul($0_1, $3_1) + ($5_1 >>> 16) + ($4_1 >>> 16) | 0;
    return $6_1 & 65535 | $4_1 << 16;
  }
  function __wasm_rotl_i32($0_1, $1_1) {
    var $2_1 = 0, $3_1 = 0;
    $2_1 = $1_1 & 31;
    $3_1 = (-1 >>> $2_1 & $0_1) << $2_1;
    $2_1 = $0_1;
    $0_1 = 0 - $1_1 & 31;
    return $3_1 | ($2_1 & -1 << $0_1) >>> $0_1;
  }
  bufferView = HEAPU8;
  initActiveSegments(imports);
  var FUNCTION_TABLE = [null, $4, $0, $3, $44, $61, $28];
  function __wasm_memory_size() {
    return buffer.byteLength / 65536 | 0;
  }
  function __wasm_memory_grow(pagesToAdd) {
    pagesToAdd = pagesToAdd | 0;
    var oldPages = __wasm_memory_size() | 0;
    var newPages = oldPages + pagesToAdd | 0;
    if (oldPages < newPages && newPages < 65536) {
      var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
      var newHEAP8 = new Int8Array(newBuffer);
      newHEAP8.set(HEAP8);
      HEAP8 = new Int8Array(newBuffer);
      HEAP16 = new Int16Array(newBuffer);
      HEAP32 = new Int32Array(newBuffer);
      HEAPU8 = new Uint8Array(newBuffer);
      HEAPU16 = new Uint16Array(newBuffer);
      HEAPU32 = new Uint32Array(newBuffer);
      HEAPF32 = new Float32Array(newBuffer);
      HEAPF64 = new Float64Array(newBuffer);
      buffer = newBuffer;
      bufferView = HEAPU8;
    }
    return oldPages;
  }
  return {
    "memory": Object.create(Object.prototype, {
      "grow": {
        "value": __wasm_memory_grow
      },
      "buffer": {
        "get": function() {
          return buffer;
        }
      }
    }),
    "initializeContext": $7,
    "isPoint": $8,
    "PUBLIC_KEY_INPUT": {
      get value() {
        return global$1;
      },
      set value(_global$1) {
        global$1 = _global$1;
      }
    },
    "pointAdd": $9,
    "PUBLIC_KEY_INPUT2": {
      get value() {
        return global$2;
      },
      set value(_global$2) {
        global$2 = _global$2;
      }
    },
    "pointAddScalar": $10,
    "TWEAK_INPUT": {
      get value() {
        return global$3;
      },
      set value(_global$3) {
        global$3 = _global$3;
      }
    },
    "xOnlyPointAddTweak": $11,
    "X_ONLY_PUBLIC_KEY_INPUT": {
      get value() {
        return global$4;
      },
      set value(_global$4) {
        global$4 = _global$4;
      }
    },
    "xOnlyPointAddTweakCheck": $12,
    "X_ONLY_PUBLIC_KEY_INPUT2": {
      get value() {
        return global$5;
      },
      set value(_global$5) {
        global$5 = _global$5;
      }
    },
    "pointCompress": $13,
    "pointFromScalar": $14,
    "PRIVATE_INPUT": {
      get value() {
        return global$6;
      },
      set value(_global$6) {
        global$6 = _global$6;
      }
    },
    "xOnlyPointFromScalar": $15,
    "xOnlyPointFromPoint": $16,
    "pointMultiply": $17,
    "privateAdd": $18,
    "privateSub": $19,
    "privateNegate": $20,
    "sign": $21,
    "HASH_INPUT": {
      get value() {
        return global$7;
      },
      set value(_global$7) {
        global$7 = _global$7;
      }
    },
    "EXTRA_DATA_INPUT": {
      get value() {
        return global$8;
      },
      set value(_global$8) {
        global$8 = _global$8;
      }
    },
    "SIGNATURE_INPUT": {
      get value() {
        return global$9;
      },
      set value(_global$9) {
        global$9 = _global$9;
      }
    },
    "signRecoverable": $22,
    "signSchnorr": $23,
    "verify": $24,
    "recover": $25,
    "verifySchnorr": $26,
    "rustsecp256k1_v0_8_1_default_error_callback_fn": $28,
    "rustsecp256k1_v0_8_1_default_illegal_callback_fn": $28,
    "__data_end": {
      get value() {
        return global$10;
      },
      set value(_global$10) {
        global$10 = _global$10;
      }
    },
    "__heap_base": {
      get value() {
        return global$11;
      },
      set value(_global$11) {
        global$11 = _global$11;
      }
    }
  };
}
var retasmFunc = asmFunc({
  "./rand.js": rand_exports,
  "./validate_error.js": validate_error_exports
});
var memory = retasmFunc.memory;
var initializeContext = retasmFunc.initializeContext;
var isPoint2 = retasmFunc.isPoint;
var PUBLIC_KEY_INPUT = retasmFunc.PUBLIC_KEY_INPUT;
var pointAdd = retasmFunc.pointAdd;
var PUBLIC_KEY_INPUT2 = retasmFunc.PUBLIC_KEY_INPUT2;
var pointAddScalar = retasmFunc.pointAddScalar;
var TWEAK_INPUT = retasmFunc.TWEAK_INPUT;
var xOnlyPointAddTweak = retasmFunc.xOnlyPointAddTweak;
var X_ONLY_PUBLIC_KEY_INPUT = retasmFunc.X_ONLY_PUBLIC_KEY_INPUT;
var xOnlyPointAddTweakCheck = retasmFunc.xOnlyPointAddTweakCheck;
var X_ONLY_PUBLIC_KEY_INPUT2 = retasmFunc.X_ONLY_PUBLIC_KEY_INPUT2;
var pointCompress = retasmFunc.pointCompress;
var pointFromScalar = retasmFunc.pointFromScalar;
var PRIVATE_INPUT = retasmFunc.PRIVATE_INPUT;
var xOnlyPointFromScalar = retasmFunc.xOnlyPointFromScalar;
var xOnlyPointFromPoint = retasmFunc.xOnlyPointFromPoint;
var pointMultiply = retasmFunc.pointMultiply;
var privateAdd = retasmFunc.privateAdd;
var privateSub = retasmFunc.privateSub;
var privateNegate = retasmFunc.privateNegate;
var sign = retasmFunc.sign;
var HASH_INPUT = retasmFunc.HASH_INPUT;
var EXTRA_DATA_INPUT = retasmFunc.EXTRA_DATA_INPUT;
var SIGNATURE_INPUT = retasmFunc.SIGNATURE_INPUT;
var signRecoverable = retasmFunc.signRecoverable;
var signSchnorr = retasmFunc.signSchnorr;
var verify = retasmFunc.verify;
var recover = retasmFunc.recover;
var verifySchnorr = retasmFunc.verifySchnorr;
var rustsecp256k1_v0_8_1_default_error_callback_fn = retasmFunc.rustsecp256k1_v0_8_1_default_error_callback_fn;
var rustsecp256k1_v0_8_1_default_illegal_callback_fn = retasmFunc.rustsecp256k1_v0_8_1_default_illegal_callback_fn;
var __data_end = retasmFunc.__data_end;
var __heap_base = retasmFunc.__heap_base;

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/wasm_loader.js
var wasm_loader_default = secp256k1_asm_exports;

// node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/index.js
var WASM_BUFFER = new Uint8Array(wasm_loader_default.memory.buffer);
var WASM_PRIVATE_KEY_PTR = wasm_loader_default.PRIVATE_INPUT.value;
var WASM_PUBLIC_KEY_INPUT_PTR = wasm_loader_default.PUBLIC_KEY_INPUT.value;
var WASM_PUBLIC_KEY_INPUT_PTR2 = wasm_loader_default.PUBLIC_KEY_INPUT2.value;
var WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR = wasm_loader_default.X_ONLY_PUBLIC_KEY_INPUT.value;
var WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR = wasm_loader_default.X_ONLY_PUBLIC_KEY_INPUT2.value;
var WASM_TWEAK_INPUT_PTR = wasm_loader_default.TWEAK_INPUT.value;
var WASM_HASH_INPUT_PTR = wasm_loader_default.HASH_INPUT.value;
var WASM_EXTRA_DATA_INPUT_PTR = wasm_loader_default.EXTRA_DATA_INPUT.value;
var WASM_SIGNATURE_INPUT_PTR = wasm_loader_default.SIGNATURE_INPUT.value;
var PRIVATE_KEY_INPUT = WASM_BUFFER.subarray(WASM_PRIVATE_KEY_PTR, WASM_PRIVATE_KEY_PTR + PRIVATE_KEY_SIZE);
var PUBLIC_KEY_INPUT3 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR + PUBLIC_KEY_UNCOMPRESSED_SIZE);
var PUBLIC_KEY_INPUT22 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR2, WASM_PUBLIC_KEY_INPUT_PTR2 + PUBLIC_KEY_UNCOMPRESSED_SIZE);
var X_ONLY_PUBLIC_KEY_INPUT3 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR + X_ONLY_PUBLIC_KEY_SIZE);
var X_ONLY_PUBLIC_KEY_INPUT22 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR + X_ONLY_PUBLIC_KEY_SIZE);
var TWEAK_INPUT2 = WASM_BUFFER.subarray(WASM_TWEAK_INPUT_PTR, WASM_TWEAK_INPUT_PTR + TWEAK_SIZE);
var HASH_INPUT2 = WASM_BUFFER.subarray(WASM_HASH_INPUT_PTR, WASM_HASH_INPUT_PTR + HASH_SIZE);
var EXTRA_DATA_INPUT2 = WASM_BUFFER.subarray(WASM_EXTRA_DATA_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR + EXTRA_DATA_SIZE);
var SIGNATURE_INPUT2 = WASM_BUFFER.subarray(WASM_SIGNATURE_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR + SIGNATURE_SIZE);
function assumeCompression(compressed, p) {
  if (compressed === void 0) {
    return p !== void 0 ? p.length : PUBLIC_KEY_COMPRESSED_SIZE;
  }
  return compressed ? PUBLIC_KEY_COMPRESSED_SIZE : PUBLIC_KEY_UNCOMPRESSED_SIZE;
}
function _isPoint(p) {
  try {
    PUBLIC_KEY_INPUT3.set(p);
    return wasm_loader_default.isPoint(p.length) === 1;
  } finally {
    PUBLIC_KEY_INPUT3.fill(0);
  }
}
function __initializeContext() {
  wasm_loader_default.initializeContext();
}
function isPoint3(p) {
  return isDERPoint(p) && _isPoint(p);
}
function isPointCompressed2(p) {
  return isPointCompressed(p) && _isPoint(p);
}
function isXOnlyPoint2(p) {
  return isXOnlyPoint(p) && _isPoint(p);
}
function isPrivate2(d) {
  return isPrivate(d);
}
function pointAdd2(pA, pB, compressed) {
  validatePoint(pA);
  validatePoint(pB);
  const outputlen = assumeCompression(compressed, pA);
  try {
    PUBLIC_KEY_INPUT3.set(pA);
    PUBLIC_KEY_INPUT22.set(pB);
    return wasm_loader_default.pointAdd(pA.length, pB.length, outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
  } finally {
    PUBLIC_KEY_INPUT3.fill(0);
    PUBLIC_KEY_INPUT22.fill(0);
  }
}
function pointAddScalar2(p, tweak, compressed) {
  validatePoint(p);
  validateTweak(tweak);
  const outputlen = assumeCompression(compressed, p);
  try {
    PUBLIC_KEY_INPUT3.set(p);
    TWEAK_INPUT2.set(tweak);
    return wasm_loader_default.pointAddScalar(p.length, outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
  } finally {
    PUBLIC_KEY_INPUT3.fill(0);
    TWEAK_INPUT2.fill(0);
  }
}
function pointCompress2(p, compressed) {
  validatePoint(p);
  const outputlen = assumeCompression(compressed, p);
  try {
    PUBLIC_KEY_INPUT3.set(p);
    wasm_loader_default.pointCompress(p.length, outputlen);
    return PUBLIC_KEY_INPUT3.slice(0, outputlen);
  } finally {
    PUBLIC_KEY_INPUT3.fill(0);
  }
}
function pointFromScalar2(d, compressed) {
  validatePrivate(d);
  const outputlen = assumeCompression(compressed);
  try {
    PRIVATE_KEY_INPUT.set(d);
    return wasm_loader_default.pointFromScalar(outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
  } finally {
    PRIVATE_KEY_INPUT.fill(0);
    PUBLIC_KEY_INPUT3.fill(0);
  }
}
function xOnlyPointFromScalar2(d) {
  validatePrivate(d);
  try {
    PRIVATE_KEY_INPUT.set(d);
    wasm_loader_default.xOnlyPointFromScalar();
    return X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
  } finally {
    PRIVATE_KEY_INPUT.fill(0);
    X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
  }
}
function xOnlyPointFromPoint2(p) {
  validatePoint(p);
  try {
    PUBLIC_KEY_INPUT3.set(p);
    wasm_loader_default.xOnlyPointFromPoint(p.length);
    return X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
  } finally {
    PUBLIC_KEY_INPUT3.fill(0);
    X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
  }
}
function pointMultiply2(p, tweak, compressed) {
  validatePoint(p);
  validateTweak(tweak);
  const outputlen = assumeCompression(compressed, p);
  try {
    PUBLIC_KEY_INPUT3.set(p);
    TWEAK_INPUT2.set(tweak);
    return wasm_loader_default.pointMultiply(p.length, outputlen) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
  } finally {
    PUBLIC_KEY_INPUT3.fill(0);
    TWEAK_INPUT2.fill(0);
  }
}
function privateAdd2(d, tweak) {
  validatePrivate(d);
  validateTweak(tweak);
  try {
    PRIVATE_KEY_INPUT.set(d);
    TWEAK_INPUT2.set(tweak);
    return wasm_loader_default.privateAdd() === 1 ? PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE) : null;
  } finally {
    PRIVATE_KEY_INPUT.fill(0);
    TWEAK_INPUT2.fill(0);
  }
}
function privateSub2(d, tweak) {
  validatePrivate(d);
  validateTweak(tweak);
  if (isZero(tweak)) {
    return new Uint8Array(d);
  }
  try {
    PRIVATE_KEY_INPUT.set(d);
    TWEAK_INPUT2.set(tweak);
    return wasm_loader_default.privateSub() === 1 ? PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE) : null;
  } finally {
    PRIVATE_KEY_INPUT.fill(0);
    TWEAK_INPUT2.fill(0);
  }
}
function privateNegate2(d) {
  validatePrivate(d);
  try {
    PRIVATE_KEY_INPUT.set(d);
    wasm_loader_default.privateNegate();
    return PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE);
  } finally {
    PRIVATE_KEY_INPUT.fill(0);
  }
}
function xOnlyPointAddTweak2(p, tweak) {
  validateXOnlyPoint(p);
  validateTweak(tweak);
  try {
    X_ONLY_PUBLIC_KEY_INPUT3.set(p);
    TWEAK_INPUT2.set(tweak);
    const parity = wasm_loader_default.xOnlyPointAddTweak();
    return parity !== -1 ? {
      parity,
      xOnlyPubkey: X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE)
    } : null;
  } finally {
    X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
    TWEAK_INPUT2.fill(0);
  }
}
function xOnlyPointAddTweakCheck2(point, tweak, resultToCheck, tweakParity) {
  validateXOnlyPoint(point);
  validateXOnlyPoint(resultToCheck);
  validateTweak(tweak);
  const hasParity = tweakParity !== void 0;
  if (hasParity)
    validateParity(tweakParity);
  try {
    X_ONLY_PUBLIC_KEY_INPUT3.set(point);
    X_ONLY_PUBLIC_KEY_INPUT22.set(resultToCheck);
    TWEAK_INPUT2.set(tweak);
    if (hasParity) {
      return wasm_loader_default.xOnlyPointAddTweakCheck(tweakParity) === 1;
    } else {
      wasm_loader_default.xOnlyPointAddTweak();
      const newKey = X_ONLY_PUBLIC_KEY_INPUT3.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
      return compare(newKey, resultToCheck) === 0;
    }
  } finally {
    X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
    X_ONLY_PUBLIC_KEY_INPUT22.fill(0);
    TWEAK_INPUT2.fill(0);
  }
}
function sign2(h, d, e) {
  validateHash(h);
  validatePrivate(d);
  validateExtraData(e);
  try {
    HASH_INPUT2.set(h);
    PRIVATE_KEY_INPUT.set(d);
    if (e !== void 0)
      EXTRA_DATA_INPUT2.set(e);
    wasm_loader_default.sign(e === void 0 ? 0 : 1);
    return SIGNATURE_INPUT2.slice(0, SIGNATURE_SIZE);
  } finally {
    HASH_INPUT2.fill(0);
    PRIVATE_KEY_INPUT.fill(0);
    if (e !== void 0)
      EXTRA_DATA_INPUT2.fill(0);
    SIGNATURE_INPUT2.fill(0);
  }
}
function signRecoverable2(h, d, e) {
  validateHash(h);
  validatePrivate(d);
  validateExtraData(e);
  try {
    HASH_INPUT2.set(h);
    PRIVATE_KEY_INPUT.set(d);
    if (e !== void 0)
      EXTRA_DATA_INPUT2.set(e);
    const recoveryId = wasm_loader_default.signRecoverable(e === void 0 ? 0 : 1);
    const signature = SIGNATURE_INPUT2.slice(0, SIGNATURE_SIZE);
    return {
      signature,
      recoveryId
    };
  } finally {
    HASH_INPUT2.fill(0);
    PRIVATE_KEY_INPUT.fill(0);
    if (e !== void 0)
      EXTRA_DATA_INPUT2.fill(0);
    SIGNATURE_INPUT2.fill(0);
  }
}
function signSchnorr2(h, d, e) {
  validateHash(h);
  validatePrivate(d);
  validateExtraData(e);
  try {
    HASH_INPUT2.set(h);
    PRIVATE_KEY_INPUT.set(d);
    if (e !== void 0)
      EXTRA_DATA_INPUT2.set(e);
    wasm_loader_default.signSchnorr(e === void 0 ? 0 : 1);
    return SIGNATURE_INPUT2.slice(0, SIGNATURE_SIZE);
  } finally {
    HASH_INPUT2.fill(0);
    PRIVATE_KEY_INPUT.fill(0);
    if (e !== void 0)
      EXTRA_DATA_INPUT2.fill(0);
    SIGNATURE_INPUT2.fill(0);
  }
}
function verify2(h, Q, signature, strict = false) {
  validateHash(h);
  validatePoint(Q);
  validateSignature(signature);
  try {
    HASH_INPUT2.set(h);
    PUBLIC_KEY_INPUT3.set(Q);
    SIGNATURE_INPUT2.set(signature);
    return wasm_loader_default.verify(Q.length, strict === true ? 1 : 0) === 1 ? true : false;
  } finally {
    HASH_INPUT2.fill(0);
    PUBLIC_KEY_INPUT3.fill(0);
    SIGNATURE_INPUT2.fill(0);
  }
}
function recover2(h, signature, recoveryId, compressed = false) {
  validateHash(h);
  validateSignature(signature);
  validateSignatureNonzeroRS(signature);
  if (recoveryId & 2) {
    validateSigrPMinusN(signature);
  }
  validateSignatureCustom(() => isXOnlyPoint2(signature.subarray(0, 32)));
  const outputlen = assumeCompression(compressed);
  try {
    HASH_INPUT2.set(h);
    SIGNATURE_INPUT2.set(signature);
    return wasm_loader_default.recover(outputlen, recoveryId) === 1 ? PUBLIC_KEY_INPUT3.slice(0, outputlen) : null;
  } finally {
    HASH_INPUT2.fill(0);
    SIGNATURE_INPUT2.fill(0);
    PUBLIC_KEY_INPUT3.fill(0);
  }
}
function verifySchnorr2(h, Q, signature) {
  validateHash(h);
  validateXOnlyPoint(Q);
  validateSignature(signature);
  try {
    HASH_INPUT2.set(h);
    X_ONLY_PUBLIC_KEY_INPUT3.set(Q);
    SIGNATURE_INPUT2.set(signature);
    return wasm_loader_default.verifySchnorr() === 1 ? true : false;
  } finally {
    HASH_INPUT2.fill(0);
    X_ONLY_PUBLIC_KEY_INPUT3.fill(0);
    SIGNATURE_INPUT2.fill(0);
  }
}

// src/actions/taproot-action.js
var import_secp256k1 = __toESM(require_dist2(), 1);
bitcoin.initEccLib(lib_exports);
var encryptData = async (privateKey, accessControlConditions) => {
  const { ciphertext: ciphertext2, dataToEncryptHash: dataToEncryptHash2 } = await Lit.Actions.encrypt({
    accessControlConditions: [accessControlConditions],
    to_encrypt: new TextEncoder().encode(privateKey)
  });
  return { ciphertext: ciphertext2, dataToEncryptHash: dataToEncryptHash2 };
};
var decryptData = async (accessControlConditions, _ciphertext, _dataToEncryptHash) => {
  const decryptedData = await Lit.Actions.decryptToSingleNode({
    accessControlConditions: [accessControlConditions],
    ciphertext: _ciphertext,
    dataToEncryptHash: _dataToEncryptHash,
    authSig: null,
    chain: "ethereum"
  });
  console.log("decryptedData: ", decryptedData.slice(2));
  return decryptedData.slice(2);
};
function getFirstSessionSig(pkpSessionSigs2) {
  const sessionSigsEntries = Object.entries(pkpSessionSigs2);
  if (sessionSigsEntries.length === 0) {
    throw new Error(
      `Invalid pkpSessionSigs, length zero: ${JSON.stringify(
        pkpSessionSigs2
      )}`
    );
  }
  const [[, sessionSig]] = sessionSigsEntries;
  return sessionSig;
}
function getPkpAddressFromSessionSig(pkpSessionSig) {
  const sessionSignedMessage = JSON.parse(pkpSessionSig.signedMessage);
  const capabilities = sessionSignedMessage.capabilities;
  if (!capabilities || capabilities.length === 0) {
    throw new Error(
      `Capabilities in the session's signedMessage is empty, but required.`
    );
  }
  const delegationAuthSig = capabilities.find(
    ({ algo }) => algo === "LIT_BLS"
  );
  if (!delegationAuthSig) {
    throw new Error(
      "SessionSig is not from a PKP; no LIT_BLS capabilities found"
    );
  }
  const pkpAddress = delegationAuthSig.address;
  console.log(`pkpAddress to permit decryption: ${pkpAddress}`);
  return pkpAddress;
}
function getPkpAccessControlCondition(pkpAddress) {
  if (!ethers.utils.isAddress(pkpAddress)) {
    throw new Error(
      `pkpAddress is not a valid Ethereum Address: ${pkpAddress}`
    );
  }
  return {
    contractAddress: "",
    standardContractType: "",
    chain: "ethereum",
    method: "",
    parameters: [":userAddress"],
    returnValueTest: {
      comparator: "=",
      value: pkpAddress
    }
  };
}
var go = async () => {
  try {
    if (method === "createWallet") {
      const sessionSig = getFirstSessionSig(pkpSessionSigs);
      const pkpAddress = getPkpAddressFromSessionSig(sessionSig);
      const ACC = getPkpAccessControlCondition(pkpAddress);
      const wallet = ethers.Wallet.createRandom();
      const publicKey = wallet.publicKey;
      const privateKey = wallet.privateKey;
      const encryptedData = await encryptData(
        privateKey,
        ACC
      );
      const response = { publicKey, ...encryptedData };
      console.log("response: ", response);
      Lit.Actions.setResponse({ response: JSON.stringify({ response }) });
    } else if (method === "signTaprootTxn") {
      const sessionSig = getFirstSessionSig(pkpSessionSigs);
      const pkpAddress = getPkpAddressFromSessionSig(sessionSig);
      const ACC = getPkpAccessControlCondition(pkpAddress);
      const decryptedData = await decryptData(
        ACC,
        ciphertext,
        dataToEncryptHash
      );
      const response = decryptedData;
      Lit.Actions.setResponse({ response: JSON.stringify({ response }) });
    }
  } catch (error) {
    Lit.Actions.setResponse({ response: error.message });
  }
};
go();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
